exports.id = "main";
exports.modules = {

/***/ "./node_modules/@apollographql/apollo-upload-server/lib/errors.js":
/*!************************************************************************!*\
  !*** ./node_modules/@apollographql/apollo-upload-server/lib/errors.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileStreamDisconnectUploadError = exports.UploadPromiseDisconnectUploadError = exports.FileMissingUploadError = exports.FilesBeforeMapUploadError = exports.MapBeforeOperationsUploadError = exports.MaxFilesUploadError = exports.MaxFileSizeUploadError = exports.UploadError = exports.SPEC_URL = void 0;\nconst SPEC_URL = 'https://github.com/jaydenseric/graphql-multipart-request-spec';\nexports.SPEC_URL = SPEC_URL;\n\nclass UploadError extends Error {\n  constructor(message, status) {\n    super(message);\n    this.name = this.constructor.name;\n    if (typeof Error.captureStackTrace === 'function') Error.captureStackTrace(this, this.constructor);else this.stack = new Error(message).stack;\n\n    if (status) {\n      this.status = status;\n      this.expose = true;\n    }\n  }\n\n}\n\nexports.UploadError = UploadError;\n\nclass MaxFileSizeUploadError extends UploadError {}\n\nexports.MaxFileSizeUploadError = MaxFileSizeUploadError;\n\nclass MaxFilesUploadError extends UploadError {}\n\nexports.MaxFilesUploadError = MaxFilesUploadError;\n\nclass MapBeforeOperationsUploadError extends UploadError {}\n\nexports.MapBeforeOperationsUploadError = MapBeforeOperationsUploadError;\n\nclass FilesBeforeMapUploadError extends UploadError {}\n\nexports.FilesBeforeMapUploadError = FilesBeforeMapUploadError;\n\nclass FileMissingUploadError extends UploadError {}\n\nexports.FileMissingUploadError = FileMissingUploadError;\n\nclass UploadPromiseDisconnectUploadError extends UploadError {}\n\nexports.UploadPromiseDisconnectUploadError = UploadPromiseDisconnectUploadError;\n\nclass FileStreamDisconnectUploadError extends UploadError {}\n\nexports.FileStreamDisconnectUploadError = FileStreamDisconnectUploadError;\n\n//# sourceURL=webpack:///./node_modules/@apollographql/apollo-upload-server/lib/errors.js?");

/***/ }),

/***/ "./node_modules/@apollographql/apollo-upload-server/lib/index.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@apollographql/apollo-upload-server/lib/index.mjs ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./node_modules/@apollographql/apollo-upload-server/lib/types.js\");\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./middleware */ \"./node_modules/@apollographql/apollo-upload-server/lib/middleware.js\");\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _middleware__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _middleware__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./node_modules/@apollographql/apollo-upload-server/lib/errors.js\");\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _errors__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _errors__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n\n\n//# sourceURL=webpack:///./node_modules/@apollographql/apollo-upload-server/lib/index.mjs?");

/***/ }),

/***/ "./node_modules/@apollographql/apollo-upload-server/lib/middleware.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apollographql/apollo-upload-server/lib/middleware.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime-corejs2/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.apolloUploadExpress = exports.apolloUploadKoa = exports.processRequest = void 0;\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime-corejs2/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js\"));\n\nvar _map = _interopRequireDefault(__webpack_require__(/*! @babel/runtime-corejs2/core-js/map */ \"./node_modules/@babel/runtime-corejs2/core-js/map.js\"));\n\nvar _entries = _interopRequireDefault(__webpack_require__(/*! @babel/runtime-corejs2/core-js/object/entries */ \"./node_modules/@babel/runtime-corejs2/core-js/object/entries.js\"));\n\nvar _promise = _interopRequireDefault(__webpack_require__(/*! @babel/runtime-corejs2/core-js/promise */ \"./node_modules/@babel/runtime-corejs2/core-js/promise.js\"));\n\nvar _busboy = _interopRequireDefault(__webpack_require__(/*! busboy */ \"busboy\"));\n\nvar _objectPath = _interopRequireDefault(__webpack_require__(/*! object-path */ \"./node_modules/object-path/index.js\"));\n\nvar _errors = __webpack_require__(/*! ./errors */ \"./node_modules/@apollographql/apollo-upload-server/lib/errors.js\");\n\nclass Upload {\n  constructor() {\n    this.promise = new _promise.default((resolve, reject) => {\n      this.reject = reject;\n\n      this.resolve = file => {\n        this.file = file;\n        file.stream.once('end', () => {\n          this.done = true;\n        });\n        file.stream.once('limit', () => file.stream.emit('error', new _errors.MaxFileSizeUploadError('File truncated as it exceeds the size limit.')));\n        resolve(file);\n      };\n    });\n  }\n\n}\n\nconst processRequest = (request, {\n  maxFieldSize,\n  maxFileSize,\n  maxFiles\n} = {}) => new _promise.default((resolve, reject) => {\n  const parser = new _busboy.default({\n    headers: request.headers,\n    limits: {\n      fieldSize: maxFieldSize,\n      fields: 2,\n      fileSize: maxFileSize,\n      files: maxFiles\n    }\n  });\n  let operations;\n  let operationsPath;\n  let map;\n  parser.on('field', (fieldName, value) => {\n    switch (fieldName) {\n      case 'operations':\n        operations = JSON.parse(value);\n        operationsPath = (0, _objectPath.default)(operations);\n        break;\n\n      case 'map':\n        {\n          if (!operations) return reject(new _errors.MapBeforeOperationsUploadError(`Misordered multipart fields; “map” should follow “operations” (${_errors.SPEC_URL}).`, 400));\n          const mapEntries = (0, _entries.default)(JSON.parse(value));\n          if (mapEntries.length > maxFiles) return reject(new _errors.MaxFilesUploadError(`${maxFiles} max file uploads exceeded.`, 413));\n          map = new _map.default();\n\n          for (const [fieldName, paths] of mapEntries) {\n            map.set(fieldName, new Upload());\n\n            for (const path of paths) operationsPath.set(path, map.get(fieldName).promise);\n          }\n\n          resolve(operations);\n        }\n    }\n  });\n  parser.on('file', (fieldName, stream, filename, encoding, mimetype) => {\n    if (!map) return reject(new _errors.FilesBeforeMapUploadError(`Misordered multipart fields; files should follow “map” (${_errors.SPEC_URL}).`, 400));\n    if (map.has(fieldName)) map.get(fieldName).resolve({\n        stream,\n        filename,\n        mimetype,\n        encoding\n      });else stream.resume();\n  });\n  parser.once('filesLimit', () => {\n    if (map) for (const upload of map.values()) if (!upload.file) upload.reject(new _errors.MaxFilesUploadError(`${maxFiles} max file uploads exceeded.`));\n  });\n  parser.once('finish', () => {\n    if (map) for (const upload of map.values()) if (!upload.file) upload.reject(new _errors.FileMissingUploadError('File missing in the request.'));\n  });\n  request.on('close', () => {\n    if (map) for (const upload of map.values()) if (!upload.file) upload.reject(new _errors.UploadPromiseDisconnectUploadError('Request disconnected before file upload stream parsing.'));else if (!upload.done) {\n      upload.file.stream.truncated = true;\n      upload.file.stream.emit('error', new _errors.FileStreamDisconnectUploadError('Request disconnected during file upload stream parsing.'));\n    }\n  });\n  request.pipe(parser);\n});\n\nexports.processRequest = processRequest;\n\nconst apolloUploadKoa = options => function () {\n  var _ref = (0, _asyncToGenerator2.default)(function* (ctx, next) {\n    if (ctx.request.is('multipart/form-data')) ctx.request.body = yield processRequest(ctx.req, options);\n    yield next();\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.apolloUploadKoa = apolloUploadKoa;\n\nconst apolloUploadExpress = options => (request, response, next) => {\n  if (!request.is('multipart/form-data')) return next();\n  processRequest(request, options).then(body => {\n    request.body = body;\n    next();\n  }).catch(error => {\n    if (error.status && error.expose) response.status(error.status);\n    next(error);\n  });\n};\n\nexports.apolloUploadExpress = apolloUploadExpress;\n\n//# sourceURL=webpack:///./node_modules/@apollographql/apollo-upload-server/lib/middleware.js?");

/***/ }),

/***/ "./node_modules/@apollographql/apollo-upload-server/lib/types.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@apollographql/apollo-upload-server/lib/types.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLUpload = void 0;\n\nvar _graphql = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\n\nconst GraphQLUpload = new _graphql.GraphQLScalarType({\n  name: 'Upload',\n  description: 'The `Upload` scalar type represents a file upload promise that resolves ' + 'an object containing `stream`, `filename`, `mimetype` and `encoding`.',\n  parseValue: value => value,\n\n  parseLiteral() {\n    throw new Error('Upload scalar literal unsupported');\n  },\n\n  serialize() {\n    throw new Error('Upload scalar serialization unsupported');\n  }\n\n});\nexports.GraphQLUpload = GraphQLUpload;\n\n//# sourceURL=webpack:///./node_modules/@apollographql/apollo-upload-server/lib/types.js?");

/***/ }),

/***/ "./node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar getLoadingMarkup = function () { return ({\n    script: \"\\n    const loadingWrapper = document.getElementById('loading-wrapper');\\n    if (loadingWrapper) {\\n      loadingWrapper.classList.add('fadeOut');\\n    }\\n    \",\n    container: \"\\n<style type=\\\"text/css\\\">\\n.fadeOut {\\n  -webkit-animation: fadeOut 0.5s ease-out forwards;\\n  animation: fadeOut 0.5s ease-out forwards;\\n}\\n\\n@-webkit-keyframes fadeIn {\\n  from {\\n    opacity: 0;\\n    -webkit-transform: translateY(-10px);\\n    -ms-transform: translateY(-10px);\\n    transform: translateY(-10px);\\n  }\\n  to {\\n    opacity: 1;\\n    -webkit-transform: translateY(0);\\n    -ms-transform: translateY(0);\\n    transform: translateY(0);\\n  }\\n}\\n\\n@keyframes fadeIn {\\n  from {\\n    opacity: 0;\\n    -webkit-transform: translateY(-10px);\\n    -ms-transform: translateY(-10px);\\n    transform: translateY(-10px);\\n  }\\n  to {\\n    opacity: 1;\\n    -webkit-transform: translateY(0);\\n    -ms-transform: translateY(0);\\n    transform: translateY(0);\\n  }\\n}\\n\\n@-webkit-keyframes fadeOut {\\n  from {\\n    opacity: 1;\\n    -webkit-transform: translateY(0);\\n    -ms-transform: translateY(0);\\n    transform: translateY(0);\\n  }\\n  to {\\n    opacity: 0;\\n    -webkit-transform: translateY(-10px);\\n    -ms-transform: translateY(-10px);\\n    transform: translateY(-10px);\\n  }\\n}\\n\\n@keyframes fadeOut {\\n  from {\\n    opacity: 1;\\n    -webkit-transform: translateY(0);\\n    -ms-transform: translateY(0);\\n    transform: translateY(0);\\n  }\\n  to {\\n    opacity: 0;\\n    -webkit-transform: translateY(-10px);\\n    -ms-transform: translateY(-10px);\\n    transform: translateY(-10px);\\n  }\\n}\\n\\n@-webkit-keyframes appearIn {\\n  from {\\n    opacity: 0;\\n    -webkit-transform: translateY(0px);\\n    -ms-transform: translateY(0px);\\n    transform: translateY(0px);\\n  }\\n  to {\\n    opacity: 1;\\n    -webkit-transform: translateY(0);\\n    -ms-transform: translateY(0);\\n    transform: translateY(0);\\n  }\\n}\\n\\n@keyframes appearIn {\\n  from {\\n    opacity: 0;\\n    -webkit-transform: translateY(0px);\\n    -ms-transform: translateY(0px);\\n    transform: translateY(0px);\\n  }\\n  to {\\n    opacity: 1;\\n    -webkit-transform: translateY(0);\\n    -ms-transform: translateY(0);\\n    transform: translateY(0);\\n  }\\n}\\n\\n@-webkit-keyframes scaleIn {\\n  from {\\n    -webkit-transform: scale(0);\\n    -ms-transform: scale(0);\\n    transform: scale(0);\\n  }\\n  to {\\n    -webkit-transform: scale(1);\\n    -ms-transform: scale(1);\\n    transform: scale(1);\\n  }\\n}\\n\\n@keyframes scaleIn {\\n  from {\\n    -webkit-transform: scale(0);\\n    -ms-transform: scale(0);\\n    transform: scale(0);\\n  }\\n  to {\\n    -webkit-transform: scale(1);\\n    -ms-transform: scale(1);\\n    transform: scale(1);\\n  }\\n}\\n\\n@-webkit-keyframes innerDrawIn {\\n  0% {\\n    stroke-dashoffset: 70;\\n  }\\n  50% {\\n    stroke-dashoffset: 140;\\n  }\\n  100% {\\n    stroke-dashoffset: 210;\\n  }\\n}\\n\\n@keyframes innerDrawIn {\\n  0% {\\n    stroke-dashoffset: 70;\\n  }\\n  50% {\\n    stroke-dashoffset: 140;\\n  }\\n  100% {\\n    stroke-dashoffset: 210;\\n  }\\n}\\n\\n@-webkit-keyframes outerDrawIn {\\n  0% {\\n    stroke-dashoffset: 76;\\n  }\\n  100% {\\n    stroke-dashoffset: 152;\\n  }\\n}\\n\\n@keyframes outerDrawIn {\\n  0% {\\n    stroke-dashoffset: 76;\\n  }\\n  100% {\\n    stroke-dashoffset: 152;\\n  }\\n}\\n\\n.hHWjkv {\\n  -webkit-transform-origin: 0px 0px;\\n  -ms-transform-origin: 0px 0px;\\n  transform-origin: 0px 0px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\\n}\\n\\n.gCDOzd {\\n  -webkit-transform-origin: 0px 0px;\\n  -ms-transform-origin: 0px 0px;\\n  transform-origin: 0px 0px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\\n}\\n\\n.hmCcxi {\\n  -webkit-transform-origin: 0px 0px;\\n  -ms-transform-origin: 0px 0px;\\n  transform-origin: 0px 0px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\\n}\\n\\n.eHamQi {\\n  -webkit-transform-origin: 0px 0px;\\n  -ms-transform-origin: 0px 0px;\\n  transform-origin: 0px 0px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\\n}\\n\\n.byhgGu {\\n  -webkit-transform-origin: 0px 0px;\\n  -ms-transform-origin: 0px 0px;\\n  transform-origin: 0px 0px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\\n}\\n\\n.llAKP {\\n  -webkit-transform-origin: 0px 0px;\\n  -ms-transform-origin: 0px 0px;\\n  transform-origin: 0px 0px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\\n}\\n\\n.bglIGM {\\n  -webkit-transform-origin: 64px 28px;\\n  -ms-transform-origin: 64px 28px;\\n  transform-origin: 64px 28px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\\n  animation: scaleIn 0.25s linear forwards 0.2222222222222222s;\\n}\\n\\n.ksxRII {\\n  -webkit-transform-origin: 95.98500061035156px 46.510000228881836px;\\n  -ms-transform-origin: 95.98500061035156px 46.510000228881836px;\\n  transform-origin: 95.98500061035156px 46.510000228881836px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\\n  animation: scaleIn 0.25s linear forwards 0.4222222222222222s;\\n}\\n\\n.cWrBmb {\\n  -webkit-transform-origin: 95.97162628173828px 83.4900016784668px;\\n  -ms-transform-origin: 95.97162628173828px 83.4900016784668px;\\n  transform-origin: 95.97162628173828px 83.4900016784668px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\\n  animation: scaleIn 0.25s linear forwards 0.6222222222222222s;\\n}\\n\\n.Wnusb {\\n  -webkit-transform-origin: 64px 101.97999572753906px;\\n  -ms-transform-origin: 64px 101.97999572753906px;\\n  transform-origin: 64px 101.97999572753906px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\\n  animation: scaleIn 0.25s linear forwards 0.8222222222222223s;\\n}\\n\\n.bfPqf {\\n  -webkit-transform-origin: 32.03982162475586px 83.4900016784668px;\\n  -ms-transform-origin: 32.03982162475586px 83.4900016784668px;\\n  transform-origin: 32.03982162475586px 83.4900016784668px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\\n  animation: scaleIn 0.25s linear forwards 1.0222222222222221s;\\n}\\n\\n.edRCTN {\\n  -webkit-transform-origin: 32.033552169799805px 46.510000228881836px;\\n  -ms-transform-origin: 32.033552169799805px 46.510000228881836px;\\n  transform-origin: 32.033552169799805px 46.510000228881836px;\\n  -webkit-transform: scale(0);\\n  -ms-transform: scale(0);\\n  transform: scale(0);\\n  -webkit-animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\\n  animation: scaleIn 0.25s linear forwards 1.2222222222222223s;\\n}\\n\\n.iEGVWn {\\n  opacity: 0;\\n  stroke-dasharray: 76;\\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\\n  animation: outerDrawIn 0.5s ease-out forwards 0.3333333333333333s, appearIn 0.1s ease-out forwards 0.3333333333333333s;\\n  -webkit-animation-iteration-count: 1, 1;\\n  animation-iteration-count: 1, 1;\\n}\\n\\n.bsocdx {\\n  opacity: 0;\\n  stroke-dasharray: 76;\\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\\n  animation: outerDrawIn 0.5s ease-out forwards 0.5333333333333333s, appearIn 0.1s ease-out forwards 0.5333333333333333s;\\n  -webkit-animation-iteration-count: 1, 1;\\n  animation-iteration-count: 1, 1;\\n}\\n\\n.jAZXmP {\\n  opacity: 0;\\n  stroke-dasharray: 76;\\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\\n  animation: outerDrawIn 0.5s ease-out forwards 0.7333333333333334s, appearIn 0.1s ease-out forwards 0.7333333333333334s;\\n  -webkit-animation-iteration-count: 1, 1;\\n  animation-iteration-count: 1, 1;\\n}\\n\\n.hSeArx {\\n  opacity: 0;\\n  stroke-dasharray: 76;\\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\\n  animation: outerDrawIn 0.5s ease-out forwards 0.9333333333333333s, appearIn 0.1s ease-out forwards 0.9333333333333333s;\\n  -webkit-animation-iteration-count: 1, 1;\\n  animation-iteration-count: 1, 1;\\n}\\n\\n.bVgqGk {\\n  opacity: 0;\\n  stroke-dasharray: 76;\\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\\n  animation: outerDrawIn 0.5s ease-out forwards 1.1333333333333333s, appearIn 0.1s ease-out forwards 1.1333333333333333s;\\n  -webkit-animation-iteration-count: 1, 1;\\n  animation-iteration-count: 1, 1;\\n}\\n\\n.hEFqBt {\\n  opacity: 0;\\n  stroke-dasharray: 76;\\n  -webkit-animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\\n  animation: outerDrawIn 0.5s ease-out forwards 1.3333333333333333s, appearIn 0.1s ease-out forwards 1.3333333333333333s;\\n  -webkit-animation-iteration-count: 1, 1;\\n  animation-iteration-count: 1, 1;\\n}\\n\\n.dzEKCM {\\n  opacity: 0;\\n  stroke-dasharray: 70;\\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\\n  animation: innerDrawIn 1s ease-in-out forwards 1.3666666666666667s, appearIn 0.1s linear forwards 1.3666666666666667s;\\n  -webkit-animation-iteration-count: infinite, 1;\\n  animation-iteration-count: infinite, 1;\\n}\\n\\n.DYnPx {\\n  opacity: 0;\\n  stroke-dasharray: 70;\\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\\n  animation: innerDrawIn 1s ease-in-out forwards 1.5333333333333332s, appearIn 0.1s linear forwards 1.5333333333333332s;\\n  -webkit-animation-iteration-count: infinite, 1;\\n  animation-iteration-count: infinite, 1;\\n}\\n\\n.hjPEAQ {\\n  opacity: 0;\\n  stroke-dasharray: 70;\\n  -webkit-animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\\n  animation: innerDrawIn 1s ease-in-out forwards 1.7000000000000002s, appearIn 0.1s linear forwards 1.7000000000000002s;\\n  -webkit-animation-iteration-count: infinite, 1;\\n  animation-iteration-count: infinite, 1;\\n}\\n\\n#loading-wrapper {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  display: -webkit-box;\\n  display: -webkit-flex;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-align-items: center;\\n  -webkit-box-align: center;\\n  -ms-flex-align: center;\\n  align-items: center;\\n  -webkit-box-pack: center;\\n  -webkit-justify-content: center;\\n  -ms-flex-pack: center;\\n  justify-content: center;\\n  -webkit-flex-direction: column;\\n  -ms-flex-direction: column;\\n  flex-direction: column;\\n}\\n\\n.logo {\\n  width: 75px;\\n  height: 75px;\\n  margin-bottom: 20px;\\n  opacity: 0;\\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\\n  animation: fadeIn 0.5s ease-out forwards;\\n}\\n\\n.text {\\n  font-size: 32px;\\n  font-weight: 200;\\n  text-align: center;\\n  color: rgba(255, 255, 255, 0.6);\\n  opacity: 0;\\n  -webkit-animation: fadeIn 0.5s ease-out forwards;\\n  animation: fadeIn 0.5s ease-out forwards;\\n}\\n\\n.dGfHfc {\\n  font-weight: 400;\\n}\\n</style>\\n<div id=\\\"loading-wrapper\\\">\\n<svg class=\\\"logo\\\" viewBox=\\\"0 0 128 128\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n  <title>GraphQL Playground Logo</title>\\n  <defs>\\n    <linearGradient id=\\\"linearGradient-1\\\" x1=\\\"4.86%\\\" x2=\\\"96.21%\\\" y1=\\\"0%\\\" y2=\\\"99.66%\\\">\\n      <stop stop-color=\\\"#E00082\\\" stop-opacity=\\\".8\\\" offset=\\\"0%\\\"></stop>\\n      <stop stop-color=\\\"#E00082\\\" offset=\\\"100%\\\"></stop>\\n    </linearGradient>\\n  </defs>\\n  <g>\\n    <rect id=\\\"Gradient\\\" width=\\\"127.96\\\" height=\\\"127.96\\\" y=\\\"1\\\" fill=\\\"url(#linearGradient-1)\\\" rx=\\\"4\\\"></rect>\\n    <path id=\\\"Border\\\" fill=\\\"#E00082\\\" fill-rule=\\\"nonzero\\\" d=\\\"M4.7 2.84c-1.58 0-2.86 1.28-2.86 2.85v116.57c0 1.57 1.28 2.84 2.85 2.84h116.57c1.57 0 2.84-1.26 2.84-2.83V5.67c0-1.55-1.26-2.83-2.83-2.83H4.67zM4.7 0h116.58c3.14 0 5.68 2.55 5.68 5.7v116.58c0 3.14-2.54 5.68-5.68 5.68H4.68c-3.13 0-5.68-2.54-5.68-5.68V5.68C-1 2.56 1.55 0 4.7 0z\\\"></path>\\n    <path class=\\\"bglIGM\\\" x=\\\"64\\\" y=\\\"28\\\" fill=\\\"#fff\\\" d=\\\"M64 36c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8\\\" style=\\\"transform: translate(100px, 100px);\\\"></path>\\n    <path class=\\\"ksxRII\\\" x=\\\"95.98500061035156\\\" y=\\\"46.510000228881836\\\" fill=\\\"#fff\\\" d=\\\"M89.04 50.52c-2.2-3.84-.9-8.73 2.94-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.76.9-10.97-2.94\\\"\\n      style=\\\"transform: translate(100px, 100px);\\\"></path>\\n    <path class=\\\"cWrBmb\\\" x=\\\"95.97162628173828\\\" y=\\\"83.4900016784668\\\" fill=\\\"#fff\\\" d=\\\"M102.9 87.5c-2.2 3.84-7.1 5.15-10.94 2.94-3.84-2.2-5.14-7.12-2.94-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.86 2.23 5.16 7.12 2.94 10.96\\\"\\n      style=\\\"transform: translate(100px, 100px);\\\"></path>\\n    <path class=\\\"Wnusb\\\" x=\\\"64\\\" y=\\\"101.97999572753906\\\" fill=\\\"#fff\\\" d=\\\"M64 110c-4.43 0-8-3.6-8-8.02 0-4.44 3.57-8.02 8-8.02s8 3.58 8 8.02c0 4.4-3.57 8.02-8 8.02\\\"\\n      style=\\\"transform: translate(100px, 100px);\\\"></path>\\n    <path class=\\\"bfPqf\\\" x=\\\"32.03982162475586\\\" y=\\\"83.4900016784668\\\" fill=\\\"#fff\\\" d=\\\"M25.1 87.5c-2.2-3.84-.9-8.73 2.93-10.96 3.83-2.2 8.72-.9 10.95 2.94 2.2 3.84.9 8.73-2.94 10.96-3.85 2.2-8.74.9-10.95-2.94\\\"\\n      style=\\\"transform: translate(100px, 100px);\\\"></path>\\n    <path class=\\\"edRCTN\\\" x=\\\"32.033552169799805\\\" y=\\\"46.510000228881836\\\" fill=\\\"#fff\\\" d=\\\"M38.96 50.52c-2.2 3.84-7.12 5.15-10.95 2.94-3.82-2.2-5.12-7.12-2.92-10.96 2.2-3.84 7.12-5.15 10.95-2.94 3.83 2.23 5.14 7.12 2.94 10.96\\\"\\n      style=\\\"transform: translate(100px, 100px);\\\"></path>\\n    <path class=\\\"iEGVWn\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" d=\\\"M63.55 27.5l32.9 19-32.9-19z\\\"></path>\\n    <path class=\\\"bsocdx\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" d=\\\"M96 46v38-38z\\\"></path>\\n    <path class=\\\"jAZXmP\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" d=\\\"M96.45 84.5l-32.9 19 32.9-19z\\\"></path>\\n    <path class=\\\"hSeArx\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" d=\\\"M64.45 103.5l-32.9-19 32.9 19z\\\"></path>\\n    <path class=\\\"bVgqGk\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" d=\\\"M32 84V46v38z\\\"></path>\\n    <path class=\\\"hEFqBt\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" d=\\\"M31.55 46.5l32.9-19-32.9 19z\\\"></path>\\n    <path class=\\\"dzEKCM\\\" id=\\\"Triangle-Bottom\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" d=\\\"M30 84h70\\\" stroke-linecap=\\\"round\\\"></path>\\n    <path class=\\\"DYnPx\\\" id=\\\"Triangle-Left\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" d=\\\"M65 26L30 87\\\" stroke-linecap=\\\"round\\\"></path>\\n    <path class=\\\"hjPEAQ\\\" id=\\\"Triangle-Right\\\" stroke=\\\"#fff\\\" stroke-width=\\\"4\\\" d=\\\"M98 87L63 26\\\" stroke-linecap=\\\"round\\\"></path>\\n  </g>\\n</svg>\\n<div class=\\\"text\\\">Loading\\n  <span class=\\\"dGfHfc\\\">GraphQL Playground</span>\\n</div>\\n</div>\\n\",\n}); };\nexports.default = getLoadingMarkup;\n//# sourceMappingURL=get-loading-markup.js.map\n\n//# sourceURL=webpack:///./node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js?");

/***/ }),

/***/ "./node_modules/@apollographql/graphql-playground-html/dist/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@apollographql/graphql-playground-html/dist/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar render_playground_page_1 = __webpack_require__(/*! ./render-playground-page */ \"./node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js\");\nexports.renderPlaygroundPage = render_playground_page_1.renderPlaygroundPage;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@apollographql/graphql-playground-html/dist/index.js?");

/***/ }),

/***/ "./node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar get_loading_markup_1 = __webpack_require__(/*! ./get-loading-markup */ \"./node_modules/@apollographql/graphql-playground-html/dist/get-loading-markup.js\");\nvar loading = get_loading_markup_1.default();\nvar getCdnMarkup = function (options) { return \"\\n    <link rel=\\\"stylesheet\\\" href=\\\"//cdn.jsdelivr.net/npm/graphql-playground-react@\" + options.version + \"/build/static/css/index.css\\\" />\\n    <link rel=\\\"shortcut icon\\\" href=\\\"//cdn.jsdelivr.net/npm/graphql-playground-react@\" + options.version + \"/build/favicon.png\\\" />\\n    <script src=\\\"//cdn.jsdelivr.net/npm/graphql-playground-react@\" + options.version + \"/build/static/js/middleware.js\\\"></script>\\n\"; };\nfunction renderPlaygroundPage(options) {\n    var extendedOptions = __assign({}, options, { canSaveConfig: false });\n    // for compatibility\n    if (options.subscriptionsEndpoint) {\n        extendedOptions.subscriptionEndpoint = options.subscriptionsEndpoint;\n    }\n    if (options.config) {\n        extendedOptions.configString = JSON.stringify(options.config, null, 2);\n    }\n    if (!extendedOptions.endpoint && !extendedOptions.configString) {\n        /* tslint:disable-next-line */\n        console.warn(\"WARNING: You didn't provide an endpoint and don't have a .graphqlconfig. Make sure you have at least one of them.\");\n    }\n    return \"\\n  <!DOCTYPE html>\\n  <html>\\n  <head>\\n    <meta charset=utf-8 />\\n    <meta name=\\\"viewport\\\" content=\\\"user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui\\\">\\n    <link rel=\\\"shortcut icon\\\" href=\\\"https://graphcool-playground.netlify.com/favicon.png\\\">\\n    <title>\" + (extendedOptions.title || 'GraphQL Playground') + \"</title>\\n    \" + (extendedOptions.env === 'react' || extendedOptions.env === 'electron'\n        ? ''\n        : getCdnMarkup(extendedOptions)) + \"\\n  </head>\\n  <body>\\n    <style type=\\\"text/css\\\">\\n      html {\\n        font-family: \\\"Open Sans\\\", sans-serif;\\n        overflow: hidden;\\n      }\\n  \\n      body {\\n        margin: 0;\\n        background: #172a3a;\\n      }\\n  \\n      .playgroundIn {\\n        -webkit-animation: playgroundIn 0.5s ease-out forwards;\\n        animation: playgroundIn 0.5s ease-out forwards;\\n      }\\n  \\n      @-webkit-keyframes playgroundIn {\\n        from {\\n          opacity: 0;\\n          -webkit-transform: translateY(10px);\\n          -ms-transform: translateY(10px);\\n          transform: translateY(10px);\\n        }\\n        to {\\n          opacity: 1;\\n          -webkit-transform: translateY(0);\\n          -ms-transform: translateY(0);\\n          transform: translateY(0);\\n        }\\n      }\\n  \\n      @keyframes playgroundIn {\\n        from {\\n          opacity: 0;\\n          -webkit-transform: translateY(10px);\\n          -ms-transform: translateY(10px);\\n          transform: translateY(10px);\\n        }\\n        to {\\n          opacity: 1;\\n          -webkit-transform: translateY(0);\\n          -ms-transform: translateY(0);\\n          transform: translateY(0);\\n        }\\n      }\\n    </style>\\n    \" + loading.container + \"\\n    <div id=\\\"root\\\" />\\n    <script type=\\\"text/javascript\\\">\\n      window.addEventListener('load', function (event) {\\n        \" + loading.script + \"\\n  \\n        const root = document.getElementById('root');\\n        root.classList.add('playgroundIn');\\n  \\n        GraphQLPlayground.init(root, \" + JSON.stringify(extendedOptions, null, 2) + \")\\n      })\\n    </script>\\n  </body>\\n  </html>\\n\";\n}\nexports.renderPlaygroundPage = renderPlaygroundPage;\n//# sourceMappingURL=render-playground-page.js.map\n\n//# sourceURL=webpack:///./node_modules/@apollographql/graphql-playground-html/dist/render-playground-page.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/map.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! core-js/library/fn/map */ \"core-js/library/fn/map\");\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime-corejs2/core-js/map.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/object/entries.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/object/entries.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! core-js/library/fn/object/entries */ \"core-js/library/fn/object/entries\");\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/entries.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/promise.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/promise.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! core-js/library/fn/promise */ \"core-js/library/fn/promise\");\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime-corejs2/core-js/promise.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _Promise = __webpack_require__(/*! ../core-js/promise */ \"./node_modules/@babel/runtime-corejs2/core-js/promise.js\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    _Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new _Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime-corejs2/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@dsherret/to-absolute-glob/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dsherret/to-absolute-glob/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar path = __webpack_require__(/*! path */ \"path\");\nvar isNegated = __webpack_require__(/*! is-negated-glob */ \"./node_modules/is-negated-glob/index.js\");\nvar isAbsolute = __webpack_require__(/*! is-absolute */ \"./node_modules/is-absolute/index.js\");\n\nmodule.exports = function(glob, options) {\n  // default options\n  var opts = options || {};\n\n  // ensure provided paths are absolute\n  var cwd = ensureAbsolute(opts.cwd ? opts.cwd : process.cwd());\n  var rootDir = opts.root ? ensureAbsolute(opts.root) : undefined;\n\n  // trim starting ./ from glob patterns\n  if (glob.slice(0, 2) === './') {\n    glob = glob.slice(2);\n  }\n\n  // when the glob pattern is only a . use an empty string\n  if (glob.length === 1 && glob === '.') {\n    glob = '';\n  }\n\n  // store last character before glob is modified\n  var suffix = glob.slice(-1);\n\n  // check to see if glob is negated (and not a leading negated-extglob)\n  var ing = isNegated(glob);\n  glob = ing.pattern;\n\n  // make glob absolute\n  if (rootDir && glob.charAt(0) === '/') {\n    glob = join(rootDir, glob);\n  } else if (!isAbsolute(glob) || glob.slice(0, 1) === '\\\\') {\n    glob = join(cwd, glob);\n  }\n\n  // if glob had a trailing `/`, re-add it now in case it was removed\n  if (suffix === '/' && glob.slice(-1) !== '/') {\n    glob += '/';\n  }\n\n  // re-add leading `!` if it was removed\n  return ing.negated ? '!' + glob : glob;\n};\n\nfunction ensureAbsolute(filepath) {\n  var absoluteFilepath = isAbsolute(filepath) ? filepath : path.resolve(filepath);\n  return unixify(absoluteFilepath);\n}\n\nfunction unixify(filepath) {\n  return filepath.replace(/\\\\/g, '/');\n}\n\nfunction join(dir, glob) {\n  if (dir.charAt(dir.length - 1) === '/') {\n    dir = dir.slice(0, -1);\n  }\n  if (glob.charAt(0) === '/') {\n    glob = glob.slice(1);\n  }\n  if (!glob) return dir;\n  return dir + '/' + glob;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@dsherret/to-absolute-glob/index.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/async/for-each.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/async/for-each.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = asyncForEach;\n\n/**\n * Simultaneously processes all items in the given array.\n *\n * @param {array} array - The array to iterate over\n * @param {function} iterator - The function to call for each item in the array\n * @param {function} done - The function to call when all iterators have completed\n */\nfunction asyncForEach (array, iterator, done) {\n  if (array.length === 0) {\n    // NOTE: Normally a bad idea to mix sync and async, but it's safe here because\n    // of the way that this method is currently used by DirectoryReader.\n    done();\n    return;\n  }\n\n  // Simultaneously process all items in the array.\n  let pending = array.length;\n  array.forEach(item => {\n    iterator(item, () => {\n      if (--pending === 0) {\n        done();\n      }\n    });\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/async/for-each.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/async/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/async/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = readdirAsync;\n\nconst maybe = __webpack_require__(/*! call-me-maybe */ \"./node_modules/call-me-maybe/index.js\");\nconst DirectoryReader = __webpack_require__(/*! ../directory-reader */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/directory-reader.js\");\n\nlet asyncFacade = {\n  fs: __webpack_require__(/*! fs */ \"fs\"),\n  forEach: __webpack_require__(/*! ./for-each */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/async/for-each.js\"),\n  async: true\n};\n\n/**\n * Returns the buffered output from an asynchronous {@link DirectoryReader},\n * via an error-first callback or a {@link Promise}.\n *\n * @param {string} dir\n * @param {object} [options]\n * @param {function} [callback]\n * @param {object} internalOptions\n */\nfunction readdirAsync (dir, options, callback, internalOptions) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  return maybe(callback, new Promise(((resolve, reject) => {\n    let results = [];\n\n    internalOptions.facade = asyncFacade;\n\n    let reader = new DirectoryReader(dir, options, internalOptions);\n    let stream = reader.stream;\n\n    stream.on('error', err => {\n      reject(err);\n      stream.pause();\n    });\n    stream.on('data', result => {\n      results.push(result);\n    });\n    stream.on('end', () => {\n      resolve(results);\n    });\n  })));\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/async/index.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/call.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/call.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nlet call = module.exports = {\n  safe: safeCall,\n  once: callOnce,\n};\n\n/**\n * Calls a function with the given arguments, and ensures that the error-first callback is _always_\n * invoked exactly once, even if the function throws an error.\n *\n * @param {function} fn - The function to invoke\n * @param {...*} args - The arguments to pass to the function. The final argument must be a callback function.\n */\nfunction safeCall (fn, args) {\n  // Get the function arguments as an array\n  args = Array.prototype.slice.call(arguments, 1);\n\n  // Replace the callback function with a wrapper that ensures it will only be called once\n  let callback = call.once(args.pop());\n  args.push(callback);\n\n  try {\n    fn.apply(null, args);\n  }\n  catch (err) {\n    callback(err);\n  }\n}\n\n/**\n * Returns a wrapper function that ensures the given callback function is only called once.\n * Subsequent calls are ignored, unless the first argument is an Error, in which case the\n * error is thrown.\n *\n * @param {function} fn - The function that should only be called once\n * @returns {function}\n */\nfunction callOnce (fn) {\n  let fulfilled = false;\n\n  return function onceWrapper (err) {\n    if (!fulfilled) {\n      fulfilled = true;\n      return fn.apply(this, arguments);\n    }\n    else if (err) {\n      // The callback has already been called, but now an error has occurred\n      // (most likely inside the callback function). So re-throw the error,\n      // so it gets handled further up the call stack\n      throw err;\n    }\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/call.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/directory-reader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/directory-reader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Readable = __webpack_require__(/*! stream */ \"stream\").Readable;\nconst EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nconst path = __webpack_require__(/*! path */ \"path\");\nconst normalizeOptions = __webpack_require__(/*! ./normalize-options */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/normalize-options.js\");\nconst stat = __webpack_require__(/*! ./stat */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/stat.js\");\nconst call = __webpack_require__(/*! ./call */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/call.js\");\n\n/**\n * Asynchronously reads the contents of a directory and streams the results\n * via a {@link stream.Readable}.\n */\nclass DirectoryReader {\n  /**\n   * @param {string} dir - The absolute or relative directory path to read\n   * @param {object} [options] - User-specified options, if any (see {@link normalizeOptions})\n   * @param {object} internalOptions - Internal options that aren't part of the public API\n   * @class\n   */\n  constructor (dir, options, internalOptions) {\n    this.options = options = normalizeOptions(options, internalOptions);\n\n    // Indicates whether we should keep reading\n    // This is set false if stream.Readable.push() returns false.\n    this.shouldRead = true;\n\n    // The directories to read\n    // (initialized with the top-level directory)\n    this.queue = [{\n      path: dir,\n      basePath: options.basePath,\n      posixBasePath: options.posixBasePath,\n      depth: 0\n    }];\n\n    // The number of directories that are currently being processed\n    this.pending = 0;\n\n    // The data that has been read, but not yet emitted\n    this.buffer = [];\n\n    this.stream = new Readable({ objectMode: true });\n    this.stream._read = () => {\n      // Start (or resume) reading\n      this.shouldRead = true;\n\n      // If we have data in the buffer, then send the next chunk\n      if (this.buffer.length > 0) {\n        this.pushFromBuffer();\n      }\n\n      // If we have directories queued, then start processing the next one\n      if (this.queue.length > 0) {\n        if (this.options.facade.sync) {\n          while (this.queue.length > 0) {\n            this.readNextDirectory();\n          }\n        }\n        else {\n          this.readNextDirectory();\n        }\n      }\n\n      this.checkForEOF();\n    };\n  }\n\n  /**\n   * Reads the next directory in the queue\n   */\n  readNextDirectory () {\n    let facade = this.options.facade;\n    let dir = this.queue.shift();\n    this.pending++;\n\n    // Read the directory listing\n    call.safe(facade.fs.readdir, dir.path, (err, items) => {\n      if (err) {\n        // fs.readdir threw an error\n        this.emit('error', err);\n        return this.finishedReadingDirectory();\n      }\n\n      try {\n        // Process each item in the directory (simultaneously, if async)\n        facade.forEach(\n          items,\n          this.processItem.bind(this, dir),\n          this.finishedReadingDirectory.bind(this, dir)\n        );\n      }\n      catch (err2) {\n        // facade.forEach threw an error\n        // (probably because fs.readdir returned an invalid result)\n        this.emit('error', err2);\n        this.finishedReadingDirectory();\n      }\n    });\n  }\n\n  /**\n   * This method is called after all items in a directory have been processed.\n   *\n   * NOTE: This does not necessarily mean that the reader is finished, since there may still\n   * be other directories queued or pending.\n   */\n  finishedReadingDirectory () {\n    this.pending--;\n\n    if (this.shouldRead) {\n      // If we have directories queued, then start processing the next one\n      if (this.queue.length > 0 && this.options.facade.async) {\n        this.readNextDirectory();\n      }\n\n      this.checkForEOF();\n    }\n  }\n\n  /**\n   * Determines whether the reader has finished processing all items in all directories.\n   * If so, then the \"end\" event is fired (via {@Readable#push})\n   */\n  checkForEOF () {\n    if (this.buffer.length === 0 &&   // The stuff we've already read\n    this.pending === 0 &&             // The stuff we're currently reading\n    this.queue.length === 0) {        // The stuff we haven't read yet\n      // There's no more stuff!\n      this.stream.push(null);\n    }\n  }\n\n  /**\n   * Processes a single item in a directory.\n   *\n   * If the item is a directory, and `option.deep` is enabled, then the item will be added\n   * to the directory queue.\n   *\n   * If the item meets the filter criteria, then it will be emitted to the reader's stream.\n   *\n   * @param {object} dir - A directory object from the queue\n   * @param {string} item - The name of the item (name only, no path)\n   * @param {function} done - A callback function that is called after the item has been processed\n   */\n  processItem (dir, item, done) {\n    let stream = this.stream;\n    let options = this.options;\n\n    let itemPath = dir.basePath + item;\n    let posixPath = dir.posixBasePath + item;\n    let fullPath = path.join(dir.path, item);\n\n    // If `options.deep` is a number, and we've already recursed to the max depth,\n    // then there's no need to check fs.Stats to know if it's a directory.\n    // If `options.deep` is a function, then we'll need fs.Stats\n    let maxDepthReached = dir.depth >= options.recurseDepth;\n\n    // Do we need to call `fs.stat`?\n    let needStats =\n      !maxDepthReached ||                                 // we need the fs.Stats to know if it's a directory\n      options.stats ||                                    // the user wants fs.Stats objects returned\n      options.recurseFn ||                                // we need fs.Stats for the recurse function\n      options.filterFn ||                                 // we need fs.Stats for the filter function\n      EventEmitter.listenerCount(stream, 'file') ||       // we need the fs.Stats to know if it's a file\n      EventEmitter.listenerCount(stream, 'directory') ||  // we need the fs.Stats to know if it's a directory\n      EventEmitter.listenerCount(stream, 'symlink');      // we need the fs.Stats to know if it's a symlink\n\n    // If we don't need stats, then exit early\n    if (!needStats) {\n      if (this.filter(itemPath, posixPath)) {\n        this.pushOrBuffer({ data: itemPath });\n      }\n      return done();\n    }\n\n    // Get the fs.Stats object for this path\n    stat(options.facade.fs, fullPath, (err, stats) => {\n      if (err) {\n        // fs.stat threw an error\n        this.emit('error', err);\n        return done();\n      }\n\n      try {\n        // Add the item's path to the fs.Stats object\n        // The base of this path, and its separators are determined by the options\n        // (i.e. options.basePath and options.sep)\n        stats.path = itemPath;\n\n        // Add depth of the path to the fs.Stats object for use this in the filter function\n        stats.depth = dir.depth;\n\n        if (this.shouldRecurse(stats, posixPath, maxDepthReached)) {\n          // Add this subdirectory to the queue\n          this.queue.push({\n            path: fullPath,\n            basePath: itemPath + options.sep,\n            posixBasePath: posixPath + '/',\n            depth: dir.depth + 1,\n          });\n        }\n\n        // Determine whether this item matches the filter criteria\n        if (this.filter(stats, posixPath)) {\n          this.pushOrBuffer({\n            data: options.stats ? stats : itemPath,\n            file: stats.isFile(),\n            directory: stats.isDirectory(),\n            symlink: stats.isSymbolicLink(),\n          });\n        }\n\n        done();\n      }\n      catch (err2) {\n        // An error occurred while processing the item\n        // (probably during a user-specified function, such as options.deep, options.filter, etc.)\n        this.emit('error', err2);\n        done();\n      }\n    });\n  }\n\n  /**\n   * Pushes the given chunk of data to the stream, or adds it to the buffer,\n   * depending on the state of the stream.\n   *\n   * @param {object} chunk\n   */\n  pushOrBuffer (chunk) {\n    // Add the chunk to the buffer\n    this.buffer.push(chunk);\n\n    // If we're still reading, then immediately emit the next chunk in the buffer\n    // (which may or may not be the chunk that we just added)\n    if (this.shouldRead) {\n      this.pushFromBuffer();\n    }\n  }\n\n  /**\n   * Immediately pushes the next chunk in the buffer to the reader's stream.\n   * The \"data\" event will always be fired (via {@link Readable#push}).\n   * In addition, the \"file\", \"directory\", and/or \"symlink\" events may be fired,\n   * depending on the type of properties of the chunk.\n   */\n  pushFromBuffer () {\n    let stream = this.stream;\n    let chunk = this.buffer.shift();\n\n    // Stream the data\n    try {\n      this.shouldRead = stream.push(chunk.data);\n    }\n    catch (err) {\n      this.emit('error', err);\n    }\n\n    // Also emit specific events, based on the type of chunk\n    chunk.file && this.emit('file', chunk.data);\n    chunk.symlink && this.emit('symlink', chunk.data);\n    chunk.directory && this.emit('directory', chunk.data);\n  }\n\n  /**\n   * Determines whether the given directory meets the user-specified recursion criteria.\n   * If the user didn't specify recursion criteria, then this function will default to true.\n   *\n   * @param {fs.Stats} stats - The directory's {@link fs.Stats} object\n   * @param {string} posixPath - The item's POSIX path (used for glob matching)\n   * @param {boolean} maxDepthReached - Whether we've already crawled the user-specified depth\n   * @returns {boolean}\n   */\n  shouldRecurse (stats, posixPath, maxDepthReached) {\n    let options = this.options;\n\n    if (maxDepthReached) {\n      // We've already crawled to the maximum depth. So no more recursion.\n      return false;\n    }\n    else if (!stats.isDirectory()) {\n      // It's not a directory. So don't try to crawl it.\n      return false;\n    }\n    else if (options.recurseGlob) {\n      // Glob patterns are always tested against the POSIX path, even on Windows\n      // https://github.com/isaacs/node-glob#windows\n      return options.recurseGlob.test(posixPath);\n    }\n    else if (options.recurseRegExp) {\n      // Regular expressions are tested against the normal path\n      // (based on the OS or options.sep)\n      return options.recurseRegExp.test(stats.path);\n    }\n    else if (options.recurseFn) {\n      try {\n        // Run the user-specified recursion criteria\n        return options.recurseFn.call(null, stats);\n      }\n      catch (err) {\n        // An error occurred in the user's code.\n        // In Sync and Async modes, this will return an error.\n        // In Streaming mode, we emit an \"error\" event, but continue processing\n        this.emit('error', err);\n      }\n    }\n    else {\n      // No recursion function was specified, and we're within the maximum depth.\n      // So crawl this directory.\n      return true;\n    }\n  }\n\n  /**\n   * Determines whether the given item meets the user-specified filter criteria.\n   * If the user didn't specify a filter, then this function will always return true.\n   *\n   * @param {string|fs.Stats} value - Either the item's path, or the item's {@link fs.Stats} object\n   * @param {string} posixPath - The item's POSIX path (used for glob matching)\n   * @returns {boolean}\n   */\n  filter (value, posixPath) {\n    let options = this.options;\n\n    if (options.filterGlob) {\n      // Glob patterns are always tested against the POSIX path, even on Windows\n      // https://github.com/isaacs/node-glob#windows\n      return options.filterGlob.test(posixPath);\n    }\n    else if (options.filterRegExp) {\n      // Regular expressions are tested against the normal path\n      // (based on the OS or options.sep)\n      return options.filterRegExp.test(value.path || value);\n    }\n    else if (options.filterFn) {\n      try {\n        // Run the user-specified filter function\n        return options.filterFn.call(null, value);\n      }\n      catch (err) {\n        // An error occurred in the user's code.\n        // In Sync and Async modes, this will return an error.\n        // In Streaming mode, we emit an \"error\" event, but continue processing\n        this.emit('error', err);\n      }\n    }\n    else {\n      // No filter was specified, so match everything\n      return true;\n    }\n  }\n\n  /**\n   * Emits an event.  If one of the event listeners throws an error,\n   * then an \"error\" event is emitted.\n   *\n   * @param {string} eventName\n   * @param {*} data\n   */\n  emit (eventName, data) {\n    let stream = this.stream;\n\n    try {\n      stream.emit(eventName, data);\n    }\n    catch (err) {\n      if (eventName === 'error') {\n        // Don't recursively emit \"error\" events.\n        // If the first one fails, then just throw\n        throw err;\n      }\n      else {\n        stream.emit('error', err);\n      }\n    }\n  }\n}\n\nmodule.exports = DirectoryReader;\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/directory-reader.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst readdirSync = __webpack_require__(/*! ./sync */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/sync/index.js\");\nconst readdirAsync = __webpack_require__(/*! ./async */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/async/index.js\");\nconst readdirStream = __webpack_require__(/*! ./stream */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/stream/index.js\");\n\nmodule.exports = exports = readdirAsyncPath;\nexports.readdir = exports.readdirAsync = exports.async = readdirAsyncPath;\nexports.readdirAsyncStat = exports.async.stat = readdirAsyncStat;\nexports.readdirStream = exports.stream = readdirStreamPath;\nexports.readdirStreamStat = exports.stream.stat = readdirStreamStat;\nexports.readdirSync = exports.sync = readdirSyncPath;\nexports.readdirSyncStat = exports.sync.stat = readdirSyncStat;\n\n/**\n * Synchronous readdir that returns an array of string paths.\n *\n * @param {string} dir\n * @param {object} [options]\n * @returns {string[]}\n */\nfunction readdirSyncPath (dir, options) {\n  return readdirSync(dir, options, {});\n}\n\n/**\n * Synchronous readdir that returns results as an array of {@link fs.Stats} objects\n *\n * @param {string} dir\n * @param {object} [options]\n * @returns {fs.Stats[]}\n */\nfunction readdirSyncStat (dir, options) {\n  return readdirSync(dir, options, { stats: true });\n}\n\n/**\n * Aynchronous readdir (accepts an error-first callback or returns a {@link Promise}).\n * Results are an array of path strings.\n *\n * @param {string} dir\n * @param {object} [options]\n * @param {function} [callback]\n * @returns {Promise<string[]>}\n */\nfunction readdirAsyncPath (dir, options, callback) {\n  return readdirAsync(dir, options, callback, {});\n}\n\n/**\n * Aynchronous readdir (accepts an error-first callback or returns a {@link Promise}).\n * Results are an array of {@link fs.Stats} objects.\n *\n * @param {string} dir\n * @param {object} [options]\n * @param {function} [callback]\n * @returns {Promise<fs.Stats[]>}\n */\nfunction readdirAsyncStat (dir, options, callback) {\n  return readdirAsync(dir, options, callback, { stats: true });\n}\n\n/**\n * Aynchronous readdir that returns a {@link stream.Readable} (which is also an {@link EventEmitter}).\n * All stream data events (\"data\", \"file\", \"directory\", \"symlink\") are passed a path string.\n *\n * @param {string} dir\n * @param {object} [options]\n * @returns {stream.Readable}\n */\nfunction readdirStreamPath (dir, options) {\n  return readdirStream(dir, options, {});\n}\n\n/**\n * Aynchronous readdir that returns a {@link stream.Readable} (which is also an {@link EventEmitter})\n * All stream data events (\"data\", \"file\", \"directory\", \"symlink\") are passed an {@link fs.Stats} object.\n *\n * @param {string} dir\n * @param {object} [options]\n * @returns {stream.Readable}\n */\nfunction readdirStreamStat (dir, options) {\n  return readdirStream(dir, options, { stats: true });\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/index.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/normalize-options.js":
/*!************************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/normalize-options.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst globToRegExp = __webpack_require__(/*! glob-to-regexp */ \"./node_modules/glob-to-regexp/index.js\");\n\nmodule.exports = normalizeOptions;\n\nlet isWindows = /^win/.test(process.platform);\n\n/**\n * @typedef {Object} FSFacade\n * @property {fs.readdir} readdir\n * @property {fs.stat} stat\n * @property {fs.lstat} lstat\n */\n\n/**\n * Validates and normalizes the options argument\n *\n * @param {object} [options] - User-specified options, if any\n * @param {object} internalOptions - Internal options that aren't part of the public API\n *\n * @param {number|boolean|function} [options.deep]\n * The number of directories to recursively traverse. Any falsy value or negative number will\n * default to zero, so only the top-level contents will be returned. Set to `true` or `Infinity`\n * to traverse all subdirectories.  Or provide a function that accepts a {@link fs.Stats} object\n * and returns a truthy value if the directory's contents should be crawled.\n *\n * @param {function|string|RegExp} [options.filter]\n * A function that accepts a {@link fs.Stats} object and returns a truthy value if the data should\n * be returned.  Or a RegExp or glob string pattern, to filter by file name.\n *\n * @param {string} [options.sep]\n * The path separator to use. By default, the OS-specific separator will be used, but this can be\n * set to a specific value to ensure consistency across platforms.\n *\n * @param {string} [options.basePath]\n * The base path to prepend to each result. If empty, then all results will be relative to `dir`.\n *\n * @param {FSFacade} [options.fs]\n * Synchronous or asynchronous facades for Node.js File System module\n *\n * @param {object} [internalOptions.facade]\n * Synchronous or asynchronous facades for various methods, including for the Node.js File System module\n *\n * @param {boolean} [internalOptions.emit]\n * Indicates whether the reader should emit \"file\", \"directory\", and \"symlink\" events\n *\n * @param {boolean} [internalOptions.stats]\n * Indicates whether the reader should emit {@link fs.Stats} objects instead of path strings\n *\n * @returns {object}\n */\nfunction normalizeOptions (options, internalOptions) {\n  if (options === null || options === undefined) {\n    options = {};\n  }\n  else if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n\n  let recurseDepth, recurseFn, recurseRegExp, recurseGlob, deep = options.deep;\n  if (deep === null || deep === undefined) {\n    recurseDepth = 0;\n  }\n  else if (typeof deep === 'boolean') {\n    recurseDepth = deep ? Infinity : 0;\n  }\n  else if (typeof deep === 'number') {\n    if (deep < 0 || isNaN(deep)) {\n      throw new Error('options.deep must be a positive number');\n    }\n    else if (Math.floor(deep) !== deep) {\n      throw new Error('options.deep must be an integer');\n    }\n    else {\n      recurseDepth = deep;\n    }\n  }\n  else if (typeof deep === 'function') {\n    recurseDepth = Infinity;\n    recurseFn = deep;\n  }\n  else if (deep instanceof RegExp) {\n    recurseDepth = Infinity;\n    recurseRegExp = deep;\n  }\n  else if (typeof deep === 'string' && deep.length > 0) {\n    recurseDepth = Infinity;\n    recurseGlob = globToRegExp(deep, { extended: true, globstar: true });\n  }\n  else {\n    throw new TypeError('options.deep must be a boolean, number, function, regular expression, or glob pattern');\n  }\n\n  let filterFn, filterRegExp, filterGlob, filter = options.filter;\n  if (filter !== null && filter !== undefined) {\n    if (typeof filter === 'function') {\n      filterFn = filter;\n    }\n    else if (filter instanceof RegExp) {\n      filterRegExp = filter;\n    }\n    else if (typeof filter === 'string' && filter.length > 0) {\n      filterGlob = globToRegExp(filter, { extended: true, globstar: true });\n    }\n    else {\n      throw new TypeError('options.filter must be a function, regular expression, or glob pattern');\n    }\n  }\n\n  let sep = options.sep;\n  if (sep === null || sep === undefined) {\n    sep = path.sep;\n  }\n  else if (typeof sep !== 'string') {\n    throw new TypeError('options.sep must be a string');\n  }\n\n  let basePath = options.basePath;\n  if (basePath === null || basePath === undefined) {\n    basePath = '';\n  }\n  else if (typeof basePath === 'string') {\n    // Append a path separator to the basePath, if necessary\n    if (basePath && basePath.substr(-1) !== sep) {\n      basePath += sep;\n    }\n  }\n  else {\n    throw new TypeError('options.basePath must be a string');\n  }\n\n  // Convert the basePath to POSIX (forward slashes)\n  // so that glob pattern matching works consistently, even on Windows\n  let posixBasePath = basePath;\n  if (posixBasePath && sep !== '/') {\n    posixBasePath = posixBasePath.replace(new RegExp('\\\\' + sep, 'g'), '/');\n\n    /* istanbul ignore if */\n    if (isWindows) {\n      // Convert Windows root paths (C:\\) and UNCs (\\\\) to POSIX root paths\n      posixBasePath = posixBasePath.replace(/^([a-zA-Z]\\:\\/|\\/\\/)/, '/');\n    }\n  }\n\n  // Determine which facade methods to use\n  let facade;\n  if (options.fs === null || options.fs === undefined) {\n    // The user didn't provide their own facades, so use our internal ones\n    facade = internalOptions.facade;\n  }\n  else if (typeof options.fs === 'object') {\n    // Merge the internal facade methods with the user-provided `fs` facades\n    facade = Object.assign({}, internalOptions.facade);\n    facade.fs = Object.assign({}, internalOptions.facade.fs, options.fs);\n  }\n  else {\n    throw new TypeError('options.fs must be an object');\n  }\n\n  return {\n    recurseDepth,\n    recurseFn,\n    recurseRegExp,\n    recurseGlob,\n    filterFn,\n    filterRegExp,\n    filterGlob,\n    sep,\n    basePath,\n    posixBasePath,\n    facade,\n    emit: !!internalOptions.emit,\n    stats: !!internalOptions.stats,\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/normalize-options.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/stat.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/stat.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst call = __webpack_require__(/*! ./call */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/call.js\");\n\nmodule.exports = stat;\n\n/**\n * Retrieves the {@link fs.Stats} for the given path. If the path is a symbolic link,\n * then the Stats of the symlink's target are returned instead.  If the symlink is broken,\n * then the Stats of the symlink itself are returned.\n *\n * @param {object} fs - Synchronous or Asynchronouse facade for the \"fs\" module\n * @param {string} path - The path to return stats for\n * @param {function} callback\n */\nfunction stat (fs, path, callback) {\n  let isSymLink = false;\n\n  call.safe(fs.lstat, path, (err, lstats) => {\n    if (err) {\n      // fs.lstat threw an eror\n      return callback(err);\n    }\n\n    try {\n      isSymLink = lstats.isSymbolicLink();\n    }\n    catch (err2) {\n      // lstats.isSymbolicLink() threw an error\n      // (probably because fs.lstat returned an invalid result)\n      return callback(err2);\n    }\n\n    if (isSymLink) {\n      // Try to resolve the symlink\n      symlinkStat(fs, path, lstats, callback);\n    }\n    else {\n      // It's not a symlink, so return the stats as-is\n      callback(null, lstats);\n    }\n  });\n}\n\n/**\n * Retrieves the {@link fs.Stats} for the target of the given symlink.\n * If the symlink is broken, then the Stats of the symlink itself are returned.\n *\n * @param {object} fs - Synchronous or Asynchronouse facade for the \"fs\" module\n * @param {string} path - The path of the symlink to return stats for\n * @param {object} lstats - The stats of the symlink\n * @param {function} callback\n */\nfunction symlinkStat (fs, path, lstats, callback) {\n  call.safe(fs.stat, path, (err, stats) => {\n    if (err) {\n      // The symlink is broken, so return the stats for the link itself\n      return callback(null, lstats);\n    }\n\n    try {\n      // Return the stats for the resolved symlink target,\n      // and override the `isSymbolicLink` method to indicate that it's a symlink\n      stats.isSymbolicLink = () => true;\n    }\n    catch (err2) {\n      // Setting stats.isSymbolicLink threw an error\n      // (probably because fs.stat returned an invalid result)\n      return callback(err2);\n    }\n\n    callback(null, stats);\n  });\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/stat.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/stream/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/stream/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = readdirStream;\n\nconst DirectoryReader = __webpack_require__(/*! ../directory-reader */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/directory-reader.js\");\n\nlet streamFacade = {\n  fs: __webpack_require__(/*! fs */ \"fs\"),\n  forEach: __webpack_require__(/*! ../async/for-each */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/async/for-each.js\"),\n  async: true\n};\n\n/**\n * Returns the {@link stream.Readable} of an asynchronous {@link DirectoryReader}.\n *\n * @param {string} dir\n * @param {object} [options]\n * @param {object} internalOptions\n */\nfunction readdirStream (dir, options, internalOptions) {\n  internalOptions.facade = streamFacade;\n\n  let reader = new DirectoryReader(dir, options, internalOptions);\n  return reader.stream;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/stream/index.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/sync/for-each.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/sync/for-each.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = syncForEach;\n\n/**\n * A facade that allows {@link Array.forEach} to be called as though it were asynchronous.\n *\n * @param {array} array - The array to iterate over\n * @param {function} iterator - The function to call for each item in the array\n * @param {function} done - The function to call when all iterators have completed\n */\nfunction syncForEach (array, iterator, done) {\n  array.forEach(item => {\n    iterator(item, () => {\n      // Note: No error-handling here because this is currently only ever called\n      // by DirectoryReader, which never passes an `error` parameter to the callback.\n      // Instead, DirectoryReader emits an \"error\" event if an error occurs.\n    });\n  });\n\n  done();\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/sync/for-each.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/sync/fs.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/sync/fs.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst call = __webpack_require__(/*! ../call */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/call.js\");\n\n/**\n * A facade around {@link fs.readdirSync} that allows it to be called\n * the same way as {@link fs.readdir}.\n *\n * @param {string} dir\n * @param {function} callback\n */\nexports.readdir = function (dir, callback) {\n  // Make sure the callback is only called once\n  callback = call.once(callback);\n\n  try {\n    let items = fs.readdirSync(dir);\n    callback(null, items);\n  }\n  catch (err) {\n    callback(err);\n  }\n};\n\n/**\n * A facade around {@link fs.statSync} that allows it to be called\n * the same way as {@link fs.stat}.\n *\n * @param {string} path\n * @param {function} callback\n */\nexports.stat = function (path, callback) {\n  // Make sure the callback is only called once\n  callback = call.once(callback);\n\n  try {\n    let stats = fs.statSync(path);\n    callback(null, stats);\n  }\n  catch (err) {\n    callback(err);\n  }\n};\n\n/**\n * A facade around {@link fs.lstatSync} that allows it to be called\n * the same way as {@link fs.lstat}.\n *\n * @param {string} path\n * @param {function} callback\n */\nexports.lstat = function (path, callback) {\n  // Make sure the callback is only called once\n  callback = call.once(callback);\n\n  try {\n    let stats = fs.lstatSync(path);\n    callback(null, stats);\n  }\n  catch (err) {\n    callback(err);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/sync/fs.js?");

/***/ }),

/***/ "./node_modules/@mrmlnc/readdir-enhanced/lib/sync/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mrmlnc/readdir-enhanced/lib/sync/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = readdirSync;\n\nconst DirectoryReader = __webpack_require__(/*! ../directory-reader */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/directory-reader.js\");\n\nlet syncFacade = {\n  fs: __webpack_require__(/*! ./fs */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/sync/fs.js\"),\n  forEach: __webpack_require__(/*! ./for-each */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/sync/for-each.js\"),\n  sync: true\n};\n\n/**\n * Returns the buffered output from a synchronous {@link DirectoryReader}.\n *\n * @param {string} dir\n * @param {object} [options]\n * @param {object} internalOptions\n */\nfunction readdirSync (dir, options, internalOptions) {\n  internalOptions.facade = syncFacade;\n\n  let reader = new DirectoryReader(dir, options, internalOptions);\n  let stream = reader.stream;\n\n  let results = [];\n  let data = stream.read();\n  while (data !== null) {\n    results.push(data);\n    data = stream.read();\n  }\n\n  return results;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@mrmlnc/readdir-enhanced/lib/sync/index.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/decorators/param.decorators.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/decorators/param.decorators.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shared_utils_1 = __webpack_require__(/*! @nestjs/common/utils/shared.utils */ \"@nestjs/common/utils/shared.utils\");\n__webpack_require__(/*! reflect-metadata */ \"reflect-metadata\");\nconst gql_paramtype_enum_1 = __webpack_require__(/*! ../enums/gql-paramtype.enum */ \"./node_modules/@nestjs/graphql/dist/enums/gql-paramtype.enum.js\");\nconst graphql_constants_1 = __webpack_require__(/*! ../graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nconst assignMetadata = (args, paramtype, index, data, ...pipes) => (Object.assign({}, args, { [`${paramtype}:${index}`]: {\n        index,\n        data,\n        pipes,\n    } }));\nconst createParamDecorator = (paramtype) => {\n    return (data) => (target, key, index) => {\n        const args = Reflect.getMetadata(graphql_constants_1.PARAM_ARGS_METADATA, target.constructor, key) || {};\n        Reflect.defineMetadata(graphql_constants_1.PARAM_ARGS_METADATA, assignMetadata(args, paramtype, index, data), target.constructor, key);\n    };\n};\nconst createPipesParamDecorator = (paramtype) => (data, ...pipes) => (target, key, index) => {\n    const args = Reflect.getMetadata(graphql_constants_1.PARAM_ARGS_METADATA, target.constructor, key) || {};\n    const hasParamData = shared_utils_1.isNil(data) || shared_utils_1.isString(data);\n    const paramData = hasParamData ? data : undefined;\n    const paramPipes = hasParamData ? pipes : [data, ...pipes];\n    Reflect.defineMetadata(graphql_constants_1.PARAM_ARGS_METADATA, assignMetadata(args, paramtype, index, paramData, ...paramPipes), target.constructor, key);\n};\nexports.Root = createParamDecorator(gql_paramtype_enum_1.GqlParamtype.ROOT);\nexports.Parent = createParamDecorator(gql_paramtype_enum_1.GqlParamtype.ROOT);\nfunction Args(property, ...pipes) {\n    return createPipesParamDecorator(gql_paramtype_enum_1.GqlParamtype.ARGS)(property, ...pipes);\n}\nexports.Args = Args;\nfunction Context(property, ...pipes) {\n    return createPipesParamDecorator(gql_paramtype_enum_1.GqlParamtype.CONTEXT)(property, ...pipes);\n}\nexports.Context = Context;\nfunction Info(...pipes) {\n    return createPipesParamDecorator(gql_paramtype_enum_1.GqlParamtype.INFO)(undefined, ...pipes);\n}\nexports.Info = Info;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/decorators/param.decorators.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/decorators/resolvers.decorators.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/decorators/resolvers.decorators.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst resolvers_enum_1 = __webpack_require__(/*! ../enums/resolvers.enum */ \"./node_modules/@nestjs/graphql/dist/enums/resolvers.enum.js\");\nconst graphql_constants_1 = __webpack_require__(/*! ../graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nfunction createResolverDecorator(resolver) {\n    return (name) => (target, key, descriptor) => {\n        common_1.ReflectMetadata(graphql_constants_1.RESOLVER_TYPE_METADATA, resolver || name)(target, key, descriptor);\n        common_1.ReflectMetadata(graphql_constants_1.RESOLVER_NAME_METADATA, name)(target, key, descriptor);\n    };\n}\nexports.createResolverDecorator = createResolverDecorator;\nfunction createPropertyDecorator(propertyName) {\n    return (target, key, descriptor) => {\n        common_1.ReflectMetadata(graphql_constants_1.RESOLVER_NAME_METADATA, propertyName)(target, key, descriptor);\n        common_1.ReflectMetadata(graphql_constants_1.RESOLVER_PROPERTY_METADATA, true)(target, key, descriptor);\n    };\n}\nexports.createPropertyDecorator = createPropertyDecorator;\nfunction createDelegateDecorator(propertyName) {\n    return (target, key, descriptor) => {\n        common_1.ReflectMetadata(graphql_constants_1.RESOLVER_NAME_METADATA, propertyName)(target, key, descriptor);\n        common_1.ReflectMetadata(graphql_constants_1.RESOLVER_DELEGATE_METADATA, propertyName)(target, key, descriptor);\n    };\n}\nexports.createDelegateDecorator = createDelegateDecorator;\nfunction Scalar(name) {\n    return (target, key, descriptor) => {\n        common_1.ReflectMetadata(graphql_constants_1.SCALAR_NAME_METADATA, name)(target, key, descriptor);\n    };\n}\nexports.Scalar = Scalar;\nexports.Query = createResolverDecorator(resolvers_enum_1.Resolvers.QUERY);\nexports.Mutation = createResolverDecorator(resolvers_enum_1.Resolvers.MUTATION);\nexports.Subscription = createResolverDecorator(resolvers_enum_1.Resolvers.SUBSCRIPTION);\nexports.Resolver = createResolverDecorator();\nexports.ResolveProperty = createPropertyDecorator;\nexports.DelegateProperty = createDelegateDecorator;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/decorators/resolvers.decorators.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/enums/gql-paramtype.enum.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/enums/gql-paramtype.enum.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GqlParamtype;\n(function (GqlParamtype) {\n    GqlParamtype[GqlParamtype[\"ROOT\"] = 0] = \"ROOT\";\n    GqlParamtype[GqlParamtype[\"ARGS\"] = 1] = \"ARGS\";\n    GqlParamtype[GqlParamtype[\"CONTEXT\"] = 2] = \"CONTEXT\";\n    GqlParamtype[GqlParamtype[\"INFO\"] = 3] = \"INFO\";\n})(GqlParamtype = exports.GqlParamtype || (exports.GqlParamtype = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/enums/gql-paramtype.enum.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/enums/resolvers.enum.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/enums/resolvers.enum.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Resolvers;\n(function (Resolvers) {\n    Resolvers[\"QUERY\"] = \"Query\";\n    Resolvers[\"MUTATION\"] = \"Mutation\";\n    Resolvers[\"SUBSCRIPTION\"] = \"Subscription\";\n})(Resolvers = exports.Resolvers || (exports.Resolvers = {}));\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/enums/resolvers.enum.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/factories/params.factory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/factories/params.factory.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst gql_paramtype_enum_1 = __webpack_require__(/*! ../enums/gql-paramtype.enum */ \"./node_modules/@nestjs/graphql/dist/enums/gql-paramtype.enum.js\");\nclass GqlParamsFactory {\n    exchangeKeyForValue(type, data, args) {\n        if (!args) {\n            return null;\n        }\n        switch (type) {\n            case gql_paramtype_enum_1.GqlParamtype.ROOT:\n                return args[0];\n            case gql_paramtype_enum_1.GqlParamtype.ARGS:\n                return data && args[1] ? args[1][data] : args[1];\n            case gql_paramtype_enum_1.GqlParamtype.CONTEXT:\n                return data && args[2] ? args[2][data] : args[2];\n            case gql_paramtype_enum_1.GqlParamtype.INFO:\n                return data && args[3] ? args[3][data] : args[3];\n            default:\n                return null;\n        }\n    }\n}\nexports.GqlParamsFactory = GqlParamsFactory;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/factories/params.factory.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/graphql-ast.explorer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/graphql-ast.explorer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst ts_simple_ast_1 = __webpack_require__(/*! ts-simple-ast */ \"./node_modules/ts-simple-ast/dist/main.js\");\nlet GraphQLAstExplorer = class GraphQLAstExplorer {\n    explore(documentNode, outputPath, mode) {\n        if (!documentNode) {\n            return;\n        }\n        const tsAstHelper = new ts_simple_ast_1.default();\n        const tsFile = tsAstHelper.createSourceFile(outputPath, '', {\n            overwrite: true,\n        });\n        let { definitions } = documentNode;\n        definitions = lodash_1.sortBy(definitions, 'kind');\n        definitions.forEach(item => this.lookupDefinition(item, tsFile, mode));\n        return tsFile;\n    }\n    lookupDefinition(item, tsFile, mode) {\n        switch (item.kind) {\n            case 'SchemaDefinition':\n                return this.lookupRootSchemaDefinition(item.operationTypes, tsFile, mode);\n            case 'ObjectTypeDefinition':\n            case 'InputObjectTypeDefinition':\n                return this.addObjectTypeDefinition(item, tsFile, mode);\n            case 'InterfaceTypeDefinition':\n                return this.addObjectTypeDefinition(item, tsFile, 'interface');\n            case 'ScalarTypeDefinition':\n                return this.addScalarDefinition(item, tsFile);\n            case 'EnumTypeDefinition':\n                return this.addEnumDefinition(item, tsFile);\n            case 'UnionTypeDefinition':\n                return this.addUnionDefinition(item, tsFile);\n        }\n    }\n    lookupRootSchemaDefinition(operationTypes, tsFile, mode) {\n        const rootInterface = this.addClassOrInterface(tsFile, mode, {\n            name: 'ISchema',\n            isExported: true,\n        });\n        operationTypes.forEach(item => {\n            if (!item) {\n                return;\n            }\n            const tempOperationName = item.operation;\n            const typeName = lodash_1.get(item, 'type.name.value');\n            const interfaceName = typeName || tempOperationName;\n            const interfaceRef = this.addClassOrInterface(tsFile, mode, {\n                name: this.addSymbolIfRoot(lodash_1.upperFirst(interfaceName)),\n                isExported: true,\n            });\n            rootInterface.addProperty({\n                name: interfaceName,\n                type: interfaceRef.getName(),\n            });\n        });\n    }\n    addObjectTypeDefinition(item, tsFile, mode) {\n        const parentName = lodash_1.get(item, 'name.value');\n        if (!parentName) {\n            return;\n        }\n        let parentRef = this.getClassOrInterface(tsFile, mode, this.addSymbolIfRoot(parentName));\n        if (!parentRef) {\n            parentRef = this.addClassOrInterface(tsFile, mode, {\n                name: this.addSymbolIfRoot(lodash_1.upperFirst(parentName)),\n                isExported: true,\n            });\n        }\n        const interfaces = lodash_1.get(item, 'interfaces');\n        if (interfaces) {\n            if (mode === 'class') {\n                this.addImplementsInterfaces(interfaces, parentRef);\n            }\n            else {\n                this.addExtendInterfaces(interfaces, parentRef);\n            }\n        }\n        (item.fields || []).forEach(element => {\n            this.lookupFieldDefiniton(element, parentRef);\n        });\n    }\n    lookupFieldDefiniton(item, parentRef) {\n        switch (item.kind) {\n            case 'FieldDefinition':\n            case 'InputValueDefinition':\n                return this.lookupField(item, parentRef);\n        }\n    }\n    lookupField(item, parentRef) {\n        const propertyName = lodash_1.get(item, 'name.value');\n        if (!propertyName) {\n            return;\n        }\n        const isFunction = (item.arguments &&\n            !lodash_1.isEmpty(item.arguments)) ||\n            this.isRoot(parentRef.getName());\n        const { name: type, required } = this.getFieldTypeDefinition(item.type);\n        if (!isFunction) {\n            parentRef.addProperty({\n                name: propertyName,\n                type,\n                hasQuestionToken: !required,\n            });\n            return;\n        }\n        parentRef.addMethod({\n            name: propertyName,\n            returnType: `${type} | Promise<${type}>`,\n            parameters: this.getFunctionParameters(item.arguments),\n        });\n    }\n    getFieldTypeDefinition(type) {\n        const { required, type: nestedType } = this.getNestedType(type);\n        type = nestedType;\n        const isArray = type.kind === 'ListType';\n        if (isArray) {\n            const { required, type: nestedType } = this.getNestedType(lodash_1.get(type, 'type'));\n            type = nestedType;\n            const typeName = lodash_1.get(type, 'name.value');\n            return {\n                name: this.getType(typeName) + '[]',\n                required,\n            };\n        }\n        const typeName = lodash_1.get(type, 'name.value');\n        return {\n            name: this.getType(typeName),\n            required,\n        };\n    }\n    getNestedType(type) {\n        const isNonNullType = type.kind === 'NonNullType';\n        if (isNonNullType) {\n            return {\n                type: this.getNestedType(lodash_1.get(type, 'type')).type,\n                required: isNonNullType,\n            };\n        }\n        return { type, required: false };\n    }\n    getType(typeName) {\n        const defaults = this.getDefaultTypes();\n        const isDefault = defaults[typeName];\n        return isDefault ? defaults[typeName] : typeName;\n    }\n    getDefaultTypes() {\n        return {\n            String: 'string',\n            Int: 'number',\n            Boolean: 'boolean',\n            ID: 'string',\n            Float: 'number',\n        };\n    }\n    getFunctionParameters(inputs) {\n        if (!inputs) {\n            return [];\n        }\n        return inputs.map(element => {\n            const { name, required } = this.getFieldTypeDefinition(element.type);\n            return {\n                name: lodash_1.get(element, 'name.value'),\n                type: name,\n                hasQuestionToken: !required,\n            };\n        });\n    }\n    addScalarDefinition(item, tsFile) {\n        const name = lodash_1.get(item, 'name.value');\n        if (!name) {\n            return;\n        }\n        tsFile.addTypeAlias({\n            name,\n            type: 'any',\n            isExported: true,\n        });\n    }\n    addExtendInterfaces(interfaces, parentRef) {\n        if (!interfaces) {\n            return;\n        }\n        interfaces.forEach(element => {\n            const interfaceName = lodash_1.get(element, 'name.value');\n            if (interfaceName) {\n                parentRef.addExtends(interfaceName);\n            }\n        });\n    }\n    addImplementsInterfaces(interfaces, parentRef) {\n        if (!interfaces) {\n            return;\n        }\n        interfaces.forEach(element => {\n            const interfaceName = lodash_1.get(element, 'name.value');\n            if (interfaceName) {\n                parentRef.addImplements(interfaceName);\n            }\n        });\n    }\n    addEnumDefinition(item, tsFile) {\n        const name = lodash_1.get(item, 'name.value');\n        if (!name) {\n            return;\n        }\n        const members = lodash_1.map(item.values, value => ({\n            name: lodash_1.get(value, 'name.value'),\n            value: lodash_1.get(value, 'name.value'),\n        }));\n        tsFile.addEnum({\n            name,\n            members,\n            isExported: true,\n        });\n    }\n    addUnionDefinition(item, tsFile) {\n        const name = lodash_1.get(item, 'name.value');\n        if (!name) {\n            return;\n        }\n        const types = lodash_1.map(item.types, value => lodash_1.get(value, 'name.value'));\n        tsFile.addTypeAlias({\n            name,\n            type: types.join(' | '),\n            isExported: true,\n        });\n    }\n    addSymbolIfRoot(name) {\n        const root = ['Query', 'Mutation', 'Subscription'];\n        return root.indexOf(name) >= 0 ? `I${name}` : name;\n    }\n    isRoot(name) {\n        return ['IQuery', 'IMutation', 'ISubscription'].indexOf(name) >= 0;\n    }\n    addClassOrInterface(tsFile, mode, options) {\n        return mode === 'class'\n            ? tsFile.addClass(options)\n            : tsFile.addInterface(options);\n    }\n    getClassOrInterface(tsFile, mode, name) {\n        return mode === 'class' ? tsFile.getClass(name) : tsFile.getInterface(name);\n    }\n};\nGraphQLAstExplorer = __decorate([\n    common_1.Injectable()\n], GraphQLAstExplorer);\nexports.GraphQLAstExplorer = GraphQLAstExplorer;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/graphql-ast.explorer.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/graphql-types.loader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/graphql-types.loader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst glob = __webpack_require__(/*! glob */ \"glob\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst merge_graphql_schemas_1 = __webpack_require__(/*! merge-graphql-schemas */ \"./node_modules/merge-graphql-schemas/dist/index.esm.js\");\nlet GraphQLTypesLoader = class GraphQLTypesLoader {\n    mergeTypesByPaths(...pathsToTypes) {\n        return merge_graphql_schemas_1.mergeTypes(lodash_1.flatten(pathsToTypes.map(pattern => this.loadFiles(pattern))), { all: true });\n    }\n    loadFiles(pattern) {\n        const paths = glob.sync(pattern);\n        return paths.map(path => fs.readFileSync(path, 'utf8'));\n    }\n};\nGraphQLTypesLoader = __decorate([\n    common_1.Injectable()\n], GraphQLTypesLoader);\nexports.GraphQLTypesLoader = GraphQLTypesLoader;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/graphql-types.loader.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/graphql.constants.js":
/*!****************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/graphql.constants.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RESOLVER_TYPE_METADATA = 'graphql:resolver_type';\nexports.RESOLVER_NAME_METADATA = 'graphql:resolver_name';\nexports.RESOLVER_PROPERTY_METADATA = 'graphql:resolve_property';\nexports.RESOLVER_DELEGATE_METADATA = 'graphql:delegate_property';\nexports.SCALAR_NAME_METADATA = 'graphql:scalar';\nexports.PARAM_ARGS_METADATA = '__routeArguments__';\nexports.GRAPHQL_MODULE_OPTIONS = 'GqlModuleOptions';\nexports.SUBSCRIPTION_TYPE = 'Subscription';\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/graphql.constants.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/graphql.factory.js":
/*!**************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/graphql.factory.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst apollo_server_express_1 = __webpack_require__(/*! apollo-server-express */ \"./node_modules/apollo-server-express/dist/index.js\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst graphql_ast_explorer_1 = __webpack_require__(/*! ./graphql-ast.explorer */ \"./node_modules/@nestjs/graphql/dist/graphql-ast.explorer.js\");\nconst delegates_explorer_service_1 = __webpack_require__(/*! ./services/delegates-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/delegates-explorer.service.js\");\nconst resolvers_explorer_service_1 = __webpack_require__(/*! ./services/resolvers-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/resolvers-explorer.service.js\");\nconst scalars_explorer_service_1 = __webpack_require__(/*! ./services/scalars-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/scalars-explorer.service.js\");\nconst extend_util_1 = __webpack_require__(/*! ./utils/extend.util */ \"./node_modules/@nestjs/graphql/dist/utils/extend.util.js\");\nlet GraphQLFactory = class GraphQLFactory {\n    constructor(resolversExplorerService, delegatesExplorerService, scalarsExplorerService, graphqlAstExplorer) {\n        this.resolversExplorerService = resolversExplorerService;\n        this.delegatesExplorerService = delegatesExplorerService;\n        this.scalarsExplorerService = scalarsExplorerService;\n        this.graphqlAstExplorer = graphqlAstExplorer;\n    }\n    mergeOptions(options = { typeDefs: [] }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const resolvers = extend_util_1.extend(this.scalarsExplorerService.explore(), this.resolversExplorerService.explore());\n            if (lodash_1.isEmpty(options.typeDefs)) {\n                return Object.assign({}, options, { typeDefs: undefined, schema: options.transformSchema\n                        ? yield options.transformSchema(options.schema)\n                        : options.schema });\n            }\n            const executableSchema = apollo_server_express_1.makeExecutableSchema({\n                resolvers: extend_util_1.extend(resolvers, options.resolvers),\n                typeDefs: apollo_server_express_1.gql `\n        ${options.typeDefs}\n      `,\n                resolverValidationOptions: options.resolverValidationOptions,\n            });\n            const schema = options.schema\n                ? apollo_server_express_1.mergeSchemas({\n                    schemas: [options.schema, executableSchema],\n                })\n                : executableSchema;\n            return Object.assign({}, options, { typeDefs: undefined, schema: options.transformSchema\n                    ? yield options.transformSchema(schema)\n                    : schema });\n        });\n    }\n    createDelegates() {\n        return this.delegatesExplorerService.explore();\n    }\n    generateDefinitions(typeDefs, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (lodash_1.isEmpty(typeDefs) || !options.definitions) {\n                return;\n            }\n            const tsFile = this.graphqlAstExplorer.explore(apollo_server_express_1.gql `\n        ${typeDefs}\n      `, options.definitions.path, options.definitions.outputAs);\n            yield tsFile.save();\n        });\n    }\n};\nGraphQLFactory = __decorate([\n    common_1.Injectable(),\n    __metadata(\"design:paramtypes\", [resolvers_explorer_service_1.ResolversExplorerService,\n        delegates_explorer_service_1.DelegatesExplorerService,\n        scalars_explorer_service_1.ScalarsExplorerService,\n        graphql_ast_explorer_1.GraphQLAstExplorer])\n], GraphQLFactory);\nexports.GraphQLFactory = GraphQLFactory;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/graphql.factory.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/graphql.module.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/graphql.module.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GraphQLModule_1;\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst core_1 = __webpack_require__(/*! @nestjs/core */ \"@nestjs/core\");\nconst metadata_scanner_1 = __webpack_require__(/*! @nestjs/core/metadata-scanner */ \"@nestjs/core/metadata-scanner\");\nconst apollo_server_express_1 = __webpack_require__(/*! apollo-server-express */ \"./node_modules/apollo-server-express/dist/index.js\");\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst graphql_ast_explorer_1 = __webpack_require__(/*! ./graphql-ast.explorer */ \"./node_modules/@nestjs/graphql/dist/graphql-ast.explorer.js\");\nconst graphql_types_loader_1 = __webpack_require__(/*! ./graphql-types.loader */ \"./node_modules/@nestjs/graphql/dist/graphql-types.loader.js\");\nconst graphql_constants_1 = __webpack_require__(/*! ./graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nconst graphql_factory_1 = __webpack_require__(/*! ./graphql.factory */ \"./node_modules/@nestjs/graphql/dist/graphql.factory.js\");\nconst delegates_explorer_service_1 = __webpack_require__(/*! ./services/delegates-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/delegates-explorer.service.js\");\nconst resolvers_explorer_service_1 = __webpack_require__(/*! ./services/resolvers-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/resolvers-explorer.service.js\");\nconst scalars_explorer_service_1 = __webpack_require__(/*! ./services/scalars-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/scalars-explorer.service.js\");\nconst extend_util_1 = __webpack_require__(/*! ./utils/extend.util */ \"./node_modules/@nestjs/graphql/dist/utils/extend.util.js\");\nconst merge_defaults_util_1 = __webpack_require__(/*! ./utils/merge-defaults.util */ \"./node_modules/@nestjs/graphql/dist/utils/merge-defaults.util.js\");\nlet GraphQLModule = GraphQLModule_1 = class GraphQLModule {\n    constructor(appRefHost, options, graphQLFactory, graphqlTypesLoader) {\n        this.appRefHost = appRefHost;\n        this.options = options;\n        this.graphQLFactory = graphQLFactory;\n        this.graphqlTypesLoader = graphqlTypesLoader;\n    }\n    static forRoot(options = {}) {\n        options = merge_defaults_util_1.mergeDefaults(options);\n        return {\n            module: GraphQLModule_1,\n            providers: [\n                {\n                    provide: graphql_constants_1.GRAPHQL_MODULE_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    }\n    static forRootAsync(options) {\n        return {\n            module: GraphQLModule_1,\n            imports: options.imports,\n            providers: [...this.createAsyncProviders(options)],\n        };\n    }\n    static createAsyncProviders(options) {\n        if (options.useExisting || options.useFactory) {\n            return [this.createAsyncOptionsProvider(options)];\n        }\n        return [\n            this.createAsyncOptionsProvider(options),\n            {\n                provide: options.useClass,\n                useClass: options.useClass,\n            },\n        ];\n    }\n    static createAsyncOptionsProvider(options) {\n        if (options.useFactory) {\n            return {\n                provide: graphql_constants_1.GRAPHQL_MODULE_OPTIONS,\n                useFactory: options.useFactory,\n                inject: options.inject || [],\n            };\n        }\n        return {\n            provide: graphql_constants_1.GRAPHQL_MODULE_OPTIONS,\n            useFactory: (optionsFactory) => __awaiter(this, void 0, void 0, function* () { return yield optionsFactory.createGqlOptions(); }),\n            inject: [options.useExisting || options.useClass],\n        };\n    }\n    onModuleInit() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.appRefHost) {\n                return;\n            }\n            const httpServer = this.appRefHost.applicationRef;\n            if (!httpServer) {\n                return;\n            }\n            const { path, disableHealthCheck, onHealthCheck } = this.options;\n            const app = httpServer.getInstance();\n            const typePathsExists = this.options.typePaths && !lodash_1.isEmpty(this.options.typePaths);\n            const typeDefs = typePathsExists\n                ? this.graphqlTypesLoader.mergeTypesByPaths(...(this.options.typePaths || []))\n                : [];\n            const mergedTypeDefs = extend_util_1.extend(typeDefs, this.options.typeDefs);\n            const apolloOptions = yield this.graphQLFactory.mergeOptions(Object.assign({}, this.options, { typeDefs: mergedTypeDefs }));\n            if (this.options.definitions && this.options.definitions.path) {\n                yield this.graphQLFactory.generateDefinitions(graphql_1.printSchema(apolloOptions.schema), this.options);\n            }\n            this.apolloServer = new apollo_server_express_1.ApolloServer(apolloOptions);\n            this.apolloServer.applyMiddleware({\n                app,\n                path,\n                disableHealthCheck,\n                onHealthCheck,\n            });\n            if (this.options.installSubscriptionHandlers) {\n                this.apolloServer.installSubscriptionHandlers(httpServer.getHttpServer());\n            }\n        });\n    }\n};\nGraphQLModule = GraphQLModule_1 = __decorate([\n    common_1.Module({\n        providers: [\n            graphql_factory_1.GraphQLFactory,\n            metadata_scanner_1.MetadataScanner,\n            resolvers_explorer_service_1.ResolversExplorerService,\n            delegates_explorer_service_1.DelegatesExplorerService,\n            scalars_explorer_service_1.ScalarsExplorerService,\n            graphql_ast_explorer_1.GraphQLAstExplorer,\n            graphql_types_loader_1.GraphQLTypesLoader,\n        ],\n        exports: [graphql_types_loader_1.GraphQLTypesLoader, graphql_ast_explorer_1.GraphQLAstExplorer],\n    }),\n    __param(1, common_1.Inject(graphql_constants_1.GRAPHQL_MODULE_OPTIONS)),\n    __metadata(\"design:paramtypes\", [core_1.ApplicationReferenceHost, Object, graphql_factory_1.GraphQLFactory,\n        graphql_types_loader_1.GraphQLTypesLoader])\n], GraphQLModule);\nexports.GraphQLModule = GraphQLModule;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/graphql.module.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./decorators/param.decorators */ \"./node_modules/@nestjs/graphql/dist/decorators/param.decorators.js\"));\nvar resolvers_decorators_1 = __webpack_require__(/*! ./decorators/resolvers.decorators */ \"./node_modules/@nestjs/graphql/dist/decorators/resolvers.decorators.js\");\nexports.DelegateProperty = resolvers_decorators_1.DelegateProperty;\nexports.Mutation = resolvers_decorators_1.Mutation;\nexports.Query = resolvers_decorators_1.Query;\nexports.ResolveProperty = resolvers_decorators_1.ResolveProperty;\nexports.Resolver = resolvers_decorators_1.Resolver;\nexports.Scalar = resolvers_decorators_1.Scalar;\nexports.Subscription = resolvers_decorators_1.Subscription;\n__export(__webpack_require__(/*! ./graphql-ast.explorer */ \"./node_modules/@nestjs/graphql/dist/graphql-ast.explorer.js\"));\n__export(__webpack_require__(/*! ./graphql-types.loader */ \"./node_modules/@nestjs/graphql/dist/graphql-types.loader.js\"));\n__export(__webpack_require__(/*! ./graphql.factory */ \"./node_modules/@nestjs/graphql/dist/graphql.factory.js\"));\n__export(__webpack_require__(/*! ./graphql.module */ \"./node_modules/@nestjs/graphql/dist/graphql.module.js\"));\n__export(__webpack_require__(/*! ./services/gql-execution-context */ \"./node_modules/@nestjs/graphql/dist/services/gql-execution-context.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/index.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/services/base-explorer.service.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/services/base-explorer.service.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nclass BaseExplorerService {\n    getModules(modulesContainer, include) {\n        const mapToProviders = (list) => list.map(module => module.components);\n        if (!include || lodash_1.isEmpty(include)) {\n            return mapToProviders([...modulesContainer.values()]);\n        }\n        return mapToProviders([...modulesContainer.values()].filter(({ metatype }) => include.some(item => item === metatype)));\n    }\n    flatMap(modules, callback) {\n        return lodash_1.flattenDeep(modules.map(module => [...module.values()].map(({ instance }) => callback(instance)))).filter(lodash_1.identity);\n    }\n    groupMetadata(resolvers) {\n        const groupByType = lodash_1.groupBy(resolvers, metadata => metadata.type);\n        return lodash_1.mapValues(groupByType, resolversArr => resolversArr.reduce((prev, curr) => {\n            return Object.assign({}, prev, { [curr.name]: curr.callback });\n        }, {}));\n    }\n}\nexports.BaseExplorerService = BaseExplorerService;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/services/base-explorer.service.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/services/delegates-explorer.service.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/services/delegates-explorer.service.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst modules_container_1 = __webpack_require__(/*! @nestjs/core/injector/modules-container */ \"@nestjs/core/injector/modules-container\");\nconst metadata_scanner_1 = __webpack_require__(/*! @nestjs/core/metadata-scanner */ \"@nestjs/core/metadata-scanner\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst graphql_constants_1 = __webpack_require__(/*! ../graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nconst extract_metadata_util_1 = __webpack_require__(/*! ../utils/extract-metadata.util */ \"./node_modules/@nestjs/graphql/dist/utils/extract-metadata.util.js\");\nconst base_explorer_service_1 = __webpack_require__(/*! ./base-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/base-explorer.service.js\");\nlet DelegatesExplorerService = class DelegatesExplorerService extends base_explorer_service_1.BaseExplorerService {\n    constructor(modulesContainer, metadataScanner, gqlOptions) {\n        super();\n        this.modulesContainer = modulesContainer;\n        this.metadataScanner = metadataScanner;\n        this.gqlOptions = gqlOptions;\n    }\n    explore() {\n        const modules = this.getModules(this.modulesContainer, this.gqlOptions.include || []);\n        const delegates = this.flatMap(modules, instance => this.filterDelegates(instance));\n        return this.curryDelegates(this.groupMetadata(delegates));\n    }\n    filterDelegates(instance) {\n        if (!instance) {\n            return undefined;\n        }\n        const prototype = Object.getPrototypeOf(instance);\n        const predicate = (resolverType, isDelegated) => !isDelegated;\n        const resolvers = this.metadataScanner.scanFromPrototype(instance, prototype, name => extract_metadata_util_1.extractMetadata(instance, prototype, name, predicate));\n        return resolvers.filter(resolver => !!resolver).map(resolver => {\n            const callback = instance[resolver.methodName].bind(instance);\n            return Object.assign({}, resolver, { callback });\n        });\n    }\n    curryDelegates(delegates) {\n        return mergeInfo => lodash_1.mapValues(delegates, parent => lodash_1.mapValues(parent, (propertyFn, key) => propertyFn()(mergeInfo)));\n    }\n};\nDelegatesExplorerService = __decorate([\n    common_1.Injectable(),\n    __param(2, common_1.Inject(graphql_constants_1.GRAPHQL_MODULE_OPTIONS)),\n    __metadata(\"design:paramtypes\", [modules_container_1.ModulesContainer,\n        metadata_scanner_1.MetadataScanner, Object])\n], DelegatesExplorerService);\nexports.DelegatesExplorerService = DelegatesExplorerService;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/services/delegates-explorer.service.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/services/gql-execution-context.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/services/gql-execution-context.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst execution_context_host_1 = __webpack_require__(/*! @nestjs/core/helpers/execution-context.host */ \"@nestjs/core/helpers/execution-context.host\");\nclass GqlExecutionContext extends execution_context_host_1.ExecutionContextHost {\n    static create(executionContext) {\n        return Object.assign({\n            getRoot: () => executionContext.getArgByIndex(0),\n            getArgs: () => executionContext.getArgByIndex(1),\n            getContext: () => executionContext.getArgByIndex(2),\n            getInfo: () => executionContext.getArgByIndex(3),\n        }, executionContext);\n    }\n}\nexports.GqlExecutionContext = GqlExecutionContext;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/services/gql-execution-context.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/services/resolvers-explorer.service.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/services/resolvers-explorer.service.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst shared_utils_1 = __webpack_require__(/*! @nestjs/common/utils/shared.utils */ \"@nestjs/common/utils/shared.utils\");\nconst external_context_creator_1 = __webpack_require__(/*! @nestjs/core/helpers/external-context-creator */ \"@nestjs/core/helpers/external-context-creator\");\nconst modules_container_1 = __webpack_require__(/*! @nestjs/core/injector/modules-container */ \"@nestjs/core/injector/modules-container\");\nconst metadata_scanner_1 = __webpack_require__(/*! @nestjs/core/metadata-scanner */ \"@nestjs/core/metadata-scanner\");\nconst resolvers_enum_1 = __webpack_require__(/*! ../enums/resolvers.enum */ \"./node_modules/@nestjs/graphql/dist/enums/resolvers.enum.js\");\nconst params_factory_1 = __webpack_require__(/*! ../factories/params.factory */ \"./node_modules/@nestjs/graphql/dist/factories/params.factory.js\");\nconst graphql_constants_1 = __webpack_require__(/*! ../graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nconst extract_metadata_util_1 = __webpack_require__(/*! ../utils/extract-metadata.util */ \"./node_modules/@nestjs/graphql/dist/utils/extract-metadata.util.js\");\nconst base_explorer_service_1 = __webpack_require__(/*! ./base-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/base-explorer.service.js\");\nlet ResolversExplorerService = class ResolversExplorerService extends base_explorer_service_1.BaseExplorerService {\n    constructor(modulesContainer, metadataScanner, externalContextCreator, gqlOptions) {\n        super();\n        this.modulesContainer = modulesContainer;\n        this.metadataScanner = metadataScanner;\n        this.externalContextCreator = externalContextCreator;\n        this.gqlOptions = gqlOptions;\n        this.gqlParamsFactory = new params_factory_1.GqlParamsFactory();\n    }\n    explore() {\n        const modules = this.getModules(this.modulesContainer, this.gqlOptions.include || []);\n        const resolvers = this.flatMap(modules, instance => this.filterResolvers(instance));\n        return this.groupMetadata(resolvers);\n    }\n    filterResolvers(instance) {\n        if (!instance) {\n            return undefined;\n        }\n        const prototype = Object.getPrototypeOf(instance);\n        const predicate = (resolverType, isDelegated, isPropertyResolver) => shared_utils_1.isUndefined(resolverType) ||\n            isDelegated ||\n            (!isPropertyResolver &&\n                ![resolvers_enum_1.Resolvers.MUTATION, resolvers_enum_1.Resolvers.QUERY, resolvers_enum_1.Resolvers.SUBSCRIPTION].some(type => type === resolverType));\n        const resolvers = this.metadataScanner.scanFromPrototype(instance, prototype, name => extract_metadata_util_1.extractMetadata(instance, prototype, name, predicate));\n        return resolvers.filter(resolver => !!resolver).map(resolver => {\n            if (resolver.type === graphql_constants_1.SUBSCRIPTION_TYPE) {\n                return Object.assign({}, resolver, { callback: instance[resolver.methodName]() });\n            }\n            const resolverCallback = this.externalContextCreator.create(instance, prototype[resolver.methodName], resolver.methodName, graphql_constants_1.PARAM_ARGS_METADATA, this.gqlParamsFactory);\n            return Object.assign({}, resolver, { callback: resolverCallback });\n        });\n    }\n};\nResolversExplorerService = __decorate([\n    common_1.Injectable(),\n    __param(3, common_1.Inject(graphql_constants_1.GRAPHQL_MODULE_OPTIONS)),\n    __metadata(\"design:paramtypes\", [modules_container_1.ModulesContainer,\n        metadata_scanner_1.MetadataScanner,\n        external_context_creator_1.ExternalContextCreator, Object])\n], ResolversExplorerService);\nexports.ResolversExplorerService = ResolversExplorerService;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/services/resolvers-explorer.service.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/services/scalars-explorer.service.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/services/scalars-explorer.service.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\nconst modules_container_1 = __webpack_require__(/*! @nestjs/core/injector/modules-container */ \"@nestjs/core/injector/modules-container\");\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nconst graphql_constants_1 = __webpack_require__(/*! ../graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nconst base_explorer_service_1 = __webpack_require__(/*! ./base-explorer.service */ \"./node_modules/@nestjs/graphql/dist/services/base-explorer.service.js\");\nlet ScalarsExplorerService = class ScalarsExplorerService extends base_explorer_service_1.BaseExplorerService {\n    constructor(modulesContainer, gqlOptions) {\n        super();\n        this.modulesContainer = modulesContainer;\n        this.gqlOptions = gqlOptions;\n    }\n    explore() {\n        const modules = this.getModules(this.modulesContainer, this.gqlOptions.include || []);\n        return this.flatMap(modules, instance => this.filterScalar(instance));\n    }\n    filterScalar(instance) {\n        if (!instance) {\n            return undefined;\n        }\n        const name = Reflect.getMetadata(graphql_constants_1.SCALAR_NAME_METADATA, instance.constructor);\n        const bindContext = (fn) => fn ? fn.bind(instance) : undefined;\n        return name\n            ? {\n                [name]: new graphql_1.GraphQLScalarType({\n                    name,\n                    description: instance['description'],\n                    parseValue: bindContext(instance.parseValue),\n                    serialize: bindContext(instance.serialize),\n                    parseLiteral: bindContext(instance.parseLiteral),\n                }),\n            }\n            : undefined;\n    }\n};\nScalarsExplorerService = __decorate([\n    common_1.Injectable(),\n    __param(1, common_1.Inject(graphql_constants_1.GRAPHQL_MODULE_OPTIONS)),\n    __metadata(\"design:paramtypes\", [modules_container_1.ModulesContainer, Object])\n], ScalarsExplorerService);\nexports.ScalarsExplorerService = ScalarsExplorerService;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/services/scalars-explorer.service.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/utils/extend.util.js":
/*!****************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/utils/extend.util.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nfunction extend(obj1, obj2) {\n    if (lodash_1.isString(obj1)) {\n        return lodash_1.isString(obj2)\n            ? [lodash_1.defaultTo(obj1, ''), lodash_1.defaultTo(obj2, '')]\n            : [lodash_1.defaultTo(obj1, '')].concat(lodash_1.defaultTo(obj2, []));\n    }\n    if (lodash_1.isArray(obj1)) {\n        return lodash_1.defaultTo(obj1, []).concat(lodash_1.defaultTo(obj2, []));\n    }\n    return Object.assign({}, (obj1 || {}), (obj2 || {}));\n}\nexports.extend = extend;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/utils/extend.util.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/utils/extract-metadata.util.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/utils/extract-metadata.util.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! reflect-metadata */ \"reflect-metadata\");\nconst graphql_constants_1 = __webpack_require__(/*! ../graphql.constants */ \"./node_modules/@nestjs/graphql/dist/graphql.constants.js\");\nfunction extractMetadata(instance, prototype, methodName, filterPredicate) {\n    const callback = prototype[methodName];\n    const resolverType = Reflect.getMetadata(graphql_constants_1.RESOLVER_TYPE_METADATA, callback) ||\n        Reflect.getMetadata(graphql_constants_1.RESOLVER_TYPE_METADATA, instance.constructor);\n    const isPropertyResolver = Reflect.getMetadata(graphql_constants_1.RESOLVER_PROPERTY_METADATA, callback);\n    const resolverName = Reflect.getMetadata(graphql_constants_1.RESOLVER_NAME_METADATA, callback);\n    const isDelegated = !!Reflect.getMetadata(graphql_constants_1.RESOLVER_DELEGATE_METADATA, callback);\n    if (filterPredicate(resolverType, isDelegated, isPropertyResolver)) {\n        return null;\n    }\n    return {\n        name: resolverName || methodName,\n        type: resolverType,\n        methodName,\n    };\n}\nexports.extractMetadata = extractMetadata;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/utils/extract-metadata.util.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/dist/utils/merge-defaults.util.js":
/*!************************************************************************!*\
  !*** ./node_modules/@nestjs/graphql/dist/utils/merge-defaults.util.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst defaultOptions = {\n    path: '/graphql',\n};\nfunction mergeDefaults(options, defaults = defaultOptions) {\n    return Object.assign({}, defaults, options);\n}\nexports.mergeDefaults = mergeDefaults;\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/dist/utils/merge-defaults.util.js?");

/***/ }),

/***/ "./node_modules/@nestjs/graphql/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@nestjs/graphql/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexports.__esModule = true;\n__export(__webpack_require__(/*! ./dist */ \"./node_modules/@nestjs/graphql/dist/index.js\"));\n\n\n//# sourceURL=webpack:///./node_modules/@nestjs/graphql/index.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/adapters/fs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/adapters/fs.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.FILE_SYSTEM_ADAPTER = {\n    lstat: fs.lstat,\n    stat: fs.stat,\n    lstatSync: fs.lstatSync,\n    statSync: fs.statSync\n};\nfunction getFileSystemAdapter(fsMethods) {\n    if (!fsMethods) {\n        return exports.FILE_SYSTEM_ADAPTER;\n    }\n    return Object.assign({}, exports.FILE_SYSTEM_ADAPTER, fsMethods);\n}\nexports.getFileSystemAdapter = getFileSystemAdapter;\n//# sourceMappingURL=fs.js.map\n\n//# sourceURL=webpack:///./node_modules/@nodelib/fs.stat/out/adapters/fs.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst optionsManager = __webpack_require__(/*! ./managers/options */ \"./node_modules/@nodelib/fs.stat/out/managers/options.js\");\nconst statProvider = __webpack_require__(/*! ./providers/stat */ \"./node_modules/@nodelib/fs.stat/out/providers/stat.js\");\n/**\n * Asynchronous API.\n */\nfunction stat(path, opts) {\n    return new Promise((resolve, reject) => {\n        statProvider.async(path, optionsManager.prepare(opts), (err, stats) => err ? reject(err) : resolve(stats));\n    });\n}\nexports.stat = stat;\nfunction statCallback(path, optsOrCallback, callback) {\n    if (typeof optsOrCallback === 'function') {\n        callback = optsOrCallback; /* tslint:disable-line: no-parameter-reassignment */\n        optsOrCallback = undefined; /* tslint:disable-line: no-parameter-reassignment */\n    }\n    if (typeof callback === 'undefined') {\n        throw new TypeError('The \"callback\" argument must be of type Function.');\n    }\n    statProvider.async(path, optionsManager.prepare(optsOrCallback), callback);\n}\nexports.statCallback = statCallback;\n/**\n * Synchronous API.\n */\nfunction statSync(path, opts) {\n    return statProvider.sync(path, optionsManager.prepare(opts));\n}\nexports.statSync = statSync;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@nodelib/fs.stat/out/index.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/managers/options.js":
/*!***************************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/managers/options.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fsAdapter = __webpack_require__(/*! ../adapters/fs */ \"./node_modules/@nodelib/fs.stat/out/adapters/fs.js\");\nfunction prepare(opts) {\n    const options = Object.assign({\n        fs: fsAdapter.getFileSystemAdapter(opts ? opts.fs : undefined),\n        throwErrorOnBrokenSymlinks: true,\n        followSymlinks: true\n    }, opts);\n    return options;\n}\nexports.prepare = prepare;\n//# sourceMappingURL=options.js.map\n\n//# sourceURL=webpack:///./node_modules/@nodelib/fs.stat/out/managers/options.js?");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/providers/stat.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/providers/stat.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction sync(path, options) {\n    const lstat = options.fs.lstatSync(path);\n    if (!isFollowedSymlink(lstat, options)) {\n        return lstat;\n    }\n    try {\n        const stat = options.fs.statSync(path);\n        stat.isSymbolicLink = () => true;\n        return stat;\n    }\n    catch (err) {\n        if (!options.throwErrorOnBrokenSymlinks) {\n            return lstat;\n        }\n        throw err;\n    }\n}\nexports.sync = sync;\nfunction async(path, options, callback) {\n    options.fs.lstat(path, (err0, lstat) => {\n        if (err0) {\n            return callback(err0, undefined);\n        }\n        if (!isFollowedSymlink(lstat, options)) {\n            return callback(null, lstat);\n        }\n        options.fs.stat(path, (err1, stat) => {\n            if (err1) {\n                return options.throwErrorOnBrokenSymlinks ? callback(err1) : callback(null, lstat);\n            }\n            stat.isSymbolicLink = () => true;\n            callback(null, stat);\n        });\n    });\n}\nexports.async = async;\n/**\n * Returns `true` for followed symlink.\n */\nfunction isFollowedSymlink(stat, options) {\n    return stat.isSymbolicLink() && options.followSymlinks;\n}\nexports.isFollowedSymlink = isFollowedSymlink;\n//# sourceMappingURL=stat.js.map\n\n//# sourceURL=webpack:///./node_modules/@nodelib/fs.stat/out/providers/stat.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/apollo-cache-control/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-cache-control/dist/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar CacheScope;\n(function (CacheScope) {\n    CacheScope[\"Public\"] = \"PUBLIC\";\n    CacheScope[\"Private\"] = \"PRIVATE\";\n})(CacheScope = exports.CacheScope || (exports.CacheScope = {}));\nclass CacheControlExtension {\n    constructor(options = {}) {\n        this.hints = new Map();\n        this.defaultMaxAge = options.defaultMaxAge || 0;\n    }\n    willResolveField(_source, _args, _context, info) {\n        let hint = {};\n        const targetType = graphql_1.getNamedType(info.returnType);\n        if (targetType instanceof graphql_1.GraphQLObjectType ||\n            targetType instanceof graphql_1.GraphQLInterfaceType) {\n            if (targetType.astNode) {\n                hint = mergeHints(hint, cacheHintFromDirectives(targetType.astNode.directives));\n            }\n        }\n        const parentType = info.parentType;\n        if (parentType instanceof graphql_1.GraphQLObjectType) {\n            const fieldDef = parentType.getFields()[info.fieldName];\n            if (fieldDef.astNode) {\n                hint = mergeHints(hint, cacheHintFromDirectives(fieldDef.astNode.directives));\n            }\n        }\n        if ((targetType instanceof graphql_1.GraphQLObjectType ||\n            targetType instanceof graphql_1.GraphQLInterfaceType) &&\n            hint.maxAge === undefined) {\n            hint.maxAge = this.defaultMaxAge;\n        }\n        if (hint.maxAge !== undefined || hint.scope !== undefined) {\n            this.addHint(info.path, hint);\n        }\n        info.cacheControl = {\n            setCacheHint: (hint) => {\n                this.addHint(info.path, hint);\n            },\n            cacheHint: hint,\n        };\n    }\n    addHint(path, hint) {\n        const existingCacheHint = this.hints.get(path);\n        if (existingCacheHint) {\n            this.hints.set(path, mergeHints(existingCacheHint, hint));\n        }\n        else {\n            this.hints.set(path, hint);\n        }\n    }\n    format() {\n        return [\n            'cacheControl',\n            {\n                version: 1,\n                hints: Array.from(this.hints).map(([path, hint]) => (Object.assign({ path: [...graphql_1.responsePathAsArray(path)] }, hint))),\n            },\n        ];\n    }\n}\nexports.CacheControlExtension = CacheControlExtension;\nfunction cacheHintFromDirectives(directives) {\n    if (!directives)\n        return undefined;\n    const cacheControlDirective = directives.find(directive => directive.name.value === 'cacheControl');\n    if (!cacheControlDirective)\n        return undefined;\n    if (!cacheControlDirective.arguments)\n        return undefined;\n    const maxAgeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'maxAge');\n    const scopeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'scope');\n    return {\n        maxAge: maxAgeArgument &&\n            maxAgeArgument.value &&\n            maxAgeArgument.value.kind === 'IntValue'\n            ? parseInt(maxAgeArgument.value.value)\n            : undefined,\n        scope: scopeArgument &&\n            scopeArgument.value &&\n            scopeArgument.value.kind === 'EnumValue'\n            ? scopeArgument.value.value\n            : undefined,\n    };\n}\nfunction mergeHints(hint, otherHint) {\n    if (!otherHint)\n        return hint;\n    return {\n        maxAge: otherHint.maxAge !== undefined ? otherHint.maxAge : hint.maxAge,\n        scope: otherHint.scope || hint.scope,\n    };\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-cache-control/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-engine-reporting-protobuf/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/apollo-engine-reporting-protobuf/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n\nvar $protobuf = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.Trace = (function() {\n\n    /**\n     * Properties of a Trace.\n     * @exports ITrace\n     * @interface ITrace\n     * @property {google.protobuf.ITimestamp|null} [startTime] Trace startTime\n     * @property {google.protobuf.ITimestamp|null} [endTime] Trace endTime\n     * @property {number|null} [durationNs] Trace durationNs\n     * @property {google.protobuf.ITimestamp|null} [originReportedStartTime] Trace originReportedStartTime\n     * @property {google.protobuf.ITimestamp|null} [originReportedEndTime] Trace originReportedEndTime\n     * @property {number|null} [originReportedDurationNs] Trace originReportedDurationNs\n     * @property {string|null} [signature] Trace signature\n     * @property {string|null} [legacySignatureNeedsResigning] Trace legacySignatureNeedsResigning\n     * @property {Trace.IDetails|null} [details] Trace details\n     * @property {string|null} [clientName] Trace clientName\n     * @property {string|null} [clientVersion] Trace clientVersion\n     * @property {string|null} [clientAddress] Trace clientAddress\n     * @property {Trace.IHTTP|null} [http] Trace http\n     * @property {Trace.ICachePolicy|null} [cachePolicy] Trace cachePolicy\n     * @property {Trace.INode|null} [root] Trace root\n     * @property {boolean|null} [fullQueryCacheHit] Trace fullQueryCacheHit\n     * @property {boolean|null} [persistedQueryHit] Trace persistedQueryHit\n     * @property {boolean|null} [persistedQueryRegister] Trace persistedQueryRegister\n     */\n\n    /**\n     * Constructs a new Trace.\n     * @exports Trace\n     * @classdesc Represents a Trace.\n     * @implements ITrace\n     * @constructor\n     * @param {ITrace=} [properties] Properties to set\n     */\n    function Trace(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Trace startTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} startTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.startTime = null;\n\n    /**\n     * Trace endTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} endTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.endTime = null;\n\n    /**\n     * Trace durationNs.\n     * @member {number} durationNs\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.durationNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Trace originReportedStartTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} originReportedStartTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.originReportedStartTime = null;\n\n    /**\n     * Trace originReportedEndTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} originReportedEndTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.originReportedEndTime = null;\n\n    /**\n     * Trace originReportedDurationNs.\n     * @member {number} originReportedDurationNs\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.originReportedDurationNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Trace signature.\n     * @member {string} signature\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.signature = \"\";\n\n    /**\n     * Trace legacySignatureNeedsResigning.\n     * @member {string} legacySignatureNeedsResigning\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.legacySignatureNeedsResigning = \"\";\n\n    /**\n     * Trace details.\n     * @member {Trace.IDetails|null|undefined} details\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.details = null;\n\n    /**\n     * Trace clientName.\n     * @member {string} clientName\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientName = \"\";\n\n    /**\n     * Trace clientVersion.\n     * @member {string} clientVersion\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientVersion = \"\";\n\n    /**\n     * Trace clientAddress.\n     * @member {string} clientAddress\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientAddress = \"\";\n\n    /**\n     * Trace http.\n     * @member {Trace.IHTTP|null|undefined} http\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.http = null;\n\n    /**\n     * Trace cachePolicy.\n     * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.cachePolicy = null;\n\n    /**\n     * Trace root.\n     * @member {Trace.INode|null|undefined} root\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.root = null;\n\n    /**\n     * Trace fullQueryCacheHit.\n     * @member {boolean} fullQueryCacheHit\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.fullQueryCacheHit = false;\n\n    /**\n     * Trace persistedQueryHit.\n     * @member {boolean} persistedQueryHit\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.persistedQueryHit = false;\n\n    /**\n     * Trace persistedQueryRegister.\n     * @member {boolean} persistedQueryRegister\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.persistedQueryRegister = false;\n\n    /**\n     * Creates a new Trace instance using the specified properties.\n     * @function create\n     * @memberof Trace\n     * @static\n     * @param {ITrace=} [properties] Properties to set\n     * @returns {Trace} Trace instance\n     */\n    Trace.create = function create(properties) {\n        return new Trace(properties);\n    };\n\n    /**\n     * Encodes the specified Trace message. Does not implicitly {@link Trace.verify|verify} messages.\n     * @function encode\n     * @memberof Trace\n     * @static\n     * @param {ITrace} message Trace message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Trace.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n            $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n        if (message.legacySignatureNeedsResigning != null && message.hasOwnProperty(\"legacySignatureNeedsResigning\"))\n            writer.uint32(/* id 5, wireType 2 =*/42).string(message.legacySignatureNeedsResigning);\n        if (message.details != null && message.hasOwnProperty(\"details\"))\n            $root.Trace.Details.encode(message.details, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            writer.uint32(/* id 7, wireType 2 =*/58).string(message.clientName);\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientVersion);\n        if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientAddress);\n        if (message.http != null && message.hasOwnProperty(\"http\"))\n            $root.Trace.HTTP.encode(message.http, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.durationNs);\n        if (message.root != null && message.hasOwnProperty(\"root\"))\n            $root.Trace.Node.encode(message.root, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n        if (message.originReportedStartTime != null && message.hasOwnProperty(\"originReportedStartTime\"))\n            $root.google.protobuf.Timestamp.encode(message.originReportedStartTime, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n        if (message.originReportedEndTime != null && message.hasOwnProperty(\"originReportedEndTime\"))\n            $root.google.protobuf.Timestamp.encode(message.originReportedEndTime, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();\n        if (message.originReportedDurationNs != null && message.hasOwnProperty(\"originReportedDurationNs\"))\n            writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.originReportedDurationNs);\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            writer.uint32(/* id 19, wireType 2 =*/154).string(message.signature);\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            writer.uint32(/* id 20, wireType 0 =*/160).bool(message.fullQueryCacheHit);\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.persistedQueryHit);\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            writer.uint32(/* id 22, wireType 0 =*/176).bool(message.persistedQueryRegister);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Trace message, length delimited. Does not implicitly {@link Trace.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace\n     * @static\n     * @param {ITrace} message Trace message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Trace.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Trace message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace} Trace\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Trace.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 4:\n                message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 11:\n                message.durationNs = reader.uint64();\n                break;\n            case 15:\n                message.originReportedStartTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 16:\n                message.originReportedEndTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 17:\n                message.originReportedDurationNs = reader.uint64();\n                break;\n            case 19:\n                message.signature = reader.string();\n                break;\n            case 5:\n                message.legacySignatureNeedsResigning = reader.string();\n                break;\n            case 6:\n                message.details = $root.Trace.Details.decode(reader, reader.uint32());\n                break;\n            case 7:\n                message.clientName = reader.string();\n                break;\n            case 8:\n                message.clientVersion = reader.string();\n                break;\n            case 9:\n                message.clientAddress = reader.string();\n                break;\n            case 10:\n                message.http = $root.Trace.HTTP.decode(reader, reader.uint32());\n                break;\n            case 18:\n                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n                break;\n            case 14:\n                message.root = $root.Trace.Node.decode(reader, reader.uint32());\n                break;\n            case 20:\n                message.fullQueryCacheHit = reader.bool();\n                break;\n            case 21:\n                message.persistedQueryHit = reader.bool();\n                break;\n            case 22:\n                message.persistedQueryRegister = reader.bool();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Trace message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace} Trace\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Trace.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Trace message.\n     * @function verify\n     * @memberof Trace\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Trace.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.startTime);\n            if (error)\n                return \"startTime.\" + error;\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.endTime);\n            if (error)\n                return \"endTime.\" + error;\n        }\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))\n                return \"durationNs: integer|Long expected\";\n        if (message.originReportedStartTime != null && message.hasOwnProperty(\"originReportedStartTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.originReportedStartTime);\n            if (error)\n                return \"originReportedStartTime.\" + error;\n        }\n        if (message.originReportedEndTime != null && message.hasOwnProperty(\"originReportedEndTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.originReportedEndTime);\n            if (error)\n                return \"originReportedEndTime.\" + error;\n        }\n        if (message.originReportedDurationNs != null && message.hasOwnProperty(\"originReportedDurationNs\"))\n            if (!$util.isInteger(message.originReportedDurationNs) && !(message.originReportedDurationNs && $util.isInteger(message.originReportedDurationNs.low) && $util.isInteger(message.originReportedDurationNs.high)))\n                return \"originReportedDurationNs: integer|Long expected\";\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            if (!$util.isString(message.signature))\n                return \"signature: string expected\";\n        if (message.legacySignatureNeedsResigning != null && message.hasOwnProperty(\"legacySignatureNeedsResigning\"))\n            if (!$util.isString(message.legacySignatureNeedsResigning))\n                return \"legacySignatureNeedsResigning: string expected\";\n        if (message.details != null && message.hasOwnProperty(\"details\")) {\n            var error = $root.Trace.Details.verify(message.details);\n            if (error)\n                return \"details.\" + error;\n        }\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            if (!$util.isString(message.clientName))\n                return \"clientName: string expected\";\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            if (!$util.isString(message.clientVersion))\n                return \"clientVersion: string expected\";\n        if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\"))\n            if (!$util.isString(message.clientAddress))\n                return \"clientAddress: string expected\";\n        if (message.http != null && message.hasOwnProperty(\"http\")) {\n            var error = $root.Trace.HTTP.verify(message.http);\n            if (error)\n                return \"http.\" + error;\n        }\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n            if (error)\n                return \"cachePolicy.\" + error;\n        }\n        if (message.root != null && message.hasOwnProperty(\"root\")) {\n            var error = $root.Trace.Node.verify(message.root);\n            if (error)\n                return \"root.\" + error;\n        }\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            if (typeof message.fullQueryCacheHit !== \"boolean\")\n                return \"fullQueryCacheHit: boolean expected\";\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            if (typeof message.persistedQueryHit !== \"boolean\")\n                return \"persistedQueryHit: boolean expected\";\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            if (typeof message.persistedQueryRegister !== \"boolean\")\n                return \"persistedQueryRegister: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a Trace message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Trace\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Trace} Trace\n     */\n    Trace.fromObject = function fromObject(object) {\n        if (object instanceof $root.Trace)\n            return object;\n        var message = new $root.Trace();\n        if (object.startTime != null) {\n            if (typeof object.startTime !== \"object\")\n                throw TypeError(\".Trace.startTime: object expected\");\n            message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);\n        }\n        if (object.endTime != null) {\n            if (typeof object.endTime !== \"object\")\n                throw TypeError(\".Trace.endTime: object expected\");\n            message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);\n        }\n        if (object.durationNs != null)\n            if ($util.Long)\n                (message.durationNs = $util.Long.fromValue(object.durationNs)).unsigned = true;\n            else if (typeof object.durationNs === \"string\")\n                message.durationNs = parseInt(object.durationNs, 10);\n            else if (typeof object.durationNs === \"number\")\n                message.durationNs = object.durationNs;\n            else if (typeof object.durationNs === \"object\")\n                message.durationNs = new $util.LongBits(object.durationNs.low >>> 0, object.durationNs.high >>> 0).toNumber(true);\n        if (object.originReportedStartTime != null) {\n            if (typeof object.originReportedStartTime !== \"object\")\n                throw TypeError(\".Trace.originReportedStartTime: object expected\");\n            message.originReportedStartTime = $root.google.protobuf.Timestamp.fromObject(object.originReportedStartTime);\n        }\n        if (object.originReportedEndTime != null) {\n            if (typeof object.originReportedEndTime !== \"object\")\n                throw TypeError(\".Trace.originReportedEndTime: object expected\");\n            message.originReportedEndTime = $root.google.protobuf.Timestamp.fromObject(object.originReportedEndTime);\n        }\n        if (object.originReportedDurationNs != null)\n            if ($util.Long)\n                (message.originReportedDurationNs = $util.Long.fromValue(object.originReportedDurationNs)).unsigned = true;\n            else if (typeof object.originReportedDurationNs === \"string\")\n                message.originReportedDurationNs = parseInt(object.originReportedDurationNs, 10);\n            else if (typeof object.originReportedDurationNs === \"number\")\n                message.originReportedDurationNs = object.originReportedDurationNs;\n            else if (typeof object.originReportedDurationNs === \"object\")\n                message.originReportedDurationNs = new $util.LongBits(object.originReportedDurationNs.low >>> 0, object.originReportedDurationNs.high >>> 0).toNumber(true);\n        if (object.signature != null)\n            message.signature = String(object.signature);\n        if (object.legacySignatureNeedsResigning != null)\n            message.legacySignatureNeedsResigning = String(object.legacySignatureNeedsResigning);\n        if (object.details != null) {\n            if (typeof object.details !== \"object\")\n                throw TypeError(\".Trace.details: object expected\");\n            message.details = $root.Trace.Details.fromObject(object.details);\n        }\n        if (object.clientName != null)\n            message.clientName = String(object.clientName);\n        if (object.clientVersion != null)\n            message.clientVersion = String(object.clientVersion);\n        if (object.clientAddress != null)\n            message.clientAddress = String(object.clientAddress);\n        if (object.http != null) {\n            if (typeof object.http !== \"object\")\n                throw TypeError(\".Trace.http: object expected\");\n            message.http = $root.Trace.HTTP.fromObject(object.http);\n        }\n        if (object.cachePolicy != null) {\n            if (typeof object.cachePolicy !== \"object\")\n                throw TypeError(\".Trace.cachePolicy: object expected\");\n            message.cachePolicy = $root.Trace.CachePolicy.fromObject(object.cachePolicy);\n        }\n        if (object.root != null) {\n            if (typeof object.root !== \"object\")\n                throw TypeError(\".Trace.root: object expected\");\n            message.root = $root.Trace.Node.fromObject(object.root);\n        }\n        if (object.fullQueryCacheHit != null)\n            message.fullQueryCacheHit = Boolean(object.fullQueryCacheHit);\n        if (object.persistedQueryHit != null)\n            message.persistedQueryHit = Boolean(object.persistedQueryHit);\n        if (object.persistedQueryRegister != null)\n            message.persistedQueryRegister = Boolean(object.persistedQueryRegister);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Trace message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace\n     * @static\n     * @param {Trace} message Trace\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Trace.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.endTime = null;\n            object.startTime = null;\n            object.legacySignatureNeedsResigning = \"\";\n            object.details = null;\n            object.clientName = \"\";\n            object.clientVersion = \"\";\n            object.clientAddress = \"\";\n            object.http = null;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.durationNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.durationNs = options.longs === String ? \"0\" : 0;\n            object.root = null;\n            object.originReportedStartTime = null;\n            object.originReportedEndTime = null;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.originReportedDurationNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.originReportedDurationNs = options.longs === String ? \"0\" : 0;\n            object.cachePolicy = null;\n            object.signature = \"\";\n            object.fullQueryCacheHit = false;\n            object.persistedQueryHit = false;\n            object.persistedQueryRegister = false;\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);\n        if (message.legacySignatureNeedsResigning != null && message.hasOwnProperty(\"legacySignatureNeedsResigning\"))\n            object.legacySignatureNeedsResigning = message.legacySignatureNeedsResigning;\n        if (message.details != null && message.hasOwnProperty(\"details\"))\n            object.details = $root.Trace.Details.toObject(message.details, options);\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            object.clientName = message.clientName;\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            object.clientVersion = message.clientVersion;\n        if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\"))\n            object.clientAddress = message.clientAddress;\n        if (message.http != null && message.hasOwnProperty(\"http\"))\n            object.http = $root.Trace.HTTP.toObject(message.http, options);\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            if (typeof message.durationNs === \"number\")\n                object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;\n            else\n                object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;\n        if (message.root != null && message.hasOwnProperty(\"root\"))\n            object.root = $root.Trace.Node.toObject(message.root, options);\n        if (message.originReportedStartTime != null && message.hasOwnProperty(\"originReportedStartTime\"))\n            object.originReportedStartTime = $root.google.protobuf.Timestamp.toObject(message.originReportedStartTime, options);\n        if (message.originReportedEndTime != null && message.hasOwnProperty(\"originReportedEndTime\"))\n            object.originReportedEndTime = $root.google.protobuf.Timestamp.toObject(message.originReportedEndTime, options);\n        if (message.originReportedDurationNs != null && message.hasOwnProperty(\"originReportedDurationNs\"))\n            if (typeof message.originReportedDurationNs === \"number\")\n                object.originReportedDurationNs = options.longs === String ? String(message.originReportedDurationNs) : message.originReportedDurationNs;\n            else\n                object.originReportedDurationNs = options.longs === String ? $util.Long.prototype.toString.call(message.originReportedDurationNs) : options.longs === Number ? new $util.LongBits(message.originReportedDurationNs.low >>> 0, message.originReportedDurationNs.high >>> 0).toNumber(true) : message.originReportedDurationNs;\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            object.signature = message.signature;\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            object.fullQueryCacheHit = message.fullQueryCacheHit;\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            object.persistedQueryHit = message.persistedQueryHit;\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            object.persistedQueryRegister = message.persistedQueryRegister;\n        return object;\n    };\n\n    /**\n     * Converts this Trace to JSON.\n     * @function toJSON\n     * @memberof Trace\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Trace.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    Trace.CachePolicy = (function() {\n\n        /**\n         * Properties of a CachePolicy.\n         * @memberof Trace\n         * @interface ICachePolicy\n         * @property {Trace.CachePolicy.Scope|null} [scope] CachePolicy scope\n         * @property {number|null} [maxAgeNs] CachePolicy maxAgeNs\n         */\n\n        /**\n         * Constructs a new CachePolicy.\n         * @memberof Trace\n         * @classdesc Represents a CachePolicy.\n         * @implements ICachePolicy\n         * @constructor\n         * @param {Trace.ICachePolicy=} [properties] Properties to set\n         */\n        function CachePolicy(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CachePolicy scope.\n         * @member {Trace.CachePolicy.Scope} scope\n         * @memberof Trace.CachePolicy\n         * @instance\n         */\n        CachePolicy.prototype.scope = 0;\n\n        /**\n         * CachePolicy maxAgeNs.\n         * @member {number} maxAgeNs\n         * @memberof Trace.CachePolicy\n         * @instance\n         */\n        CachePolicy.prototype.maxAgeNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * Creates a new CachePolicy instance using the specified properties.\n         * @function create\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy=} [properties] Properties to set\n         * @returns {Trace.CachePolicy} CachePolicy instance\n         */\n        CachePolicy.create = function create(properties) {\n            return new CachePolicy(properties);\n        };\n\n        /**\n         * Encodes the specified CachePolicy message. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CachePolicy.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scope);\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxAgeNs);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CachePolicy message, length delimited. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CachePolicy message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.CachePolicy} CachePolicy\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CachePolicy.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.scope = reader.int32();\n                    break;\n                case 2:\n                    message.maxAgeNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CachePolicy message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.CachePolicy} CachePolicy\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CachePolicy.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CachePolicy message.\n         * @function verify\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CachePolicy.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                switch (message.scope) {\n                default:\n                    return \"scope: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                    break;\n                }\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))\n                    return \"maxAgeNs: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates a CachePolicy message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Trace.CachePolicy} CachePolicy\n         */\n        CachePolicy.fromObject = function fromObject(object) {\n            if (object instanceof $root.Trace.CachePolicy)\n                return object;\n            var message = new $root.Trace.CachePolicy();\n            switch (object.scope) {\n            case \"UNKNOWN\":\n            case 0:\n                message.scope = 0;\n                break;\n            case \"PUBLIC\":\n            case 1:\n                message.scope = 1;\n                break;\n            case \"PRIVATE\":\n            case 2:\n                message.scope = 2;\n                break;\n            }\n            if (object.maxAgeNs != null)\n                if ($util.Long)\n                    (message.maxAgeNs = $util.Long.fromValue(object.maxAgeNs)).unsigned = false;\n                else if (typeof object.maxAgeNs === \"string\")\n                    message.maxAgeNs = parseInt(object.maxAgeNs, 10);\n                else if (typeof object.maxAgeNs === \"number\")\n                    message.maxAgeNs = object.maxAgeNs;\n                else if (typeof object.maxAgeNs === \"object\")\n                    message.maxAgeNs = new $util.LongBits(object.maxAgeNs.low >>> 0, object.maxAgeNs.high >>> 0).toNumber();\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CachePolicy message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.CachePolicy} message CachePolicy\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CachePolicy.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.scope = options.enums === String ? \"UNKNOWN\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.maxAgeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.maxAgeNs = options.longs === String ? \"0\" : 0;\n            }\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                if (typeof message.maxAgeNs === \"number\")\n                    object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;\n                else\n                    object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;\n            return object;\n        };\n\n        /**\n         * Converts this CachePolicy to JSON.\n         * @function toJSON\n         * @memberof Trace.CachePolicy\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CachePolicy.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Scope enum.\n         * @name Trace.CachePolicy.Scope\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} PUBLIC=1 PUBLIC value\n         * @property {number} PRIVATE=2 PRIVATE value\n         */\n        CachePolicy.Scope = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNKNOWN\"] = 0;\n            values[valuesById[1] = \"PUBLIC\"] = 1;\n            values[valuesById[2] = \"PRIVATE\"] = 2;\n            return values;\n        })();\n\n        return CachePolicy;\n    })();\n\n    Trace.Details = (function() {\n\n        /**\n         * Properties of a Details.\n         * @memberof Trace\n         * @interface IDetails\n         * @property {Object.<string,string>|null} [variablesJson] Details variablesJson\n         * @property {Object.<string,Uint8Array>|null} [variables] Details variables\n         * @property {string|null} [rawQuery] Details rawQuery\n         * @property {string|null} [operationName] Details operationName\n         */\n\n        /**\n         * Constructs a new Details.\n         * @memberof Trace\n         * @classdesc Represents a Details.\n         * @implements IDetails\n         * @constructor\n         * @param {Trace.IDetails=} [properties] Properties to set\n         */\n        function Details(properties) {\n            this.variablesJson = {};\n            this.variables = {};\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Details variablesJson.\n         * @member {Object.<string,string>} variablesJson\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.variablesJson = $util.emptyObject;\n\n        /**\n         * Details variables.\n         * @member {Object.<string,Uint8Array>} variables\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.variables = $util.emptyObject;\n\n        /**\n         * Details rawQuery.\n         * @member {string} rawQuery\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.rawQuery = \"\";\n\n        /**\n         * Details operationName.\n         * @member {string} operationName\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.operationName = \"\";\n\n        /**\n         * Creates a new Details instance using the specified properties.\n         * @function create\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails=} [properties] Properties to set\n         * @returns {Trace.Details} Details instance\n         */\n        Details.create = function create(properties) {\n            return new Details(properties);\n        };\n\n        /**\n         * Encodes the specified Details message. Does not implicitly {@link Trace.Details.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails} message Details message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Details.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.variables != null && message.hasOwnProperty(\"variables\"))\n                for (var keys = Object.keys(message.variables), i = 0; i < keys.length; ++i)\n                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.variables[keys[i]]).ldelim();\n            if (message.rawQuery != null && message.hasOwnProperty(\"rawQuery\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.rawQuery);\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.operationName);\n            if (message.variablesJson != null && message.hasOwnProperty(\"variablesJson\"))\n                for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.variablesJson[keys[i]]).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Details message, length delimited. Does not implicitly {@link Trace.Details.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails} message Details message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Details.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Details message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Details\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Details} Details\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Details.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 4:\n                    reader.skip().pos++;\n                    if (message.variablesJson === $util.emptyObject)\n                        message.variablesJson = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.variablesJson[key] = reader.string();\n                    break;\n                case 1:\n                    reader.skip().pos++;\n                    if (message.variables === $util.emptyObject)\n                        message.variables = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.variables[key] = reader.bytes();\n                    break;\n                case 2:\n                    message.rawQuery = reader.string();\n                    break;\n                case 3:\n                    message.operationName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Details message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Details\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Details} Details\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Details.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Details message.\n         * @function verify\n         * @memberof Trace.Details\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Details.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.variablesJson != null && message.hasOwnProperty(\"variablesJson\")) {\n                if (!$util.isObject(message.variablesJson))\n                    return \"variablesJson: object expected\";\n                var key = Object.keys(message.variablesJson);\n                for (var i = 0; i < key.length; ++i)\n                    if (!$util.isString(message.variablesJson[key[i]]))\n                        return \"variablesJson: string{k:string} expected\";\n            }\n            if (message.variables != null && message.hasOwnProperty(\"variables\")) {\n                if (!$util.isObject(message.variables))\n                    return \"variables: object expected\";\n                var key = Object.keys(message.variables);\n                for (var i = 0; i < key.length; ++i)\n                    if (!(message.variables[key[i]] && typeof message.variables[key[i]].length === \"number\" || $util.isString(message.variables[key[i]])))\n                        return \"variables: buffer{k:string} expected\";\n            }\n            if (message.rawQuery != null && message.hasOwnProperty(\"rawQuery\"))\n                if (!$util.isString(message.rawQuery))\n                    return \"rawQuery: string expected\";\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                if (!$util.isString(message.operationName))\n                    return \"operationName: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a Details message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Trace.Details\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Trace.Details} Details\n         */\n        Details.fromObject = function fromObject(object) {\n            if (object instanceof $root.Trace.Details)\n                return object;\n            var message = new $root.Trace.Details();\n            if (object.variablesJson) {\n                if (typeof object.variablesJson !== \"object\")\n                    throw TypeError(\".Trace.Details.variablesJson: object expected\");\n                message.variablesJson = {};\n                for (var keys = Object.keys(object.variablesJson), i = 0; i < keys.length; ++i)\n                    message.variablesJson[keys[i]] = String(object.variablesJson[keys[i]]);\n            }\n            if (object.variables) {\n                if (typeof object.variables !== \"object\")\n                    throw TypeError(\".Trace.Details.variables: object expected\");\n                message.variables = {};\n                for (var keys = Object.keys(object.variables), i = 0; i < keys.length; ++i)\n                    if (typeof object.variables[keys[i]] === \"string\")\n                        $util.base64.decode(object.variables[keys[i]], message.variables[keys[i]] = $util.newBuffer($util.base64.length(object.variables[keys[i]])), 0);\n                    else if (object.variables[keys[i]].length)\n                        message.variables[keys[i]] = object.variables[keys[i]];\n            }\n            if (object.rawQuery != null)\n                message.rawQuery = String(object.rawQuery);\n            if (object.operationName != null)\n                message.operationName = String(object.operationName);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Details message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.Details} message Details\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Details.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.objects || options.defaults) {\n                object.variables = {};\n                object.variablesJson = {};\n            }\n            if (options.defaults) {\n                object.rawQuery = \"\";\n                object.operationName = \"\";\n            }\n            var keys2;\n            if (message.variables && (keys2 = Object.keys(message.variables)).length) {\n                object.variables = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.variables[keys2[j]] = options.bytes === String ? $util.base64.encode(message.variables[keys2[j]], 0, message.variables[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.variables[keys2[j]]) : message.variables[keys2[j]];\n            }\n            if (message.rawQuery != null && message.hasOwnProperty(\"rawQuery\"))\n                object.rawQuery = message.rawQuery;\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                object.operationName = message.operationName;\n            if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {\n                object.variablesJson = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this Details to JSON.\n         * @function toJSON\n         * @memberof Trace.Details\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Details.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Details;\n    })();\n\n    Trace.Error = (function() {\n\n        /**\n         * Properties of an Error.\n         * @memberof Trace\n         * @interface IError\n         * @property {string|null} [message] Error message\n         * @property {Array.<Trace.ILocation>|null} [location] Error location\n         * @property {number|null} [timeNs] Error timeNs\n         * @property {string|null} [json] Error json\n         */\n\n        /**\n         * Constructs a new Error.\n         * @memberof Trace\n         * @classdesc Represents an Error.\n         * @implements IError\n         * @constructor\n         * @param {Trace.IError=} [properties] Properties to set\n         */\n        function Error(properties) {\n            this.location = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Error message.\n         * @member {string} message\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.message = \"\";\n\n        /**\n         * Error location.\n         * @member {Array.<Trace.ILocation>} location\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.location = $util.emptyArray;\n\n        /**\n         * Error timeNs.\n         * @member {number} timeNs\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.timeNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * Error json.\n         * @member {string} json\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.json = \"\";\n\n        /**\n         * Creates a new Error instance using the specified properties.\n         * @function create\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError=} [properties] Properties to set\n         * @returns {Trace.Error} Error instance\n         */\n        Error.create = function create(properties) {\n            return new Error(properties);\n        };\n\n        /**\n         * Encodes the specified Error message. Does not implicitly {@link Trace.Error.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError} message Error message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Error.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);\n            if (message.location != null && message.location.length)\n                for (var i = 0; i < message.location.length; ++i)\n                    $root.Trace.Location.encode(message.location[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeNs);\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.json);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Error message, length delimited. Does not implicitly {@link Trace.Error.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError} message Error message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Error.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an Error message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Error\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Error} Error\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Error.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Error();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                case 2:\n                    if (!(message.location && message.location.length))\n                        message.location = [];\n                    message.location.push($root.Trace.Location.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.timeNs = reader.uint64();\n                    break;\n                case 4:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an Error message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Error\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Error} Error\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Error.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an Error message.\n         * @function verify\n         * @memberof Trace.Error\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Error.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                if (!$util.isString(message.message))\n                    return \"message: string expected\";\n            if (message.location != null && message.hasOwnProperty(\"location\")) {\n                if (!Array.isArray(message.location))\n                    return \"location: array expected\";\n                for (var i = 0; i < message.location.length; ++i) {\n                    var error = $root.Trace.Location.verify(message.location[i]);\n                    if (error)\n                        return \"location.\" + error;\n                }\n            }\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))\n                    return \"timeNs: integer|Long expected\";\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                if (!$util.isString(message.json))\n                    return \"json: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates an Error message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Trace.Error\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Trace.Error} Error\n         */\n        Error.fromObject = function fromObject(object) {\n            if (object instanceof $root.Trace.Error)\n                return object;\n            var message = new $root.Trace.Error();\n            if (object.message != null)\n                message.message = String(object.message);\n            if (object.location) {\n                if (!Array.isArray(object.location))\n                    throw TypeError(\".Trace.Error.location: array expected\");\n                message.location = [];\n                for (var i = 0; i < object.location.length; ++i) {\n                    if (typeof object.location[i] !== \"object\")\n                        throw TypeError(\".Trace.Error.location: object expected\");\n                    message.location[i] = $root.Trace.Location.fromObject(object.location[i]);\n                }\n            }\n            if (object.timeNs != null)\n                if ($util.Long)\n                    (message.timeNs = $util.Long.fromValue(object.timeNs)).unsigned = true;\n                else if (typeof object.timeNs === \"string\")\n                    message.timeNs = parseInt(object.timeNs, 10);\n                else if (typeof object.timeNs === \"number\")\n                    message.timeNs = object.timeNs;\n                else if (typeof object.timeNs === \"object\")\n                    message.timeNs = new $util.LongBits(object.timeNs.low >>> 0, object.timeNs.high >>> 0).toNumber(true);\n            if (object.json != null)\n                message.json = String(object.json);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an Error message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.Error} message Error\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Error.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.location = [];\n            if (options.defaults) {\n                object.message = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, true);\n                    object.timeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.timeNs = options.longs === String ? \"0\" : 0;\n                object.json = \"\";\n            }\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = message.message;\n            if (message.location && message.location.length) {\n                object.location = [];\n                for (var j = 0; j < message.location.length; ++j)\n                    object.location[j] = $root.Trace.Location.toObject(message.location[j], options);\n            }\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                if (typeof message.timeNs === \"number\")\n                    object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;\n                else\n                    object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                object.json = message.json;\n            return object;\n        };\n\n        /**\n         * Converts this Error to JSON.\n         * @function toJSON\n         * @memberof Trace.Error\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Error.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Error;\n    })();\n\n    Trace.HTTP = (function() {\n\n        /**\n         * Properties of a HTTP.\n         * @memberof Trace\n         * @interface IHTTP\n         * @property {Trace.HTTP.Method|null} [method] HTTP method\n         * @property {string|null} [host] HTTP host\n         * @property {string|null} [path] HTTP path\n         * @property {Object.<string,Trace.HTTP.IValues>|null} [requestHeaders] HTTP requestHeaders\n         * @property {Object.<string,Trace.HTTP.IValues>|null} [responseHeaders] HTTP responseHeaders\n         * @property {number|null} [statusCode] HTTP statusCode\n         * @property {boolean|null} [secure] HTTP secure\n         * @property {string|null} [protocol] HTTP protocol\n         */\n\n        /**\n         * Constructs a new HTTP.\n         * @memberof Trace\n         * @classdesc Represents a HTTP.\n         * @implements IHTTP\n         * @constructor\n         * @param {Trace.IHTTP=} [properties] Properties to set\n         */\n        function HTTP(properties) {\n            this.requestHeaders = {};\n            this.responseHeaders = {};\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HTTP method.\n         * @member {Trace.HTTP.Method} method\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.method = 0;\n\n        /**\n         * HTTP host.\n         * @member {string} host\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.host = \"\";\n\n        /**\n         * HTTP path.\n         * @member {string} path\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.path = \"\";\n\n        /**\n         * HTTP requestHeaders.\n         * @member {Object.<string,Trace.HTTP.IValues>} requestHeaders\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.requestHeaders = $util.emptyObject;\n\n        /**\n         * HTTP responseHeaders.\n         * @member {Object.<string,Trace.HTTP.IValues>} responseHeaders\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.responseHeaders = $util.emptyObject;\n\n        /**\n         * HTTP statusCode.\n         * @member {number} statusCode\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.statusCode = 0;\n\n        /**\n         * HTTP secure.\n         * @member {boolean} secure\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.secure = false;\n\n        /**\n         * HTTP protocol.\n         * @member {string} protocol\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.protocol = \"\";\n\n        /**\n         * Creates a new HTTP instance using the specified properties.\n         * @function create\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP=} [properties] Properties to set\n         * @returns {Trace.HTTP} HTTP instance\n         */\n        HTTP.create = function create(properties) {\n            return new HTTP(properties);\n        };\n\n        /**\n         * Encodes the specified HTTP message. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP} message HTTP message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HTTP.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);\n            if (message.host != null && message.hasOwnProperty(\"host\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);\n            if (message.path != null && message.hasOwnProperty(\"path\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);\n            if (message.requestHeaders != null && message.hasOwnProperty(\"requestHeaders\"))\n                for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                    $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                }\n            if (message.responseHeaders != null && message.hasOwnProperty(\"responseHeaders\"))\n                for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {\n                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                    $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.statusCode);\n            if (message.secure != null && message.hasOwnProperty(\"secure\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.secure);\n            if (message.protocol != null && message.hasOwnProperty(\"protocol\"))\n                writer.uint32(/* id 9, wireType 2 =*/74).string(message.protocol);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HTTP message, length delimited. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP} message HTTP message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HTTP.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HTTP message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.HTTP\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.HTTP} HTTP\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HTTP.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.method = reader.int32();\n                    break;\n                case 2:\n                    message.host = reader.string();\n                    break;\n                case 3:\n                    message.path = reader.string();\n                    break;\n                case 4:\n                    reader.skip().pos++;\n                    if (message.requestHeaders === $util.emptyObject)\n                        message.requestHeaders = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    reader.skip().pos++;\n                    if (message.responseHeaders === $util.emptyObject)\n                        message.responseHeaders = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.statusCode = reader.uint32();\n                    break;\n                case 8:\n                    message.secure = reader.bool();\n                    break;\n                case 9:\n                    message.protocol = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HTTP message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.HTTP\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.HTTP} HTTP\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HTTP.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HTTP message.\n         * @function verify\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HTTP.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                switch (message.method) {\n                default:\n                    return \"method: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                    break;\n                }\n            if (message.host != null && message.hasOwnProperty(\"host\"))\n                if (!$util.isString(message.host))\n                    return \"host: string expected\";\n            if (message.path != null && message.hasOwnProperty(\"path\"))\n                if (!$util.isString(message.path))\n                    return \"path: string expected\";\n            if (message.requestHeaders != null && message.hasOwnProperty(\"requestHeaders\")) {\n                if (!$util.isObject(message.requestHeaders))\n                    return \"requestHeaders: object expected\";\n                var key = Object.keys(message.requestHeaders);\n                for (var i = 0; i < key.length; ++i) {\n                    var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);\n                    if (error)\n                        return \"requestHeaders.\" + error;\n                }\n            }\n            if (message.responseHeaders != null && message.hasOwnProperty(\"responseHeaders\")) {\n                if (!$util.isObject(message.responseHeaders))\n                    return \"responseHeaders: object expected\";\n                var key = Object.keys(message.responseHeaders);\n                for (var i = 0; i < key.length; ++i) {\n                    var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);\n                    if (error)\n                        return \"responseHeaders.\" + error;\n                }\n            }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                if (!$util.isInteger(message.statusCode))\n                    return \"statusCode: integer expected\";\n            if (message.secure != null && message.hasOwnProperty(\"secure\"))\n                if (typeof message.secure !== \"boolean\")\n                    return \"secure: boolean expected\";\n            if (message.protocol != null && message.hasOwnProperty(\"protocol\"))\n                if (!$util.isString(message.protocol))\n                    return \"protocol: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a HTTP message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Trace.HTTP} HTTP\n         */\n        HTTP.fromObject = function fromObject(object) {\n            if (object instanceof $root.Trace.HTTP)\n                return object;\n            var message = new $root.Trace.HTTP();\n            switch (object.method) {\n            case \"UNKNOWN\":\n            case 0:\n                message.method = 0;\n                break;\n            case \"OPTIONS\":\n            case 1:\n                message.method = 1;\n                break;\n            case \"GET\":\n            case 2:\n                message.method = 2;\n                break;\n            case \"HEAD\":\n            case 3:\n                message.method = 3;\n                break;\n            case \"POST\":\n            case 4:\n                message.method = 4;\n                break;\n            case \"PUT\":\n            case 5:\n                message.method = 5;\n                break;\n            case \"DELETE\":\n            case 6:\n                message.method = 6;\n                break;\n            case \"TRACE\":\n            case 7:\n                message.method = 7;\n                break;\n            case \"CONNECT\":\n            case 8:\n                message.method = 8;\n                break;\n            case \"PATCH\":\n            case 9:\n                message.method = 9;\n                break;\n            }\n            if (object.host != null)\n                message.host = String(object.host);\n            if (object.path != null)\n                message.path = String(object.path);\n            if (object.requestHeaders) {\n                if (typeof object.requestHeaders !== \"object\")\n                    throw TypeError(\".Trace.HTTP.requestHeaders: object expected\");\n                message.requestHeaders = {};\n                for (var keys = Object.keys(object.requestHeaders), i = 0; i < keys.length; ++i) {\n                    if (typeof object.requestHeaders[keys[i]] !== \"object\")\n                        throw TypeError(\".Trace.HTTP.requestHeaders: object expected\");\n                    message.requestHeaders[keys[i]] = $root.Trace.HTTP.Values.fromObject(object.requestHeaders[keys[i]]);\n                }\n            }\n            if (object.responseHeaders) {\n                if (typeof object.responseHeaders !== \"object\")\n                    throw TypeError(\".Trace.HTTP.responseHeaders: object expected\");\n                message.responseHeaders = {};\n                for (var keys = Object.keys(object.responseHeaders), i = 0; i < keys.length; ++i) {\n                    if (typeof object.responseHeaders[keys[i]] !== \"object\")\n                        throw TypeError(\".Trace.HTTP.responseHeaders: object expected\");\n                    message.responseHeaders[keys[i]] = $root.Trace.HTTP.Values.fromObject(object.responseHeaders[keys[i]]);\n                }\n            }\n            if (object.statusCode != null)\n                message.statusCode = object.statusCode >>> 0;\n            if (object.secure != null)\n                message.secure = Boolean(object.secure);\n            if (object.protocol != null)\n                message.protocol = String(object.protocol);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a HTTP message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.HTTP} message HTTP\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HTTP.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.objects || options.defaults) {\n                object.requestHeaders = {};\n                object.responseHeaders = {};\n            }\n            if (options.defaults) {\n                object.method = options.enums === String ? \"UNKNOWN\" : 0;\n                object.host = \"\";\n                object.path = \"\";\n                object.statusCode = 0;\n                object.secure = false;\n                object.protocol = \"\";\n            }\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;\n            if (message.host != null && message.hasOwnProperty(\"host\"))\n                object.host = message.host;\n            if (message.path != null && message.hasOwnProperty(\"path\"))\n                object.path = message.path;\n            var keys2;\n            if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {\n                object.requestHeaders = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);\n            }\n            if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {\n                object.responseHeaders = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);\n            }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                object.statusCode = message.statusCode;\n            if (message.secure != null && message.hasOwnProperty(\"secure\"))\n                object.secure = message.secure;\n            if (message.protocol != null && message.hasOwnProperty(\"protocol\"))\n                object.protocol = message.protocol;\n            return object;\n        };\n\n        /**\n         * Converts this HTTP to JSON.\n         * @function toJSON\n         * @memberof Trace.HTTP\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HTTP.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        HTTP.Values = (function() {\n\n            /**\n             * Properties of a Values.\n             * @memberof Trace.HTTP\n             * @interface IValues\n             * @property {Array.<string>|null} [value] Values value\n             */\n\n            /**\n             * Constructs a new Values.\n             * @memberof Trace.HTTP\n             * @classdesc Represents a Values.\n             * @implements IValues\n             * @constructor\n             * @param {Trace.HTTP.IValues=} [properties] Properties to set\n             */\n            function Values(properties) {\n                this.value = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Values value.\n             * @member {Array.<string>} value\n             * @memberof Trace.HTTP.Values\n             * @instance\n             */\n            Values.prototype.value = $util.emptyArray;\n\n            /**\n             * Creates a new Values instance using the specified properties.\n             * @function create\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues=} [properties] Properties to set\n             * @returns {Trace.HTTP.Values} Values instance\n             */\n            Values.create = function create(properties) {\n                return new Values(properties);\n            };\n\n            /**\n             * Encodes the specified Values message. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Values.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.value != null && message.value.length)\n                    for (var i = 0; i < message.value.length; ++i)\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Values message, length delimited. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Values.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Values message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.HTTP.Values} Values\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Values.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.value && message.value.length))\n                            message.value = [];\n                        message.value.push(reader.string());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Values message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.HTTP.Values} Values\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Values.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Values message.\n             * @function verify\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Values.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.value != null && message.hasOwnProperty(\"value\")) {\n                    if (!Array.isArray(message.value))\n                        return \"value: array expected\";\n                    for (var i = 0; i < message.value.length; ++i)\n                        if (!$util.isString(message.value[i]))\n                            return \"value: string[] expected\";\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Values message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {Trace.HTTP.Values} Values\n             */\n            Values.fromObject = function fromObject(object) {\n                if (object instanceof $root.Trace.HTTP.Values)\n                    return object;\n                var message = new $root.Trace.HTTP.Values();\n                if (object.value) {\n                    if (!Array.isArray(object.value))\n                        throw TypeError(\".Trace.HTTP.Values.value: array expected\");\n                    message.value = [];\n                    for (var i = 0; i < object.value.length; ++i)\n                        message.value[i] = String(object.value[i]);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Values message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.Values} message Values\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Values.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.value = [];\n                if (message.value && message.value.length) {\n                    object.value = [];\n                    for (var j = 0; j < message.value.length; ++j)\n                        object.value[j] = message.value[j];\n                }\n                return object;\n            };\n\n            /**\n             * Converts this Values to JSON.\n             * @function toJSON\n             * @memberof Trace.HTTP.Values\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Values.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Values;\n        })();\n\n        /**\n         * Method enum.\n         * @name Trace.HTTP.Method\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} OPTIONS=1 OPTIONS value\n         * @property {number} GET=2 GET value\n         * @property {number} HEAD=3 HEAD value\n         * @property {number} POST=4 POST value\n         * @property {number} PUT=5 PUT value\n         * @property {number} DELETE=6 DELETE value\n         * @property {number} TRACE=7 TRACE value\n         * @property {number} CONNECT=8 CONNECT value\n         * @property {number} PATCH=9 PATCH value\n         */\n        HTTP.Method = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNKNOWN\"] = 0;\n            values[valuesById[1] = \"OPTIONS\"] = 1;\n            values[valuesById[2] = \"GET\"] = 2;\n            values[valuesById[3] = \"HEAD\"] = 3;\n            values[valuesById[4] = \"POST\"] = 4;\n            values[valuesById[5] = \"PUT\"] = 5;\n            values[valuesById[6] = \"DELETE\"] = 6;\n            values[valuesById[7] = \"TRACE\"] = 7;\n            values[valuesById[8] = \"CONNECT\"] = 8;\n            values[valuesById[9] = \"PATCH\"] = 9;\n            return values;\n        })();\n\n        return HTTP;\n    })();\n\n    Trace.Location = (function() {\n\n        /**\n         * Properties of a Location.\n         * @memberof Trace\n         * @interface ILocation\n         * @property {number|null} [line] Location line\n         * @property {number|null} [column] Location column\n         */\n\n        /**\n         * Constructs a new Location.\n         * @memberof Trace\n         * @classdesc Represents a Location.\n         * @implements ILocation\n         * @constructor\n         * @param {Trace.ILocation=} [properties] Properties to set\n         */\n        function Location(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Location line.\n         * @member {number} line\n         * @memberof Trace.Location\n         * @instance\n         */\n        Location.prototype.line = 0;\n\n        /**\n         * Location column.\n         * @member {number} column\n         * @memberof Trace.Location\n         * @instance\n         */\n        Location.prototype.column = 0;\n\n        /**\n         * Creates a new Location instance using the specified properties.\n         * @function create\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation=} [properties] Properties to set\n         * @returns {Trace.Location} Location instance\n         */\n        Location.create = function create(properties) {\n            return new Location(properties);\n        };\n\n        /**\n         * Encodes the specified Location message. Does not implicitly {@link Trace.Location.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation} message Location message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Location.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.line);\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Location message, length delimited. Does not implicitly {@link Trace.Location.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation} message Location message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Location.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Location message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Location.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Location();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.line = reader.uint32();\n                    break;\n                case 2:\n                    message.column = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Location message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Location.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Location message.\n         * @function verify\n         * @memberof Trace.Location\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Location.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                if (!$util.isInteger(message.line))\n                    return \"line: integer expected\";\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                if (!$util.isInteger(message.column))\n                    return \"column: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a Location message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Trace.Location\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Trace.Location} Location\n         */\n        Location.fromObject = function fromObject(object) {\n            if (object instanceof $root.Trace.Location)\n                return object;\n            var message = new $root.Trace.Location();\n            if (object.line != null)\n                message.line = object.line >>> 0;\n            if (object.column != null)\n                message.column = object.column >>> 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Location message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.Location} message Location\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Location.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.line = 0;\n                object.column = 0;\n            }\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                object.line = message.line;\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                object.column = message.column;\n            return object;\n        };\n\n        /**\n         * Converts this Location to JSON.\n         * @function toJSON\n         * @memberof Trace.Location\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Location.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Location;\n    })();\n\n    Trace.Node = (function() {\n\n        /**\n         * Properties of a Node.\n         * @memberof Trace\n         * @interface INode\n         * @property {string|null} [fieldName] Node fieldName\n         * @property {number|null} [index] Node index\n         * @property {string|null} [type] Node type\n         * @property {string|null} [parentType] Node parentType\n         * @property {Trace.ICachePolicy|null} [cachePolicy] Node cachePolicy\n         * @property {number|null} [startTime] Node startTime\n         * @property {number|null} [endTime] Node endTime\n         * @property {Array.<Trace.IError>|null} [error] Node error\n         * @property {Array.<Trace.INode>|null} [child] Node child\n         */\n\n        /**\n         * Constructs a new Node.\n         * @memberof Trace\n         * @classdesc Represents a Node.\n         * @implements INode\n         * @constructor\n         * @param {Trace.INode=} [properties] Properties to set\n         */\n        function Node(properties) {\n            this.error = [];\n            this.child = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Node fieldName.\n         * @member {string} fieldName\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.fieldName = \"\";\n\n        /**\n         * Node index.\n         * @member {number} index\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.index = 0;\n\n        /**\n         * Node type.\n         * @member {string} type\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.type = \"\";\n\n        /**\n         * Node parentType.\n         * @member {string} parentType\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.parentType = \"\";\n\n        /**\n         * Node cachePolicy.\n         * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.cachePolicy = null;\n\n        /**\n         * Node startTime.\n         * @member {number} startTime\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * Node endTime.\n         * @member {number} endTime\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * Node error.\n         * @member {Array.<Trace.IError>} error\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.error = $util.emptyArray;\n\n        /**\n         * Node child.\n         * @member {Array.<Trace.INode>} child\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.child = $util.emptyArray;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * Node id.\n         * @member {\"fieldName\"|\"index\"|undefined} id\n         * @memberof Trace.Node\n         * @instance\n         */\n        Object.defineProperty(Node.prototype, \"id\", {\n            get: $util.oneOfGetter($oneOfFields = [\"fieldName\", \"index\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new Node instance using the specified properties.\n         * @function create\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode=} [properties] Properties to set\n         * @returns {Trace.Node} Node instance\n         */\n        Node.create = function create(properties) {\n            return new Node(properties);\n        };\n\n        /**\n         * Encodes the specified Node message. Does not implicitly {@link Trace.Node.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode} message Node message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Node.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.fieldName != null && message.hasOwnProperty(\"fieldName\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);\n            if (message.index != null && message.hasOwnProperty(\"index\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n                $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.startTime);\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.endTime);\n            if (message.error != null && message.error.length)\n                for (var i = 0; i < message.error.length; ++i)\n                    $root.Trace.Error.encode(message.error[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.child != null && message.child.length)\n                for (var i = 0; i < message.child.length; ++i)\n                    $root.Trace.Node.encode(message.child[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentType);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Node message, length delimited. Does not implicitly {@link Trace.Node.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode} message Node message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Node.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Node message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Node\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Node} Node\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Node.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Node();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.fieldName = reader.string();\n                    break;\n                case 2:\n                    message.index = reader.uint32();\n                    break;\n                case 3:\n                    message.type = reader.string();\n                    break;\n                case 13:\n                    message.parentType = reader.string();\n                    break;\n                case 5:\n                    message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.startTime = reader.uint64();\n                    break;\n                case 9:\n                    message.endTime = reader.uint64();\n                    break;\n                case 11:\n                    if (!(message.error && message.error.length))\n                        message.error = [];\n                    message.error.push($root.Trace.Error.decode(reader, reader.uint32()));\n                    break;\n                case 12:\n                    if (!(message.child && message.child.length))\n                        message.child = [];\n                    message.child.push($root.Trace.Node.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Node message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Node\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Node} Node\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Node.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Node message.\n         * @function verify\n         * @memberof Trace.Node\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Node.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n                properties.id = 1;\n                if (!$util.isString(message.fieldName))\n                    return \"fieldName: string expected\";\n            }\n            if (message.index != null && message.hasOwnProperty(\"index\")) {\n                if (properties.id === 1)\n                    return \"id: multiple values\";\n                properties.id = 1;\n                if (!$util.isInteger(message.index))\n                    return \"index: integer expected\";\n            }\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                if (!$util.isString(message.type))\n                    return \"type: string expected\";\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                if (!$util.isString(message.parentType))\n                    return \"parentType: string expected\";\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n                var error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n                if (error)\n                    return \"cachePolicy.\" + error;\n            }\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))\n                    return \"startTime: integer|Long expected\";\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))\n                    return \"endTime: integer|Long expected\";\n            if (message.error != null && message.hasOwnProperty(\"error\")) {\n                if (!Array.isArray(message.error))\n                    return \"error: array expected\";\n                for (var i = 0; i < message.error.length; ++i) {\n                    var error = $root.Trace.Error.verify(message.error[i]);\n                    if (error)\n                        return \"error.\" + error;\n                }\n            }\n            if (message.child != null && message.hasOwnProperty(\"child\")) {\n                if (!Array.isArray(message.child))\n                    return \"child: array expected\";\n                for (var i = 0; i < message.child.length; ++i) {\n                    var error = $root.Trace.Node.verify(message.child[i]);\n                    if (error)\n                        return \"child.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a Node message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Trace.Node\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Trace.Node} Node\n         */\n        Node.fromObject = function fromObject(object) {\n            if (object instanceof $root.Trace.Node)\n                return object;\n            var message = new $root.Trace.Node();\n            if (object.fieldName != null)\n                message.fieldName = String(object.fieldName);\n            if (object.index != null)\n                message.index = object.index >>> 0;\n            if (object.type != null)\n                message.type = String(object.type);\n            if (object.parentType != null)\n                message.parentType = String(object.parentType);\n            if (object.cachePolicy != null) {\n                if (typeof object.cachePolicy !== \"object\")\n                    throw TypeError(\".Trace.Node.cachePolicy: object expected\");\n                message.cachePolicy = $root.Trace.CachePolicy.fromObject(object.cachePolicy);\n            }\n            if (object.startTime != null)\n                if ($util.Long)\n                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = true;\n                else if (typeof object.startTime === \"string\")\n                    message.startTime = parseInt(object.startTime, 10);\n                else if (typeof object.startTime === \"number\")\n                    message.startTime = object.startTime;\n                else if (typeof object.startTime === \"object\")\n                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber(true);\n            if (object.endTime != null)\n                if ($util.Long)\n                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = true;\n                else if (typeof object.endTime === \"string\")\n                    message.endTime = parseInt(object.endTime, 10);\n                else if (typeof object.endTime === \"number\")\n                    message.endTime = object.endTime;\n                else if (typeof object.endTime === \"object\")\n                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber(true);\n            if (object.error) {\n                if (!Array.isArray(object.error))\n                    throw TypeError(\".Trace.Node.error: array expected\");\n                message.error = [];\n                for (var i = 0; i < object.error.length; ++i) {\n                    if (typeof object.error[i] !== \"object\")\n                        throw TypeError(\".Trace.Node.error: object expected\");\n                    message.error[i] = $root.Trace.Error.fromObject(object.error[i]);\n                }\n            }\n            if (object.child) {\n                if (!Array.isArray(object.child))\n                    throw TypeError(\".Trace.Node.child: array expected\");\n                message.child = [];\n                for (var i = 0; i < object.child.length; ++i) {\n                    if (typeof object.child[i] !== \"object\")\n                        throw TypeError(\".Trace.Node.child: object expected\");\n                    message.child[i] = $root.Trace.Node.fromObject(object.child[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a Node message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.Node} message Node\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Node.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.error = [];\n                object.child = [];\n            }\n            if (options.defaults) {\n                object.type = \"\";\n                object.cachePolicy = null;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, true);\n                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.startTime = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, true);\n                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.endTime = options.longs === String ? \"0\" : 0;\n                object.parentType = \"\";\n            }\n            if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n                object.fieldName = message.fieldName;\n                if (options.oneofs)\n                    object.id = \"fieldName\";\n            }\n            if (message.index != null && message.hasOwnProperty(\"index\")) {\n                object.index = message.index;\n                if (options.oneofs)\n                    object.id = \"index\";\n            }\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = message.type;\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n                object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                if (typeof message.startTime === \"number\")\n                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;\n                else\n                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                if (typeof message.endTime === \"number\")\n                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;\n                else\n                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;\n            if (message.error && message.error.length) {\n                object.error = [];\n                for (var j = 0; j < message.error.length; ++j)\n                    object.error[j] = $root.Trace.Error.toObject(message.error[j], options);\n            }\n            if (message.child && message.child.length) {\n                object.child = [];\n                for (var j = 0; j < message.child.length; ++j)\n                    object.child[j] = $root.Trace.Node.toObject(message.child[j], options);\n            }\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                object.parentType = message.parentType;\n            return object;\n        };\n\n        /**\n         * Converts this Node to JSON.\n         * @function toJSON\n         * @memberof Trace.Node\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Node.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Node;\n    })();\n\n    return Trace;\n})();\n\n$root.ReportHeader = (function() {\n\n    /**\n     * Properties of a ReportHeader.\n     * @exports IReportHeader\n     * @interface IReportHeader\n     * @property {string|null} [service] ReportHeader service\n     * @property {string|null} [hostname] ReportHeader hostname\n     * @property {string|null} [agentVersion] ReportHeader agentVersion\n     * @property {string|null} [serviceVersion] ReportHeader serviceVersion\n     * @property {string|null} [runtimeVersion] ReportHeader runtimeVersion\n     * @property {string|null} [uname] ReportHeader uname\n     */\n\n    /**\n     * Constructs a new ReportHeader.\n     * @exports ReportHeader\n     * @classdesc Represents a ReportHeader.\n     * @implements IReportHeader\n     * @constructor\n     * @param {IReportHeader=} [properties] Properties to set\n     */\n    function ReportHeader(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ReportHeader service.\n     * @member {string} service\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.service = \"\";\n\n    /**\n     * ReportHeader hostname.\n     * @member {string} hostname\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.hostname = \"\";\n\n    /**\n     * ReportHeader agentVersion.\n     * @member {string} agentVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.agentVersion = \"\";\n\n    /**\n     * ReportHeader serviceVersion.\n     * @member {string} serviceVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.serviceVersion = \"\";\n\n    /**\n     * ReportHeader runtimeVersion.\n     * @member {string} runtimeVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.runtimeVersion = \"\";\n\n    /**\n     * ReportHeader uname.\n     * @member {string} uname\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.uname = \"\";\n\n    /**\n     * Creates a new ReportHeader instance using the specified properties.\n     * @function create\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader=} [properties] Properties to set\n     * @returns {ReportHeader} ReportHeader instance\n     */\n    ReportHeader.create = function create(properties) {\n        return new ReportHeader(properties);\n    };\n\n    /**\n     * Encodes the specified ReportHeader message. Does not implicitly {@link ReportHeader.verify|verify} messages.\n     * @function encode\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader} message ReportHeader message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReportHeader.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.service != null && message.hasOwnProperty(\"service\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.service);\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hostname);\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            writer.uint32(/* id 6, wireType 2 =*/50).string(message.agentVersion);\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            writer.uint32(/* id 7, wireType 2 =*/58).string(message.serviceVersion);\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            writer.uint32(/* id 8, wireType 2 =*/66).string(message.runtimeVersion);\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).string(message.uname);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ReportHeader message, length delimited. Does not implicitly {@link ReportHeader.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader} message ReportHeader message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ReportHeader message from the specified reader or buffer.\n     * @function decode\n     * @memberof ReportHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ReportHeader} ReportHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReportHeader.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReportHeader();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 3:\n                message.service = reader.string();\n                break;\n            case 5:\n                message.hostname = reader.string();\n                break;\n            case 6:\n                message.agentVersion = reader.string();\n                break;\n            case 7:\n                message.serviceVersion = reader.string();\n                break;\n            case 8:\n                message.runtimeVersion = reader.string();\n                break;\n            case 9:\n                message.uname = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ReportHeader message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ReportHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ReportHeader} ReportHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReportHeader.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ReportHeader message.\n     * @function verify\n     * @memberof ReportHeader\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ReportHeader.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.service != null && message.hasOwnProperty(\"service\"))\n            if (!$util.isString(message.service))\n                return \"service: string expected\";\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            if (!$util.isString(message.hostname))\n                return \"hostname: string expected\";\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            if (!$util.isString(message.agentVersion))\n                return \"agentVersion: string expected\";\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            if (!$util.isString(message.serviceVersion))\n                return \"serviceVersion: string expected\";\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            if (!$util.isString(message.runtimeVersion))\n                return \"runtimeVersion: string expected\";\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            if (!$util.isString(message.uname))\n                return \"uname: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a ReportHeader message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ReportHeader\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ReportHeader} ReportHeader\n     */\n    ReportHeader.fromObject = function fromObject(object) {\n        if (object instanceof $root.ReportHeader)\n            return object;\n        var message = new $root.ReportHeader();\n        if (object.service != null)\n            message.service = String(object.service);\n        if (object.hostname != null)\n            message.hostname = String(object.hostname);\n        if (object.agentVersion != null)\n            message.agentVersion = String(object.agentVersion);\n        if (object.serviceVersion != null)\n            message.serviceVersion = String(object.serviceVersion);\n        if (object.runtimeVersion != null)\n            message.runtimeVersion = String(object.runtimeVersion);\n        if (object.uname != null)\n            message.uname = String(object.uname);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a ReportHeader message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ReportHeader\n     * @static\n     * @param {ReportHeader} message ReportHeader\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ReportHeader.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.service = \"\";\n            object.hostname = \"\";\n            object.agentVersion = \"\";\n            object.serviceVersion = \"\";\n            object.runtimeVersion = \"\";\n            object.uname = \"\";\n        }\n        if (message.service != null && message.hasOwnProperty(\"service\"))\n            object.service = message.service;\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            object.hostname = message.hostname;\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            object.agentVersion = message.agentVersion;\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            object.serviceVersion = message.serviceVersion;\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            object.runtimeVersion = message.runtimeVersion;\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            object.uname = message.uname;\n        return object;\n    };\n\n    /**\n     * Converts this ReportHeader to JSON.\n     * @function toJSON\n     * @memberof ReportHeader\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ReportHeader.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ReportHeader;\n})();\n\n$root.PathErrorStats = (function() {\n\n    /**\n     * Properties of a PathErrorStats.\n     * @exports IPathErrorStats\n     * @interface IPathErrorStats\n     * @property {Object.<string,IPathErrorStats>|null} [children] PathErrorStats children\n     * @property {number|null} [errorsCount] PathErrorStats errorsCount\n     * @property {number|null} [requestsWithErrorsCount] PathErrorStats requestsWithErrorsCount\n     */\n\n    /**\n     * Constructs a new PathErrorStats.\n     * @exports PathErrorStats\n     * @classdesc Represents a PathErrorStats.\n     * @implements IPathErrorStats\n     * @constructor\n     * @param {IPathErrorStats=} [properties] Properties to set\n     */\n    function PathErrorStats(properties) {\n        this.children = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PathErrorStats children.\n     * @member {Object.<string,IPathErrorStats>} children\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.children = $util.emptyObject;\n\n    /**\n     * PathErrorStats errorsCount.\n     * @member {number} errorsCount\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.errorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * PathErrorStats requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Creates a new PathErrorStats instance using the specified properties.\n     * @function create\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats=} [properties] Properties to set\n     * @returns {PathErrorStats} PathErrorStats instance\n     */\n    PathErrorStats.create = function create(properties) {\n        return new PathErrorStats(properties);\n    };\n\n    /**\n     * Encodes the specified PathErrorStats message. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n     * @function encode\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PathErrorStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.children != null && message.hasOwnProperty(\"children\"))\n            for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.errorsCount);\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.requestsWithErrorsCount);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PathErrorStats message, length delimited. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PathErrorStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof PathErrorStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PathErrorStats} PathErrorStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PathErrorStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.children === $util.emptyObject)\n                    message.children = {};\n                key = reader.string();\n                reader.pos++;\n                message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());\n                break;\n            case 4:\n                message.errorsCount = reader.uint64();\n                break;\n            case 5:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a PathErrorStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PathErrorStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PathErrorStats} PathErrorStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PathErrorStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PathErrorStats message.\n     * @function verify\n     * @memberof PathErrorStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PathErrorStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.children != null && message.hasOwnProperty(\"children\")) {\n            if (!$util.isObject(message.children))\n                return \"children: object expected\";\n            var key = Object.keys(message.children);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.PathErrorStats.verify(message.children[key[i]]);\n                if (error)\n                    return \"children.\" + error;\n            }\n        }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))\n                return \"errorsCount: integer|Long expected\";\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a PathErrorStats message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PathErrorStats\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PathErrorStats} PathErrorStats\n     */\n    PathErrorStats.fromObject = function fromObject(object) {\n        if (object instanceof $root.PathErrorStats)\n            return object;\n        var message = new $root.PathErrorStats();\n        if (object.children) {\n            if (typeof object.children !== \"object\")\n                throw TypeError(\".PathErrorStats.children: object expected\");\n            message.children = {};\n            for (var keys = Object.keys(object.children), i = 0; i < keys.length; ++i) {\n                if (typeof object.children[keys[i]] !== \"object\")\n                    throw TypeError(\".PathErrorStats.children: object expected\");\n                message.children[keys[i]] = $root.PathErrorStats.fromObject(object.children[keys[i]]);\n            }\n        }\n        if (object.errorsCount != null)\n            if ($util.Long)\n                (message.errorsCount = $util.Long.fromValue(object.errorsCount)).unsigned = true;\n            else if (typeof object.errorsCount === \"string\")\n                message.errorsCount = parseInt(object.errorsCount, 10);\n            else if (typeof object.errorsCount === \"number\")\n                message.errorsCount = object.errorsCount;\n            else if (typeof object.errorsCount === \"object\")\n                message.errorsCount = new $util.LongBits(object.errorsCount.low >>> 0, object.errorsCount.high >>> 0).toNumber(true);\n        if (object.requestsWithErrorsCount != null)\n            if ($util.Long)\n                (message.requestsWithErrorsCount = $util.Long.fromValue(object.requestsWithErrorsCount)).unsigned = true;\n            else if (typeof object.requestsWithErrorsCount === \"string\")\n                message.requestsWithErrorsCount = parseInt(object.requestsWithErrorsCount, 10);\n            else if (typeof object.requestsWithErrorsCount === \"number\")\n                message.requestsWithErrorsCount = object.requestsWithErrorsCount;\n            else if (typeof object.requestsWithErrorsCount === \"object\")\n                message.requestsWithErrorsCount = new $util.LongBits(object.requestsWithErrorsCount.low >>> 0, object.requestsWithErrorsCount.high >>> 0).toNumber(true);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a PathErrorStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PathErrorStats\n     * @static\n     * @param {PathErrorStats} message PathErrorStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PathErrorStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.children = {};\n        if (options.defaults) {\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.errorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.errorsCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n        }\n        var keys2;\n        if (message.children && (keys2 = Object.keys(message.children)).length) {\n            object.children = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);\n        }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (typeof message.errorsCount === \"number\")\n                object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;\n            else\n                object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        return object;\n    };\n\n    /**\n     * Converts this PathErrorStats to JSON.\n     * @function toJSON\n     * @memberof PathErrorStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PathErrorStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PathErrorStats;\n})();\n\n$root.ClientNameStats = (function() {\n\n    /**\n     * Properties of a ClientNameStats.\n     * @exports IClientNameStats\n     * @interface IClientNameStats\n     * @property {Array.<number>|null} [latencyCount] ClientNameStats latencyCount\n     * @property {Object.<string,number>|null} [requestsCountPerVersion] ClientNameStats requestsCountPerVersion\n     * @property {Object.<string,number>|null} [cacheHitsPerVersion] ClientNameStats cacheHitsPerVersion\n     * @property {Object.<string,number>|null} [persistedQueryHitsPerVersion] ClientNameStats persistedQueryHitsPerVersion\n     * @property {Object.<string,number>|null} [persistedQueryMissesPerVersion] ClientNameStats persistedQueryMissesPerVersion\n     * @property {Array.<number>|null} [cacheLatencyCount] ClientNameStats cacheLatencyCount\n     * @property {IPathErrorStats|null} [rootErrorStats] ClientNameStats rootErrorStats\n     * @property {number|null} [requestsWithErrorsCount] ClientNameStats requestsWithErrorsCount\n     * @property {Array.<number>|null} [publicCacheTtlCount] ClientNameStats publicCacheTtlCount\n     * @property {Array.<number>|null} [privateCacheTtlCount] ClientNameStats privateCacheTtlCount\n     */\n\n    /**\n     * Constructs a new ClientNameStats.\n     * @exports ClientNameStats\n     * @classdesc Represents a ClientNameStats.\n     * @implements IClientNameStats\n     * @constructor\n     * @param {IClientNameStats=} [properties] Properties to set\n     */\n    function ClientNameStats(properties) {\n        this.latencyCount = [];\n        this.requestsCountPerVersion = {};\n        this.cacheHitsPerVersion = {};\n        this.persistedQueryHitsPerVersion = {};\n        this.persistedQueryMissesPerVersion = {};\n        this.cacheLatencyCount = [];\n        this.publicCacheTtlCount = [];\n        this.privateCacheTtlCount = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ClientNameStats latencyCount.\n     * @member {Array.<number>} latencyCount\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.latencyCount = $util.emptyArray;\n\n    /**\n     * ClientNameStats requestsCountPerVersion.\n     * @member {Object.<string,number>} requestsCountPerVersion\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.requestsCountPerVersion = $util.emptyObject;\n\n    /**\n     * ClientNameStats cacheHitsPerVersion.\n     * @member {Object.<string,number>} cacheHitsPerVersion\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.cacheHitsPerVersion = $util.emptyObject;\n\n    /**\n     * ClientNameStats persistedQueryHitsPerVersion.\n     * @member {Object.<string,number>} persistedQueryHitsPerVersion\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.persistedQueryHitsPerVersion = $util.emptyObject;\n\n    /**\n     * ClientNameStats persistedQueryMissesPerVersion.\n     * @member {Object.<string,number>} persistedQueryMissesPerVersion\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.persistedQueryMissesPerVersion = $util.emptyObject;\n\n    /**\n     * ClientNameStats cacheLatencyCount.\n     * @member {Array.<number>} cacheLatencyCount\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.cacheLatencyCount = $util.emptyArray;\n\n    /**\n     * ClientNameStats rootErrorStats.\n     * @member {IPathErrorStats|null|undefined} rootErrorStats\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.rootErrorStats = null;\n\n    /**\n     * ClientNameStats requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * ClientNameStats publicCacheTtlCount.\n     * @member {Array.<number>} publicCacheTtlCount\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.publicCacheTtlCount = $util.emptyArray;\n\n    /**\n     * ClientNameStats privateCacheTtlCount.\n     * @member {Array.<number>} privateCacheTtlCount\n     * @memberof ClientNameStats\n     * @instance\n     */\n    ClientNameStats.prototype.privateCacheTtlCount = $util.emptyArray;\n\n    /**\n     * Creates a new ClientNameStats instance using the specified properties.\n     * @function create\n     * @memberof ClientNameStats\n     * @static\n     * @param {IClientNameStats=} [properties] Properties to set\n     * @returns {ClientNameStats} ClientNameStats instance\n     */\n    ClientNameStats.create = function create(properties) {\n        return new ClientNameStats(properties);\n    };\n\n    /**\n     * Encodes the specified ClientNameStats message. Does not implicitly {@link ClientNameStats.verify|verify} messages.\n     * @function encode\n     * @memberof ClientNameStats\n     * @static\n     * @param {IClientNameStats} message ClientNameStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ClientNameStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.latencyCount != null && message.latencyCount.length) {\n            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n            for (var i = 0; i < message.latencyCount.length; ++i)\n                writer.int64(message.latencyCount[i]);\n            writer.ldelim();\n        }\n        if (message.requestsCountPerVersion != null && message.hasOwnProperty(\"requestsCountPerVersion\"))\n            for (var keys = Object.keys(message.requestsCountPerVersion), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.requestsCountPerVersion[keys[i]]).ldelim();\n        if (message.cacheHitsPerVersion != null && message.hasOwnProperty(\"cacheHitsPerVersion\"))\n            for (var keys = Object.keys(message.cacheHitsPerVersion), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.cacheHitsPerVersion[keys[i]]).ldelim();\n        if (message.cacheLatencyCount != null && message.cacheLatencyCount.length) {\n            writer.uint32(/* id 5, wireType 2 =*/42).fork();\n            for (var i = 0; i < message.cacheLatencyCount.length; ++i)\n                writer.int64(message.cacheLatencyCount[i]);\n            writer.ldelim();\n        }\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\"))\n            $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.requestsWithErrorsCount);\n        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.length) {\n            writer.uint32(/* id 8, wireType 2 =*/66).fork();\n            for (var i = 0; i < message.publicCacheTtlCount.length; ++i)\n                writer.int64(message.publicCacheTtlCount[i]);\n            writer.ldelim();\n        }\n        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.length) {\n            writer.uint32(/* id 9, wireType 2 =*/74).fork();\n            for (var i = 0; i < message.privateCacheTtlCount.length; ++i)\n                writer.int64(message.privateCacheTtlCount[i]);\n            writer.ldelim();\n        }\n        if (message.persistedQueryHitsPerVersion != null && message.hasOwnProperty(\"persistedQueryHitsPerVersion\"))\n            for (var keys = Object.keys(message.persistedQueryHitsPerVersion), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.persistedQueryHitsPerVersion[keys[i]]).ldelim();\n        if (message.persistedQueryMissesPerVersion != null && message.hasOwnProperty(\"persistedQueryMissesPerVersion\"))\n            for (var keys = Object.keys(message.persistedQueryMissesPerVersion), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.persistedQueryMissesPerVersion[keys[i]]).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ClientNameStats message, length delimited. Does not implicitly {@link ClientNameStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ClientNameStats\n     * @static\n     * @param {IClientNameStats} message ClientNameStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ClientNameStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ClientNameStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ClientNameStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ClientNameStats} ClientNameStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ClientNameStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientNameStats(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.latencyCount && message.latencyCount.length))\n                    message.latencyCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.latencyCount.push(reader.int64());\n                } else\n                    message.latencyCount.push(reader.int64());\n                break;\n            case 3:\n                reader.skip().pos++;\n                if (message.requestsCountPerVersion === $util.emptyObject)\n                    message.requestsCountPerVersion = {};\n                key = reader.string();\n                reader.pos++;\n                message.requestsCountPerVersion[key] = reader.uint64();\n                break;\n            case 4:\n                reader.skip().pos++;\n                if (message.cacheHitsPerVersion === $util.emptyObject)\n                    message.cacheHitsPerVersion = {};\n                key = reader.string();\n                reader.pos++;\n                message.cacheHitsPerVersion[key] = reader.uint64();\n                break;\n            case 10:\n                reader.skip().pos++;\n                if (message.persistedQueryHitsPerVersion === $util.emptyObject)\n                    message.persistedQueryHitsPerVersion = {};\n                key = reader.string();\n                reader.pos++;\n                message.persistedQueryHitsPerVersion[key] = reader.uint64();\n                break;\n            case 11:\n                reader.skip().pos++;\n                if (message.persistedQueryMissesPerVersion === $util.emptyObject)\n                    message.persistedQueryMissesPerVersion = {};\n                key = reader.string();\n                reader.pos++;\n                message.persistedQueryMissesPerVersion[key] = reader.uint64();\n                break;\n            case 5:\n                if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))\n                    message.cacheLatencyCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.cacheLatencyCount.push(reader.int64());\n                } else\n                    message.cacheLatencyCount.push(reader.int64());\n                break;\n            case 6:\n                message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());\n                break;\n            case 7:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            case 8:\n                if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))\n                    message.publicCacheTtlCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.publicCacheTtlCount.push(reader.int64());\n                } else\n                    message.publicCacheTtlCount.push(reader.int64());\n                break;\n            case 9:\n                if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))\n                    message.privateCacheTtlCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.privateCacheTtlCount.push(reader.int64());\n                } else\n                    message.privateCacheTtlCount.push(reader.int64());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ClientNameStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ClientNameStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ClientNameStats} ClientNameStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ClientNameStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ClientNameStats message.\n     * @function verify\n     * @memberof ClientNameStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ClientNameStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n            if (!Array.isArray(message.latencyCount))\n                return \"latencyCount: array expected\";\n            for (var i = 0; i < message.latencyCount.length; ++i)\n                if (!$util.isInteger(message.latencyCount[i]) && !(message.latencyCount[i] && $util.isInteger(message.latencyCount[i].low) && $util.isInteger(message.latencyCount[i].high)))\n                    return \"latencyCount: integer|Long[] expected\";\n        }\n        if (message.requestsCountPerVersion != null && message.hasOwnProperty(\"requestsCountPerVersion\")) {\n            if (!$util.isObject(message.requestsCountPerVersion))\n                return \"requestsCountPerVersion: object expected\";\n            var key = Object.keys(message.requestsCountPerVersion);\n            for (var i = 0; i < key.length; ++i)\n                if (!$util.isInteger(message.requestsCountPerVersion[key[i]]) && !(message.requestsCountPerVersion[key[i]] && $util.isInteger(message.requestsCountPerVersion[key[i]].low) && $util.isInteger(message.requestsCountPerVersion[key[i]].high)))\n                    return \"requestsCountPerVersion: integer|Long{k:string} expected\";\n        }\n        if (message.cacheHitsPerVersion != null && message.hasOwnProperty(\"cacheHitsPerVersion\")) {\n            if (!$util.isObject(message.cacheHitsPerVersion))\n                return \"cacheHitsPerVersion: object expected\";\n            var key = Object.keys(message.cacheHitsPerVersion);\n            for (var i = 0; i < key.length; ++i)\n                if (!$util.isInteger(message.cacheHitsPerVersion[key[i]]) && !(message.cacheHitsPerVersion[key[i]] && $util.isInteger(message.cacheHitsPerVersion[key[i]].low) && $util.isInteger(message.cacheHitsPerVersion[key[i]].high)))\n                    return \"cacheHitsPerVersion: integer|Long{k:string} expected\";\n        }\n        if (message.persistedQueryHitsPerVersion != null && message.hasOwnProperty(\"persistedQueryHitsPerVersion\")) {\n            if (!$util.isObject(message.persistedQueryHitsPerVersion))\n                return \"persistedQueryHitsPerVersion: object expected\";\n            var key = Object.keys(message.persistedQueryHitsPerVersion);\n            for (var i = 0; i < key.length; ++i)\n                if (!$util.isInteger(message.persistedQueryHitsPerVersion[key[i]]) && !(message.persistedQueryHitsPerVersion[key[i]] && $util.isInteger(message.persistedQueryHitsPerVersion[key[i]].low) && $util.isInteger(message.persistedQueryHitsPerVersion[key[i]].high)))\n                    return \"persistedQueryHitsPerVersion: integer|Long{k:string} expected\";\n        }\n        if (message.persistedQueryMissesPerVersion != null && message.hasOwnProperty(\"persistedQueryMissesPerVersion\")) {\n            if (!$util.isObject(message.persistedQueryMissesPerVersion))\n                return \"persistedQueryMissesPerVersion: object expected\";\n            var key = Object.keys(message.persistedQueryMissesPerVersion);\n            for (var i = 0; i < key.length; ++i)\n                if (!$util.isInteger(message.persistedQueryMissesPerVersion[key[i]]) && !(message.persistedQueryMissesPerVersion[key[i]] && $util.isInteger(message.persistedQueryMissesPerVersion[key[i]].low) && $util.isInteger(message.persistedQueryMissesPerVersion[key[i]].high)))\n                    return \"persistedQueryMissesPerVersion: integer|Long{k:string} expected\";\n        }\n        if (message.cacheLatencyCount != null && message.hasOwnProperty(\"cacheLatencyCount\")) {\n            if (!Array.isArray(message.cacheLatencyCount))\n                return \"cacheLatencyCount: array expected\";\n            for (var i = 0; i < message.cacheLatencyCount.length; ++i)\n                if (!$util.isInteger(message.cacheLatencyCount[i]) && !(message.cacheLatencyCount[i] && $util.isInteger(message.cacheLatencyCount[i].low) && $util.isInteger(message.cacheLatencyCount[i].high)))\n                    return \"cacheLatencyCount: integer|Long[] expected\";\n        }\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\")) {\n            var error = $root.PathErrorStats.verify(message.rootErrorStats);\n            if (error)\n                return \"rootErrorStats.\" + error;\n        }\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        if (message.publicCacheTtlCount != null && message.hasOwnProperty(\"publicCacheTtlCount\")) {\n            if (!Array.isArray(message.publicCacheTtlCount))\n                return \"publicCacheTtlCount: array expected\";\n            for (var i = 0; i < message.publicCacheTtlCount.length; ++i)\n                if (!$util.isInteger(message.publicCacheTtlCount[i]) && !(message.publicCacheTtlCount[i] && $util.isInteger(message.publicCacheTtlCount[i].low) && $util.isInteger(message.publicCacheTtlCount[i].high)))\n                    return \"publicCacheTtlCount: integer|Long[] expected\";\n        }\n        if (message.privateCacheTtlCount != null && message.hasOwnProperty(\"privateCacheTtlCount\")) {\n            if (!Array.isArray(message.privateCacheTtlCount))\n                return \"privateCacheTtlCount: array expected\";\n            for (var i = 0; i < message.privateCacheTtlCount.length; ++i)\n                if (!$util.isInteger(message.privateCacheTtlCount[i]) && !(message.privateCacheTtlCount[i] && $util.isInteger(message.privateCacheTtlCount[i].low) && $util.isInteger(message.privateCacheTtlCount[i].high)))\n                    return \"privateCacheTtlCount: integer|Long[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a ClientNameStats message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ClientNameStats\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ClientNameStats} ClientNameStats\n     */\n    ClientNameStats.fromObject = function fromObject(object) {\n        if (object instanceof $root.ClientNameStats)\n            return object;\n        var message = new $root.ClientNameStats();\n        if (object.latencyCount) {\n            if (!Array.isArray(object.latencyCount))\n                throw TypeError(\".ClientNameStats.latencyCount: array expected\");\n            message.latencyCount = [];\n            for (var i = 0; i < object.latencyCount.length; ++i)\n                if ($util.Long)\n                    (message.latencyCount[i] = $util.Long.fromValue(object.latencyCount[i])).unsigned = false;\n                else if (typeof object.latencyCount[i] === \"string\")\n                    message.latencyCount[i] = parseInt(object.latencyCount[i], 10);\n                else if (typeof object.latencyCount[i] === \"number\")\n                    message.latencyCount[i] = object.latencyCount[i];\n                else if (typeof object.latencyCount[i] === \"object\")\n                    message.latencyCount[i] = new $util.LongBits(object.latencyCount[i].low >>> 0, object.latencyCount[i].high >>> 0).toNumber();\n        }\n        if (object.requestsCountPerVersion) {\n            if (typeof object.requestsCountPerVersion !== \"object\")\n                throw TypeError(\".ClientNameStats.requestsCountPerVersion: object expected\");\n            message.requestsCountPerVersion = {};\n            for (var keys = Object.keys(object.requestsCountPerVersion), i = 0; i < keys.length; ++i)\n                if ($util.Long)\n                    (message.requestsCountPerVersion[keys[i]] = $util.Long.fromValue(object.requestsCountPerVersion[keys[i]])).unsigned = true;\n                else if (typeof object.requestsCountPerVersion[keys[i]] === \"string\")\n                    message.requestsCountPerVersion[keys[i]] = parseInt(object.requestsCountPerVersion[keys[i]], 10);\n                else if (typeof object.requestsCountPerVersion[keys[i]] === \"number\")\n                    message.requestsCountPerVersion[keys[i]] = object.requestsCountPerVersion[keys[i]];\n                else if (typeof object.requestsCountPerVersion[keys[i]] === \"object\")\n                    message.requestsCountPerVersion[keys[i]] = new $util.LongBits(object.requestsCountPerVersion[keys[i]].low >>> 0, object.requestsCountPerVersion[keys[i]].high >>> 0).toNumber(true);\n        }\n        if (object.cacheHitsPerVersion) {\n            if (typeof object.cacheHitsPerVersion !== \"object\")\n                throw TypeError(\".ClientNameStats.cacheHitsPerVersion: object expected\");\n            message.cacheHitsPerVersion = {};\n            for (var keys = Object.keys(object.cacheHitsPerVersion), i = 0; i < keys.length; ++i)\n                if ($util.Long)\n                    (message.cacheHitsPerVersion[keys[i]] = $util.Long.fromValue(object.cacheHitsPerVersion[keys[i]])).unsigned = true;\n                else if (typeof object.cacheHitsPerVersion[keys[i]] === \"string\")\n                    message.cacheHitsPerVersion[keys[i]] = parseInt(object.cacheHitsPerVersion[keys[i]], 10);\n                else if (typeof object.cacheHitsPerVersion[keys[i]] === \"number\")\n                    message.cacheHitsPerVersion[keys[i]] = object.cacheHitsPerVersion[keys[i]];\n                else if (typeof object.cacheHitsPerVersion[keys[i]] === \"object\")\n                    message.cacheHitsPerVersion[keys[i]] = new $util.LongBits(object.cacheHitsPerVersion[keys[i]].low >>> 0, object.cacheHitsPerVersion[keys[i]].high >>> 0).toNumber(true);\n        }\n        if (object.persistedQueryHitsPerVersion) {\n            if (typeof object.persistedQueryHitsPerVersion !== \"object\")\n                throw TypeError(\".ClientNameStats.persistedQueryHitsPerVersion: object expected\");\n            message.persistedQueryHitsPerVersion = {};\n            for (var keys = Object.keys(object.persistedQueryHitsPerVersion), i = 0; i < keys.length; ++i)\n                if ($util.Long)\n                    (message.persistedQueryHitsPerVersion[keys[i]] = $util.Long.fromValue(object.persistedQueryHitsPerVersion[keys[i]])).unsigned = true;\n                else if (typeof object.persistedQueryHitsPerVersion[keys[i]] === \"string\")\n                    message.persistedQueryHitsPerVersion[keys[i]] = parseInt(object.persistedQueryHitsPerVersion[keys[i]], 10);\n                else if (typeof object.persistedQueryHitsPerVersion[keys[i]] === \"number\")\n                    message.persistedQueryHitsPerVersion[keys[i]] = object.persistedQueryHitsPerVersion[keys[i]];\n                else if (typeof object.persistedQueryHitsPerVersion[keys[i]] === \"object\")\n                    message.persistedQueryHitsPerVersion[keys[i]] = new $util.LongBits(object.persistedQueryHitsPerVersion[keys[i]].low >>> 0, object.persistedQueryHitsPerVersion[keys[i]].high >>> 0).toNumber(true);\n        }\n        if (object.persistedQueryMissesPerVersion) {\n            if (typeof object.persistedQueryMissesPerVersion !== \"object\")\n                throw TypeError(\".ClientNameStats.persistedQueryMissesPerVersion: object expected\");\n            message.persistedQueryMissesPerVersion = {};\n            for (var keys = Object.keys(object.persistedQueryMissesPerVersion), i = 0; i < keys.length; ++i)\n                if ($util.Long)\n                    (message.persistedQueryMissesPerVersion[keys[i]] = $util.Long.fromValue(object.persistedQueryMissesPerVersion[keys[i]])).unsigned = true;\n                else if (typeof object.persistedQueryMissesPerVersion[keys[i]] === \"string\")\n                    message.persistedQueryMissesPerVersion[keys[i]] = parseInt(object.persistedQueryMissesPerVersion[keys[i]], 10);\n                else if (typeof object.persistedQueryMissesPerVersion[keys[i]] === \"number\")\n                    message.persistedQueryMissesPerVersion[keys[i]] = object.persistedQueryMissesPerVersion[keys[i]];\n                else if (typeof object.persistedQueryMissesPerVersion[keys[i]] === \"object\")\n                    message.persistedQueryMissesPerVersion[keys[i]] = new $util.LongBits(object.persistedQueryMissesPerVersion[keys[i]].low >>> 0, object.persistedQueryMissesPerVersion[keys[i]].high >>> 0).toNumber(true);\n        }\n        if (object.cacheLatencyCount) {\n            if (!Array.isArray(object.cacheLatencyCount))\n                throw TypeError(\".ClientNameStats.cacheLatencyCount: array expected\");\n            message.cacheLatencyCount = [];\n            for (var i = 0; i < object.cacheLatencyCount.length; ++i)\n                if ($util.Long)\n                    (message.cacheLatencyCount[i] = $util.Long.fromValue(object.cacheLatencyCount[i])).unsigned = false;\n                else if (typeof object.cacheLatencyCount[i] === \"string\")\n                    message.cacheLatencyCount[i] = parseInt(object.cacheLatencyCount[i], 10);\n                else if (typeof object.cacheLatencyCount[i] === \"number\")\n                    message.cacheLatencyCount[i] = object.cacheLatencyCount[i];\n                else if (typeof object.cacheLatencyCount[i] === \"object\")\n                    message.cacheLatencyCount[i] = new $util.LongBits(object.cacheLatencyCount[i].low >>> 0, object.cacheLatencyCount[i].high >>> 0).toNumber();\n        }\n        if (object.rootErrorStats != null) {\n            if (typeof object.rootErrorStats !== \"object\")\n                throw TypeError(\".ClientNameStats.rootErrorStats: object expected\");\n            message.rootErrorStats = $root.PathErrorStats.fromObject(object.rootErrorStats);\n        }\n        if (object.requestsWithErrorsCount != null)\n            if ($util.Long)\n                (message.requestsWithErrorsCount = $util.Long.fromValue(object.requestsWithErrorsCount)).unsigned = true;\n            else if (typeof object.requestsWithErrorsCount === \"string\")\n                message.requestsWithErrorsCount = parseInt(object.requestsWithErrorsCount, 10);\n            else if (typeof object.requestsWithErrorsCount === \"number\")\n                message.requestsWithErrorsCount = object.requestsWithErrorsCount;\n            else if (typeof object.requestsWithErrorsCount === \"object\")\n                message.requestsWithErrorsCount = new $util.LongBits(object.requestsWithErrorsCount.low >>> 0, object.requestsWithErrorsCount.high >>> 0).toNumber(true);\n        if (object.publicCacheTtlCount) {\n            if (!Array.isArray(object.publicCacheTtlCount))\n                throw TypeError(\".ClientNameStats.publicCacheTtlCount: array expected\");\n            message.publicCacheTtlCount = [];\n            for (var i = 0; i < object.publicCacheTtlCount.length; ++i)\n                if ($util.Long)\n                    (message.publicCacheTtlCount[i] = $util.Long.fromValue(object.publicCacheTtlCount[i])).unsigned = false;\n                else if (typeof object.publicCacheTtlCount[i] === \"string\")\n                    message.publicCacheTtlCount[i] = parseInt(object.publicCacheTtlCount[i], 10);\n                else if (typeof object.publicCacheTtlCount[i] === \"number\")\n                    message.publicCacheTtlCount[i] = object.publicCacheTtlCount[i];\n                else if (typeof object.publicCacheTtlCount[i] === \"object\")\n                    message.publicCacheTtlCount[i] = new $util.LongBits(object.publicCacheTtlCount[i].low >>> 0, object.publicCacheTtlCount[i].high >>> 0).toNumber();\n        }\n        if (object.privateCacheTtlCount) {\n            if (!Array.isArray(object.privateCacheTtlCount))\n                throw TypeError(\".ClientNameStats.privateCacheTtlCount: array expected\");\n            message.privateCacheTtlCount = [];\n            for (var i = 0; i < object.privateCacheTtlCount.length; ++i)\n                if ($util.Long)\n                    (message.privateCacheTtlCount[i] = $util.Long.fromValue(object.privateCacheTtlCount[i])).unsigned = false;\n                else if (typeof object.privateCacheTtlCount[i] === \"string\")\n                    message.privateCacheTtlCount[i] = parseInt(object.privateCacheTtlCount[i], 10);\n                else if (typeof object.privateCacheTtlCount[i] === \"number\")\n                    message.privateCacheTtlCount[i] = object.privateCacheTtlCount[i];\n                else if (typeof object.privateCacheTtlCount[i] === \"object\")\n                    message.privateCacheTtlCount[i] = new $util.LongBits(object.privateCacheTtlCount[i].low >>> 0, object.privateCacheTtlCount[i].high >>> 0).toNumber();\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a ClientNameStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ClientNameStats\n     * @static\n     * @param {ClientNameStats} message ClientNameStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ClientNameStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults) {\n            object.latencyCount = [];\n            object.cacheLatencyCount = [];\n            object.publicCacheTtlCount = [];\n            object.privateCacheTtlCount = [];\n        }\n        if (options.objects || options.defaults) {\n            object.requestsCountPerVersion = {};\n            object.cacheHitsPerVersion = {};\n            object.persistedQueryHitsPerVersion = {};\n            object.persistedQueryMissesPerVersion = {};\n        }\n        if (options.defaults) {\n            object.rootErrorStats = null;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n        }\n        if (message.latencyCount && message.latencyCount.length) {\n            object.latencyCount = [];\n            for (var j = 0; j < message.latencyCount.length; ++j)\n                if (typeof message.latencyCount[j] === \"number\")\n                    object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];\n                else\n                    object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n        }\n        var keys2;\n        if (message.requestsCountPerVersion && (keys2 = Object.keys(message.requestsCountPerVersion)).length) {\n            object.requestsCountPerVersion = {};\n            for (var j = 0; j < keys2.length; ++j)\n                if (typeof message.requestsCountPerVersion[keys2[j]] === \"number\")\n                    object.requestsCountPerVersion[keys2[j]] = options.longs === String ? String(message.requestsCountPerVersion[keys2[j]]) : message.requestsCountPerVersion[keys2[j]];\n                else\n                    object.requestsCountPerVersion[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.requestsCountPerVersion[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.requestsCountPerVersion[keys2[j]].low >>> 0, message.requestsCountPerVersion[keys2[j]].high >>> 0).toNumber(true) : message.requestsCountPerVersion[keys2[j]];\n        }\n        if (message.cacheHitsPerVersion && (keys2 = Object.keys(message.cacheHitsPerVersion)).length) {\n            object.cacheHitsPerVersion = {};\n            for (var j = 0; j < keys2.length; ++j)\n                if (typeof message.cacheHitsPerVersion[keys2[j]] === \"number\")\n                    object.cacheHitsPerVersion[keys2[j]] = options.longs === String ? String(message.cacheHitsPerVersion[keys2[j]]) : message.cacheHitsPerVersion[keys2[j]];\n                else\n                    object.cacheHitsPerVersion[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHitsPerVersion[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.cacheHitsPerVersion[keys2[j]].low >>> 0, message.cacheHitsPerVersion[keys2[j]].high >>> 0).toNumber(true) : message.cacheHitsPerVersion[keys2[j]];\n        }\n        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {\n            object.cacheLatencyCount = [];\n            for (var j = 0; j < message.cacheLatencyCount.length; ++j)\n                if (typeof message.cacheLatencyCount[j] === \"number\")\n                    object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];\n                else\n                    object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];\n        }\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\"))\n            object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {\n            object.publicCacheTtlCount = [];\n            for (var j = 0; j < message.publicCacheTtlCount.length; ++j)\n                if (typeof message.publicCacheTtlCount[j] === \"number\")\n                    object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];\n                else\n                    object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];\n        }\n        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {\n            object.privateCacheTtlCount = [];\n            for (var j = 0; j < message.privateCacheTtlCount.length; ++j)\n                if (typeof message.privateCacheTtlCount[j] === \"number\")\n                    object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];\n                else\n                    object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];\n        }\n        if (message.persistedQueryHitsPerVersion && (keys2 = Object.keys(message.persistedQueryHitsPerVersion)).length) {\n            object.persistedQueryHitsPerVersion = {};\n            for (var j = 0; j < keys2.length; ++j)\n                if (typeof message.persistedQueryHitsPerVersion[keys2[j]] === \"number\")\n                    object.persistedQueryHitsPerVersion[keys2[j]] = options.longs === String ? String(message.persistedQueryHitsPerVersion[keys2[j]]) : message.persistedQueryHitsPerVersion[keys2[j]];\n                else\n                    object.persistedQueryHitsPerVersion[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHitsPerVersion[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.persistedQueryHitsPerVersion[keys2[j]].low >>> 0, message.persistedQueryHitsPerVersion[keys2[j]].high >>> 0).toNumber(true) : message.persistedQueryHitsPerVersion[keys2[j]];\n        }\n        if (message.persistedQueryMissesPerVersion && (keys2 = Object.keys(message.persistedQueryMissesPerVersion)).length) {\n            object.persistedQueryMissesPerVersion = {};\n            for (var j = 0; j < keys2.length; ++j)\n                if (typeof message.persistedQueryMissesPerVersion[keys2[j]] === \"number\")\n                    object.persistedQueryMissesPerVersion[keys2[j]] = options.longs === String ? String(message.persistedQueryMissesPerVersion[keys2[j]]) : message.persistedQueryMissesPerVersion[keys2[j]];\n                else\n                    object.persistedQueryMissesPerVersion[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMissesPerVersion[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.persistedQueryMissesPerVersion[keys2[j]].low >>> 0, message.persistedQueryMissesPerVersion[keys2[j]].high >>> 0).toNumber(true) : message.persistedQueryMissesPerVersion[keys2[j]];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ClientNameStats to JSON.\n     * @function toJSON\n     * @memberof ClientNameStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ClientNameStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ClientNameStats;\n})();\n\n$root.FieldStat = (function() {\n\n    /**\n     * Properties of a FieldStat.\n     * @exports IFieldStat\n     * @interface IFieldStat\n     * @property {string|null} [name] FieldStat name\n     * @property {string|null} [returnType] FieldStat returnType\n     * @property {number|null} [errorsCount] FieldStat errorsCount\n     * @property {number|null} [count] FieldStat count\n     * @property {number|null} [requestsWithErrorsCount] FieldStat requestsWithErrorsCount\n     * @property {Array.<number>|null} [latencyCount] FieldStat latencyCount\n     */\n\n    /**\n     * Constructs a new FieldStat.\n     * @exports FieldStat\n     * @classdesc Represents a FieldStat.\n     * @implements IFieldStat\n     * @constructor\n     * @param {IFieldStat=} [properties] Properties to set\n     */\n    function FieldStat(properties) {\n        this.latencyCount = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FieldStat name.\n     * @member {string} name\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.name = \"\";\n\n    /**\n     * FieldStat returnType.\n     * @member {string} returnType\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.returnType = \"\";\n\n    /**\n     * FieldStat errorsCount.\n     * @member {number} errorsCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.errorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * FieldStat count.\n     * @member {number} count\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * FieldStat requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * FieldStat latencyCount.\n     * @member {Array.<number>} latencyCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.latencyCount = $util.emptyArray;\n\n    /**\n     * Creates a new FieldStat instance using the specified properties.\n     * @function create\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat=} [properties] Properties to set\n     * @returns {FieldStat} FieldStat instance\n     */\n    FieldStat.create = function create(properties) {\n        return new FieldStat(properties);\n    };\n\n    /**\n     * Encodes the specified FieldStat message. Does not implicitly {@link FieldStat.verify|verify} messages.\n     * @function encode\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat} message FieldStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FieldStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.returnType);\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.errorsCount);\n        if (message.count != null && message.hasOwnProperty(\"count\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.count);\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.requestsWithErrorsCount);\n        if (message.latencyCount != null && message.latencyCount.length) {\n            writer.uint32(/* id 8, wireType 2 =*/66).fork();\n            for (var i = 0; i < message.latencyCount.length; ++i)\n                writer.int64(message.latencyCount[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified FieldStat message, length delimited. Does not implicitly {@link FieldStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat} message FieldStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FieldStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FieldStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof FieldStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FieldStat} FieldStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FieldStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FieldStat();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 2:\n                message.name = reader.string();\n                break;\n            case 3:\n                message.returnType = reader.string();\n                break;\n            case 4:\n                message.errorsCount = reader.uint64();\n                break;\n            case 5:\n                message.count = reader.uint64();\n                break;\n            case 6:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            case 8:\n                if (!(message.latencyCount && message.latencyCount.length))\n                    message.latencyCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.latencyCount.push(reader.int64());\n                } else\n                    message.latencyCount.push(reader.int64());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a FieldStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof FieldStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {FieldStat} FieldStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FieldStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FieldStat message.\n     * @function verify\n     * @memberof FieldStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FieldStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            if (!$util.isString(message.name))\n                return \"name: string expected\";\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            if (!$util.isString(message.returnType))\n                return \"returnType: string expected\";\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))\n                return \"errorsCount: integer|Long expected\";\n        if (message.count != null && message.hasOwnProperty(\"count\"))\n            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                return \"count: integer|Long expected\";\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n            if (!Array.isArray(message.latencyCount))\n                return \"latencyCount: array expected\";\n            for (var i = 0; i < message.latencyCount.length; ++i)\n                if (!$util.isInteger(message.latencyCount[i]) && !(message.latencyCount[i] && $util.isInteger(message.latencyCount[i].low) && $util.isInteger(message.latencyCount[i].high)))\n                    return \"latencyCount: integer|Long[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a FieldStat message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof FieldStat\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {FieldStat} FieldStat\n     */\n    FieldStat.fromObject = function fromObject(object) {\n        if (object instanceof $root.FieldStat)\n            return object;\n        var message = new $root.FieldStat();\n        if (object.name != null)\n            message.name = String(object.name);\n        if (object.returnType != null)\n            message.returnType = String(object.returnType);\n        if (object.errorsCount != null)\n            if ($util.Long)\n                (message.errorsCount = $util.Long.fromValue(object.errorsCount)).unsigned = true;\n            else if (typeof object.errorsCount === \"string\")\n                message.errorsCount = parseInt(object.errorsCount, 10);\n            else if (typeof object.errorsCount === \"number\")\n                message.errorsCount = object.errorsCount;\n            else if (typeof object.errorsCount === \"object\")\n                message.errorsCount = new $util.LongBits(object.errorsCount.low >>> 0, object.errorsCount.high >>> 0).toNumber(true);\n        if (object.count != null)\n            if ($util.Long)\n                (message.count = $util.Long.fromValue(object.count)).unsigned = true;\n            else if (typeof object.count === \"string\")\n                message.count = parseInt(object.count, 10);\n            else if (typeof object.count === \"number\")\n                message.count = object.count;\n            else if (typeof object.count === \"object\")\n                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber(true);\n        if (object.requestsWithErrorsCount != null)\n            if ($util.Long)\n                (message.requestsWithErrorsCount = $util.Long.fromValue(object.requestsWithErrorsCount)).unsigned = true;\n            else if (typeof object.requestsWithErrorsCount === \"string\")\n                message.requestsWithErrorsCount = parseInt(object.requestsWithErrorsCount, 10);\n            else if (typeof object.requestsWithErrorsCount === \"number\")\n                message.requestsWithErrorsCount = object.requestsWithErrorsCount;\n            else if (typeof object.requestsWithErrorsCount === \"object\")\n                message.requestsWithErrorsCount = new $util.LongBits(object.requestsWithErrorsCount.low >>> 0, object.requestsWithErrorsCount.high >>> 0).toNumber(true);\n        if (object.latencyCount) {\n            if (!Array.isArray(object.latencyCount))\n                throw TypeError(\".FieldStat.latencyCount: array expected\");\n            message.latencyCount = [];\n            for (var i = 0; i < object.latencyCount.length; ++i)\n                if ($util.Long)\n                    (message.latencyCount[i] = $util.Long.fromValue(object.latencyCount[i])).unsigned = false;\n                else if (typeof object.latencyCount[i] === \"string\")\n                    message.latencyCount[i] = parseInt(object.latencyCount[i], 10);\n                else if (typeof object.latencyCount[i] === \"number\")\n                    message.latencyCount[i] = object.latencyCount[i];\n                else if (typeof object.latencyCount[i] === \"object\")\n                    message.latencyCount[i] = new $util.LongBits(object.latencyCount[i].low >>> 0, object.latencyCount[i].high >>> 0).toNumber();\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a FieldStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof FieldStat\n     * @static\n     * @param {FieldStat} message FieldStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FieldStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.latencyCount = [];\n        if (options.defaults) {\n            object.name = \"\";\n            object.returnType = \"\";\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.errorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.errorsCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.count = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n        }\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            object.returnType = message.returnType;\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (typeof message.errorsCount === \"number\")\n                object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;\n            else\n                object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n        if (message.count != null && message.hasOwnProperty(\"count\"))\n            if (typeof message.count === \"number\")\n                object.count = options.longs === String ? String(message.count) : message.count;\n            else\n                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        if (message.latencyCount && message.latencyCount.length) {\n            object.latencyCount = [];\n            for (var j = 0; j < message.latencyCount.length; ++j)\n                if (typeof message.latencyCount[j] === \"number\")\n                    object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];\n                else\n                    object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this FieldStat to JSON.\n     * @function toJSON\n     * @memberof FieldStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FieldStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return FieldStat;\n})();\n\n$root.TypeStat = (function() {\n\n    /**\n     * Properties of a TypeStat.\n     * @exports ITypeStat\n     * @interface ITypeStat\n     * @property {string|null} [name] TypeStat name\n     * @property {Array.<IFieldStat>|null} [field] TypeStat field\n     * @property {Object.<string,IFieldStat>|null} [perFieldStat] TypeStat perFieldStat\n     */\n\n    /**\n     * Constructs a new TypeStat.\n     * @exports TypeStat\n     * @classdesc Represents a TypeStat.\n     * @implements ITypeStat\n     * @constructor\n     * @param {ITypeStat=} [properties] Properties to set\n     */\n    function TypeStat(properties) {\n        this.field = [];\n        this.perFieldStat = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TypeStat name.\n     * @member {string} name\n     * @memberof TypeStat\n     * @instance\n     */\n    TypeStat.prototype.name = \"\";\n\n    /**\n     * TypeStat field.\n     * @member {Array.<IFieldStat>} field\n     * @memberof TypeStat\n     * @instance\n     */\n    TypeStat.prototype.field = $util.emptyArray;\n\n    /**\n     * TypeStat perFieldStat.\n     * @member {Object.<string,IFieldStat>} perFieldStat\n     * @memberof TypeStat\n     * @instance\n     */\n    TypeStat.prototype.perFieldStat = $util.emptyObject;\n\n    /**\n     * Creates a new TypeStat instance using the specified properties.\n     * @function create\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat=} [properties] Properties to set\n     * @returns {TypeStat} TypeStat instance\n     */\n    TypeStat.create = function create(properties) {\n        return new TypeStat(properties);\n    };\n\n    /**\n     * Encodes the specified TypeStat message. Does not implicitly {@link TypeStat.verify|verify} messages.\n     * @function encode\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat} message TypeStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n        if (message.field != null && message.field.length)\n            for (var i = 0; i < message.field.length; ++i)\n                $root.FieldStat.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.perFieldStat != null && message.hasOwnProperty(\"perFieldStat\"))\n            for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TypeStat message, length delimited. Does not implicitly {@link TypeStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat} message TypeStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TypeStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof TypeStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TypeStat} TypeStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.name = reader.string();\n                break;\n            case 2:\n                if (!(message.field && message.field.length))\n                    message.field = [];\n                message.field.push($root.FieldStat.decode(reader, reader.uint32()));\n                break;\n            case 3:\n                reader.skip().pos++;\n                if (message.perFieldStat === $util.emptyObject)\n                    message.perFieldStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TypeStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TypeStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TypeStat} TypeStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TypeStat message.\n     * @function verify\n     * @memberof TypeStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TypeStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            if (!$util.isString(message.name))\n                return \"name: string expected\";\n        if (message.field != null && message.hasOwnProperty(\"field\")) {\n            if (!Array.isArray(message.field))\n                return \"field: array expected\";\n            for (var i = 0; i < message.field.length; ++i) {\n                var error = $root.FieldStat.verify(message.field[i]);\n                if (error)\n                    return \"field.\" + error;\n            }\n        }\n        if (message.perFieldStat != null && message.hasOwnProperty(\"perFieldStat\")) {\n            if (!$util.isObject(message.perFieldStat))\n                return \"perFieldStat: object expected\";\n            var key = Object.keys(message.perFieldStat);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);\n                if (error)\n                    return \"perFieldStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a TypeStat message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TypeStat\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TypeStat} TypeStat\n     */\n    TypeStat.fromObject = function fromObject(object) {\n        if (object instanceof $root.TypeStat)\n            return object;\n        var message = new $root.TypeStat();\n        if (object.name != null)\n            message.name = String(object.name);\n        if (object.field) {\n            if (!Array.isArray(object.field))\n                throw TypeError(\".TypeStat.field: array expected\");\n            message.field = [];\n            for (var i = 0; i < object.field.length; ++i) {\n                if (typeof object.field[i] !== \"object\")\n                    throw TypeError(\".TypeStat.field: object expected\");\n                message.field[i] = $root.FieldStat.fromObject(object.field[i]);\n            }\n        }\n        if (object.perFieldStat) {\n            if (typeof object.perFieldStat !== \"object\")\n                throw TypeError(\".TypeStat.perFieldStat: object expected\");\n            message.perFieldStat = {};\n            for (var keys = Object.keys(object.perFieldStat), i = 0; i < keys.length; ++i) {\n                if (typeof object.perFieldStat[keys[i]] !== \"object\")\n                    throw TypeError(\".TypeStat.perFieldStat: object expected\");\n                message.perFieldStat[keys[i]] = $root.FieldStat.fromObject(object.perFieldStat[keys[i]]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TypeStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TypeStat\n     * @static\n     * @param {TypeStat} message TypeStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TypeStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.field = [];\n        if (options.objects || options.defaults)\n            object.perFieldStat = {};\n        if (options.defaults)\n            object.name = \"\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n        if (message.field && message.field.length) {\n            object.field = [];\n            for (var j = 0; j < message.field.length; ++j)\n                object.field[j] = $root.FieldStat.toObject(message.field[j], options);\n        }\n        var keys2;\n        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {\n            object.perFieldStat = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TypeStat to JSON.\n     * @function toJSON\n     * @memberof TypeStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TypeStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TypeStat;\n})();\n\n$root.QueryStats = (function() {\n\n    /**\n     * Properties of a QueryStats.\n     * @exports IQueryStats\n     * @interface IQueryStats\n     * @property {Object.<string,IClientNameStats>|null} [perClientName] QueryStats perClientName\n     * @property {Array.<ITypeStat>|null} [perType] QueryStats perType\n     * @property {Object.<string,ITypeStat>|null} [perTypeStat] QueryStats perTypeStat\n     */\n\n    /**\n     * Constructs a new QueryStats.\n     * @exports QueryStats\n     * @classdesc Represents a QueryStats.\n     * @implements IQueryStats\n     * @constructor\n     * @param {IQueryStats=} [properties] Properties to set\n     */\n    function QueryStats(properties) {\n        this.perClientName = {};\n        this.perType = [];\n        this.perTypeStat = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * QueryStats perClientName.\n     * @member {Object.<string,IClientNameStats>} perClientName\n     * @memberof QueryStats\n     * @instance\n     */\n    QueryStats.prototype.perClientName = $util.emptyObject;\n\n    /**\n     * QueryStats perType.\n     * @member {Array.<ITypeStat>} perType\n     * @memberof QueryStats\n     * @instance\n     */\n    QueryStats.prototype.perType = $util.emptyArray;\n\n    /**\n     * QueryStats perTypeStat.\n     * @member {Object.<string,ITypeStat>} perTypeStat\n     * @memberof QueryStats\n     * @instance\n     */\n    QueryStats.prototype.perTypeStat = $util.emptyObject;\n\n    /**\n     * Creates a new QueryStats instance using the specified properties.\n     * @function create\n     * @memberof QueryStats\n     * @static\n     * @param {IQueryStats=} [properties] Properties to set\n     * @returns {QueryStats} QueryStats instance\n     */\n    QueryStats.create = function create(properties) {\n        return new QueryStats(properties);\n    };\n\n    /**\n     * Encodes the specified QueryStats message. Does not implicitly {@link QueryStats.verify|verify} messages.\n     * @function encode\n     * @memberof QueryStats\n     * @static\n     * @param {IQueryStats} message QueryStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QueryStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.perClientName != null && message.hasOwnProperty(\"perClientName\"))\n            for (var keys = Object.keys(message.perClientName), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.ClientNameStats.encode(message.perClientName[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.perType != null && message.perType.length)\n            for (var i = 0; i < message.perType.length; ++i)\n                $root.TypeStat.encode(message.perType[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\"))\n            for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified QueryStats message, length delimited. Does not implicitly {@link QueryStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof QueryStats\n     * @static\n     * @param {IQueryStats} message QueryStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QueryStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a QueryStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof QueryStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {QueryStats} QueryStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QueryStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.QueryStats(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.perClientName === $util.emptyObject)\n                    message.perClientName = {};\n                key = reader.string();\n                reader.pos++;\n                message.perClientName[key] = $root.ClientNameStats.decode(reader, reader.uint32());\n                break;\n            case 2:\n                if (!(message.perType && message.perType.length))\n                    message.perType = [];\n                message.perType.push($root.TypeStat.decode(reader, reader.uint32()));\n                break;\n            case 3:\n                reader.skip().pos++;\n                if (message.perTypeStat === $util.emptyObject)\n                    message.perTypeStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a QueryStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof QueryStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {QueryStats} QueryStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QueryStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a QueryStats message.\n     * @function verify\n     * @memberof QueryStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    QueryStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.perClientName != null && message.hasOwnProperty(\"perClientName\")) {\n            if (!$util.isObject(message.perClientName))\n                return \"perClientName: object expected\";\n            var key = Object.keys(message.perClientName);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.ClientNameStats.verify(message.perClientName[key[i]]);\n                if (error)\n                    return \"perClientName.\" + error;\n            }\n        }\n        if (message.perType != null && message.hasOwnProperty(\"perType\")) {\n            if (!Array.isArray(message.perType))\n                return \"perType: array expected\";\n            for (var i = 0; i < message.perType.length; ++i) {\n                var error = $root.TypeStat.verify(message.perType[i]);\n                if (error)\n                    return \"perType.\" + error;\n            }\n        }\n        if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n            if (!$util.isObject(message.perTypeStat))\n                return \"perTypeStat: object expected\";\n            var key = Object.keys(message.perTypeStat);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n                if (error)\n                    return \"perTypeStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a QueryStats message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof QueryStats\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {QueryStats} QueryStats\n     */\n    QueryStats.fromObject = function fromObject(object) {\n        if (object instanceof $root.QueryStats)\n            return object;\n        var message = new $root.QueryStats();\n        if (object.perClientName) {\n            if (typeof object.perClientName !== \"object\")\n                throw TypeError(\".QueryStats.perClientName: object expected\");\n            message.perClientName = {};\n            for (var keys = Object.keys(object.perClientName), i = 0; i < keys.length; ++i) {\n                if (typeof object.perClientName[keys[i]] !== \"object\")\n                    throw TypeError(\".QueryStats.perClientName: object expected\");\n                message.perClientName[keys[i]] = $root.ClientNameStats.fromObject(object.perClientName[keys[i]]);\n            }\n        }\n        if (object.perType) {\n            if (!Array.isArray(object.perType))\n                throw TypeError(\".QueryStats.perType: array expected\");\n            message.perType = [];\n            for (var i = 0; i < object.perType.length; ++i) {\n                if (typeof object.perType[i] !== \"object\")\n                    throw TypeError(\".QueryStats.perType: object expected\");\n                message.perType[i] = $root.TypeStat.fromObject(object.perType[i]);\n            }\n        }\n        if (object.perTypeStat) {\n            if (typeof object.perTypeStat !== \"object\")\n                throw TypeError(\".QueryStats.perTypeStat: object expected\");\n            message.perTypeStat = {};\n            for (var keys = Object.keys(object.perTypeStat), i = 0; i < keys.length; ++i) {\n                if (typeof object.perTypeStat[keys[i]] !== \"object\")\n                    throw TypeError(\".QueryStats.perTypeStat: object expected\");\n                message.perTypeStat[keys[i]] = $root.TypeStat.fromObject(object.perTypeStat[keys[i]]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a QueryStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof QueryStats\n     * @static\n     * @param {QueryStats} message QueryStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    QueryStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.perType = [];\n        if (options.objects || options.defaults) {\n            object.perClientName = {};\n            object.perTypeStat = {};\n        }\n        var keys2;\n        if (message.perClientName && (keys2 = Object.keys(message.perClientName)).length) {\n            object.perClientName = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perClientName[keys2[j]] = $root.ClientNameStats.toObject(message.perClientName[keys2[j]], options);\n        }\n        if (message.perType && message.perType.length) {\n            object.perType = [];\n            for (var j = 0; j < message.perType.length; ++j)\n                object.perType[j] = $root.TypeStat.toObject(message.perType[j], options);\n        }\n        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n            object.perTypeStat = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this QueryStats to JSON.\n     * @function toJSON\n     * @memberof QueryStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    QueryStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return QueryStats;\n})();\n\n$root.TracesReport = (function() {\n\n    /**\n     * Properties of a TracesReport.\n     * @exports ITracesReport\n     * @interface ITracesReport\n     * @property {IReportHeader|null} [header] TracesReport header\n     * @property {Array.<ITrace>|null} [trace] TracesReport trace\n     */\n\n    /**\n     * Constructs a new TracesReport.\n     * @exports TracesReport\n     * @classdesc Represents a TracesReport.\n     * @implements ITracesReport\n     * @constructor\n     * @param {ITracesReport=} [properties] Properties to set\n     */\n    function TracesReport(properties) {\n        this.trace = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TracesReport header.\n     * @member {IReportHeader|null|undefined} header\n     * @memberof TracesReport\n     * @instance\n     */\n    TracesReport.prototype.header = null;\n\n    /**\n     * TracesReport trace.\n     * @member {Array.<ITrace>} trace\n     * @memberof TracesReport\n     * @instance\n     */\n    TracesReport.prototype.trace = $util.emptyArray;\n\n    /**\n     * Creates a new TracesReport instance using the specified properties.\n     * @function create\n     * @memberof TracesReport\n     * @static\n     * @param {ITracesReport=} [properties] Properties to set\n     * @returns {TracesReport} TracesReport instance\n     */\n    TracesReport.create = function create(properties) {\n        return new TracesReport(properties);\n    };\n\n    /**\n     * Encodes the specified TracesReport message. Does not implicitly {@link TracesReport.verify|verify} messages.\n     * @function encode\n     * @memberof TracesReport\n     * @static\n     * @param {ITracesReport} message TracesReport message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TracesReport.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            $root.ReportHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.trace != null && message.trace.length)\n            for (var i = 0; i < message.trace.length; ++i)\n                $root.Trace.encode(message.trace[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TracesReport message, length delimited. Does not implicitly {@link TracesReport.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TracesReport\n     * @static\n     * @param {ITracesReport} message TracesReport message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TracesReport.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TracesReport message from the specified reader or buffer.\n     * @function decode\n     * @memberof TracesReport\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TracesReport} TracesReport\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TracesReport.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TracesReport();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.header = $root.ReportHeader.decode(reader, reader.uint32());\n                break;\n            case 2:\n                if (!(message.trace && message.trace.length))\n                    message.trace = [];\n                message.trace.push($root.Trace.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TracesReport message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TracesReport\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TracesReport} TracesReport\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TracesReport.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TracesReport message.\n     * @function verify\n     * @memberof TracesReport\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TracesReport.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.ReportHeader.verify(message.header);\n            if (error)\n                return \"header.\" + error;\n        }\n        if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n            if (!Array.isArray(message.trace))\n                return \"trace: array expected\";\n            for (var i = 0; i < message.trace.length; ++i) {\n                var error = $root.Trace.verify(message.trace[i]);\n                if (error)\n                    return \"trace.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a TracesReport message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TracesReport\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TracesReport} TracesReport\n     */\n    TracesReport.fromObject = function fromObject(object) {\n        if (object instanceof $root.TracesReport)\n            return object;\n        var message = new $root.TracesReport();\n        if (object.header != null) {\n            if (typeof object.header !== \"object\")\n                throw TypeError(\".TracesReport.header: object expected\");\n            message.header = $root.ReportHeader.fromObject(object.header);\n        }\n        if (object.trace) {\n            if (!Array.isArray(object.trace))\n                throw TypeError(\".TracesReport.trace: array expected\");\n            message.trace = [];\n            for (var i = 0; i < object.trace.length; ++i) {\n                if (typeof object.trace[i] !== \"object\")\n                    throw TypeError(\".TracesReport.trace: object expected\");\n                message.trace[i] = $root.Trace.fromObject(object.trace[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TracesReport message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TracesReport\n     * @static\n     * @param {TracesReport} message TracesReport\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TracesReport.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.trace = [];\n        if (options.defaults)\n            object.header = null;\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            object.header = $root.ReportHeader.toObject(message.header, options);\n        if (message.trace && message.trace.length) {\n            object.trace = [];\n            for (var j = 0; j < message.trace.length; ++j)\n                object.trace[j] = $root.Trace.toObject(message.trace[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TracesReport to JSON.\n     * @function toJSON\n     * @memberof TracesReport\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TracesReport.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TracesReport;\n})();\n\n$root.Field = (function() {\n\n    /**\n     * Properties of a Field.\n     * @exports IField\n     * @interface IField\n     * @property {string|null} [name] Field name\n     * @property {string|null} [returnType] Field returnType\n     */\n\n    /**\n     * Constructs a new Field.\n     * @exports Field\n     * @classdesc Represents a Field.\n     * @implements IField\n     * @constructor\n     * @param {IField=} [properties] Properties to set\n     */\n    function Field(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Field name.\n     * @member {string} name\n     * @memberof Field\n     * @instance\n     */\n    Field.prototype.name = \"\";\n\n    /**\n     * Field returnType.\n     * @member {string} returnType\n     * @memberof Field\n     * @instance\n     */\n    Field.prototype.returnType = \"\";\n\n    /**\n     * Creates a new Field instance using the specified properties.\n     * @function create\n     * @memberof Field\n     * @static\n     * @param {IField=} [properties] Properties to set\n     * @returns {Field} Field instance\n     */\n    Field.create = function create(properties) {\n        return new Field(properties);\n    };\n\n    /**\n     * Encodes the specified Field message. Does not implicitly {@link Field.verify|verify} messages.\n     * @function encode\n     * @memberof Field\n     * @static\n     * @param {IField} message Field message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Field.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.returnType);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Field message, length delimited. Does not implicitly {@link Field.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Field\n     * @static\n     * @param {IField} message Field message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Field.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Field message from the specified reader or buffer.\n     * @function decode\n     * @memberof Field\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Field} Field\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Field.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Field();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 2:\n                message.name = reader.string();\n                break;\n            case 3:\n                message.returnType = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Field message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Field\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Field} Field\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Field.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Field message.\n     * @function verify\n     * @memberof Field\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Field.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            if (!$util.isString(message.name))\n                return \"name: string expected\";\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            if (!$util.isString(message.returnType))\n                return \"returnType: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a Field message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Field\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Field} Field\n     */\n    Field.fromObject = function fromObject(object) {\n        if (object instanceof $root.Field)\n            return object;\n        var message = new $root.Field();\n        if (object.name != null)\n            message.name = String(object.name);\n        if (object.returnType != null)\n            message.returnType = String(object.returnType);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Field message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Field\n     * @static\n     * @param {Field} message Field\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Field.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.name = \"\";\n            object.returnType = \"\";\n        }\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            object.returnType = message.returnType;\n        return object;\n    };\n\n    /**\n     * Converts this Field to JSON.\n     * @function toJSON\n     * @memberof Field\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Field.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Field;\n})();\n\n$root.Type = (function() {\n\n    /**\n     * Properties of a Type.\n     * @exports IType\n     * @interface IType\n     * @property {string|null} [name] Type name\n     * @property {Array.<IField>|null} [field] Type field\n     */\n\n    /**\n     * Constructs a new Type.\n     * @exports Type\n     * @classdesc Represents a Type.\n     * @implements IType\n     * @constructor\n     * @param {IType=} [properties] Properties to set\n     */\n    function Type(properties) {\n        this.field = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Type name.\n     * @member {string} name\n     * @memberof Type\n     * @instance\n     */\n    Type.prototype.name = \"\";\n\n    /**\n     * Type field.\n     * @member {Array.<IField>} field\n     * @memberof Type\n     * @instance\n     */\n    Type.prototype.field = $util.emptyArray;\n\n    /**\n     * Creates a new Type instance using the specified properties.\n     * @function create\n     * @memberof Type\n     * @static\n     * @param {IType=} [properties] Properties to set\n     * @returns {Type} Type instance\n     */\n    Type.create = function create(properties) {\n        return new Type(properties);\n    };\n\n    /**\n     * Encodes the specified Type message. Does not implicitly {@link Type.verify|verify} messages.\n     * @function encode\n     * @memberof Type\n     * @static\n     * @param {IType} message Type message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Type.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n        if (message.field != null && message.field.length)\n            for (var i = 0; i < message.field.length; ++i)\n                $root.Field.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Type message, length delimited. Does not implicitly {@link Type.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Type\n     * @static\n     * @param {IType} message Type message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Type.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Type message from the specified reader or buffer.\n     * @function decode\n     * @memberof Type\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Type} Type\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Type.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Type();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.name = reader.string();\n                break;\n            case 2:\n                if (!(message.field && message.field.length))\n                    message.field = [];\n                message.field.push($root.Field.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Type message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Type\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Type} Type\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Type.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Type message.\n     * @function verify\n     * @memberof Type\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Type.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            if (!$util.isString(message.name))\n                return \"name: string expected\";\n        if (message.field != null && message.hasOwnProperty(\"field\")) {\n            if (!Array.isArray(message.field))\n                return \"field: array expected\";\n            for (var i = 0; i < message.field.length; ++i) {\n                var error = $root.Field.verify(message.field[i]);\n                if (error)\n                    return \"field.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Type message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Type\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Type} Type\n     */\n    Type.fromObject = function fromObject(object) {\n        if (object instanceof $root.Type)\n            return object;\n        var message = new $root.Type();\n        if (object.name != null)\n            message.name = String(object.name);\n        if (object.field) {\n            if (!Array.isArray(object.field))\n                throw TypeError(\".Type.field: array expected\");\n            message.field = [];\n            for (var i = 0; i < object.field.length; ++i) {\n                if (typeof object.field[i] !== \"object\")\n                    throw TypeError(\".Type.field: object expected\");\n                message.field[i] = $root.Field.fromObject(object.field[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Type message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Type\n     * @static\n     * @param {Type} message Type\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Type.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.field = [];\n        if (options.defaults)\n            object.name = \"\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n        if (message.field && message.field.length) {\n            object.field = [];\n            for (var j = 0; j < message.field.length; ++j)\n                object.field[j] = $root.Field.toObject(message.field[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Type to JSON.\n     * @function toJSON\n     * @memberof Type\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Type.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Type;\n})();\n\n$root.MemStats = (function() {\n\n    /**\n     * Properties of a MemStats.\n     * @exports IMemStats\n     * @interface IMemStats\n     * @property {number|null} [totalBytes] MemStats totalBytes\n     * @property {number|null} [stackBytes] MemStats stackBytes\n     * @property {number|null} [heapBytes] MemStats heapBytes\n     * @property {number|null} [heapReleasedBytes] MemStats heapReleasedBytes\n     * @property {number|null} [gcOverheadBytes] MemStats gcOverheadBytes\n     * @property {number|null} [stackUsedBytes] MemStats stackUsedBytes\n     * @property {number|null} [heapAllocatedBytes] MemStats heapAllocatedBytes\n     * @property {number|null} [heapAllocatedObjects] MemStats heapAllocatedObjects\n     * @property {number|null} [heapAllocatedBytesDelta] MemStats heapAllocatedBytesDelta\n     * @property {number|null} [heapAllocatedObjectsDelta] MemStats heapAllocatedObjectsDelta\n     * @property {number|null} [heapFreedObjectsDelta] MemStats heapFreedObjectsDelta\n     * @property {number|null} [gcStwNsDelta] MemStats gcStwNsDelta\n     * @property {number|null} [gcCountDelta] MemStats gcCountDelta\n     */\n\n    /**\n     * Constructs a new MemStats.\n     * @exports MemStats\n     * @classdesc Represents a MemStats.\n     * @implements IMemStats\n     * @constructor\n     * @param {IMemStats=} [properties] Properties to set\n     */\n    function MemStats(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MemStats totalBytes.\n     * @member {number} totalBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.totalBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats stackBytes.\n     * @member {number} stackBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.stackBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapBytes.\n     * @member {number} heapBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapReleasedBytes.\n     * @member {number} heapReleasedBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapReleasedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats gcOverheadBytes.\n     * @member {number} gcOverheadBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.gcOverheadBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats stackUsedBytes.\n     * @member {number} stackUsedBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.stackUsedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapAllocatedBytes.\n     * @member {number} heapAllocatedBytes\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapAllocatedBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapAllocatedObjects.\n     * @member {number} heapAllocatedObjects\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapAllocatedObjects = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapAllocatedBytesDelta.\n     * @member {number} heapAllocatedBytesDelta\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapAllocatedBytesDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapAllocatedObjectsDelta.\n     * @member {number} heapAllocatedObjectsDelta\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapAllocatedObjectsDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats heapFreedObjectsDelta.\n     * @member {number} heapFreedObjectsDelta\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.heapFreedObjectsDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats gcStwNsDelta.\n     * @member {number} gcStwNsDelta\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.gcStwNsDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * MemStats gcCountDelta.\n     * @member {number} gcCountDelta\n     * @memberof MemStats\n     * @instance\n     */\n    MemStats.prototype.gcCountDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Creates a new MemStats instance using the specified properties.\n     * @function create\n     * @memberof MemStats\n     * @static\n     * @param {IMemStats=} [properties] Properties to set\n     * @returns {MemStats} MemStats instance\n     */\n    MemStats.create = function create(properties) {\n        return new MemStats(properties);\n    };\n\n    /**\n     * Encodes the specified MemStats message. Does not implicitly {@link MemStats.verify|verify} messages.\n     * @function encode\n     * @memberof MemStats\n     * @static\n     * @param {IMemStats} message MemStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MemStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.totalBytes != null && message.hasOwnProperty(\"totalBytes\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.totalBytes);\n        if (message.stackBytes != null && message.hasOwnProperty(\"stackBytes\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.stackBytes);\n        if (message.heapBytes != null && message.hasOwnProperty(\"heapBytes\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.heapBytes);\n        if (message.gcOverheadBytes != null && message.hasOwnProperty(\"gcOverheadBytes\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.gcOverheadBytes);\n        if (message.stackUsedBytes != null && message.hasOwnProperty(\"stackUsedBytes\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.stackUsedBytes);\n        if (message.heapAllocatedBytes != null && message.hasOwnProperty(\"heapAllocatedBytes\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.heapAllocatedBytes);\n        if (message.heapAllocatedObjects != null && message.hasOwnProperty(\"heapAllocatedObjects\"))\n            writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.heapAllocatedObjects);\n        if (message.heapAllocatedBytesDelta != null && message.hasOwnProperty(\"heapAllocatedBytesDelta\"))\n            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.heapAllocatedBytesDelta);\n        if (message.heapAllocatedObjectsDelta != null && message.hasOwnProperty(\"heapAllocatedObjectsDelta\"))\n            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.heapAllocatedObjectsDelta);\n        if (message.heapFreedObjectsDelta != null && message.hasOwnProperty(\"heapFreedObjectsDelta\"))\n            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.heapFreedObjectsDelta);\n        if (message.gcStwNsDelta != null && message.hasOwnProperty(\"gcStwNsDelta\"))\n            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.gcStwNsDelta);\n        if (message.gcCountDelta != null && message.hasOwnProperty(\"gcCountDelta\"))\n            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.gcCountDelta);\n        if (message.heapReleasedBytes != null && message.hasOwnProperty(\"heapReleasedBytes\"))\n            writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.heapReleasedBytes);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified MemStats message, length delimited. Does not implicitly {@link MemStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof MemStats\n     * @static\n     * @param {IMemStats} message MemStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MemStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MemStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof MemStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MemStats} MemStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MemStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MemStats();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.totalBytes = reader.uint64();\n                break;\n            case 2:\n                message.stackBytes = reader.uint64();\n                break;\n            case 3:\n                message.heapBytes = reader.uint64();\n                break;\n            case 13:\n                message.heapReleasedBytes = reader.uint64();\n                break;\n            case 4:\n                message.gcOverheadBytes = reader.uint64();\n                break;\n            case 5:\n                message.stackUsedBytes = reader.uint64();\n                break;\n            case 6:\n                message.heapAllocatedBytes = reader.uint64();\n                break;\n            case 7:\n                message.heapAllocatedObjects = reader.uint64();\n                break;\n            case 8:\n                message.heapAllocatedBytesDelta = reader.uint64();\n                break;\n            case 9:\n                message.heapAllocatedObjectsDelta = reader.uint64();\n                break;\n            case 10:\n                message.heapFreedObjectsDelta = reader.uint64();\n                break;\n            case 11:\n                message.gcStwNsDelta = reader.uint64();\n                break;\n            case 12:\n                message.gcCountDelta = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a MemStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof MemStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {MemStats} MemStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MemStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MemStats message.\n     * @function verify\n     * @memberof MemStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MemStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.totalBytes != null && message.hasOwnProperty(\"totalBytes\"))\n            if (!$util.isInteger(message.totalBytes) && !(message.totalBytes && $util.isInteger(message.totalBytes.low) && $util.isInteger(message.totalBytes.high)))\n                return \"totalBytes: integer|Long expected\";\n        if (message.stackBytes != null && message.hasOwnProperty(\"stackBytes\"))\n            if (!$util.isInteger(message.stackBytes) && !(message.stackBytes && $util.isInteger(message.stackBytes.low) && $util.isInteger(message.stackBytes.high)))\n                return \"stackBytes: integer|Long expected\";\n        if (message.heapBytes != null && message.hasOwnProperty(\"heapBytes\"))\n            if (!$util.isInteger(message.heapBytes) && !(message.heapBytes && $util.isInteger(message.heapBytes.low) && $util.isInteger(message.heapBytes.high)))\n                return \"heapBytes: integer|Long expected\";\n        if (message.heapReleasedBytes != null && message.hasOwnProperty(\"heapReleasedBytes\"))\n            if (!$util.isInteger(message.heapReleasedBytes) && !(message.heapReleasedBytes && $util.isInteger(message.heapReleasedBytes.low) && $util.isInteger(message.heapReleasedBytes.high)))\n                return \"heapReleasedBytes: integer|Long expected\";\n        if (message.gcOverheadBytes != null && message.hasOwnProperty(\"gcOverheadBytes\"))\n            if (!$util.isInteger(message.gcOverheadBytes) && !(message.gcOverheadBytes && $util.isInteger(message.gcOverheadBytes.low) && $util.isInteger(message.gcOverheadBytes.high)))\n                return \"gcOverheadBytes: integer|Long expected\";\n        if (message.stackUsedBytes != null && message.hasOwnProperty(\"stackUsedBytes\"))\n            if (!$util.isInteger(message.stackUsedBytes) && !(message.stackUsedBytes && $util.isInteger(message.stackUsedBytes.low) && $util.isInteger(message.stackUsedBytes.high)))\n                return \"stackUsedBytes: integer|Long expected\";\n        if (message.heapAllocatedBytes != null && message.hasOwnProperty(\"heapAllocatedBytes\"))\n            if (!$util.isInteger(message.heapAllocatedBytes) && !(message.heapAllocatedBytes && $util.isInteger(message.heapAllocatedBytes.low) && $util.isInteger(message.heapAllocatedBytes.high)))\n                return \"heapAllocatedBytes: integer|Long expected\";\n        if (message.heapAllocatedObjects != null && message.hasOwnProperty(\"heapAllocatedObjects\"))\n            if (!$util.isInteger(message.heapAllocatedObjects) && !(message.heapAllocatedObjects && $util.isInteger(message.heapAllocatedObjects.low) && $util.isInteger(message.heapAllocatedObjects.high)))\n                return \"heapAllocatedObjects: integer|Long expected\";\n        if (message.heapAllocatedBytesDelta != null && message.hasOwnProperty(\"heapAllocatedBytesDelta\"))\n            if (!$util.isInteger(message.heapAllocatedBytesDelta) && !(message.heapAllocatedBytesDelta && $util.isInteger(message.heapAllocatedBytesDelta.low) && $util.isInteger(message.heapAllocatedBytesDelta.high)))\n                return \"heapAllocatedBytesDelta: integer|Long expected\";\n        if (message.heapAllocatedObjectsDelta != null && message.hasOwnProperty(\"heapAllocatedObjectsDelta\"))\n            if (!$util.isInteger(message.heapAllocatedObjectsDelta) && !(message.heapAllocatedObjectsDelta && $util.isInteger(message.heapAllocatedObjectsDelta.low) && $util.isInteger(message.heapAllocatedObjectsDelta.high)))\n                return \"heapAllocatedObjectsDelta: integer|Long expected\";\n        if (message.heapFreedObjectsDelta != null && message.hasOwnProperty(\"heapFreedObjectsDelta\"))\n            if (!$util.isInteger(message.heapFreedObjectsDelta) && !(message.heapFreedObjectsDelta && $util.isInteger(message.heapFreedObjectsDelta.low) && $util.isInteger(message.heapFreedObjectsDelta.high)))\n                return \"heapFreedObjectsDelta: integer|Long expected\";\n        if (message.gcStwNsDelta != null && message.hasOwnProperty(\"gcStwNsDelta\"))\n            if (!$util.isInteger(message.gcStwNsDelta) && !(message.gcStwNsDelta && $util.isInteger(message.gcStwNsDelta.low) && $util.isInteger(message.gcStwNsDelta.high)))\n                return \"gcStwNsDelta: integer|Long expected\";\n        if (message.gcCountDelta != null && message.hasOwnProperty(\"gcCountDelta\"))\n            if (!$util.isInteger(message.gcCountDelta) && !(message.gcCountDelta && $util.isInteger(message.gcCountDelta.low) && $util.isInteger(message.gcCountDelta.high)))\n                return \"gcCountDelta: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a MemStats message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof MemStats\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {MemStats} MemStats\n     */\n    MemStats.fromObject = function fromObject(object) {\n        if (object instanceof $root.MemStats)\n            return object;\n        var message = new $root.MemStats();\n        if (object.totalBytes != null)\n            if ($util.Long)\n                (message.totalBytes = $util.Long.fromValue(object.totalBytes)).unsigned = true;\n            else if (typeof object.totalBytes === \"string\")\n                message.totalBytes = parseInt(object.totalBytes, 10);\n            else if (typeof object.totalBytes === \"number\")\n                message.totalBytes = object.totalBytes;\n            else if (typeof object.totalBytes === \"object\")\n                message.totalBytes = new $util.LongBits(object.totalBytes.low >>> 0, object.totalBytes.high >>> 0).toNumber(true);\n        if (object.stackBytes != null)\n            if ($util.Long)\n                (message.stackBytes = $util.Long.fromValue(object.stackBytes)).unsigned = true;\n            else if (typeof object.stackBytes === \"string\")\n                message.stackBytes = parseInt(object.stackBytes, 10);\n            else if (typeof object.stackBytes === \"number\")\n                message.stackBytes = object.stackBytes;\n            else if (typeof object.stackBytes === \"object\")\n                message.stackBytes = new $util.LongBits(object.stackBytes.low >>> 0, object.stackBytes.high >>> 0).toNumber(true);\n        if (object.heapBytes != null)\n            if ($util.Long)\n                (message.heapBytes = $util.Long.fromValue(object.heapBytes)).unsigned = true;\n            else if (typeof object.heapBytes === \"string\")\n                message.heapBytes = parseInt(object.heapBytes, 10);\n            else if (typeof object.heapBytes === \"number\")\n                message.heapBytes = object.heapBytes;\n            else if (typeof object.heapBytes === \"object\")\n                message.heapBytes = new $util.LongBits(object.heapBytes.low >>> 0, object.heapBytes.high >>> 0).toNumber(true);\n        if (object.heapReleasedBytes != null)\n            if ($util.Long)\n                (message.heapReleasedBytes = $util.Long.fromValue(object.heapReleasedBytes)).unsigned = true;\n            else if (typeof object.heapReleasedBytes === \"string\")\n                message.heapReleasedBytes = parseInt(object.heapReleasedBytes, 10);\n            else if (typeof object.heapReleasedBytes === \"number\")\n                message.heapReleasedBytes = object.heapReleasedBytes;\n            else if (typeof object.heapReleasedBytes === \"object\")\n                message.heapReleasedBytes = new $util.LongBits(object.heapReleasedBytes.low >>> 0, object.heapReleasedBytes.high >>> 0).toNumber(true);\n        if (object.gcOverheadBytes != null)\n            if ($util.Long)\n                (message.gcOverheadBytes = $util.Long.fromValue(object.gcOverheadBytes)).unsigned = true;\n            else if (typeof object.gcOverheadBytes === \"string\")\n                message.gcOverheadBytes = parseInt(object.gcOverheadBytes, 10);\n            else if (typeof object.gcOverheadBytes === \"number\")\n                message.gcOverheadBytes = object.gcOverheadBytes;\n            else if (typeof object.gcOverheadBytes === \"object\")\n                message.gcOverheadBytes = new $util.LongBits(object.gcOverheadBytes.low >>> 0, object.gcOverheadBytes.high >>> 0).toNumber(true);\n        if (object.stackUsedBytes != null)\n            if ($util.Long)\n                (message.stackUsedBytes = $util.Long.fromValue(object.stackUsedBytes)).unsigned = true;\n            else if (typeof object.stackUsedBytes === \"string\")\n                message.stackUsedBytes = parseInt(object.stackUsedBytes, 10);\n            else if (typeof object.stackUsedBytes === \"number\")\n                message.stackUsedBytes = object.stackUsedBytes;\n            else if (typeof object.stackUsedBytes === \"object\")\n                message.stackUsedBytes = new $util.LongBits(object.stackUsedBytes.low >>> 0, object.stackUsedBytes.high >>> 0).toNumber(true);\n        if (object.heapAllocatedBytes != null)\n            if ($util.Long)\n                (message.heapAllocatedBytes = $util.Long.fromValue(object.heapAllocatedBytes)).unsigned = true;\n            else if (typeof object.heapAllocatedBytes === \"string\")\n                message.heapAllocatedBytes = parseInt(object.heapAllocatedBytes, 10);\n            else if (typeof object.heapAllocatedBytes === \"number\")\n                message.heapAllocatedBytes = object.heapAllocatedBytes;\n            else if (typeof object.heapAllocatedBytes === \"object\")\n                message.heapAllocatedBytes = new $util.LongBits(object.heapAllocatedBytes.low >>> 0, object.heapAllocatedBytes.high >>> 0).toNumber(true);\n        if (object.heapAllocatedObjects != null)\n            if ($util.Long)\n                (message.heapAllocatedObjects = $util.Long.fromValue(object.heapAllocatedObjects)).unsigned = true;\n            else if (typeof object.heapAllocatedObjects === \"string\")\n                message.heapAllocatedObjects = parseInt(object.heapAllocatedObjects, 10);\n            else if (typeof object.heapAllocatedObjects === \"number\")\n                message.heapAllocatedObjects = object.heapAllocatedObjects;\n            else if (typeof object.heapAllocatedObjects === \"object\")\n                message.heapAllocatedObjects = new $util.LongBits(object.heapAllocatedObjects.low >>> 0, object.heapAllocatedObjects.high >>> 0).toNumber(true);\n        if (object.heapAllocatedBytesDelta != null)\n            if ($util.Long)\n                (message.heapAllocatedBytesDelta = $util.Long.fromValue(object.heapAllocatedBytesDelta)).unsigned = true;\n            else if (typeof object.heapAllocatedBytesDelta === \"string\")\n                message.heapAllocatedBytesDelta = parseInt(object.heapAllocatedBytesDelta, 10);\n            else if (typeof object.heapAllocatedBytesDelta === \"number\")\n                message.heapAllocatedBytesDelta = object.heapAllocatedBytesDelta;\n            else if (typeof object.heapAllocatedBytesDelta === \"object\")\n                message.heapAllocatedBytesDelta = new $util.LongBits(object.heapAllocatedBytesDelta.low >>> 0, object.heapAllocatedBytesDelta.high >>> 0).toNumber(true);\n        if (object.heapAllocatedObjectsDelta != null)\n            if ($util.Long)\n                (message.heapAllocatedObjectsDelta = $util.Long.fromValue(object.heapAllocatedObjectsDelta)).unsigned = true;\n            else if (typeof object.heapAllocatedObjectsDelta === \"string\")\n                message.heapAllocatedObjectsDelta = parseInt(object.heapAllocatedObjectsDelta, 10);\n            else if (typeof object.heapAllocatedObjectsDelta === \"number\")\n                message.heapAllocatedObjectsDelta = object.heapAllocatedObjectsDelta;\n            else if (typeof object.heapAllocatedObjectsDelta === \"object\")\n                message.heapAllocatedObjectsDelta = new $util.LongBits(object.heapAllocatedObjectsDelta.low >>> 0, object.heapAllocatedObjectsDelta.high >>> 0).toNumber(true);\n        if (object.heapFreedObjectsDelta != null)\n            if ($util.Long)\n                (message.heapFreedObjectsDelta = $util.Long.fromValue(object.heapFreedObjectsDelta)).unsigned = true;\n            else if (typeof object.heapFreedObjectsDelta === \"string\")\n                message.heapFreedObjectsDelta = parseInt(object.heapFreedObjectsDelta, 10);\n            else if (typeof object.heapFreedObjectsDelta === \"number\")\n                message.heapFreedObjectsDelta = object.heapFreedObjectsDelta;\n            else if (typeof object.heapFreedObjectsDelta === \"object\")\n                message.heapFreedObjectsDelta = new $util.LongBits(object.heapFreedObjectsDelta.low >>> 0, object.heapFreedObjectsDelta.high >>> 0).toNumber(true);\n        if (object.gcStwNsDelta != null)\n            if ($util.Long)\n                (message.gcStwNsDelta = $util.Long.fromValue(object.gcStwNsDelta)).unsigned = true;\n            else if (typeof object.gcStwNsDelta === \"string\")\n                message.gcStwNsDelta = parseInt(object.gcStwNsDelta, 10);\n            else if (typeof object.gcStwNsDelta === \"number\")\n                message.gcStwNsDelta = object.gcStwNsDelta;\n            else if (typeof object.gcStwNsDelta === \"object\")\n                message.gcStwNsDelta = new $util.LongBits(object.gcStwNsDelta.low >>> 0, object.gcStwNsDelta.high >>> 0).toNumber(true);\n        if (object.gcCountDelta != null)\n            if ($util.Long)\n                (message.gcCountDelta = $util.Long.fromValue(object.gcCountDelta)).unsigned = true;\n            else if (typeof object.gcCountDelta === \"string\")\n                message.gcCountDelta = parseInt(object.gcCountDelta, 10);\n            else if (typeof object.gcCountDelta === \"number\")\n                message.gcCountDelta = object.gcCountDelta;\n            else if (typeof object.gcCountDelta === \"object\")\n                message.gcCountDelta = new $util.LongBits(object.gcCountDelta.low >>> 0, object.gcCountDelta.high >>> 0).toNumber(true);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a MemStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof MemStats\n     * @static\n     * @param {MemStats} message MemStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MemStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.totalBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.totalBytes = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.stackBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.stackBytes = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapBytes = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.gcOverheadBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.gcOverheadBytes = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.stackUsedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.stackUsedBytes = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapAllocatedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapAllocatedBytes = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapAllocatedObjects = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapAllocatedObjects = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapAllocatedBytesDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapAllocatedBytesDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapAllocatedObjectsDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapAllocatedObjectsDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapFreedObjectsDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapFreedObjectsDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.gcStwNsDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.gcStwNsDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.gcCountDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.gcCountDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.heapReleasedBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.heapReleasedBytes = options.longs === String ? \"0\" : 0;\n        }\n        if (message.totalBytes != null && message.hasOwnProperty(\"totalBytes\"))\n            if (typeof message.totalBytes === \"number\")\n                object.totalBytes = options.longs === String ? String(message.totalBytes) : message.totalBytes;\n            else\n                object.totalBytes = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytes) : options.longs === Number ? new $util.LongBits(message.totalBytes.low >>> 0, message.totalBytes.high >>> 0).toNumber(true) : message.totalBytes;\n        if (message.stackBytes != null && message.hasOwnProperty(\"stackBytes\"))\n            if (typeof message.stackBytes === \"number\")\n                object.stackBytes = options.longs === String ? String(message.stackBytes) : message.stackBytes;\n            else\n                object.stackBytes = options.longs === String ? $util.Long.prototype.toString.call(message.stackBytes) : options.longs === Number ? new $util.LongBits(message.stackBytes.low >>> 0, message.stackBytes.high >>> 0).toNumber(true) : message.stackBytes;\n        if (message.heapBytes != null && message.hasOwnProperty(\"heapBytes\"))\n            if (typeof message.heapBytes === \"number\")\n                object.heapBytes = options.longs === String ? String(message.heapBytes) : message.heapBytes;\n            else\n                object.heapBytes = options.longs === String ? $util.Long.prototype.toString.call(message.heapBytes) : options.longs === Number ? new $util.LongBits(message.heapBytes.low >>> 0, message.heapBytes.high >>> 0).toNumber(true) : message.heapBytes;\n        if (message.gcOverheadBytes != null && message.hasOwnProperty(\"gcOverheadBytes\"))\n            if (typeof message.gcOverheadBytes === \"number\")\n                object.gcOverheadBytes = options.longs === String ? String(message.gcOverheadBytes) : message.gcOverheadBytes;\n            else\n                object.gcOverheadBytes = options.longs === String ? $util.Long.prototype.toString.call(message.gcOverheadBytes) : options.longs === Number ? new $util.LongBits(message.gcOverheadBytes.low >>> 0, message.gcOverheadBytes.high >>> 0).toNumber(true) : message.gcOverheadBytes;\n        if (message.stackUsedBytes != null && message.hasOwnProperty(\"stackUsedBytes\"))\n            if (typeof message.stackUsedBytes === \"number\")\n                object.stackUsedBytes = options.longs === String ? String(message.stackUsedBytes) : message.stackUsedBytes;\n            else\n                object.stackUsedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.stackUsedBytes) : options.longs === Number ? new $util.LongBits(message.stackUsedBytes.low >>> 0, message.stackUsedBytes.high >>> 0).toNumber(true) : message.stackUsedBytes;\n        if (message.heapAllocatedBytes != null && message.hasOwnProperty(\"heapAllocatedBytes\"))\n            if (typeof message.heapAllocatedBytes === \"number\")\n                object.heapAllocatedBytes = options.longs === String ? String(message.heapAllocatedBytes) : message.heapAllocatedBytes;\n            else\n                object.heapAllocatedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.heapAllocatedBytes) : options.longs === Number ? new $util.LongBits(message.heapAllocatedBytes.low >>> 0, message.heapAllocatedBytes.high >>> 0).toNumber(true) : message.heapAllocatedBytes;\n        if (message.heapAllocatedObjects != null && message.hasOwnProperty(\"heapAllocatedObjects\"))\n            if (typeof message.heapAllocatedObjects === \"number\")\n                object.heapAllocatedObjects = options.longs === String ? String(message.heapAllocatedObjects) : message.heapAllocatedObjects;\n            else\n                object.heapAllocatedObjects = options.longs === String ? $util.Long.prototype.toString.call(message.heapAllocatedObjects) : options.longs === Number ? new $util.LongBits(message.heapAllocatedObjects.low >>> 0, message.heapAllocatedObjects.high >>> 0).toNumber(true) : message.heapAllocatedObjects;\n        if (message.heapAllocatedBytesDelta != null && message.hasOwnProperty(\"heapAllocatedBytesDelta\"))\n            if (typeof message.heapAllocatedBytesDelta === \"number\")\n                object.heapAllocatedBytesDelta = options.longs === String ? String(message.heapAllocatedBytesDelta) : message.heapAllocatedBytesDelta;\n            else\n                object.heapAllocatedBytesDelta = options.longs === String ? $util.Long.prototype.toString.call(message.heapAllocatedBytesDelta) : options.longs === Number ? new $util.LongBits(message.heapAllocatedBytesDelta.low >>> 0, message.heapAllocatedBytesDelta.high >>> 0).toNumber(true) : message.heapAllocatedBytesDelta;\n        if (message.heapAllocatedObjectsDelta != null && message.hasOwnProperty(\"heapAllocatedObjectsDelta\"))\n            if (typeof message.heapAllocatedObjectsDelta === \"number\")\n                object.heapAllocatedObjectsDelta = options.longs === String ? String(message.heapAllocatedObjectsDelta) : message.heapAllocatedObjectsDelta;\n            else\n                object.heapAllocatedObjectsDelta = options.longs === String ? $util.Long.prototype.toString.call(message.heapAllocatedObjectsDelta) : options.longs === Number ? new $util.LongBits(message.heapAllocatedObjectsDelta.low >>> 0, message.heapAllocatedObjectsDelta.high >>> 0).toNumber(true) : message.heapAllocatedObjectsDelta;\n        if (message.heapFreedObjectsDelta != null && message.hasOwnProperty(\"heapFreedObjectsDelta\"))\n            if (typeof message.heapFreedObjectsDelta === \"number\")\n                object.heapFreedObjectsDelta = options.longs === String ? String(message.heapFreedObjectsDelta) : message.heapFreedObjectsDelta;\n            else\n                object.heapFreedObjectsDelta = options.longs === String ? $util.Long.prototype.toString.call(message.heapFreedObjectsDelta) : options.longs === Number ? new $util.LongBits(message.heapFreedObjectsDelta.low >>> 0, message.heapFreedObjectsDelta.high >>> 0).toNumber(true) : message.heapFreedObjectsDelta;\n        if (message.gcStwNsDelta != null && message.hasOwnProperty(\"gcStwNsDelta\"))\n            if (typeof message.gcStwNsDelta === \"number\")\n                object.gcStwNsDelta = options.longs === String ? String(message.gcStwNsDelta) : message.gcStwNsDelta;\n            else\n                object.gcStwNsDelta = options.longs === String ? $util.Long.prototype.toString.call(message.gcStwNsDelta) : options.longs === Number ? new $util.LongBits(message.gcStwNsDelta.low >>> 0, message.gcStwNsDelta.high >>> 0).toNumber(true) : message.gcStwNsDelta;\n        if (message.gcCountDelta != null && message.hasOwnProperty(\"gcCountDelta\"))\n            if (typeof message.gcCountDelta === \"number\")\n                object.gcCountDelta = options.longs === String ? String(message.gcCountDelta) : message.gcCountDelta;\n            else\n                object.gcCountDelta = options.longs === String ? $util.Long.prototype.toString.call(message.gcCountDelta) : options.longs === Number ? new $util.LongBits(message.gcCountDelta.low >>> 0, message.gcCountDelta.high >>> 0).toNumber(true) : message.gcCountDelta;\n        if (message.heapReleasedBytes != null && message.hasOwnProperty(\"heapReleasedBytes\"))\n            if (typeof message.heapReleasedBytes === \"number\")\n                object.heapReleasedBytes = options.longs === String ? String(message.heapReleasedBytes) : message.heapReleasedBytes;\n            else\n                object.heapReleasedBytes = options.longs === String ? $util.Long.prototype.toString.call(message.heapReleasedBytes) : options.longs === Number ? new $util.LongBits(message.heapReleasedBytes.low >>> 0, message.heapReleasedBytes.high >>> 0).toNumber(true) : message.heapReleasedBytes;\n        return object;\n    };\n\n    /**\n     * Converts this MemStats to JSON.\n     * @function toJSON\n     * @memberof MemStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MemStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MemStats;\n})();\n\n$root.TimeStats = (function() {\n\n    /**\n     * Properties of a TimeStats.\n     * @exports ITimeStats\n     * @interface ITimeStats\n     * @property {number|null} [uptimeNs] TimeStats uptimeNs\n     * @property {number|null} [realNsDelta] TimeStats realNsDelta\n     * @property {number|null} [userNsDelta] TimeStats userNsDelta\n     * @property {number|null} [sysNsDelta] TimeStats sysNsDelta\n     */\n\n    /**\n     * Constructs a new TimeStats.\n     * @exports TimeStats\n     * @classdesc Represents a TimeStats.\n     * @implements ITimeStats\n     * @constructor\n     * @param {ITimeStats=} [properties] Properties to set\n     */\n    function TimeStats(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TimeStats uptimeNs.\n     * @member {number} uptimeNs\n     * @memberof TimeStats\n     * @instance\n     */\n    TimeStats.prototype.uptimeNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * TimeStats realNsDelta.\n     * @member {number} realNsDelta\n     * @memberof TimeStats\n     * @instance\n     */\n    TimeStats.prototype.realNsDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * TimeStats userNsDelta.\n     * @member {number} userNsDelta\n     * @memberof TimeStats\n     * @instance\n     */\n    TimeStats.prototype.userNsDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * TimeStats sysNsDelta.\n     * @member {number} sysNsDelta\n     * @memberof TimeStats\n     * @instance\n     */\n    TimeStats.prototype.sysNsDelta = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Creates a new TimeStats instance using the specified properties.\n     * @function create\n     * @memberof TimeStats\n     * @static\n     * @param {ITimeStats=} [properties] Properties to set\n     * @returns {TimeStats} TimeStats instance\n     */\n    TimeStats.create = function create(properties) {\n        return new TimeStats(properties);\n    };\n\n    /**\n     * Encodes the specified TimeStats message. Does not implicitly {@link TimeStats.verify|verify} messages.\n     * @function encode\n     * @memberof TimeStats\n     * @static\n     * @param {ITimeStats} message TimeStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TimeStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.uptimeNs != null && message.hasOwnProperty(\"uptimeNs\"))\n            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uptimeNs);\n        if (message.realNsDelta != null && message.hasOwnProperty(\"realNsDelta\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.realNsDelta);\n        if (message.userNsDelta != null && message.hasOwnProperty(\"userNsDelta\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.userNsDelta);\n        if (message.sysNsDelta != null && message.hasOwnProperty(\"sysNsDelta\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.sysNsDelta);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TimeStats message, length delimited. Does not implicitly {@link TimeStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TimeStats\n     * @static\n     * @param {ITimeStats} message TimeStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TimeStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TimeStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof TimeStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TimeStats} TimeStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TimeStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TimeStats();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.uptimeNs = reader.uint64();\n                break;\n            case 2:\n                message.realNsDelta = reader.uint64();\n                break;\n            case 3:\n                message.userNsDelta = reader.uint64();\n                break;\n            case 4:\n                message.sysNsDelta = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TimeStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TimeStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TimeStats} TimeStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TimeStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TimeStats message.\n     * @function verify\n     * @memberof TimeStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TimeStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.uptimeNs != null && message.hasOwnProperty(\"uptimeNs\"))\n            if (!$util.isInteger(message.uptimeNs) && !(message.uptimeNs && $util.isInteger(message.uptimeNs.low) && $util.isInteger(message.uptimeNs.high)))\n                return \"uptimeNs: integer|Long expected\";\n        if (message.realNsDelta != null && message.hasOwnProperty(\"realNsDelta\"))\n            if (!$util.isInteger(message.realNsDelta) && !(message.realNsDelta && $util.isInteger(message.realNsDelta.low) && $util.isInteger(message.realNsDelta.high)))\n                return \"realNsDelta: integer|Long expected\";\n        if (message.userNsDelta != null && message.hasOwnProperty(\"userNsDelta\"))\n            if (!$util.isInteger(message.userNsDelta) && !(message.userNsDelta && $util.isInteger(message.userNsDelta.low) && $util.isInteger(message.userNsDelta.high)))\n                return \"userNsDelta: integer|Long expected\";\n        if (message.sysNsDelta != null && message.hasOwnProperty(\"sysNsDelta\"))\n            if (!$util.isInteger(message.sysNsDelta) && !(message.sysNsDelta && $util.isInteger(message.sysNsDelta.low) && $util.isInteger(message.sysNsDelta.high)))\n                return \"sysNsDelta: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a TimeStats message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof TimeStats\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {TimeStats} TimeStats\n     */\n    TimeStats.fromObject = function fromObject(object) {\n        if (object instanceof $root.TimeStats)\n            return object;\n        var message = new $root.TimeStats();\n        if (object.uptimeNs != null)\n            if ($util.Long)\n                (message.uptimeNs = $util.Long.fromValue(object.uptimeNs)).unsigned = true;\n            else if (typeof object.uptimeNs === \"string\")\n                message.uptimeNs = parseInt(object.uptimeNs, 10);\n            else if (typeof object.uptimeNs === \"number\")\n                message.uptimeNs = object.uptimeNs;\n            else if (typeof object.uptimeNs === \"object\")\n                message.uptimeNs = new $util.LongBits(object.uptimeNs.low >>> 0, object.uptimeNs.high >>> 0).toNumber(true);\n        if (object.realNsDelta != null)\n            if ($util.Long)\n                (message.realNsDelta = $util.Long.fromValue(object.realNsDelta)).unsigned = true;\n            else if (typeof object.realNsDelta === \"string\")\n                message.realNsDelta = parseInt(object.realNsDelta, 10);\n            else if (typeof object.realNsDelta === \"number\")\n                message.realNsDelta = object.realNsDelta;\n            else if (typeof object.realNsDelta === \"object\")\n                message.realNsDelta = new $util.LongBits(object.realNsDelta.low >>> 0, object.realNsDelta.high >>> 0).toNumber(true);\n        if (object.userNsDelta != null)\n            if ($util.Long)\n                (message.userNsDelta = $util.Long.fromValue(object.userNsDelta)).unsigned = true;\n            else if (typeof object.userNsDelta === \"string\")\n                message.userNsDelta = parseInt(object.userNsDelta, 10);\n            else if (typeof object.userNsDelta === \"number\")\n                message.userNsDelta = object.userNsDelta;\n            else if (typeof object.userNsDelta === \"object\")\n                message.userNsDelta = new $util.LongBits(object.userNsDelta.low >>> 0, object.userNsDelta.high >>> 0).toNumber(true);\n        if (object.sysNsDelta != null)\n            if ($util.Long)\n                (message.sysNsDelta = $util.Long.fromValue(object.sysNsDelta)).unsigned = true;\n            else if (typeof object.sysNsDelta === \"string\")\n                message.sysNsDelta = parseInt(object.sysNsDelta, 10);\n            else if (typeof object.sysNsDelta === \"number\")\n                message.sysNsDelta = object.sysNsDelta;\n            else if (typeof object.sysNsDelta === \"object\")\n                message.sysNsDelta = new $util.LongBits(object.sysNsDelta.low >>> 0, object.sysNsDelta.high >>> 0).toNumber(true);\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a TimeStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TimeStats\n     * @static\n     * @param {TimeStats} message TimeStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TimeStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.uptimeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.uptimeNs = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.realNsDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.realNsDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.userNsDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.userNsDelta = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.sysNsDelta = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.sysNsDelta = options.longs === String ? \"0\" : 0;\n        }\n        if (message.uptimeNs != null && message.hasOwnProperty(\"uptimeNs\"))\n            if (typeof message.uptimeNs === \"number\")\n                object.uptimeNs = options.longs === String ? String(message.uptimeNs) : message.uptimeNs;\n            else\n                object.uptimeNs = options.longs === String ? $util.Long.prototype.toString.call(message.uptimeNs) : options.longs === Number ? new $util.LongBits(message.uptimeNs.low >>> 0, message.uptimeNs.high >>> 0).toNumber(true) : message.uptimeNs;\n        if (message.realNsDelta != null && message.hasOwnProperty(\"realNsDelta\"))\n            if (typeof message.realNsDelta === \"number\")\n                object.realNsDelta = options.longs === String ? String(message.realNsDelta) : message.realNsDelta;\n            else\n                object.realNsDelta = options.longs === String ? $util.Long.prototype.toString.call(message.realNsDelta) : options.longs === Number ? new $util.LongBits(message.realNsDelta.low >>> 0, message.realNsDelta.high >>> 0).toNumber(true) : message.realNsDelta;\n        if (message.userNsDelta != null && message.hasOwnProperty(\"userNsDelta\"))\n            if (typeof message.userNsDelta === \"number\")\n                object.userNsDelta = options.longs === String ? String(message.userNsDelta) : message.userNsDelta;\n            else\n                object.userNsDelta = options.longs === String ? $util.Long.prototype.toString.call(message.userNsDelta) : options.longs === Number ? new $util.LongBits(message.userNsDelta.low >>> 0, message.userNsDelta.high >>> 0).toNumber(true) : message.userNsDelta;\n        if (message.sysNsDelta != null && message.hasOwnProperty(\"sysNsDelta\"))\n            if (typeof message.sysNsDelta === \"number\")\n                object.sysNsDelta = options.longs === String ? String(message.sysNsDelta) : message.sysNsDelta;\n            else\n                object.sysNsDelta = options.longs === String ? $util.Long.prototype.toString.call(message.sysNsDelta) : options.longs === Number ? new $util.LongBits(message.sysNsDelta.low >>> 0, message.sysNsDelta.high >>> 0).toNumber(true) : message.sysNsDelta;\n        return object;\n    };\n\n    /**\n     * Converts this TimeStats to JSON.\n     * @function toJSON\n     * @memberof TimeStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TimeStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TimeStats;\n})();\n\n$root.StatsReport = (function() {\n\n    /**\n     * Properties of a StatsReport.\n     * @exports IStatsReport\n     * @interface IStatsReport\n     * @property {IReportHeader|null} [header] StatsReport header\n     * @property {IMemStats|null} [memStats] StatsReport memStats\n     * @property {ITimeStats|null} [timeStats] StatsReport timeStats\n     * @property {google.protobuf.ITimestamp|null} [startTime] StatsReport startTime\n     * @property {google.protobuf.ITimestamp|null} [endTime] StatsReport endTime\n     * @property {number|null} [realtimeDuration] StatsReport realtimeDuration\n     * @property {Object.<string,IQueryStats>|null} [perQuery] StatsReport perQuery\n     * @property {Object.<string,IQueryStats>|null} [legacyPerQueryImplicitOperationName] StatsReport legacyPerQueryImplicitOperationName\n     * @property {Array.<IType>|null} [type] StatsReport type\n     */\n\n    /**\n     * Constructs a new StatsReport.\n     * @exports StatsReport\n     * @classdesc Represents a StatsReport.\n     * @implements IStatsReport\n     * @constructor\n     * @param {IStatsReport=} [properties] Properties to set\n     */\n    function StatsReport(properties) {\n        this.perQuery = {};\n        this.legacyPerQueryImplicitOperationName = {};\n        this.type = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * StatsReport header.\n     * @member {IReportHeader|null|undefined} header\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.header = null;\n\n    /**\n     * StatsReport memStats.\n     * @member {IMemStats|null|undefined} memStats\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.memStats = null;\n\n    /**\n     * StatsReport timeStats.\n     * @member {ITimeStats|null|undefined} timeStats\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.timeStats = null;\n\n    /**\n     * StatsReport startTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} startTime\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.startTime = null;\n\n    /**\n     * StatsReport endTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} endTime\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.endTime = null;\n\n    /**\n     * StatsReport realtimeDuration.\n     * @member {number} realtimeDuration\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.realtimeDuration = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * StatsReport perQuery.\n     * @member {Object.<string,IQueryStats>} perQuery\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.perQuery = $util.emptyObject;\n\n    /**\n     * StatsReport legacyPerQueryImplicitOperationName.\n     * @member {Object.<string,IQueryStats>} legacyPerQueryImplicitOperationName\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.legacyPerQueryImplicitOperationName = $util.emptyObject;\n\n    /**\n     * StatsReport type.\n     * @member {Array.<IType>} type\n     * @memberof StatsReport\n     * @instance\n     */\n    StatsReport.prototype.type = $util.emptyArray;\n\n    /**\n     * Creates a new StatsReport instance using the specified properties.\n     * @function create\n     * @memberof StatsReport\n     * @static\n     * @param {IStatsReport=} [properties] Properties to set\n     * @returns {StatsReport} StatsReport instance\n     */\n    StatsReport.create = function create(properties) {\n        return new StatsReport(properties);\n    };\n\n    /**\n     * Encodes the specified StatsReport message. Does not implicitly {@link StatsReport.verify|verify} messages.\n     * @function encode\n     * @memberof StatsReport\n     * @static\n     * @param {IStatsReport} message StatsReport message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatsReport.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            $root.ReportHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.memStats != null && message.hasOwnProperty(\"memStats\"))\n            $root.MemStats.encode(message.memStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.timeStats != null && message.hasOwnProperty(\"timeStats\"))\n            $root.TimeStats.encode(message.timeStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n            $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n        if (message.realtimeDuration != null && message.hasOwnProperty(\"realtimeDuration\"))\n            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.realtimeDuration);\n        if (message.legacyPerQueryImplicitOperationName != null && message.hasOwnProperty(\"legacyPerQueryImplicitOperationName\"))\n            for (var keys = Object.keys(message.legacyPerQueryImplicitOperationName), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 12, wireType 2 =*/98).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.QueryStats.encode(message.legacyPerQueryImplicitOperationName[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.type != null && message.type.length)\n            for (var i = 0; i < message.type.length; ++i)\n                $root.Type.encode(message.type[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n        if (message.perQuery != null && message.hasOwnProperty(\"perQuery\"))\n            for (var keys = Object.keys(message.perQuery), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.QueryStats.encode(message.perQuery[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified StatsReport message, length delimited. Does not implicitly {@link StatsReport.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof StatsReport\n     * @static\n     * @param {IStatsReport} message StatsReport message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatsReport.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a StatsReport message from the specified reader or buffer.\n     * @function decode\n     * @memberof StatsReport\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {StatsReport} StatsReport\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatsReport.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StatsReport(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.header = $root.ReportHeader.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.memStats = $root.MemStats.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.timeStats = $root.TimeStats.decode(reader, reader.uint32());\n                break;\n            case 8:\n                message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 9:\n                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 10:\n                message.realtimeDuration = reader.uint64();\n                break;\n            case 14:\n                reader.skip().pos++;\n                if (message.perQuery === $util.emptyObject)\n                    message.perQuery = {};\n                key = reader.string();\n                reader.pos++;\n                message.perQuery[key] = $root.QueryStats.decode(reader, reader.uint32());\n                break;\n            case 12:\n                reader.skip().pos++;\n                if (message.legacyPerQueryImplicitOperationName === $util.emptyObject)\n                    message.legacyPerQueryImplicitOperationName = {};\n                key = reader.string();\n                reader.pos++;\n                message.legacyPerQueryImplicitOperationName[key] = $root.QueryStats.decode(reader, reader.uint32());\n                break;\n            case 13:\n                if (!(message.type && message.type.length))\n                    message.type = [];\n                message.type.push($root.Type.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a StatsReport message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof StatsReport\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {StatsReport} StatsReport\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatsReport.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a StatsReport message.\n     * @function verify\n     * @memberof StatsReport\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    StatsReport.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.ReportHeader.verify(message.header);\n            if (error)\n                return \"header.\" + error;\n        }\n        if (message.memStats != null && message.hasOwnProperty(\"memStats\")) {\n            var error = $root.MemStats.verify(message.memStats);\n            if (error)\n                return \"memStats.\" + error;\n        }\n        if (message.timeStats != null && message.hasOwnProperty(\"timeStats\")) {\n            var error = $root.TimeStats.verify(message.timeStats);\n            if (error)\n                return \"timeStats.\" + error;\n        }\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.startTime);\n            if (error)\n                return \"startTime.\" + error;\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.endTime);\n            if (error)\n                return \"endTime.\" + error;\n        }\n        if (message.realtimeDuration != null && message.hasOwnProperty(\"realtimeDuration\"))\n            if (!$util.isInteger(message.realtimeDuration) && !(message.realtimeDuration && $util.isInteger(message.realtimeDuration.low) && $util.isInteger(message.realtimeDuration.high)))\n                return \"realtimeDuration: integer|Long expected\";\n        if (message.perQuery != null && message.hasOwnProperty(\"perQuery\")) {\n            if (!$util.isObject(message.perQuery))\n                return \"perQuery: object expected\";\n            var key = Object.keys(message.perQuery);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.QueryStats.verify(message.perQuery[key[i]]);\n                if (error)\n                    return \"perQuery.\" + error;\n            }\n        }\n        if (message.legacyPerQueryImplicitOperationName != null && message.hasOwnProperty(\"legacyPerQueryImplicitOperationName\")) {\n            if (!$util.isObject(message.legacyPerQueryImplicitOperationName))\n                return \"legacyPerQueryImplicitOperationName: object expected\";\n            var key = Object.keys(message.legacyPerQueryImplicitOperationName);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.QueryStats.verify(message.legacyPerQueryImplicitOperationName[key[i]]);\n                if (error)\n                    return \"legacyPerQueryImplicitOperationName.\" + error;\n            }\n        }\n        if (message.type != null && message.hasOwnProperty(\"type\")) {\n            if (!Array.isArray(message.type))\n                return \"type: array expected\";\n            for (var i = 0; i < message.type.length; ++i) {\n                var error = $root.Type.verify(message.type[i]);\n                if (error)\n                    return \"type.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a StatsReport message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof StatsReport\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {StatsReport} StatsReport\n     */\n    StatsReport.fromObject = function fromObject(object) {\n        if (object instanceof $root.StatsReport)\n            return object;\n        var message = new $root.StatsReport();\n        if (object.header != null) {\n            if (typeof object.header !== \"object\")\n                throw TypeError(\".StatsReport.header: object expected\");\n            message.header = $root.ReportHeader.fromObject(object.header);\n        }\n        if (object.memStats != null) {\n            if (typeof object.memStats !== \"object\")\n                throw TypeError(\".StatsReport.memStats: object expected\");\n            message.memStats = $root.MemStats.fromObject(object.memStats);\n        }\n        if (object.timeStats != null) {\n            if (typeof object.timeStats !== \"object\")\n                throw TypeError(\".StatsReport.timeStats: object expected\");\n            message.timeStats = $root.TimeStats.fromObject(object.timeStats);\n        }\n        if (object.startTime != null) {\n            if (typeof object.startTime !== \"object\")\n                throw TypeError(\".StatsReport.startTime: object expected\");\n            message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);\n        }\n        if (object.endTime != null) {\n            if (typeof object.endTime !== \"object\")\n                throw TypeError(\".StatsReport.endTime: object expected\");\n            message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);\n        }\n        if (object.realtimeDuration != null)\n            if ($util.Long)\n                (message.realtimeDuration = $util.Long.fromValue(object.realtimeDuration)).unsigned = true;\n            else if (typeof object.realtimeDuration === \"string\")\n                message.realtimeDuration = parseInt(object.realtimeDuration, 10);\n            else if (typeof object.realtimeDuration === \"number\")\n                message.realtimeDuration = object.realtimeDuration;\n            else if (typeof object.realtimeDuration === \"object\")\n                message.realtimeDuration = new $util.LongBits(object.realtimeDuration.low >>> 0, object.realtimeDuration.high >>> 0).toNumber(true);\n        if (object.perQuery) {\n            if (typeof object.perQuery !== \"object\")\n                throw TypeError(\".StatsReport.perQuery: object expected\");\n            message.perQuery = {};\n            for (var keys = Object.keys(object.perQuery), i = 0; i < keys.length; ++i) {\n                if (typeof object.perQuery[keys[i]] !== \"object\")\n                    throw TypeError(\".StatsReport.perQuery: object expected\");\n                message.perQuery[keys[i]] = $root.QueryStats.fromObject(object.perQuery[keys[i]]);\n            }\n        }\n        if (object.legacyPerQueryImplicitOperationName) {\n            if (typeof object.legacyPerQueryImplicitOperationName !== \"object\")\n                throw TypeError(\".StatsReport.legacyPerQueryImplicitOperationName: object expected\");\n            message.legacyPerQueryImplicitOperationName = {};\n            for (var keys = Object.keys(object.legacyPerQueryImplicitOperationName), i = 0; i < keys.length; ++i) {\n                if (typeof object.legacyPerQueryImplicitOperationName[keys[i]] !== \"object\")\n                    throw TypeError(\".StatsReport.legacyPerQueryImplicitOperationName: object expected\");\n                message.legacyPerQueryImplicitOperationName[keys[i]] = $root.QueryStats.fromObject(object.legacyPerQueryImplicitOperationName[keys[i]]);\n            }\n        }\n        if (object.type) {\n            if (!Array.isArray(object.type))\n                throw TypeError(\".StatsReport.type: array expected\");\n            message.type = [];\n            for (var i = 0; i < object.type.length; ++i) {\n                if (typeof object.type[i] !== \"object\")\n                    throw TypeError(\".StatsReport.type: object expected\");\n                message.type[i] = $root.Type.fromObject(object.type[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a StatsReport message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof StatsReport\n     * @static\n     * @param {StatsReport} message StatsReport\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    StatsReport.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.type = [];\n        if (options.objects || options.defaults) {\n            object.legacyPerQueryImplicitOperationName = {};\n            object.perQuery = {};\n        }\n        if (options.defaults) {\n            object.header = null;\n            object.memStats = null;\n            object.timeStats = null;\n            object.startTime = null;\n            object.endTime = null;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.realtimeDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.realtimeDuration = options.longs === String ? \"0\" : 0;\n        }\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            object.header = $root.ReportHeader.toObject(message.header, options);\n        if (message.memStats != null && message.hasOwnProperty(\"memStats\"))\n            object.memStats = $root.MemStats.toObject(message.memStats, options);\n        if (message.timeStats != null && message.hasOwnProperty(\"timeStats\"))\n            object.timeStats = $root.TimeStats.toObject(message.timeStats, options);\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n        if (message.realtimeDuration != null && message.hasOwnProperty(\"realtimeDuration\"))\n            if (typeof message.realtimeDuration === \"number\")\n                object.realtimeDuration = options.longs === String ? String(message.realtimeDuration) : message.realtimeDuration;\n            else\n                object.realtimeDuration = options.longs === String ? $util.Long.prototype.toString.call(message.realtimeDuration) : options.longs === Number ? new $util.LongBits(message.realtimeDuration.low >>> 0, message.realtimeDuration.high >>> 0).toNumber(true) : message.realtimeDuration;\n        var keys2;\n        if (message.legacyPerQueryImplicitOperationName && (keys2 = Object.keys(message.legacyPerQueryImplicitOperationName)).length) {\n            object.legacyPerQueryImplicitOperationName = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.legacyPerQueryImplicitOperationName[keys2[j]] = $root.QueryStats.toObject(message.legacyPerQueryImplicitOperationName[keys2[j]], options);\n        }\n        if (message.type && message.type.length) {\n            object.type = [];\n            for (var j = 0; j < message.type.length; ++j)\n                object.type[j] = $root.Type.toObject(message.type[j], options);\n        }\n        if (message.perQuery && (keys2 = Object.keys(message.perQuery)).length) {\n            object.perQuery = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perQuery[keys2[j]] = $root.QueryStats.toObject(message.perQuery[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this StatsReport to JSON.\n     * @function toJSON\n     * @memberof StatsReport\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    StatsReport.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return StatsReport;\n})();\n\n$root.FullTracesReport = (function() {\n\n    /**\n     * Properties of a FullTracesReport.\n     * @exports IFullTracesReport\n     * @interface IFullTracesReport\n     * @property {IReportHeader|null} [header] FullTracesReport header\n     * @property {Object.<string,ITraces>|null} [tracesPerQuery] FullTracesReport tracesPerQuery\n     */\n\n    /**\n     * Constructs a new FullTracesReport.\n     * @exports FullTracesReport\n     * @classdesc Represents a FullTracesReport.\n     * @implements IFullTracesReport\n     * @constructor\n     * @param {IFullTracesReport=} [properties] Properties to set\n     */\n    function FullTracesReport(properties) {\n        this.tracesPerQuery = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FullTracesReport header.\n     * @member {IReportHeader|null|undefined} header\n     * @memberof FullTracesReport\n     * @instance\n     */\n    FullTracesReport.prototype.header = null;\n\n    /**\n     * FullTracesReport tracesPerQuery.\n     * @member {Object.<string,ITraces>} tracesPerQuery\n     * @memberof FullTracesReport\n     * @instance\n     */\n    FullTracesReport.prototype.tracesPerQuery = $util.emptyObject;\n\n    /**\n     * Creates a new FullTracesReport instance using the specified properties.\n     * @function create\n     * @memberof FullTracesReport\n     * @static\n     * @param {IFullTracesReport=} [properties] Properties to set\n     * @returns {FullTracesReport} FullTracesReport instance\n     */\n    FullTracesReport.create = function create(properties) {\n        return new FullTracesReport(properties);\n    };\n\n    /**\n     * Encodes the specified FullTracesReport message. Does not implicitly {@link FullTracesReport.verify|verify} messages.\n     * @function encode\n     * @memberof FullTracesReport\n     * @static\n     * @param {IFullTracesReport} message FullTracesReport message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FullTracesReport.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            $root.ReportHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.tracesPerQuery != null && message.hasOwnProperty(\"tracesPerQuery\"))\n            for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.Traces.encode(message.tracesPerQuery[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified FullTracesReport message, length delimited. Does not implicitly {@link FullTracesReport.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof FullTracesReport\n     * @static\n     * @param {IFullTracesReport} message FullTracesReport message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FullTracesReport.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FullTracesReport message from the specified reader or buffer.\n     * @function decode\n     * @memberof FullTracesReport\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FullTracesReport} FullTracesReport\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FullTracesReport.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FullTracesReport(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.header = $root.ReportHeader.decode(reader, reader.uint32());\n                break;\n            case 5:\n                reader.skip().pos++;\n                if (message.tracesPerQuery === $util.emptyObject)\n                    message.tracesPerQuery = {};\n                key = reader.string();\n                reader.pos++;\n                message.tracesPerQuery[key] = $root.Traces.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a FullTracesReport message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof FullTracesReport\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {FullTracesReport} FullTracesReport\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FullTracesReport.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FullTracesReport message.\n     * @function verify\n     * @memberof FullTracesReport\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FullTracesReport.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.ReportHeader.verify(message.header);\n            if (error)\n                return \"header.\" + error;\n        }\n        if (message.tracesPerQuery != null && message.hasOwnProperty(\"tracesPerQuery\")) {\n            if (!$util.isObject(message.tracesPerQuery))\n                return \"tracesPerQuery: object expected\";\n            var key = Object.keys(message.tracesPerQuery);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.Traces.verify(message.tracesPerQuery[key[i]]);\n                if (error)\n                    return \"tracesPerQuery.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a FullTracesReport message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof FullTracesReport\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {FullTracesReport} FullTracesReport\n     */\n    FullTracesReport.fromObject = function fromObject(object) {\n        if (object instanceof $root.FullTracesReport)\n            return object;\n        var message = new $root.FullTracesReport();\n        if (object.header != null) {\n            if (typeof object.header !== \"object\")\n                throw TypeError(\".FullTracesReport.header: object expected\");\n            message.header = $root.ReportHeader.fromObject(object.header);\n        }\n        if (object.tracesPerQuery) {\n            if (typeof object.tracesPerQuery !== \"object\")\n                throw TypeError(\".FullTracesReport.tracesPerQuery: object expected\");\n            message.tracesPerQuery = {};\n            for (var keys = Object.keys(object.tracesPerQuery), i = 0; i < keys.length; ++i) {\n                if (typeof object.tracesPerQuery[keys[i]] !== \"object\")\n                    throw TypeError(\".FullTracesReport.tracesPerQuery: object expected\");\n                message.tracesPerQuery[keys[i]] = $root.Traces.fromObject(object.tracesPerQuery[keys[i]]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a FullTracesReport message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof FullTracesReport\n     * @static\n     * @param {FullTracesReport} message FullTracesReport\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FullTracesReport.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.tracesPerQuery = {};\n        if (options.defaults)\n            object.header = null;\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            object.header = $root.ReportHeader.toObject(message.header, options);\n        var keys2;\n        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {\n            object.tracesPerQuery = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.tracesPerQuery[keys2[j]] = $root.Traces.toObject(message.tracesPerQuery[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this FullTracesReport to JSON.\n     * @function toJSON\n     * @memberof FullTracesReport\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FullTracesReport.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return FullTracesReport;\n})();\n\n$root.Traces = (function() {\n\n    /**\n     * Properties of a Traces.\n     * @exports ITraces\n     * @interface ITraces\n     * @property {Array.<ITrace>|null} [trace] Traces trace\n     */\n\n    /**\n     * Constructs a new Traces.\n     * @exports Traces\n     * @classdesc Represents a Traces.\n     * @implements ITraces\n     * @constructor\n     * @param {ITraces=} [properties] Properties to set\n     */\n    function Traces(properties) {\n        this.trace = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Traces trace.\n     * @member {Array.<ITrace>} trace\n     * @memberof Traces\n     * @instance\n     */\n    Traces.prototype.trace = $util.emptyArray;\n\n    /**\n     * Creates a new Traces instance using the specified properties.\n     * @function create\n     * @memberof Traces\n     * @static\n     * @param {ITraces=} [properties] Properties to set\n     * @returns {Traces} Traces instance\n     */\n    Traces.create = function create(properties) {\n        return new Traces(properties);\n    };\n\n    /**\n     * Encodes the specified Traces message. Does not implicitly {@link Traces.verify|verify} messages.\n     * @function encode\n     * @memberof Traces\n     * @static\n     * @param {ITraces} message Traces message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Traces.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.trace != null && message.trace.length)\n            for (var i = 0; i < message.trace.length; ++i)\n                $root.Trace.encode(message.trace[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Traces message, length delimited. Does not implicitly {@link Traces.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Traces\n     * @static\n     * @param {ITraces} message Traces message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Traces.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Traces message from the specified reader or buffer.\n     * @function decode\n     * @memberof Traces\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Traces} Traces\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Traces.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Traces();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.trace && message.trace.length))\n                    message.trace = [];\n                message.trace.push($root.Trace.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Traces message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Traces\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Traces} Traces\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Traces.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Traces message.\n     * @function verify\n     * @memberof Traces\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Traces.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n            if (!Array.isArray(message.trace))\n                return \"trace: array expected\";\n            for (var i = 0; i < message.trace.length; ++i) {\n                var error = $root.Trace.verify(message.trace[i]);\n                if (error)\n                    return \"trace.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a Traces message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Traces\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Traces} Traces\n     */\n    Traces.fromObject = function fromObject(object) {\n        if (object instanceof $root.Traces)\n            return object;\n        var message = new $root.Traces();\n        if (object.trace) {\n            if (!Array.isArray(object.trace))\n                throw TypeError(\".Traces.trace: array expected\");\n            message.trace = [];\n            for (var i = 0; i < object.trace.length; ++i) {\n                if (typeof object.trace[i] !== \"object\")\n                    throw TypeError(\".Traces.trace: object expected\");\n                message.trace[i] = $root.Trace.fromObject(object.trace[i]);\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Creates a plain object from a Traces message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Traces\n     * @static\n     * @param {Traces} message Traces\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Traces.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.trace = [];\n        if (message.trace && message.trace.length) {\n            object.trace = [];\n            for (var j = 0; j < message.trace.length; ++j)\n                object.trace[j] = $root.Trace.toObject(message.trace[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Traces to JSON.\n     * @function toJSON\n     * @memberof Traces\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Traces.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Traces;\n})();\n\n$root.google = (function() {\n\n    /**\n     * Namespace google.\n     * @exports google\n     * @namespace\n     */\n    var google = {};\n\n    google.protobuf = (function() {\n\n        /**\n         * Namespace protobuf.\n         * @memberof google\n         * @namespace\n         */\n        var protobuf = {};\n\n        protobuf.Timestamp = (function() {\n\n            /**\n             * Properties of a Timestamp.\n             * @memberof google.protobuf\n             * @interface ITimestamp\n             * @property {number|null} [seconds] Timestamp seconds\n             * @property {number|null} [nanos] Timestamp nanos\n             */\n\n            /**\n             * Constructs a new Timestamp.\n             * @memberof google.protobuf\n             * @classdesc Represents a Timestamp.\n             * @implements ITimestamp\n             * @constructor\n             * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n             */\n            function Timestamp(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Timestamp seconds.\n             * @member {number} seconds\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             */\n            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Timestamp nanos.\n             * @member {number} nanos\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             */\n            Timestamp.prototype.nanos = 0;\n\n            /**\n             * Creates a new Timestamp instance using the specified properties.\n             * @function create\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n             * @returns {google.protobuf.Timestamp} Timestamp instance\n             */\n            Timestamp.create = function create(properties) {\n                return new Timestamp(properties);\n            };\n\n            /**\n             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n             * @function encode\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Timestamp.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Timestamp message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.Timestamp} Timestamp\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Timestamp.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.seconds = reader.int64();\n                        break;\n                    case 2:\n                        message.nanos = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {google.protobuf.Timestamp} Timestamp\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Timestamp.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Timestamp message.\n             * @function verify\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Timestamp.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))\n                        return \"seconds: integer|Long expected\";\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    if (!$util.isInteger(message.nanos))\n                        return \"nanos: integer expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {google.protobuf.Timestamp} Timestamp\n             */\n            Timestamp.fromObject = function fromObject(object) {\n                if (object instanceof $root.google.protobuf.Timestamp)\n                    return object;\n                var message = new $root.google.protobuf.Timestamp();\n                if (object.seconds != null)\n                    if ($util.Long)\n                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;\n                    else if (typeof object.seconds === \"string\")\n                        message.seconds = parseInt(object.seconds, 10);\n                    else if (typeof object.seconds === \"number\")\n                        message.seconds = object.seconds;\n                    else if (typeof object.seconds === \"object\")\n                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();\n                if (object.nanos != null)\n                    message.nanos = object.nanos | 0;\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.Timestamp} message Timestamp\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Timestamp.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.seconds = options.longs === String ? \"0\" : 0;\n                    object.nanos = 0;\n                }\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    if (typeof message.seconds === \"number\")\n                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;\n                    else\n                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    object.nanos = message.nanos;\n                return object;\n            };\n\n            /**\n             * Converts this Timestamp to JSON.\n             * @function toJSON\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Timestamp.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Timestamp;\n        })();\n\n        return protobuf;\n    })();\n\n    return google;\n})();\n\nmodule.exports = $root;\n\n\n//# sourceURL=webpack:///./node_modules/apollo-engine-reporting-protobuf/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-engine-reporting/dist/agent.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-engine-reporting/dist/agent.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst os = __webpack_require__(/*! os */ \"os\");\nconst zlib_1 = __webpack_require__(/*! zlib */ \"zlib\");\nconst apollo_engine_reporting_protobuf_1 = __webpack_require__(/*! apollo-engine-reporting-protobuf */ \"./node_modules/apollo-engine-reporting-protobuf/dist/index.js\");\nconst apollo_server_env_1 = __webpack_require__(/*! apollo-server-env */ \"./node_modules/apollo-server-env/dist/index.js\");\nconst retry = __webpack_require__(/*! async-retry */ \"./node_modules/async-retry/lib/index.js\");\nconst extension_1 = __webpack_require__(/*! ./extension */ \"./node_modules/apollo-engine-reporting/dist/extension.js\");\nconst originalTracesEncode = apollo_engine_reporting_protobuf_1.Traces.encode;\napollo_engine_reporting_protobuf_1.Traces.encode = function (message, originalWriter) {\n    const writer = originalTracesEncode(message, originalWriter);\n    const encodedTraces = message.encodedTraces;\n    if (encodedTraces != null && encodedTraces.length) {\n        for (let i = 0; i < encodedTraces.length; ++i) {\n            writer.uint32(10);\n            writer.bytes(encodedTraces[i]);\n        }\n    }\n    return writer;\n};\nconst REPORT_HEADER = new apollo_engine_reporting_protobuf_1.ReportHeader({\n    hostname: os.hostname(),\n    agentVersion: `apollo-engine-reporting@${__webpack_require__(/*! ../package.json */ \"./node_modules/apollo-engine-reporting/package.json\").version}`,\n    runtimeVersion: `node ${process.version}`,\n    uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n});\nclass EngineReportingAgent {\n    constructor(options = {}) {\n        this.stopped = false;\n        this.options = options;\n        this.apiKey = options.apiKey || process.env.ENGINE_API_KEY || '';\n        if (!this.apiKey) {\n            throw new Error('To use EngineReportingAgent, you must specify an API key via the apiKey option or the ENGINE_API_KEY environment variable.');\n        }\n        this.resetReport();\n        this.sendReportsImmediately = options.sendReportsImmediately;\n        if (!this.sendReportsImmediately) {\n            this.reportTimer = setInterval(() => this.sendReportAndReportErrors(), this.options.reportIntervalMs || 10 * 1000);\n        }\n        if (this.options.handleSignals !== false) {\n            const signals = ['SIGINT', 'SIGTERM'];\n            signals.forEach(signal => {\n                process.once(signal, () => __awaiter(this, void 0, void 0, function* () {\n                    this.stop();\n                    yield this.sendReportAndReportErrors();\n                    process.kill(process.pid, signal);\n                }));\n            });\n        }\n    }\n    newExtension() {\n        return new extension_1.EngineReportingExtension(this.options, this.addTrace.bind(this));\n    }\n    addTrace(signature, operationName, trace) {\n        if (this.stopped) {\n            return;\n        }\n        const protobufError = apollo_engine_reporting_protobuf_1.Trace.verify(trace);\n        if (protobufError) {\n            throw new Error(`Error encoding trace: ${protobufError}`);\n        }\n        const encodedTrace = apollo_engine_reporting_protobuf_1.Trace.encode(trace).finish();\n        const statsReportKey = `# ${operationName || '-'}\\n${signature}`;\n        if (!this.report.tracesPerQuery.hasOwnProperty(statsReportKey)) {\n            this.report.tracesPerQuery[statsReportKey] = new apollo_engine_reporting_protobuf_1.Traces();\n            this.report.tracesPerQuery[statsReportKey].encodedTraces = [];\n        }\n        this.report.tracesPerQuery[statsReportKey].encodedTraces.push(encodedTrace);\n        this.reportSize += encodedTrace.length + Buffer.byteLength(statsReportKey);\n        if (this.sendReportsImmediately ||\n            this.reportSize >=\n                (this.options.maxUncompressedReportSize || 4 * 1024 * 1024)) {\n            this.sendReportAndReportErrors();\n        }\n    }\n    sendReport() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const report = this.report;\n            this.resetReport();\n            if (Object.keys(report.tracesPerQuery).length === 0) {\n                return;\n            }\n            yield Promise.resolve();\n            if (this.options.debugPrintReports) {\n                console.log(`Engine sending report: ${JSON.stringify(report.toJSON())}`);\n            }\n            const protobufError = apollo_engine_reporting_protobuf_1.FullTracesReport.verify(report);\n            if (protobufError) {\n                throw new Error(`Error encoding report: ${protobufError}`);\n            }\n            const message = apollo_engine_reporting_protobuf_1.FullTracesReport.encode(report).finish();\n            const compressed = yield new Promise((resolve, reject) => {\n                const messageBuffer = Buffer.from(message.buffer, message.byteOffset, message.byteLength);\n                zlib_1.gzip(messageBuffer, (err, compressed) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(compressed);\n                    }\n                });\n            });\n            const endpointUrl = (this.options.endpointUrl || 'https://engine-report.apollodata.com') +\n                '/api/ingress/traces';\n            const response = yield retry(() => __awaiter(this, void 0, void 0, function* () {\n                const response = yield apollo_server_env_1.fetch(endpointUrl, {\n                    method: 'POST',\n                    headers: {\n                        'user-agent': 'apollo-engine-reporting',\n                        'x-api-key': this.apiKey,\n                        'content-encoding': 'gzip',\n                    },\n                    body: compressed,\n                });\n                if (response.status >= 500 && response.status < 600) {\n                    throw new Error(`${response.status}: ${response.statusText}`);\n                }\n                else {\n                    return response;\n                }\n            }), {\n                retries: this.options.maxAttempts || 5,\n                minTimeout: this.options.minimumRetryDelayMs || 100,\n                factor: 2,\n            }).catch((err) => {\n                throw new Error(`Error sending report to Engine servers: ${err}`);\n            });\n            if (response.status < 200 || response.status >= 300) {\n                throw new Error(`Error sending report to Engine servers (HTTP status ${response.status}): ${yield response.text()}`);\n            }\n            if (this.options.debugPrintReports) {\n                console.log(`Engine report: status ${response.status}`);\n            }\n        });\n    }\n    stop() {\n        if (this.reportTimer) {\n            clearInterval(this.reportTimer);\n            this.reportTimer = undefined;\n        }\n        this.stopped = true;\n    }\n    sendReportAndReportErrors() {\n        return this.sendReport().catch(err => {\n            if (this.options.reportErrorFunction) {\n                this.options.reportErrorFunction(err);\n            }\n            else {\n                console.error(err.message);\n            }\n        });\n    }\n    resetReport() {\n        this.report = new apollo_engine_reporting_protobuf_1.FullTracesReport({ header: REPORT_HEADER });\n        this.reportSize = 0;\n    }\n}\nexports.EngineReportingAgent = EngineReportingAgent;\n//# sourceMappingURL=agent.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-engine-reporting/dist/agent.js?");

/***/ }),

/***/ "./node_modules/apollo-engine-reporting/dist/extension.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-engine-reporting/dist/extension.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nconst apollo_engine_reporting_protobuf_1 = __webpack_require__(/*! apollo-engine-reporting-protobuf */ \"./node_modules/apollo-engine-reporting-protobuf/dist/index.js\");\nconst signature_1 = __webpack_require__(/*! ./signature */ \"./node_modules/apollo-engine-reporting/dist/signature.js\");\nclass EngineReportingExtension {\n    constructor(options, addTrace) {\n        this.trace = new apollo_engine_reporting_protobuf_1.Trace();\n        this.nodes = new Map();\n        this.options = Object.assign({ maskErrorDetails: false }, options);\n        this.addTrace = addTrace;\n        const root = new apollo_engine_reporting_protobuf_1.Trace.Node();\n        this.trace.root = root;\n        this.nodes.set(responsePathAsString(undefined), root);\n    }\n    requestDidStart(o) {\n        this.trace.startTime = dateToTimestamp(new Date());\n        this.startHrTime = process.hrtime();\n        this.queryString = o.queryString;\n        this.documentAST = o.parsedQuery;\n        this.trace.http = new apollo_engine_reporting_protobuf_1.Trace.HTTP({\n            method: apollo_engine_reporting_protobuf_1.Trace.HTTP.Method[o.request.method] ||\n                apollo_engine_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN,\n            host: null,\n            path: null,\n        });\n        if (this.options.privateHeaders !== true) {\n            for (const [key, value] of o.request.headers) {\n                if (this.options.privateHeaders &&\n                    typeof this.options.privateHeaders === 'object' &&\n                    this.options.privateHeaders.includes(key.toLowerCase())) {\n                    break;\n                }\n                switch (key) {\n                    case 'authorization':\n                    case 'cookie':\n                    case 'set-cookie':\n                        break;\n                    default:\n                        this.trace.http.requestHeaders[key] = new apollo_engine_reporting_protobuf_1.Trace.HTTP.Values({\n                            value: [value],\n                        });\n                }\n            }\n            if (o.persistedQueryHit) {\n                this.trace.persistedQueryHit = true;\n            }\n            if (o.persistedQueryRegister) {\n                this.trace.persistedQueryRegister = true;\n            }\n        }\n        if (this.options.privateVariables !== true && o.variables) {\n            this.trace.details = new apollo_engine_reporting_protobuf_1.Trace.Details();\n            Object.keys(o.variables).forEach(name => {\n                if (this.options.privateVariables &&\n                    typeof this.options.privateVariables === 'object' &&\n                    this.options.privateVariables.includes(name)) {\n                    this.trace.details.variablesJson[name] = '';\n                }\n                else {\n                    this.trace.details.variablesJson[name] = JSON.stringify(o.variables[name]);\n                }\n            });\n        }\n        return () => {\n            this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n            this.trace.endTime = dateToTimestamp(new Date());\n            const operationName = this.operationName || '';\n            let signature;\n            if (this.documentAST) {\n                const calculateSignature = this.options.calculateSignature || signature_1.defaultSignature;\n                signature = calculateSignature(this.documentAST, operationName);\n            }\n            else if (this.queryString) {\n                signature = this.queryString;\n            }\n            else {\n                throw new Error('No queryString or parsedQuery?');\n            }\n            this.addTrace(signature, operationName, this.trace);\n        };\n    }\n    executionDidStart(o) {\n        if (o.executionArgs.operationName) {\n            this.operationName = o.executionArgs.operationName;\n        }\n        this.documentAST = o.executionArgs.document;\n    }\n    willResolveField(_source, _args, _context, info) {\n        if (this.operationName === undefined) {\n            this.operationName =\n                (info.operation.name && info.operation.name.value) || '';\n        }\n        const path = info.path;\n        const node = this.newNode(path);\n        node.type = info.returnType.toString();\n        node.parentType = info.parentType.toString();\n        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n        return () => {\n            node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n        };\n    }\n    willSendResponse(o) {\n        const { errors } = o.graphqlResponse;\n        if (errors) {\n            errors.forEach((error) => {\n                let node = this.nodes.get('');\n                if (error.path) {\n                    const specificNode = this.nodes.get(error.path.join('.'));\n                    if (specificNode) {\n                        node = specificNode;\n                    }\n                }\n                const errorInfo = this.options.maskErrorDetails\n                    ? { message: '<masked>' }\n                    : {\n                        message: error.message,\n                        location: (error.locations || []).map(({ line, column }) => new apollo_engine_reporting_protobuf_1.Trace.Location({ line, column })),\n                        json: JSON.stringify(error),\n                    };\n                node.error.push(new apollo_engine_reporting_protobuf_1.Trace.Error(errorInfo));\n            });\n        }\n    }\n    newNode(path) {\n        const node = new apollo_engine_reporting_protobuf_1.Trace.Node();\n        const id = path.key;\n        if (typeof id === 'number') {\n            node.index = id;\n        }\n        else {\n            node.fieldName = id;\n        }\n        this.nodes.set(responsePathAsString(path), node);\n        const parentNode = this.ensureParentNode(path);\n        parentNode.child.push(node);\n        return node;\n    }\n    ensureParentNode(path) {\n        const parentPath = responsePathAsString(path.prev);\n        const parentNode = this.nodes.get(parentPath);\n        if (parentNode) {\n            return parentNode;\n        }\n        return this.newNode(path.prev);\n    }\n}\nexports.EngineReportingExtension = EngineReportingExtension;\nfunction responsePathAsString(p) {\n    if (p === undefined) {\n        return '';\n    }\n    return graphql_1.responsePathAsArray(p).join('.');\n}\nfunction dateToTimestamp(date) {\n    const totalMillis = +date;\n    const millis = totalMillis % 1000;\n    return new apollo_engine_reporting_protobuf_1.google.protobuf.Timestamp({\n        seconds: (totalMillis - millis) / 1000,\n        nanos: millis * 1e6,\n    });\n}\nfunction durationHrTimeToNanos(hrtime) {\n    return hrtime[0] * 1e9 + hrtime[1];\n}\n//# sourceMappingURL=extension.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-engine-reporting/dist/extension.js?");

/***/ }),

/***/ "./node_modules/apollo-engine-reporting/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-engine-reporting/dist/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar signature_1 = __webpack_require__(/*! ./signature */ \"./node_modules/apollo-engine-reporting/dist/signature.js\");\nexports.hideLiterals = signature_1.hideLiterals;\nexports.dropUnusedDefinitions = signature_1.dropUnusedDefinitions;\nexports.sortAST = signature_1.sortAST;\nexports.removeAliases = signature_1.removeAliases;\nexports.printWithReducedWhitespace = signature_1.printWithReducedWhitespace;\nexports.defaultSignature = signature_1.defaultSignature;\nvar agent_1 = __webpack_require__(/*! ./agent */ \"./node_modules/apollo-engine-reporting/dist/agent.js\");\nexports.EngineReportingAgent = agent_1.EngineReportingAgent;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-engine-reporting/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-engine-reporting/dist/signature.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-engine-reporting/dist/signature.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nfunction hideLiterals(ast) {\n    return graphql_1.visit(ast, {\n        IntValue(node) {\n            return Object.assign({}, node, { value: '0' });\n        },\n        FloatValue(node) {\n            return Object.assign({}, node, { value: '0' });\n        },\n        StringValue(node) {\n            return Object.assign({}, node, { value: '', block: false });\n        },\n        ListValue(node) {\n            return Object.assign({}, node, { values: [] });\n        },\n        ObjectValue(node) {\n            return Object.assign({}, node, { fields: [] });\n        },\n    });\n}\nexports.hideLiterals = hideLiterals;\nfunction dropUnusedDefinitions(ast, operationName) {\n    const separated = graphql_1.separateOperations(ast)[operationName];\n    if (!separated) {\n        return ast;\n    }\n    return separated;\n}\nexports.dropUnusedDefinitions = dropUnusedDefinitions;\nfunction sorted(items, ...iteratees) {\n    if (items) {\n        return lodash_1.sortBy(items, ...iteratees);\n    }\n    return undefined;\n}\nfunction sortAST(ast) {\n    return graphql_1.visit(ast, {\n        OperationDefinition(node) {\n            return Object.assign({}, node, { variableDefinitions: sorted(node.variableDefinitions, 'variable.name.value') });\n        },\n        SelectionSet(node) {\n            return Object.assign({}, node, { selections: lodash_1.sortBy(node.selections, 'kind', 'name.value') });\n        },\n        Field(node) {\n            return Object.assign({}, node, { arguments: sorted(node.arguments, 'name.value') });\n        },\n        FragmentSpread(node) {\n            return Object.assign({}, node, { directives: sorted(node.directives, 'name.value') });\n        },\n        InlineFragment(node) {\n            return Object.assign({}, node, { directives: sorted(node.directives, 'name.value') });\n        },\n        FragmentDefinition(node) {\n            return Object.assign({}, node, { directives: sorted(node.directives, 'name.value'), variableDefinitions: sorted(node.variableDefinitions, 'variable.name.value') });\n        },\n        Directive(node) {\n            return Object.assign({}, node, { arguments: sorted(node.arguments, 'name.value') });\n        },\n    });\n}\nexports.sortAST = sortAST;\nfunction removeAliases(ast) {\n    return graphql_1.visit(ast, {\n        Field(node) {\n            return Object.assign({}, node, { alias: undefined });\n        },\n    });\n}\nexports.removeAliases = removeAliases;\nfunction printWithReducedWhitespace(ast) {\n    const sanitizedAST = graphql_1.visit(ast, {\n        StringValue(node) {\n            return Object.assign({}, node, { value: Buffer.from(node.value, 'utf8').toString('hex'), block: false });\n        },\n    });\n    const withWhitespace = graphql_1.print(sanitizedAST);\n    const minimizedButStillHex = withWhitespace\n        .replace(/\\s+/g, ' ')\n        .replace(/([^_a-zA-Z0-9]) /g, (_, c) => c)\n        .replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);\n    return minimizedButStillHex.replace(/\"([a-f0-9]+)\"/g, (_, hex) => JSON.stringify(Buffer.from(hex, 'hex').toString('utf8')));\n}\nexports.printWithReducedWhitespace = printWithReducedWhitespace;\nfunction defaultSignature(ast, operationName) {\n    return printWithReducedWhitespace(sortAST(removeAliases(hideLiterals(dropUnusedDefinitions(ast, operationName)))));\n}\nexports.defaultSignature = defaultSignature;\n//# sourceMappingURL=signature.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-engine-reporting/dist/signature.js?");

/***/ }),

/***/ "./node_modules/apollo-engine-reporting/package.json":
/*!***********************************************************!*\
  !*** ./node_modules/apollo-engine-reporting/package.json ***!
  \***********************************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, bugs, bundleDependencies, dependencies, deprecated, description, engines, gitHead, homepage, license, main, name, repository, scripts, types, version, default */
/***/ (function(module) {

eval("module.exports = {\"_from\":\"apollo-engine-reporting@0.0.4\",\"_id\":\"apollo-engine-reporting@0.0.4\",\"_inBundle\":false,\"_integrity\":\"sha512-VEgTR15FtMU84FvM5Tgn5v0msX2omKcc1itzAX9cmz6zzu/cUMVABuOEghyFsDAJHTy2ofzW2EufnfCbzIBNoQ==\",\"_location\":\"/apollo-engine-reporting\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"apollo-engine-reporting@0.0.4\",\"name\":\"apollo-engine-reporting\",\"escapedName\":\"apollo-engine-reporting\",\"rawSpec\":\"0.0.4\",\"saveSpec\":null,\"fetchSpec\":\"0.0.4\"},\"_requiredBy\":[\"/apollo-server-core\"],\"_resolved\":\"https://registry.npmjs.org/apollo-engine-reporting/-/apollo-engine-reporting-0.0.4.tgz\",\"_shasum\":\"b2d6318febde9a1a64b518736d4695e81f069ba1\",\"_spec\":\"apollo-engine-reporting@0.0.4\",\"_where\":\"C:\\\\Users\\\\rafael\\\\Job\\\\Javascript\\\\TypeScript\\\\api-nest\\\\node_modules\\\\apollo-server-core\",\"author\":{\"name\":\"Apollo\",\"email\":\"community@apollographql.com\"},\"bugs\":{\"url\":\"https://github.com/apollographql/apollo-engine-reporting/issues\"},\"bundleDependencies\":false,\"dependencies\":{\"apollo-engine-reporting-protobuf\":\"0.0.1\",\"apollo-server-env\":\"2.0.3\",\"async-retry\":\"^1.2.1\",\"graphql-extensions\":\"0.1.3\",\"lodash\":\"^4.17.10\"},\"deprecated\":false,\"description\":\"Send reports about your GraphQL services to Apollo Engine\",\"engines\":{\"node\":\">=6.0\"},\"gitHead\":\"996c73063af8aa361ecd6bb78e43b9d0c0df78a2\",\"homepage\":\"https://github.com/apollographql/apollo-engine-reporting#readme\",\"license\":\"MIT\",\"main\":\"./dist/index.js\",\"name\":\"apollo-engine-reporting\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/apollographql/apollo-engine-reporting.git\"},\"scripts\":{\"clean\":\"rm -rf dist\",\"compile\":\"tsc\",\"lint\":\"prettier -l 'src/**/*.{ts,js}' && tslint -p tsconfig.json 'src/**/*.ts'\",\"lint-fix\":\"prettier --write 'src/**/*.{ts,js}' && tslint --fix -p tsconfig.json 'src/**/*.ts'\",\"prepare\":\"npm run clean && npm run compile\"},\"types\":\"./dist/index.d.ts\",\"version\":\"0.0.4\"};\n\n//# sourceURL=webpack:///./node_modules/apollo-engine-reporting/package.json?");

/***/ }),

/***/ "./node_modules/apollo-link/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/apollo-link/lib/index.js ***!
  \***********************************************/
/*! exports provided: createOperation, makePromise, toPromise, fromPromise, fromError, Observable, empty, from, split, concat, ApolloLink, execute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./link */ \"./node_modules/apollo-link/lib/link.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return _link__WEBPACK_IMPORTED_MODULE_0__[\"empty\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"from\", function() { return _link__WEBPACK_IMPORTED_MODULE_0__[\"from\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"split\", function() { return _link__WEBPACK_IMPORTED_MODULE_0__[\"split\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"concat\", function() { return _link__WEBPACK_IMPORTED_MODULE_0__[\"concat\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ApolloLink\", function() { return _link__WEBPACK_IMPORTED_MODULE_0__[\"ApolloLink\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"execute\", function() { return _link__WEBPACK_IMPORTED_MODULE_0__[\"execute\"]; });\n\n/* harmony import */ var _linkUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linkUtils */ \"./node_modules/apollo-link/lib/linkUtils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createOperation\", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"createOperation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"makePromise\", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"makePromise\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"toPromise\", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"toPromise\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fromPromise\", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"fromPromise\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"fromError\", function() { return _linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"fromError\"]; });\n\n/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zen-observable-ts */ \"./node_modules/zen-observable-ts/lib/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Observable\", function() { return zen_observable_ts__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-link/lib/index.js?");

/***/ }),

/***/ "./node_modules/apollo-link/lib/link.js":
/*!**********************************************!*\
  !*** ./node_modules/apollo-link/lib/link.js ***!
  \**********************************************/
/*! exports provided: empty, from, split, concat, ApolloLink, execute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"empty\", function() { return empty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"from\", function() { return from; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"split\", function() { return split; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"concat\", function() { return concat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ApolloLink\", function() { return ApolloLink; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"execute\", function() { return execute; });\n/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zen-observable-ts */ \"./node_modules/zen-observable-ts/lib/index.js\");\n/* harmony import */ var _linkUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linkUtils */ \"./node_modules/apollo-link/lib/linkUtils.js\");\n\n\nvar passthrough = function (op, forward) { return (forward ? forward(op) : zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of()); };\nvar toLink = function (handler) {\n    return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n};\nvar empty = function () {\n    return new ApolloLink(function (op, forward) { return zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of(); });\n};\nvar from = function (links) {\n    if (links.length === 0)\n        return empty();\n    return links.map(toLink).reduce(function (x, y) { return x.concat(y); });\n};\nvar split = function (test, left, right) {\n    if (right === void 0) { right = new ApolloLink(passthrough); }\n    var leftLink = toLink(left);\n    var rightLink = toLink(right);\n    if (Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"isTerminating\"])(leftLink) && Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"isTerminating\"])(rightLink)) {\n        return new ApolloLink(function (operation) {\n            return test(operation)\n                ? leftLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of()\n                : rightLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of();\n        });\n    }\n    else {\n        return new ApolloLink(function (operation, forward) {\n            return test(operation)\n                ? leftLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of()\n                : rightLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of();\n        });\n    }\n};\n// join two Links together\nvar concat = function (first, second) {\n    var firstLink = toLink(first);\n    if (Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"isTerminating\"])(firstLink)) {\n        console.warn(new _linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"LinkError\"](\"You are calling concat on a terminating link, which will have no effect\", firstLink));\n        return firstLink;\n    }\n    var nextLink = toLink(second);\n    if (Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"isTerminating\"])(nextLink)) {\n        return new ApolloLink(function (operation) {\n            return firstLink.request(operation, function (op) { return nextLink.request(op) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of(); }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of();\n        });\n    }\n    else {\n        return new ApolloLink(function (operation, forward) {\n            return (firstLink.request(operation, function (op) {\n                return nextLink.request(op, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of();\n            }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of());\n        });\n    }\n};\nvar ApolloLink = /** @class */ (function () {\n    function ApolloLink(request) {\n        if (request)\n            this.request = request;\n    }\n    ApolloLink.prototype.split = function (test, left, right) {\n        if (right === void 0) { right = new ApolloLink(passthrough); }\n        return this.concat(split(test, left, right));\n    };\n    ApolloLink.prototype.concat = function (next) {\n        return concat(this, next);\n    };\n    ApolloLink.prototype.request = function (operation, forward) {\n        throw new Error('request is not implemented');\n    };\n    ApolloLink.empty = empty;\n    ApolloLink.from = from;\n    ApolloLink.split = split;\n    ApolloLink.execute = execute;\n    return ApolloLink;\n}());\n\nfunction execute(link, operation) {\n    return (link.request(Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"createOperation\"])(operation.context, Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"transformOperation\"])(Object(_linkUtils__WEBPACK_IMPORTED_MODULE_1__[\"validateOperation\"])(operation)))) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of());\n}\n//# sourceMappingURL=link.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-link/lib/link.js?");

/***/ }),

/***/ "./node_modules/apollo-link/lib/linkUtils.js":
/*!***************************************************!*\
  !*** ./node_modules/apollo-link/lib/linkUtils.js ***!
  \***************************************************/
/*! exports provided: validateOperation, LinkError, isTerminating, toPromise, makePromise, fromPromise, fromError, transformOperation, createOperation, getKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateOperation\", function() { return validateOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinkError\", function() { return LinkError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTerminating\", function() { return isTerminating; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toPromise\", function() { return toPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makePromise\", function() { return makePromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromPromise\", function() { return fromPromise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromError\", function() { return fromError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformOperation\", function() { return transformOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createOperation\", function() { return createOperation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getKey\", function() { return getKey; });\n/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! apollo-utilities */ \"./node_modules/apollo-utilities/lib/index.js\");\n/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zen-observable-ts */ \"./node_modules/zen-observable-ts/lib/index.js\");\n/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphql/language/printer */ \"./node_modules/graphql/language/printer.js\");\n/* harmony import */ var graphql_language_printer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__);\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (undefined && undefined.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\nfunction validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        'query',\n        'operationName',\n        'variables',\n        'extensions',\n        'context',\n    ];\n    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw new Error(\"illegal argument: \" + key);\n        }\n    }\n    return operation;\n}\nvar LinkError = /** @class */ (function (_super) {\n    __extends(LinkError, _super);\n    function LinkError(message, link) {\n        var _this = _super.call(this, message) || this;\n        _this.link = link;\n        return _this;\n    }\n    return LinkError;\n}(Error));\n\nfunction isTerminating(link) {\n    return link.request.length <= 1;\n}\nfunction toPromise(observable) {\n    var completed = false;\n    return new Promise(function (resolve, reject) {\n        observable.subscribe({\n            next: function (data) {\n                if (completed) {\n                    console.warn(\"Promise Wrapper does not support multiple results from Observable\");\n                }\n                else {\n                    completed = true;\n                    resolve(data);\n                }\n            },\n            error: reject,\n        });\n    });\n}\n// backwards compat\nvar makePromise = toPromise;\nfunction fromPromise(promise) {\n    return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_1__[\"default\"](function (observer) {\n        promise\n            .then(function (value) {\n            observer.next(value);\n            observer.complete();\n        })\n            .catch(observer.error.bind(observer));\n    });\n}\nfunction fromError(errorValue) {\n    return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_1__[\"default\"](function (observer) {\n        observer.error(errorValue);\n    });\n}\nfunction transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query,\n    };\n    // best guess at an operation name\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName =\n            typeof transformedOperation.query !== 'string'\n                ? Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_0__[\"getOperationName\"])(transformedOperation.query)\n                : '';\n    }\n    return transformedOperation;\n}\nfunction createOperation(starting, operation) {\n    var context = __assign({}, starting);\n    var setContext = function (next) {\n        if (typeof next === 'function') {\n            context = __assign({}, context, next(context));\n        }\n        else {\n            context = __assign({}, context, next);\n        }\n    };\n    var getContext = function () { return (__assign({}, context)); };\n    Object.defineProperty(operation, 'setContext', {\n        enumerable: false,\n        value: setContext,\n    });\n    Object.defineProperty(operation, 'getContext', {\n        enumerable: false,\n        value: getContext,\n    });\n    Object.defineProperty(operation, 'toKey', {\n        enumerable: false,\n        value: function () { return getKey(operation); },\n    });\n    return operation;\n}\nfunction getKey(operation) {\n    // XXX we're assuming here that variables will be serialized in the same order.\n    // that might not always be true\n    return Object(graphql_language_printer__WEBPACK_IMPORTED_MODULE_2__[\"print\"])(operation.query) + \"|\" + JSON.stringify(operation.variables) + \"|\" + operation.operationName;\n}\n//# sourceMappingURL=linkUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-link/lib/linkUtils.js?");

/***/ }),

/***/ "./node_modules/apollo-server-caching/dist/InMemoryLRUCache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/apollo-server-caching/dist/InMemoryLRUCache.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LRU = __webpack_require__(/*! lru-cache */ \"lru-cache\");\nclass InMemoryLRUCache {\n    constructor({ maxSize = Infinity } = {}) {\n        this.store = LRU({\n            max: maxSize,\n            length: item => item.length,\n        });\n    }\n    get(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.store.get(key);\n        });\n    }\n    set(key, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.store.set(key, value);\n        });\n    }\n}\nexports.InMemoryLRUCache = InMemoryLRUCache;\n//# sourceMappingURL=InMemoryLRUCache.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-caching/dist/InMemoryLRUCache.js?");

/***/ }),

/***/ "./node_modules/apollo-server-caching/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-server-caching/dist/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar InMemoryLRUCache_1 = __webpack_require__(/*! ./InMemoryLRUCache */ \"./node_modules/apollo-server-caching/dist/InMemoryLRUCache.js\");\nexports.InMemoryLRUCache = InMemoryLRUCache_1.InMemoryLRUCache;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-caching/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/ApolloServer.js":
/*!**************************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/ApolloServer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_tools_1 = __webpack_require__(/*! graphql-tools */ \"./node_modules/graphql-tools/dist/index.js\");\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nconst apollo_engine_reporting_1 = __webpack_require__(/*! apollo-engine-reporting */ \"./node_modules/apollo-engine-reporting/dist/index.js\");\nconst apollo_server_caching_1 = __webpack_require__(/*! apollo-server-caching */ \"./node_modules/apollo-server-caching/dist/index.js\");\nconst subscriptions_transport_ws_1 = __webpack_require__(/*! subscriptions-transport-ws */ \"./node_modules/subscriptions-transport-ws/dist/index.js\");\nconst apollo_server_errors_1 = __webpack_require__(/*! apollo-server-errors */ \"./node_modules/apollo-server-errors/dist/index.js\");\nconst formatters_1 = __webpack_require__(/*! ./formatters */ \"./node_modules/apollo-server-core/dist/formatters.js\");\nconst index_1 = __webpack_require__(/*! ./index */ \"./node_modules/apollo-server-core/dist/index.js\");\nconst playground_1 = __webpack_require__(/*! ./playground */ \"./node_modules/apollo-server-core/dist/playground.js\");\nconst NoIntrospection = (context) => ({\n    Field(node) {\n        if (node.name.value === '__schema' || node.name.value === '__type') {\n            context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', [node]));\n        }\n    },\n});\nclass ApolloServerBase {\n    constructor(config) {\n        this.graphqlPath = '/graphql';\n        if (!config)\n            throw new Error('ApolloServer requires options.');\n        const { context, resolvers, schema, schemaDirectives, typeDefs, introspection, mocks, mockEntireSchema, extensions, engine, subscriptions, uploads, playground } = config, requestOptions = __rest(config, [\"context\", \"resolvers\", \"schema\", \"schemaDirectives\", \"typeDefs\", \"introspection\", \"mocks\", \"mockEntireSchema\", \"extensions\", \"engine\", \"subscriptions\", \"uploads\", \"playground\"]);\n        const isDev = \"development\" !== 'production';\n        if ((typeof introspection === 'boolean' && !introspection) ||\n            (introspection === undefined && !isDev)) {\n            const noIntro = [NoIntrospection];\n            requestOptions.validationRules = requestOptions.validationRules\n                ? requestOptions.validationRules.concat(noIntro)\n                : noIntro;\n        }\n        if (!requestOptions.cache) {\n            requestOptions.cache = new apollo_server_caching_1.InMemoryLRUCache();\n        }\n        if (requestOptions.persistedQueries !== false) {\n            if (!requestOptions.persistedQueries) {\n                requestOptions.persistedQueries = {\n                    cache: requestOptions.cache,\n                };\n            }\n        }\n        else {\n            delete requestOptions.persistedQueries;\n        }\n        this.requestOptions = requestOptions;\n        this.context = context;\n        if (uploads !== false) {\n            if (this.supportsUploads()) {\n                if (uploads === true || typeof uploads === 'undefined') {\n                    this.uploadsConfig = {};\n                }\n                else {\n                    this.uploadsConfig = uploads;\n                }\n            }\n            else if (uploads) {\n                throw new Error('This implementation of ApolloServer does not support file uploads because the environmnet cannot accept multi-part forms');\n            }\n        }\n        if (schema) {\n            this.schema = schema;\n        }\n        else {\n            if (!typeDefs) {\n                throw Error('Apollo Server requires either an existing schema or typeDefs');\n            }\n            let augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n            augmentedTypeDefs.push(index_1.gql `\n          enum CacheControlScope {\n            PUBLIC\n            PRIVATE\n          }\n\n          directive @cacheControl(\n            maxAge: Int\n            scope: CacheControlScope\n          ) on FIELD_DEFINITION | OBJECT | INTERFACE\n        `);\n            if (this.uploadsConfig) {\n                const { GraphQLUpload, } = __webpack_require__(/*! @apollographql/apollo-upload-server */ \"./node_modules/@apollographql/apollo-upload-server/lib/index.mjs\");\n                if (resolvers && !resolvers.Upload) {\n                    resolvers.Upload = GraphQLUpload;\n                }\n                augmentedTypeDefs.push(index_1.gql `\n            scalar Upload\n          `);\n            }\n            this.schema = graphql_tools_1.makeExecutableSchema({\n                typeDefs: augmentedTypeDefs,\n                schemaDirectives,\n                resolvers,\n            });\n        }\n        if (mocks || typeof mockEntireSchema !== 'undefined') {\n            graphql_tools_1.addMockFunctionsToSchema({\n                schema: this.schema,\n                mocks: typeof mocks === 'boolean' || typeof mocks === 'undefined'\n                    ? {}\n                    : mocks,\n                preserveResolvers: typeof mockEntireSchema === 'undefined' ? false : !mockEntireSchema,\n            });\n        }\n        this.extensions = [];\n        if (this.requestOptions.formatError) {\n            this.extensions.push(() => new formatters_1.FormatErrorExtension(this.requestOptions.formatError, this.requestOptions.debug));\n        }\n        if (engine || (engine !== false && process.env.ENGINE_API_KEY)) {\n            this.engineReportingAgent = new apollo_engine_reporting_1.EngineReportingAgent(engine === true ? {} : engine);\n            this.extensions.push(() => this.engineReportingAgent.newExtension());\n        }\n        if (extensions) {\n            this.extensions = [...this.extensions, ...extensions];\n        }\n        if (subscriptions !== false) {\n            if (this.supportsSubscriptions()) {\n                if (subscriptions === true || typeof subscriptions === 'undefined') {\n                    this.subscriptionServerOptions = {\n                        path: this.graphqlPath,\n                    };\n                }\n                else if (typeof subscriptions === 'string') {\n                    this.subscriptionServerOptions = { path: subscriptions };\n                }\n                else {\n                    this.subscriptionServerOptions = Object.assign({ path: this.graphqlPath }, subscriptions);\n                }\n                this.subscriptionsPath = this.subscriptionServerOptions.path;\n            }\n            else if (subscriptions) {\n                throw new Error('This implementation of ApolloServer does not support GraphQL subscriptions.');\n            }\n        }\n        this.playgroundOptions = playground_1.createPlaygroundOptions(playground);\n    }\n    setGraphQLPath(path) {\n        this.graphqlPath = path;\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.subscriptionServer)\n                yield this.subscriptionServer.close();\n            if (this.engineReportingAgent) {\n                this.engineReportingAgent.stop();\n                yield this.engineReportingAgent.sendReport();\n            }\n        });\n    }\n    installSubscriptionHandlers(server) {\n        if (!this.subscriptionServerOptions) {\n            if (this.supportsSubscriptions()) {\n                throw Error('Subscriptions are disabled, due to subscriptions set to false in the ApolloServer constructor');\n            }\n            else {\n                throw Error('Subscriptions are not supported, choose an integration, such as apollo-server-express that allows persistent connections');\n            }\n        }\n        const { onDisconnect, onConnect, keepAlive, path, } = this.subscriptionServerOptions;\n        this.subscriptionServer = subscriptions_transport_ws_1.SubscriptionServer.create({\n            schema: this.schema,\n            execute: graphql_1.execute,\n            subscribe: graphql_1.subscribe,\n            onConnect: onConnect\n                ? onConnect\n                : (connectionParams) => (Object.assign({}, connectionParams)),\n            onDisconnect: onDisconnect,\n            onOperation: (message, connection) => __awaiter(this, void 0, void 0, function* () {\n                connection.formatResponse = (value) => (Object.assign({}, value, { errors: value.errors &&\n                        apollo_server_errors_1.formatApolloErrors([...value.errors], {\n                            formatter: this.requestOptions.formatError,\n                            debug: this.requestOptions.debug,\n                        }) }));\n                let context = this.context ? this.context : { connection };\n                try {\n                    context =\n                        typeof this.context === 'function'\n                            ? yield this.context({ connection, payload: message.payload })\n                            : context;\n                }\n                catch (e) {\n                    throw apollo_server_errors_1.formatApolloErrors([e], {\n                        formatter: this.requestOptions.formatError,\n                        debug: this.requestOptions.debug,\n                    })[0];\n                }\n                return Object.assign({}, connection, { context });\n            }),\n            keepAlive,\n        }, {\n            server,\n            path,\n        });\n    }\n    supportsSubscriptions() {\n        return false;\n    }\n    supportsUploads() {\n        return false;\n    }\n    graphQLServerOptions(integrationContextArgument) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let context = this.context ? this.context : {};\n            try {\n                context =\n                    typeof this.context === 'function'\n                        ? yield this.context(integrationContextArgument || {})\n                        : context;\n            }\n            catch (error) {\n                context = () => {\n                    throw error;\n                };\n            }\n            return Object.assign({ schema: this.schema, extensions: this.extensions, context, persistedQueries: this.requestOptions\n                    .persistedQueries, fieldResolver: this.requestOptions.fieldResolver }, this.requestOptions);\n        });\n    }\n}\nexports.ApolloServerBase = ApolloServerBase;\n//# sourceMappingURL=ApolloServer.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/ApolloServer.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/caching.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/caching.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction calculateCacheControlHeaders(responses) {\n    let lowestMaxAge = Number.MAX_VALUE;\n    let publicOrPrivate = 'public';\n    for (const response of responses) {\n        const cacheControl = response.extensions && response.extensions.cacheControl;\n        if (!cacheControl ||\n            !cacheControl.hints ||\n            cacheControl.hints.length === 0 ||\n            cacheControl.version !== 1) {\n            if (cacheControl && cacheControl.version !== 1) {\n                console.warn('Invalid cacheControl version.');\n            }\n            return {};\n        }\n        const rootHints = new Set();\n        for (const hint of cacheControl.hints) {\n            if (hint.scope && hint.scope.toLowerCase() === 'private') {\n                publicOrPrivate = 'private';\n            }\n            if (hint.maxAge === undefined) {\n                continue;\n            }\n            if (hint.maxAge === 0) {\n                return {};\n            }\n            if (hint.maxAge < lowestMaxAge) {\n                lowestMaxAge = hint.maxAge;\n            }\n            if (hint.path.length === 1) {\n                rootHints.add(hint.path[0]);\n            }\n        }\n        if (response.data &&\n            Object.keys(response.data).find(rootKey => !rootHints.has(rootKey))) {\n            return {};\n        }\n    }\n    return {\n        'Cache-Control': `max-age=${lowestMaxAge}, ${publicOrPrivate}`,\n    };\n}\nexports.calculateCacheControlHeaders = calculateCacheControlHeaders;\n//# sourceMappingURL=caching.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/caching.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/formatters.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/formatters.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_extensions_1 = __webpack_require__(/*! graphql-extensions */ \"./node_modules/graphql-extensions/dist/index.js\");\nconst apollo_server_errors_1 = __webpack_require__(/*! apollo-server-errors */ \"./node_modules/apollo-server-errors/dist/index.js\");\nclass FormatErrorExtension extends graphql_extensions_1.GraphQLExtension {\n    constructor(formatError, debug = false) {\n        super();\n        this.formatError = formatError;\n        this.debug = debug;\n    }\n    willSendResponse(o) {\n        if (o.graphqlResponse.errors) {\n            return {\n                graphqlResponse: Object.assign({}, o.graphqlResponse, { errors: apollo_server_errors_1.formatApolloErrors(o.graphqlResponse.errors, {\n                        formatter: this.formatError,\n                        debug: this.debug,\n                    }) }),\n            };\n        }\n    }\n}\nexports.FormatErrorExtension = FormatErrorExtension;\n//# sourceMappingURL=formatters.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/formatters.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/graphqlOptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/graphqlOptions.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction resolveGraphqlOptions(options, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof options === 'function') {\n            return yield options(...args);\n        }\n        else {\n            return options;\n        }\n    });\n}\nexports.resolveGraphqlOptions = resolveGraphqlOptions;\n//# sourceMappingURL=graphqlOptions.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/graphqlOptions.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! apollo-server-env */ \"./node_modules/apollo-server-env/dist/index.js\");\nvar runQuery_1 = __webpack_require__(/*! ./runQuery */ \"./node_modules/apollo-server-core/dist/runQuery.js\");\nexports.runQuery = runQuery_1.runQuery;\nvar runHttpQuery_1 = __webpack_require__(/*! ./runHttpQuery */ \"./node_modules/apollo-server-core/dist/runHttpQuery.js\");\nexports.runHttpQuery = runHttpQuery_1.runHttpQuery;\nexports.HttpQueryError = runHttpQuery_1.HttpQueryError;\nvar graphqlOptions_1 = __webpack_require__(/*! ./graphqlOptions */ \"./node_modules/apollo-server-core/dist/graphqlOptions.js\");\nexports.resolveGraphqlOptions = graphqlOptions_1.resolveGraphqlOptions;\nvar apollo_server_errors_1 = __webpack_require__(/*! apollo-server-errors */ \"./node_modules/apollo-server-errors/dist/index.js\");\nexports.ApolloError = apollo_server_errors_1.ApolloError;\nexports.toApolloError = apollo_server_errors_1.toApolloError;\nexports.SyntaxError = apollo_server_errors_1.SyntaxError;\nexports.ValidationError = apollo_server_errors_1.ValidationError;\nexports.AuthenticationError = apollo_server_errors_1.AuthenticationError;\nexports.ForbiddenError = apollo_server_errors_1.ForbiddenError;\nexports.UserInputError = apollo_server_errors_1.UserInputError;\nexports.formatApolloErrors = apollo_server_errors_1.formatApolloErrors;\nvar nodeHttpToRequest_1 = __webpack_require__(/*! ./nodeHttpToRequest */ \"./node_modules/apollo-server-core/dist/nodeHttpToRequest.js\");\nexports.convertNodeHttpToRequest = nodeHttpToRequest_1.convertNodeHttpToRequest;\nvar playground_1 = __webpack_require__(/*! ./playground */ \"./node_modules/apollo-server-core/dist/playground.js\");\nexports.createPlaygroundOptions = playground_1.createPlaygroundOptions;\nexports.defaultPlaygroundOptions = playground_1.defaultPlaygroundOptions;\nvar ApolloServer_1 = __webpack_require__(/*! ./ApolloServer */ \"./node_modules/apollo-server-core/dist/ApolloServer.js\");\nexports.ApolloServerBase = ApolloServer_1.ApolloServerBase;\n__export(__webpack_require__(/*! ./types */ \"./node_modules/apollo-server-core/dist/types.js\"));\nconst graphql_tag_1 = __webpack_require__(/*! graphql-tag */ \"./node_modules/graphql-tag/src/index.js\");\nexports.gql = graphql_tag_1.default;\nconst apollo_upload_server_1 = __webpack_require__(/*! @apollographql/apollo-upload-server */ \"./node_modules/@apollographql/apollo-upload-server/lib/index.mjs\");\nexports.GraphQLUpload = apollo_upload_server_1.GraphQLUpload;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/nodeHttpToRequest.js":
/*!*******************************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/nodeHttpToRequest.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst apollo_server_env_1 = __webpack_require__(/*! apollo-server-env */ \"./node_modules/apollo-server-env/dist/index.js\");\nfunction convertNodeHttpToRequest(req) {\n    const headers = new apollo_server_env_1.Headers();\n    Object.keys(req.headers).forEach(key => {\n        const values = req.headers[key];\n        if (Array.isArray(values)) {\n            values.forEach(value => headers.append(key, value));\n        }\n        else {\n            headers.append(key, values);\n        }\n    });\n    return new apollo_server_env_1.Request(req.url, {\n        headers,\n        method: req.method,\n    });\n}\nexports.convertNodeHttpToRequest = convertNodeHttpToRequest;\n//# sourceMappingURL=nodeHttpToRequest.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/nodeHttpToRequest.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/playground.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/playground.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst playgroundVersion = '1.7.4';\nexports.defaultPlaygroundOptions = {\n    version: playgroundVersion,\n    settings: {\n        'general.betaUpdates': false,\n        'editor.theme': 'dark',\n        'editor.reuseHeaders': true,\n        'tracing.hideTracingResponse': true,\n        'editor.fontSize': 14,\n        'editor.fontFamily': `'Source Code Pro', 'Consolas', 'Inconsolata', 'Droid Sans Mono', 'Monaco', monospace`,\n        'request.credentials': 'omit',\n    },\n};\nfunction createPlaygroundOptions(playground = {}) {\n    const isDev = \"development\" !== 'production';\n    const enabled = typeof playground !== 'undefined' ? !!playground : isDev;\n    if (!enabled) {\n        return undefined;\n    }\n    const playgroundOverrides = typeof playground === 'boolean' ? {} : playground || {};\n    const settingsOverrides = playgroundOverrides.hasOwnProperty('settings')\n        ? {\n            settings: Object.assign({}, exports.defaultPlaygroundOptions.settings, playgroundOverrides.settings),\n        }\n        : { settings: undefined };\n    const playgroundOptions = Object.assign({}, exports.defaultPlaygroundOptions, playgroundOverrides, settingsOverrides);\n    return playgroundOptions;\n}\nexports.createPlaygroundOptions = createPlaygroundOptions;\n//# sourceMappingURL=playground.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/playground.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/runHttpQuery.js":
/*!**************************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/runHttpQuery.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sha256 = __webpack_require__(/*! hash.js/lib/hash/sha/256 */ \"hash.js/lib/hash/sha/256\");\nconst lodash_1 = __webpack_require__(/*! lodash */ \"lodash\");\nconst runQuery_1 = __webpack_require__(/*! ./runQuery */ \"./node_modules/apollo-server-core/dist/runQuery.js\");\nconst graphqlOptions_1 = __webpack_require__(/*! ./graphqlOptions */ \"./node_modules/apollo-server-core/dist/graphqlOptions.js\");\nconst apollo_server_errors_1 = __webpack_require__(/*! apollo-server-errors */ \"./node_modules/apollo-server-errors/dist/index.js\");\nconst caching_1 = __webpack_require__(/*! ./caching */ \"./node_modules/apollo-server-core/dist/caching.js\");\nfunction prettyJSONStringify(value) {\n    return JSON.stringify(value) + '\\n';\n}\nclass HttpQueryError extends Error {\n    constructor(statusCode, message, isGraphQLError = false, headers) {\n        super(message);\n        this.name = 'HttpQueryError';\n        this.statusCode = statusCode;\n        this.isGraphQLError = isGraphQLError;\n        this.headers = headers;\n    }\n}\nexports.HttpQueryError = HttpQueryError;\nfunction throwHttpGraphQLError(statusCode, errors, optionsObject) {\n    throw new HttpQueryError(statusCode, prettyJSONStringify({\n        errors: optionsObject\n            ? apollo_server_errors_1.formatApolloErrors(errors, {\n                debug: optionsObject.debug,\n                formatter: optionsObject.formatError,\n            })\n            : errors,\n    }), true, {\n        'Content-Type': 'application/json',\n    });\n}\nfunction runHttpQuery(handlerArguments, request) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let isGetRequest = false;\n        let optionsObject;\n        const debugDefault = \"development\" !== 'production' && \"development\" !== 'test';\n        let cacheControl;\n        try {\n            optionsObject = yield graphqlOptions_1.resolveGraphqlOptions(request.options, ...handlerArguments);\n        }\n        catch (e) {\n            e.message = `Invalid options provided to ApolloServer: ${e.message}`;\n            if (!debugDefault) {\n                e.warning = `To remove the stacktrace, set the NODE_ENV environment variable to production if the options creation can fail`;\n            }\n            return throwHttpGraphQLError(500, [e], { debug: debugDefault });\n        }\n        if (optionsObject.debug === undefined) {\n            optionsObject.debug = debugDefault;\n        }\n        let requestPayload;\n        switch (request.method) {\n            case 'POST':\n                if (!request.query || Object.keys(request.query).length === 0) {\n                    throw new HttpQueryError(500, 'POST body missing. Did you forget use body-parser middleware?');\n                }\n                requestPayload = request.query;\n                break;\n            case 'GET':\n                if (!request.query || Object.keys(request.query).length === 0) {\n                    throw new HttpQueryError(400, 'GET query missing.');\n                }\n                isGetRequest = true;\n                requestPayload = request.query;\n                break;\n            default:\n                throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {\n                    Allow: 'GET, POST',\n                });\n        }\n        let isBatch = true;\n        if (!Array.isArray(requestPayload)) {\n            isBatch = false;\n            requestPayload = [requestPayload];\n        }\n        const requests = requestPayload.map((requestParams) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                let queryString = requestParams.query;\n                let extensions = requestParams.extensions;\n                let persistedQueryHit = false;\n                let persistedQueryRegister = false;\n                if (isGetRequest && extensions) {\n                    try {\n                        extensions = JSON.parse(extensions);\n                    }\n                    catch (error) {\n                        throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n                    }\n                }\n                if (extensions && extensions.persistedQuery) {\n                    if (!optionsObject.persistedQueries ||\n                        !optionsObject.persistedQueries.cache) {\n                        if (isBatch) {\n                            throw new apollo_server_errors_1.PersistedQueryNotSupportedError();\n                        }\n                        return throwHttpGraphQLError(200, [new apollo_server_errors_1.PersistedQueryNotSupportedError()], optionsObject);\n                    }\n                    else if (extensions.persistedQuery.version !== 1) {\n                        throw new HttpQueryError(400, 'Unsupported persisted query version');\n                    }\n                    const sha = extensions.persistedQuery.sha256Hash;\n                    if (queryString === undefined) {\n                        queryString =\n                            (yield optionsObject.persistedQueries.cache.get(`apq:${sha}`)) ||\n                                undefined;\n                        if (queryString) {\n                            persistedQueryHit = true;\n                        }\n                        else {\n                            if (isBatch) {\n                                throw new apollo_server_errors_1.PersistedQueryNotFoundError();\n                            }\n                            return throwHttpGraphQLError(200, [new apollo_server_errors_1.PersistedQueryNotFoundError()], optionsObject);\n                        }\n                    }\n                    else {\n                        const calculatedSha = sha256()\n                            .update(queryString)\n                            .digest('hex');\n                        if (sha !== calculatedSha) {\n                            throw new HttpQueryError(400, 'provided sha does not match query');\n                        }\n                        persistedQueryRegister = true;\n                        (() => __awaiter(this, void 0, void 0, function* () {\n                            return (optionsObject.persistedQueries &&\n                                optionsObject.persistedQueries.cache.set(`apq:${sha}`, queryString));\n                        }))().catch(error => {\n                            console.warn(error);\n                        });\n                    }\n                }\n                if (!queryString) {\n                    throw new HttpQueryError(400, 'Must provide query string.');\n                }\n                if (typeof queryString !== 'string') {\n                    if (queryString && queryString.kind === 'Document') {\n                        throw new HttpQueryError(400, \"GraphQL queries must be strings. It looks like you're sending the \" +\n                            'internal graphql-js representation of a parsed query in your ' +\n                            'request instead of a request in the GraphQL query language. You ' +\n                            'can convert an AST to a string using the `print` function from ' +\n                            '`graphql`, or use a client like `apollo-client` which converts ' +\n                            'the internal representation to a string for you.');\n                    }\n                    throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n                }\n                let nonQueryError;\n                if (isGetRequest) {\n                    nonQueryError = new HttpQueryError(405, `GET supports only query operation`, false, {\n                        Allow: 'POST',\n                    });\n                }\n                const operationName = requestParams.operationName;\n                let variables = requestParams.variables;\n                if (typeof variables === 'string') {\n                    try {\n                        variables = JSON.parse(variables);\n                    }\n                    catch (error) {\n                        throw new HttpQueryError(400, 'Variables are invalid JSON.');\n                    }\n                }\n                let context = optionsObject.context;\n                if (!context) {\n                    context = {};\n                }\n                else if (typeof context === 'function') {\n                    try {\n                        context = yield context();\n                    }\n                    catch (e) {\n                        e.message = `Context creation failed: ${e.message}`;\n                        if (e.extensions &&\n                            e.extensions.code &&\n                            e.extensions.code !== 'INTERNAL_SERVER_ERROR') {\n                            return throwHttpGraphQLError(400, [e], optionsObject);\n                        }\n                        else {\n                            return throwHttpGraphQLError(500, [e], optionsObject);\n                        }\n                    }\n                }\n                else {\n                    context = Object.assign(Object.create(Object.getPrototypeOf(context)), context);\n                }\n                if (optionsObject.dataSources) {\n                    const dataSources = optionsObject.dataSources() || {};\n                    for (const dataSource of Object.values(dataSources)) {\n                        if (dataSource.initialize) {\n                            dataSource.initialize({ context, cache: optionsObject.cache });\n                        }\n                    }\n                    if ('dataSources' in context) {\n                        throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');\n                    }\n                    context.dataSources = dataSources;\n                }\n                if (optionsObject.cacheControl !== false) {\n                    if (typeof optionsObject.cacheControl === 'boolean' &&\n                        optionsObject.cacheControl === true) {\n                        cacheControl = {\n                            stripFormattedExtensions: false,\n                            calculateHttpHeaders: false,\n                            defaultMaxAge: 0,\n                        };\n                    }\n                    else {\n                        cacheControl = Object.assign({ stripFormattedExtensions: true, calculateHttpHeaders: true, defaultMaxAge: 0 }, optionsObject.cacheControl);\n                    }\n                }\n                let params = {\n                    schema: optionsObject.schema,\n                    queryString,\n                    nonQueryError,\n                    variables: variables,\n                    context,\n                    rootValue: optionsObject.rootValue,\n                    operationName: operationName,\n                    validationRules: optionsObject.validationRules,\n                    formatError: optionsObject.formatError,\n                    formatResponse: optionsObject.formatResponse,\n                    fieldResolver: optionsObject.fieldResolver,\n                    debug: optionsObject.debug,\n                    tracing: optionsObject.tracing,\n                    cacheControl: cacheControl\n                        ? lodash_1.omit(cacheControl, [\n                            'calculateHttpHeaders',\n                            'stripFormattedExtensions',\n                        ])\n                        : false,\n                    request: request.request,\n                    extensions: optionsObject.extensions,\n                    persistedQueryHit,\n                    persistedQueryRegister,\n                };\n                return runQuery_1.runQuery(params);\n            }\n            catch (e) {\n                if (e.name === 'HttpQueryError') {\n                    throw e;\n                }\n                return {\n                    errors: apollo_server_errors_1.formatApolloErrors([e], optionsObject),\n                };\n            }\n        }));\n        let responses;\n        try {\n            responses = yield Promise.all(requests);\n        }\n        catch (e) {\n            if (e.name === 'HttpQueryError') {\n                throw e;\n            }\n            return throwHttpGraphQLError(500, [e], optionsObject);\n        }\n        const responseInit = {\n            headers: {\n                'Content-Type': 'application/json',\n            },\n        };\n        if (cacheControl) {\n            if (cacheControl.calculateHttpHeaders) {\n                const calculatedHeaders = caching_1.calculateCacheControlHeaders(responses);\n                responseInit.headers = Object.assign({}, responseInit.headers, calculatedHeaders);\n            }\n            if (cacheControl.stripFormattedExtensions) {\n                responses.forEach(response => {\n                    if (response.extensions) {\n                        delete response.extensions.cacheControl;\n                        if (Object.keys(response.extensions).length === 0) {\n                            delete response.extensions;\n                        }\n                    }\n                });\n            }\n        }\n        if (!isBatch) {\n            const graphqlResponse = responses[0];\n            if (graphqlResponse.errors && typeof graphqlResponse.data === 'undefined') {\n                return throwHttpGraphQLError(400, graphqlResponse.errors);\n            }\n            const stringified = prettyJSONStringify(graphqlResponse);\n            responseInit.headers['Content-Length'] = Buffer.byteLength(stringified, 'utf8').toString();\n            return {\n                graphqlResponse: stringified,\n                responseInit,\n            };\n        }\n        const stringified = prettyJSONStringify(responses);\n        responseInit.headers['Content-Length'] = Buffer.byteLength(stringified, 'utf8').toString();\n        return {\n            graphqlResponse: stringified,\n            responseInit,\n        };\n    });\n}\nexports.runHttpQuery = runHttpQuery;\n//# sourceMappingURL=runHttpQuery.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/runHttpQuery.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/runQuery.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/runQuery.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nconst graphql_extensions_1 = __webpack_require__(/*! graphql-extensions */ \"./node_modules/graphql-extensions/dist/index.js\");\nconst apollo_tracing_1 = __webpack_require__(/*! apollo-tracing */ \"./node_modules/apollo-tracing/dist/index.js\");\nconst apollo_cache_control_1 = __webpack_require__(/*! apollo-cache-control */ \"./node_modules/apollo-cache-control/dist/index.js\");\nconst apollo_server_errors_1 = __webpack_require__(/*! apollo-server-errors */ \"./node_modules/apollo-server-errors/dist/index.js\");\nfunction isQueryOperation(query, operationName) {\n    const operationAST = graphql_1.getOperationAST(query, operationName);\n    return operationAST && operationAST.operation === 'query';\n}\nfunction runQuery(options) {\n    return Promise.resolve().then(() => doRunQuery(options));\n}\nexports.runQuery = runQuery;\nfunction doRunQuery(options) {\n    if (options.queryString && options.parsedQuery) {\n        throw new Error('Only supply one of queryString and parsedQuery');\n    }\n    if (!(options.queryString || options.parsedQuery)) {\n        throw new Error('Must supply one of queryString and parsedQuery');\n    }\n    const debugDefault = \"development\" !== 'production' && \"development\" !== 'test';\n    const debug = options.debug !== undefined ? options.debug : debugDefault;\n    const context = options.context || {};\n    const extensions = options.extensions ? options.extensions.map(f => f()) : [];\n    if (options.tracing) {\n        extensions.push(new apollo_tracing_1.TracingExtension());\n    }\n    if (options.cacheControl === true) {\n        extensions.push(new apollo_cache_control_1.CacheControlExtension());\n    }\n    else if (options.cacheControl) {\n        extensions.push(new apollo_cache_control_1.CacheControlExtension(options.cacheControl));\n    }\n    const extensionStack = new graphql_extensions_1.GraphQLExtensionStack(extensions);\n    if (extensions.length > 0) {\n        graphql_extensions_1.enableGraphQLExtensions(options.schema);\n    }\n    context._extensionStack = extensionStack;\n    const requestDidEnd = extensionStack.requestDidStart({\n        request: options.request,\n        queryString: options.queryString,\n        parsedQuery: options.parsedQuery,\n        operationName: options.operationName,\n        variables: options.variables,\n        persistedQueryHit: options.persistedQueryHit,\n        persistedQueryRegister: options.persistedQueryRegister,\n    });\n    return Promise.resolve()\n        .then(() => {\n        let documentAST;\n        if (options.parsedQuery) {\n            documentAST = options.parsedQuery;\n        }\n        else if (!options.queryString) {\n            throw new Error('Must supply one of queryString and parsedQuery');\n        }\n        else {\n            const parsingDidEnd = extensionStack.parsingDidStart({\n                queryString: options.queryString,\n            });\n            let graphqlParseErrors;\n            try {\n                documentAST = graphql_1.parse(options.queryString);\n            }\n            catch (syntaxError) {\n                graphqlParseErrors = apollo_server_errors_1.formatApolloErrors([\n                    apollo_server_errors_1.fromGraphQLError(syntaxError, {\n                        errorClass: apollo_server_errors_1.SyntaxError,\n                    }),\n                ], {\n                    debug,\n                });\n                return Promise.resolve({ errors: graphqlParseErrors });\n            }\n            finally {\n                parsingDidEnd(...(graphqlParseErrors || []));\n            }\n        }\n        if (options.nonQueryError &&\n            !isQueryOperation(documentAST, options.operationName)) {\n            throw options.nonQueryError;\n        }\n        let rules = graphql_1.specifiedRules;\n        if (options.validationRules) {\n            rules = rules.concat(options.validationRules);\n        }\n        const validationDidEnd = extensionStack.validationDidStart();\n        let validationErrors;\n        try {\n            validationErrors = graphql_1.validate(options.schema, documentAST, rules);\n        }\n        catch (validationThrewError) {\n            validationErrors = [validationThrewError];\n        }\n        finally {\n            try {\n                if (validationErrors) {\n                    validationErrors = apollo_server_errors_1.formatApolloErrors(validationErrors.map(err => apollo_server_errors_1.fromGraphQLError(err, { errorClass: apollo_server_errors_1.ValidationError })), {\n                        debug,\n                    });\n                }\n            }\n            finally {\n                validationDidEnd(...(validationErrors || []));\n                if (validationErrors && validationErrors.length) {\n                    return Promise.resolve({\n                        errors: validationErrors,\n                    });\n                }\n            }\n        }\n        const executionArgs = {\n            schema: options.schema,\n            document: documentAST,\n            rootValue: options.rootValue,\n            contextValue: context,\n            variableValues: options.variables,\n            operationName: options.operationName,\n            fieldResolver: options.fieldResolver,\n        };\n        const executionDidEnd = extensionStack.executionDidStart({\n            executionArgs,\n        });\n        return Promise.resolve()\n            .then(() => graphql_1.execute(executionArgs))\n            .catch(executionError => {\n            return {\n                errors: [apollo_server_errors_1.fromGraphQLError(executionError)],\n            };\n        })\n            .then(result => {\n            let response = {\n                data: result.data,\n            };\n            if (result.errors) {\n                response.errors = apollo_server_errors_1.formatApolloErrors([...result.errors], {\n                    debug,\n                });\n            }\n            executionDidEnd(...(result.errors || []));\n            const formattedExtensions = extensionStack.format();\n            if (Object.keys(formattedExtensions).length > 0) {\n                response.extensions = formattedExtensions;\n            }\n            if (options.formatResponse) {\n                response = options.formatResponse(response, options);\n            }\n            return response;\n        });\n    })\n        .catch((err) => {\n        requestDidEnd(err);\n        throw err;\n    })\n        .then((graphqlResponse) => {\n        const response = extensionStack.willSendResponse({ graphqlResponse });\n        requestDidEnd();\n        return response.graphqlResponse;\n    });\n}\n//# sourceMappingURL=runQuery.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/runQuery.js?");

/***/ }),

/***/ "./node_modules/apollo-server-core/dist/types.js":
/*!*******************************************************!*\
  !*** ./node_modules/apollo-server-core/dist/types.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_extensions_1 = __webpack_require__(/*! graphql-extensions */ \"./node_modules/graphql-extensions/dist/index.js\");\nexports.GraphQLExtension = graphql_extensions_1.GraphQLExtension;\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-core/dist/types.js?");

/***/ }),

/***/ "./node_modules/apollo-server-env/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/apollo-server-env/dist/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(/*! ./polyfills/Object.values */ \"./node_modules/apollo-server-env/dist/polyfills/Object.values.js\");\n__webpack_require__(/*! ./polyfills/Object.entries */ \"./node_modules/apollo-server-env/dist/polyfills/Object.entries.js\");\n__webpack_require__(/*! util.promisify */ \"util.promisify\").shim();\n__export(__webpack_require__(/*! ./polyfills/fetch */ \"./node_modules/apollo-server-env/dist/polyfills/fetch.js\"));\n__export(__webpack_require__(/*! ./polyfills/url */ \"./node_modules/apollo-server-env/dist/polyfills/url.js\"));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-env/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-server-env/dist/polyfills/Object.entries.js":
/*!*************************************************************************!*\
  !*** ./node_modules/apollo-server-env/dist/polyfills/Object.entries.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nif (!global.Object.entries) {\n    global.Object.entries = function (object) {\n        return Object.keys(object).map(key => [key, object[key]]);\n    };\n}\n//# sourceMappingURL=Object.entries.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-env/dist/polyfills/Object.entries.js?");

/***/ }),

/***/ "./node_modules/apollo-server-env/dist/polyfills/Object.values.js":
/*!************************************************************************!*\
  !*** ./node_modules/apollo-server-env/dist/polyfills/Object.values.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nif (!global.Object.values) {\n    global.Object.values = function (object) {\n        return Object.keys(object).map(key => object[key]);\n    };\n}\n//# sourceMappingURL=Object.values.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-env/dist/polyfills/Object.values.js?");

/***/ }),

/***/ "./node_modules/apollo-server-env/dist/polyfills/fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-server-env/dist/polyfills/fetch.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar node_fetch_1 = __webpack_require__(/*! node-fetch */ \"node-fetch\");\nexports.fetch = node_fetch_1.default;\nexports.Request = node_fetch_1.Request;\nexports.Response = node_fetch_1.Response;\nexports.Headers = node_fetch_1.Headers;\n//# sourceMappingURL=fetch.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-env/dist/polyfills/fetch.js?");

/***/ }),

/***/ "./node_modules/apollo-server-env/dist/polyfills/url.js":
/*!**************************************************************!*\
  !*** ./node_modules/apollo-server-env/dist/polyfills/url.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar url_1 = __webpack_require__(/*! url */ \"url\");\nexports.URL = url_1.URL;\nexports.URLSearchParams = url_1.URLSearchParams;\n//# sourceMappingURL=url.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-env/dist/polyfills/url.js?");

/***/ }),

/***/ "./node_modules/apollo-server-errors/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-server-errors/dist/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nclass ApolloError extends Error {\n    constructor(message, code, properties) {\n        super(message);\n        if (properties) {\n            Object.keys(properties).forEach(key => {\n                this[key] = properties[key];\n            });\n        }\n        if (!this.name) {\n            Object.defineProperty(this, 'name', { value: 'ApolloError' });\n        }\n        this.extensions = { code };\n    }\n}\nexports.ApolloError = ApolloError;\nfunction enrichError(error, debug = false) {\n    const expanded = Object.create(Object.getPrototypeOf(error), {\n        name: {\n            value: error.name,\n        },\n        message: {\n            value: error.message,\n            enumerable: true,\n            writable: true,\n        },\n        locations: {\n            value: error.locations || undefined,\n            enumerable: true,\n        },\n        path: {\n            value: error.path || undefined,\n            enumerable: true,\n        },\n        nodes: {\n            value: error.nodes || undefined,\n        },\n        source: {\n            value: error.source || undefined,\n        },\n        positions: {\n            value: error.positions || undefined,\n        },\n        originalError: {\n            value: error.originalError,\n        },\n    });\n    expanded.extensions = Object.assign({}, error.extensions, { code: (error.extensions && error.extensions.code) || 'INTERNAL_SERVER_ERROR', exception: Object.assign({}, (error.extensions && error.extensions.exception), error.originalError) });\n    delete expanded.extensions.exception.extensions;\n    if (debug && !expanded.extensions.exception.stacktrace) {\n        expanded.extensions.exception.stacktrace =\n            (error.originalError &&\n                error.originalError.stack &&\n                error.originalError.stack.split('\\n')) ||\n                (error.stack && error.stack.split('\\n'));\n    }\n    if (Object.keys(expanded.extensions.exception).length === 0) {\n        delete expanded.extensions.exception;\n    }\n    return expanded;\n}\nfunction toApolloError(error, code = 'INTERNAL_SERVER_ERROR') {\n    let err = error;\n    if (err.extensions) {\n        err.extensions.code = code;\n    }\n    else {\n        err.extensions = { code };\n    }\n    return err;\n}\nexports.toApolloError = toApolloError;\nfunction fromGraphQLError(error, options) {\n    const copy = options && options.errorClass\n        ? new options.errorClass(error.message)\n        : new ApolloError(error.message);\n    Object.keys(error).forEach(key => {\n        copy[key] = error[key];\n    });\n    copy.extensions = Object.assign({}, copy.extensions, error.extensions);\n    if (!copy.extensions.code) {\n        copy.extensions.code = (options && options.code) || 'INTERNAL_SERVER_ERROR';\n    }\n    Object.defineProperty(copy, 'originalError', { value: {} });\n    Object.getOwnPropertyNames(error).forEach(key => {\n        Object.defineProperty(copy.originalError, key, { value: error[key] });\n    });\n    return copy;\n}\nexports.fromGraphQLError = fromGraphQLError;\nclass SyntaxError extends ApolloError {\n    constructor(message) {\n        super(message, 'GRAPHQL_PARSE_FAILED');\n        Object.defineProperty(this, 'name', { value: 'SyntaxError' });\n    }\n}\nexports.SyntaxError = SyntaxError;\nclass ValidationError extends ApolloError {\n    constructor(message) {\n        super(message, 'GRAPHQL_VALIDATION_FAILED');\n        Object.defineProperty(this, 'name', { value: 'ValidationError' });\n    }\n}\nexports.ValidationError = ValidationError;\nclass AuthenticationError extends ApolloError {\n    constructor(message) {\n        super(message, 'UNAUTHENTICATED');\n        Object.defineProperty(this, 'name', { value: 'AuthenticationError' });\n    }\n}\nexports.AuthenticationError = AuthenticationError;\nclass ForbiddenError extends ApolloError {\n    constructor(message) {\n        super(message, 'FORBIDDEN');\n        Object.defineProperty(this, 'name', { value: 'ForbiddenError' });\n    }\n}\nexports.ForbiddenError = ForbiddenError;\nclass PersistedQueryNotFoundError extends ApolloError {\n    constructor() {\n        super('PersistedQueryNotFound', 'PERSISTED_QUERY_NOT_FOUND');\n        Object.defineProperty(this, 'name', {\n            value: 'PersistedQueryNotFoundError',\n        });\n    }\n}\nexports.PersistedQueryNotFoundError = PersistedQueryNotFoundError;\nclass PersistedQueryNotSupportedError extends ApolloError {\n    constructor() {\n        super('PersistedQueryNotSupported', 'PERSISTED_QUERY_NOT_SUPPORTED');\n        Object.defineProperty(this, 'name', {\n            value: 'PersistedQueryNotSupportedError',\n        });\n    }\n}\nexports.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;\nclass UserInputError extends ApolloError {\n    constructor(message, properties) {\n        super(message, 'BAD_USER_INPUT', properties);\n        Object.defineProperty(this, 'name', { value: 'UserInputError' });\n    }\n}\nexports.UserInputError = UserInputError;\nfunction formatApolloErrors(errors, options) {\n    if (!options) {\n        return errors.map(error => enrichError(error));\n    }\n    const { formatter, debug } = options;\n    const enrichedErrors = errors.map(error => enrichError(error, debug));\n    if (!formatter) {\n        return enrichedErrors;\n    }\n    return enrichedErrors.map(error => {\n        try {\n            return formatter(error);\n        }\n        catch (err) {\n            if (debug) {\n                return enrichError(err, debug);\n            }\n            else {\n                const newError = fromGraphQLError(new graphql_1.GraphQLError('Internal server error'));\n                return enrichError(newError, debug);\n            }\n        }\n    });\n}\nexports.formatApolloErrors = formatApolloErrors;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-errors/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-server-express/dist/ApolloServer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/apollo-server-express/dist/ApolloServer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst corsMiddleware = __webpack_require__(/*! cors */ \"cors\");\nconst body_parser_1 = __webpack_require__(/*! body-parser */ \"body-parser\");\nconst graphql_playground_html_1 = __webpack_require__(/*! @apollographql/graphql-playground-html */ \"./node_modules/@apollographql/graphql-playground-html/dist/index.js\");\nconst apollo_server_core_1 = __webpack_require__(/*! apollo-server-core */ \"./node_modules/apollo-server-core/dist/index.js\");\nconst accepts = __webpack_require__(/*! accepts */ \"accepts\");\nconst typeis = __webpack_require__(/*! type-is */ \"type-is\");\nconst expressApollo_1 = __webpack_require__(/*! ./expressApollo */ \"./node_modules/apollo-server-express/dist/expressApollo.js\");\nconst apollo_upload_server_1 = __webpack_require__(/*! @apollographql/apollo-upload-server */ \"./node_modules/@apollographql/apollo-upload-server/lib/index.mjs\");\nvar apollo_server_core_2 = __webpack_require__(/*! apollo-server-core */ \"./node_modules/apollo-server-core/dist/index.js\");\nexports.GraphQLExtension = apollo_server_core_2.GraphQLExtension;\nconst fileUploadMiddleware = (uploadsConfig, server) => (req, res, next) => {\n    if (typeis(req, ['multipart/form-data'])) {\n        apollo_upload_server_1.processRequest(req, uploadsConfig)\n            .then(body => {\n            req.body = body;\n            next();\n        })\n            .catch(error => {\n            if (error.status && error.expose)\n                res.status(error.status);\n            next(apollo_server_core_1.formatApolloErrors([error], {\n                formatter: server.requestOptions.formatError,\n                debug: server.requestOptions.debug,\n            }));\n        });\n    }\n    else {\n        next();\n    }\n};\nclass ApolloServer extends apollo_server_core_1.ApolloServerBase {\n    createGraphQLServerOptions(req, res) {\n        const _super = name => super[name];\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super(\"graphQLServerOptions\").call(this, { req, res });\n        });\n    }\n    supportsSubscriptions() {\n        return true;\n    }\n    supportsUploads() {\n        return true;\n    }\n    applyMiddleware({ app, path, cors, bodyParserConfig, disableHealthCheck, onHealthCheck, }) {\n        if (!path)\n            path = '/graphql';\n        if (!disableHealthCheck) {\n            app.use('/.well-known/apollo/server-health', (req, res) => {\n                res.type('application/health+json');\n                if (onHealthCheck) {\n                    onHealthCheck(req)\n                        .then(() => {\n                        res.json({ status: 'pass' });\n                    })\n                        .catch(() => {\n                        res.status(503).json({ status: 'fail' });\n                    });\n                }\n                else {\n                    res.json({ status: 'pass' });\n                }\n            });\n        }\n        let uploadsMiddleware;\n        if (this.uploadsConfig) {\n            uploadsMiddleware = fileUploadMiddleware(this.uploadsConfig, this);\n        }\n        this.graphqlPath = path;\n        if (cors === true) {\n            app.use(path, corsMiddleware());\n        }\n        else if (cors !== false) {\n            app.use(path, corsMiddleware(cors));\n        }\n        if (bodyParserConfig === true) {\n            app.use(path, body_parser_1.json());\n        }\n        else if (bodyParserConfig !== false) {\n            app.use(path, body_parser_1.json(bodyParserConfig));\n        }\n        if (uploadsMiddleware) {\n            app.use(path, uploadsMiddleware);\n        }\n        app.use(path, (req, res, next) => {\n            if (this.playgroundOptions && req.method === 'GET') {\n                const accept = accepts(req);\n                const types = accept.types();\n                const prefersHTML = types.find((x) => x === 'text/html' || x === 'application/json') === 'text/html';\n                if (prefersHTML) {\n                    const playgroundRenderPageOptions = Object.assign({ endpoint: path, subscriptionEndpoint: this.subscriptionsPath }, this.playgroundOptions);\n                    res.setHeader('Content-Type', 'text/html');\n                    const playground = graphql_playground_html_1.renderPlaygroundPage(playgroundRenderPageOptions);\n                    res.write(playground);\n                    res.end();\n                    return;\n                }\n            }\n            return expressApollo_1.graphqlExpress(this.createGraphQLServerOptions.bind(this))(req, res, next);\n        });\n    }\n}\nexports.ApolloServer = ApolloServer;\nexports.registerServer = () => {\n    throw new Error('Please use server.applyMiddleware instead of registerServer. This warning will be removed in the next release');\n};\n//# sourceMappingURL=ApolloServer.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-express/dist/ApolloServer.js?");

/***/ }),

/***/ "./node_modules/apollo-server-express/dist/expressApollo.js":
/*!******************************************************************!*\
  !*** ./node_modules/apollo-server-express/dist/expressApollo.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst apollo_server_core_1 = __webpack_require__(/*! apollo-server-core */ \"./node_modules/apollo-server-core/dist/index.js\");\nfunction graphqlExpress(options) {\n    if (!options) {\n        throw new Error('Apollo Server requires options.');\n    }\n    if (arguments.length > 1) {\n        throw new Error(`Apollo Server expects exactly one argument, got ${arguments.length}`);\n    }\n    const graphqlHandler = (req, res, next) => {\n        apollo_server_core_1.runHttpQuery([req, res], {\n            method: req.method,\n            options: options,\n            query: req.method === 'POST' ? req.body : req.query,\n            request: apollo_server_core_1.convertNodeHttpToRequest(req),\n        }).then(({ graphqlResponse, responseInit }) => {\n            Object.keys(responseInit.headers).forEach(key => res.setHeader(key, responseInit.headers[key]));\n            res.write(graphqlResponse);\n            res.end();\n        }, (error) => {\n            if ('HttpQueryError' !== error.name) {\n                return next(error);\n            }\n            if (error.headers) {\n                Object.keys(error.headers).forEach(header => {\n                    res.setHeader(header, error.headers[header]);\n                });\n            }\n            res.statusCode = error.statusCode;\n            res.write(error.message);\n            res.end();\n        });\n    };\n    return graphqlHandler;\n}\nexports.graphqlExpress = graphqlExpress;\n//# sourceMappingURL=expressApollo.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-express/dist/expressApollo.js?");

/***/ }),

/***/ "./node_modules/apollo-server-express/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-server-express/dist/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar apollo_server_core_1 = __webpack_require__(/*! apollo-server-core */ \"./node_modules/apollo-server-core/dist/index.js\");\nexports.GraphQLUpload = apollo_server_core_1.GraphQLUpload;\nexports.GraphQLExtension = apollo_server_core_1.GraphQLExtension;\nexports.gql = apollo_server_core_1.gql;\nexports.ApolloError = apollo_server_core_1.ApolloError;\nexports.toApolloError = apollo_server_core_1.toApolloError;\nexports.SyntaxError = apollo_server_core_1.SyntaxError;\nexports.ValidationError = apollo_server_core_1.ValidationError;\nexports.AuthenticationError = apollo_server_core_1.AuthenticationError;\nexports.ForbiddenError = apollo_server_core_1.ForbiddenError;\nexports.UserInputError = apollo_server_core_1.UserInputError;\nexports.defaultPlaygroundOptions = apollo_server_core_1.defaultPlaygroundOptions;\n__export(__webpack_require__(/*! graphql-tools */ \"./node_modules/graphql-tools/dist/index.js\"));\n__export(__webpack_require__(/*! graphql-subscriptions */ \"./node_modules/graphql-subscriptions/dist/index.js\"));\nvar ApolloServer_1 = __webpack_require__(/*! ./ApolloServer */ \"./node_modules/apollo-server-express/dist/ApolloServer.js\");\nexports.ApolloServer = ApolloServer_1.ApolloServer;\nexports.registerServer = ApolloServer_1.registerServer;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-server-express/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-tracing/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/apollo-tracing/dist/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nclass TracingExtension {\n    constructor() {\n        this.resolverCalls = [];\n    }\n    requestDidStart() {\n        this.startWallTime = new Date();\n        this.startHrTime = process.hrtime();\n    }\n    executionDidStart() {\n        return () => {\n            this.duration = process.hrtime(this.startHrTime);\n            this.endWallTime = new Date();\n        };\n    }\n    willResolveField(_source, _args, _context, info) {\n        const resolverCall = {\n            path: info.path,\n            fieldName: info.fieldName,\n            parentType: info.parentType,\n            returnType: info.returnType,\n            startOffset: process.hrtime(this.startHrTime),\n        };\n        this.resolverCalls.push(resolverCall);\n        return () => {\n            resolverCall.endOffset = process.hrtime(this.startHrTime);\n        };\n    }\n    format() {\n        if (typeof this.startWallTime === 'undefined' ||\n            typeof this.endWallTime === 'undefined' ||\n            typeof this.duration === 'undefined') {\n            return;\n        }\n        return [\n            'tracing',\n            {\n                version: 1,\n                startTime: this.startWallTime.toISOString(),\n                endTime: this.endWallTime.toISOString(),\n                duration: durationHrTimeToNanos(this.duration),\n                execution: {\n                    resolvers: this.resolverCalls.map(resolverCall => {\n                        const startOffset = durationHrTimeToNanos(resolverCall.startOffset);\n                        const duration = resolverCall.endOffset\n                            ? durationHrTimeToNanos(resolverCall.endOffset) - startOffset\n                            : 0;\n                        return {\n                            path: [...graphql_1.responsePathAsArray(resolverCall.path)],\n                            parentType: resolverCall.parentType.toString(),\n                            fieldName: resolverCall.fieldName,\n                            returnType: resolverCall.returnType.toString(),\n                            startOffset,\n                            duration,\n                        };\n                    }),\n                },\n            },\n        ];\n    }\n}\nexports.TracingExtension = TracingExtension;\nfunction durationHrTimeToNanos(hrtime) {\n    return hrtime[0] * 1e9 + hrtime[1];\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-tracing/dist/index.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/directives.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/directives.js ***!
  \*********************************************************/
/*! exports provided: getDirectiveInfoFromField, shouldInclude, flattenSelections, getDirectiveNames, hasDirectives */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDirectiveInfoFromField\", function() { return getDirectiveInfoFromField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shouldInclude\", function() { return shouldInclude; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flattenSelections\", function() { return flattenSelections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDirectiveNames\", function() { return getDirectiveNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasDirectives\", function() { return hasDirectives; });\n/* harmony import */ var _storeUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storeUtils */ \"./node_modules/apollo-utilities/lib/storeUtils.js\");\n\nfunction getDirectiveInfoFromField(field, variables) {\n    if (field.directives && field.directives.length) {\n        var directiveObj_1 = {};\n        field.directives.forEach(function (directive) {\n            directiveObj_1[directive.name.value] = Object(_storeUtils__WEBPACK_IMPORTED_MODULE_0__[\"argumentsObjectFromField\"])(directive, variables);\n        });\n        return directiveObj_1;\n    }\n    return null;\n}\nfunction shouldInclude(selection, variables) {\n    if (variables === void 0) { variables = {}; }\n    if (!selection.directives) {\n        return true;\n    }\n    var res = true;\n    selection.directives.forEach(function (directive) {\n        if (directive.name.value !== 'skip' && directive.name.value !== 'include') {\n            return;\n        }\n        var directiveArguments = directive.arguments || [];\n        var directiveName = directive.name.value;\n        if (directiveArguments.length !== 1) {\n            throw new Error(\"Incorrect number of arguments for the @\" + directiveName + \" directive.\");\n        }\n        var ifArgument = directiveArguments[0];\n        if (!ifArgument.name || ifArgument.name.value !== 'if') {\n            throw new Error(\"Invalid argument for the @\" + directiveName + \" directive.\");\n        }\n        var ifValue = directiveArguments[0].value;\n        var evaledValue = false;\n        if (!ifValue || ifValue.kind !== 'BooleanValue') {\n            if (ifValue.kind !== 'Variable') {\n                throw new Error(\"Argument for the @\" + directiveName + \" directive must be a variable or a boolean value.\");\n            }\n            else {\n                evaledValue = variables[ifValue.name.value];\n                if (evaledValue === undefined) {\n                    throw new Error(\"Invalid variable referenced in @\" + directiveName + \" directive.\");\n                }\n            }\n        }\n        else {\n            evaledValue = ifValue.value;\n        }\n        if (directiveName === 'skip') {\n            evaledValue = !evaledValue;\n        }\n        if (!evaledValue) {\n            res = false;\n        }\n    });\n    return res;\n}\nfunction flattenSelections(selection) {\n    if (!selection.selectionSet ||\n        !(selection.selectionSet.selections.length > 0))\n        return [selection];\n    return [selection].concat(selection.selectionSet.selections\n        .map(function (selectionNode) {\n        return [selectionNode].concat(flattenSelections(selectionNode));\n    })\n        .reduce(function (selections, selected) { return selections.concat(selected); }, []));\n}\nfunction getDirectiveNames(doc) {\n    var directiveNames = doc.definitions\n        .filter(function (definition) {\n        return definition.selectionSet && definition.selectionSet.selections;\n    })\n        .map(function (x) { return flattenSelections(x); })\n        .reduce(function (selections, selected) { return selections.concat(selected); }, [])\n        .filter(function (selection) {\n        return selection.directives && selection.directives.length > 0;\n    })\n        .map(function (selection) { return selection.directives; })\n        .reduce(function (directives, directive) { return directives.concat(directive); }, [])\n        .map(function (directive) { return directive.name.value; });\n    return directiveNames;\n}\nfunction hasDirectives(names, doc) {\n    return getDirectiveNames(doc).some(function (name) { return names.indexOf(name) > -1; });\n}\n//# sourceMappingURL=directives.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/directives.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/fragments.js":
/*!********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/fragments.js ***!
  \********************************************************/
/*! exports provided: getFragmentQueryDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFragmentQueryDocument\", function() { return getFragmentQueryDocument; });\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        if (definition.kind === 'OperationDefinition') {\n            throw new Error(\"Found a \" + definition.operation + \" operation\" + (definition.name ? \" named '\" + definition.name.value + \"'\" : '') + \". \" +\n                'No operations are allowed when using a fragment as a query. Only fragments are allowed.');\n        }\n        if (definition.kind === 'FragmentDefinition') {\n            fragments.push(definition);\n        }\n    });\n    if (typeof actualFragmentName === 'undefined') {\n        if (fragments.length !== 1) {\n            throw new Error(\"Found \" + fragments.length + \" fragments. `fragmentName` must be provided when there is not exactly 1 fragment.\");\n        }\n        actualFragmentName = fragments[0].name.value;\n    }\n    var query = __assign({}, document, { definitions: [\n            {\n                kind: 'OperationDefinition',\n                operation: 'query',\n                selectionSet: {\n                    kind: 'SelectionSet',\n                    selections: [\n                        {\n                            kind: 'FragmentSpread',\n                            name: {\n                                kind: 'Name',\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ].concat(document.definitions) });\n    return query;\n}\n//# sourceMappingURL=fragments.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/fragments.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/getFromAST.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/getFromAST.js ***!
  \*********************************************************/
/*! exports provided: getMutationDefinition, checkDocument, getOperationDefinition, getOperationDefinitionOrDie, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, createFragmentMap, getDefaultValues, variablesInOperation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMutationDefinition\", function() { return getMutationDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkDocument\", function() { return checkDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOperationDefinition\", function() { return getOperationDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOperationDefinitionOrDie\", function() { return getOperationDefinitionOrDie; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOperationName\", function() { return getOperationName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFragmentDefinitions\", function() { return getFragmentDefinitions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getQueryDefinition\", function() { return getQueryDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFragmentDefinition\", function() { return getFragmentDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMainDefinition\", function() { return getMainDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFragmentMap\", function() { return createFragmentMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDefaultValues\", function() { return getDefaultValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"variablesInOperation\", function() { return variablesInOperation; });\n/* harmony import */ var _util_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/assign */ \"./node_modules/apollo-utilities/lib/util/assign.js\");\n/* harmony import */ var _storeUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storeUtils */ \"./node_modules/apollo-utilities/lib/storeUtils.js\");\n\n\nfunction getMutationDefinition(doc) {\n    checkDocument(doc);\n    var mutationDef = doc.definitions.filter(function (definition) {\n        return definition.kind === 'OperationDefinition' &&\n            definition.operation === 'mutation';\n    })[0];\n    if (!mutationDef) {\n        throw new Error('Must contain a mutation definition.');\n    }\n    return mutationDef;\n}\nfunction checkDocument(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })\n        .map(function (definition) {\n        if (definition.kind !== 'OperationDefinition') {\n            throw new Error(\"Schema type definitions not allowed in queries. Found: \\\"\" + definition.kind + \"\\\"\");\n        }\n        return definition;\n    });\n    if (operations.length > 1) {\n        throw new Error(\"Ambiguous GraphQL document: contains \" + operations.length + \" operations\");\n    }\n}\nfunction getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];\n}\nfunction getOperationDefinitionOrDie(document) {\n    var def = getOperationDefinition(document);\n    if (!def) {\n        throw new Error(\"GraphQL document is missing an operation\");\n    }\n    return def;\n}\nfunction getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === 'OperationDefinition' && definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\nfunction getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });\n}\nfunction getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    if (!queryDef || queryDef.operation !== 'query') {\n        throw new Error('Must contain a query definition.');\n    }\n    return queryDef;\n}\nfunction getFragmentDefinition(doc) {\n    if (doc.kind !== 'Document') {\n        throw new Error(\"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n    }\n    if (doc.definitions.length > 1) {\n        throw new Error('Fragment must have exactly one definition.');\n    }\n    var fragmentDef = doc.definitions[0];\n    if (fragmentDef.kind !== 'FragmentDefinition') {\n        throw new Error('Must be a fragment definition.');\n    }\n    return fragmentDef;\n}\nfunction getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' ||\n                operation === 'mutation' ||\n                operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\nfunction createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nfunction getDefaultValues(definition) {\n    if (definition &&\n        definition.variableDefinitions &&\n        definition.variableDefinitions.length) {\n        var defaultValues = definition.variableDefinitions\n            .filter(function (_a) {\n            var defaultValue = _a.defaultValue;\n            return defaultValue;\n        })\n            .map(function (_a) {\n            var variable = _a.variable, defaultValue = _a.defaultValue;\n            var defaultValueObj = {};\n            Object(_storeUtils__WEBPACK_IMPORTED_MODULE_1__[\"valueToObjectRepresentation\"])(defaultValueObj, variable.name, defaultValue);\n            return defaultValueObj;\n        });\n        return _util_assign__WEBPACK_IMPORTED_MODULE_0__[\"assign\"].apply(void 0, [{}].concat(defaultValues));\n    }\n    return {};\n}\nfunction variablesInOperation(operation) {\n    var names = new Set();\n    if (operation.variableDefinitions) {\n        for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            names.add(definition.variable.name.value);\n        }\n    }\n    return names;\n}\n//# sourceMappingURL=getFromAST.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/getFromAST.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/index.js ***!
  \****************************************************/
/*! exports provided: getDirectiveInfoFromField, shouldInclude, flattenSelections, getDirectiveNames, hasDirectives, getFragmentQueryDocument, getMutationDefinition, checkDocument, getOperationDefinition, getOperationDefinitionOrDie, getOperationName, getFragmentDefinitions, getQueryDefinition, getFragmentDefinition, getMainDefinition, createFragmentMap, getDefaultValues, variablesInOperation, removeDirectivesFromDocument, addTypenameToDocument, removeConnectionDirectiveFromDocument, getDirectivesFromDocument, isScalarValue, isNumberValue, valueToObjectRepresentation, storeKeyNameFromField, getStoreKeyName, argumentsObjectFromField, resultKeyNameFromField, isField, isInlineFragment, isIdValue, toIdValue, isJsonValue, valueFromNode, assign, cloneDeep, getEnv, isEnv, isProduction, isDevelopment, isTest, tryFunctionOrLogError, graphQLResultHasError, isEqual, maybeDeepFreeze, warnOnceInDevelopment, stripSymbols */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _directives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./directives */ \"./node_modules/apollo-utilities/lib/directives.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDirectiveInfoFromField\", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__[\"getDirectiveInfoFromField\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shouldInclude\", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__[\"shouldInclude\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"flattenSelections\", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__[\"flattenSelections\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDirectiveNames\", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__[\"getDirectiveNames\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hasDirectives\", function() { return _directives__WEBPACK_IMPORTED_MODULE_0__[\"hasDirectives\"]; });\n\n/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fragments */ \"./node_modules/apollo-utilities/lib/fragments.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFragmentQueryDocument\", function() { return _fragments__WEBPACK_IMPORTED_MODULE_1__[\"getFragmentQueryDocument\"]; });\n\n/* harmony import */ var _getFromAST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getFromAST */ \"./node_modules/apollo-utilities/lib/getFromAST.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getMutationDefinition\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getMutationDefinition\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"checkDocument\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"checkDocument\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getOperationDefinition\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getOperationDefinition\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getOperationDefinitionOrDie\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getOperationDefinitionOrDie\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getOperationName\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getOperationName\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFragmentDefinitions\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getFragmentDefinitions\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getQueryDefinition\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getQueryDefinition\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFragmentDefinition\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getFragmentDefinition\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getMainDefinition\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getMainDefinition\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createFragmentMap\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"createFragmentMap\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDefaultValues\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"getDefaultValues\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"variablesInOperation\", function() { return _getFromAST__WEBPACK_IMPORTED_MODULE_2__[\"variablesInOperation\"]; });\n\n/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform */ \"./node_modules/apollo-utilities/lib/transform.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"removeDirectivesFromDocument\", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__[\"removeDirectivesFromDocument\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addTypenameToDocument\", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__[\"addTypenameToDocument\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"removeConnectionDirectiveFromDocument\", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__[\"removeConnectionDirectiveFromDocument\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDirectivesFromDocument\", function() { return _transform__WEBPACK_IMPORTED_MODULE_3__[\"getDirectivesFromDocument\"]; });\n\n/* harmony import */ var _storeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./storeUtils */ \"./node_modules/apollo-utilities/lib/storeUtils.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isScalarValue\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"isScalarValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isNumberValue\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"isNumberValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"valueToObjectRepresentation\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"valueToObjectRepresentation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"storeKeyNameFromField\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"storeKeyNameFromField\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getStoreKeyName\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"getStoreKeyName\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"argumentsObjectFromField\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"argumentsObjectFromField\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"resultKeyNameFromField\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"resultKeyNameFromField\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isField\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"isField\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isInlineFragment\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"isInlineFragment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isIdValue\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"isIdValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"toIdValue\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"toIdValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isJsonValue\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"isJsonValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"valueFromNode\", function() { return _storeUtils__WEBPACK_IMPORTED_MODULE_4__[\"valueFromNode\"]; });\n\n/* harmony import */ var _util_assign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/assign */ \"./node_modules/apollo-utilities/lib/util/assign.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return _util_assign__WEBPACK_IMPORTED_MODULE_5__[\"assign\"]; });\n\n/* harmony import */ var _util_cloneDeep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/cloneDeep */ \"./node_modules/apollo-utilities/lib/util/cloneDeep.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"cloneDeep\", function() { return _util_cloneDeep__WEBPACK_IMPORTED_MODULE_6__[\"cloneDeep\"]; });\n\n/* harmony import */ var _util_environment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/environment */ \"./node_modules/apollo-utilities/lib/util/environment.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getEnv\", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__[\"getEnv\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isEnv\", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__[\"isEnv\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isProduction\", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__[\"isProduction\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isDevelopment\", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__[\"isDevelopment\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isTest\", function() { return _util_environment__WEBPACK_IMPORTED_MODULE_7__[\"isTest\"]; });\n\n/* harmony import */ var _util_errorHandling__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/errorHandling */ \"./node_modules/apollo-utilities/lib/util/errorHandling.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"tryFunctionOrLogError\", function() { return _util_errorHandling__WEBPACK_IMPORTED_MODULE_8__[\"tryFunctionOrLogError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"graphQLResultHasError\", function() { return _util_errorHandling__WEBPACK_IMPORTED_MODULE_8__[\"graphQLResultHasError\"]; });\n\n/* harmony import */ var _util_isEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util/isEqual */ \"./node_modules/apollo-utilities/lib/util/isEqual.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isEqual\", function() { return _util_isEqual__WEBPACK_IMPORTED_MODULE_9__[\"isEqual\"]; });\n\n/* harmony import */ var _util_maybeDeepFreeze__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./util/maybeDeepFreeze */ \"./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"maybeDeepFreeze\", function() { return _util_maybeDeepFreeze__WEBPACK_IMPORTED_MODULE_10__[\"maybeDeepFreeze\"]; });\n\n/* harmony import */ var _util_warnOnce__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./util/warnOnce */ \"./node_modules/apollo-utilities/lib/util/warnOnce.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"warnOnceInDevelopment\", function() { return _util_warnOnce__WEBPACK_IMPORTED_MODULE_11__[\"warnOnceInDevelopment\"]; });\n\n/* harmony import */ var _util_stripSymbols__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util/stripSymbols */ \"./node_modules/apollo-utilities/lib/util/stripSymbols.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"stripSymbols\", function() { return _util_stripSymbols__WEBPACK_IMPORTED_MODULE_12__[\"stripSymbols\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/index.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/storeUtils.js":
/*!*********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/storeUtils.js ***!
  \*********************************************************/
/*! exports provided: isScalarValue, isNumberValue, valueToObjectRepresentation, storeKeyNameFromField, getStoreKeyName, argumentsObjectFromField, resultKeyNameFromField, isField, isInlineFragment, isIdValue, toIdValue, isJsonValue, valueFromNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isScalarValue\", function() { return isScalarValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumberValue\", function() { return isNumberValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"valueToObjectRepresentation\", function() { return valueToObjectRepresentation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"storeKeyNameFromField\", function() { return storeKeyNameFromField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStoreKeyName\", function() { return getStoreKeyName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"argumentsObjectFromField\", function() { return argumentsObjectFromField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resultKeyNameFromField\", function() { return resultKeyNameFromField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isField\", function() { return isField; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isInlineFragment\", function() { return isInlineFragment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdValue\", function() { return isIdValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toIdValue\", function() { return toIdValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isJsonValue\", function() { return isJsonValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"valueFromNode\", function() { return valueFromNode; });\n/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-json-stable-stringify */ \"fast-json-stable-stringify\");\n/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\nfunction isScalarValue(value) {\n    return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\nfunction isNumberValue(value) {\n    return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\nfunction isStringValue(value) {\n    return value.kind === 'StringValue';\n}\nfunction isBooleanValue(value) {\n    return value.kind === 'BooleanValue';\n}\nfunction isIntValue(value) {\n    return value.kind === 'IntValue';\n}\nfunction isFloatValue(value) {\n    return value.kind === 'FloatValue';\n}\nfunction isVariable(value) {\n    return value.kind === 'Variable';\n}\nfunction isObjectValue(value) {\n    return value.kind === 'ObjectValue';\n}\nfunction isListValue(value) {\n    return value.kind === 'ListValue';\n}\nfunction isEnumValue(value) {\n    return value.kind === 'EnumValue';\n}\nfunction isNullValue(value) {\n    return value.kind === 'NullValue';\n}\nfunction valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw new Error(\"The inline argument \\\"\" + name.value + \"\\\" of kind \\\"\" + value.kind + \"\\\"\" +\n            'is not supported. Use variables instead of inline arguments to ' +\n            'overcome this limitation.');\n    }\n}\nfunction storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    'connection',\n    'include',\n    'skip',\n    'client',\n    'rest',\n    'export',\n];\nfunction getStoreKeyName(fieldName, args, directives) {\n    if (directives &&\n        directives['connection'] &&\n        directives['connection']['key']) {\n        if (directives['connection']['filter'] &&\n            directives['connection']['filter'].length > 0) {\n            var filterKeys = directives['connection']['filter']\n                ? directives['connection']['filter']\n                : [];\n            filterKeys.sort();\n            var queryArgs_1 = args;\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = queryArgs_1[key];\n            });\n            return directives['connection']['key'] + \"(\" + JSON.stringify(filteredArgs_1) + \")\";\n        }\n        else {\n            return directives['connection']['key'];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        var stringifiedArgs = fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(args);\n        completeFieldName += \"(\" + stringifiedArgs + \")\";\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\" + key + \"(\" + JSON.stringify(directives[key]) + \")\";\n            }\n            else {\n                completeFieldName += \"@\" + key;\n            }\n        });\n    }\n    return completeFieldName;\n}\nfunction argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nfunction resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nfunction isField(selection) {\n    return selection.kind === 'Field';\n}\nfunction isInlineFragment(selection) {\n    return selection.kind === 'InlineFragment';\n}\nfunction isIdValue(idObject) {\n    return idObject && idObject.type === 'id';\n}\nfunction toIdValue(idConfig, generated) {\n    if (generated === void 0) { generated = false; }\n    return __assign({ type: 'id', generated: generated }, (typeof idConfig === 'string'\n        ? { id: idConfig, typename: undefined }\n        : idConfig));\n}\nfunction isJsonValue(jsonObject) {\n    return (jsonObject != null &&\n        typeof jsonObject === 'object' &&\n        jsonObject.type === 'json');\n}\nfunction defaultValueFromVariable(node) {\n    throw new Error(\"Variable nodes are not supported by valueFromNode\");\n}\nfunction valueFromNode(node, onVariable) {\n    if (onVariable === void 0) { onVariable = defaultValueFromVariable; }\n    switch (node.kind) {\n        case 'Variable':\n            return onVariable(node);\n        case 'NullValue':\n            return null;\n        case 'IntValue':\n            return parseInt(node.value, 10);\n        case 'FloatValue':\n            return parseFloat(node.value);\n        case 'ListValue':\n            return node.values.map(function (v) { return valueFromNode(v, onVariable); });\n        case 'ObjectValue': {\n            var value = {};\n            for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {\n                var field = _a[_i];\n                value[field.name.value] = valueFromNode(field.value, onVariable);\n            }\n            return value;\n        }\n        default:\n            return node.value;\n    }\n}\n//# sourceMappingURL=storeUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/storeUtils.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/transform.js":
/*!********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/transform.js ***!
  \********************************************************/
/*! exports provided: removeDirectivesFromDocument, addTypenameToDocument, removeConnectionDirectiveFromDocument, getDirectivesFromDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeDirectivesFromDocument\", function() { return removeDirectivesFromDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addTypenameToDocument\", function() { return addTypenameToDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeConnectionDirectiveFromDocument\", function() { return removeConnectionDirectiveFromDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDirectivesFromDocument\", function() { return getDirectivesFromDocument; });\n/* harmony import */ var _util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/cloneDeep */ \"./node_modules/apollo-utilities/lib/util/cloneDeep.js\");\n/* harmony import */ var _getFromAST__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getFromAST */ \"./node_modules/apollo-utilities/lib/getFromAST.js\");\n\n\nvar TYPENAME_FIELD = {\n    kind: 'Field',\n    name: {\n        kind: 'Name',\n        value: '__typename',\n    },\n};\nfunction isNotEmpty(op, fragments) {\n    return (op.selectionSet.selections.filter(function (selectionSet) {\n        return !(selectionSet &&\n            selectionSet.kind === 'FragmentSpread' &&\n            !isNotEmpty(fragments[selectionSet.name.value], fragments));\n    }).length > 0);\n}\nfunction getDirectiveMatcher(directives) {\n    return function directiveMatcher(directive) {\n        return directives.some(function (dir) {\n            if (dir.name && dir.name === directive.name.value)\n                return true;\n            if (dir.test && dir.test(directive))\n                return true;\n            return false;\n        });\n    };\n}\nfunction addTypenameToSelectionSet(selectionSet, isRoot) {\n    if (isRoot === void 0) { isRoot = false; }\n    if (selectionSet.selections) {\n        if (!isRoot) {\n            var alreadyHasThisField = selectionSet.selections.some(function (selection) {\n                return (selection.kind === 'Field' &&\n                    selection.name.value === '__typename');\n            });\n            if (!alreadyHasThisField) {\n                selectionSet.selections.push(TYPENAME_FIELD);\n            }\n        }\n        selectionSet.selections.forEach(function (selection) {\n            if (selection.kind === 'Field') {\n                if (selection.name.value.lastIndexOf('__', 0) !== 0 &&\n                    selection.selectionSet) {\n                    addTypenameToSelectionSet(selection.selectionSet);\n                }\n            }\n            else if (selection.kind === 'InlineFragment') {\n                if (selection.selectionSet) {\n                    addTypenameToSelectionSet(selection.selectionSet);\n                }\n            }\n        });\n    }\n}\nfunction removeDirectivesFromSelectionSet(directives, selectionSet) {\n    if (!selectionSet.selections)\n        return selectionSet;\n    var agressiveRemove = directives.some(function (dir) { return dir.remove; });\n    selectionSet.selections = selectionSet.selections\n        .map(function (selection) {\n        if (selection.kind !== 'Field' ||\n            !selection ||\n            !selection.directives)\n            return selection;\n        var directiveMatcher = getDirectiveMatcher(directives);\n        var remove;\n        selection.directives = selection.directives.filter(function (directive) {\n            var shouldKeep = !directiveMatcher(directive);\n            if (!remove && !shouldKeep && agressiveRemove)\n                remove = true;\n            return shouldKeep;\n        });\n        return remove ? null : selection;\n    })\n        .filter(function (x) { return !!x; });\n    selectionSet.selections.forEach(function (selection) {\n        if ((selection.kind === 'Field' || selection.kind === 'InlineFragment') &&\n            selection.selectionSet) {\n            removeDirectivesFromSelectionSet(directives, selection.selectionSet);\n        }\n    });\n    return selectionSet;\n}\nfunction removeDirectivesFromDocument(directives, doc) {\n    var docClone = Object(_util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__[\"cloneDeep\"])(doc);\n    docClone.definitions.forEach(function (definition) {\n        removeDirectivesFromSelectionSet(directives, definition.selectionSet);\n    });\n    var operation = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"getOperationDefinitionOrDie\"])(docClone);\n    var fragments = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"createFragmentMap\"])(Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"getFragmentDefinitions\"])(docClone));\n    return isNotEmpty(operation, fragments) ? docClone : null;\n}\nfunction addTypenameToDocument(doc) {\n    Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"checkDocument\"])(doc);\n    var docClone = Object(_util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__[\"cloneDeep\"])(doc);\n    docClone.definitions.forEach(function (definition) {\n        var isRoot = definition.kind === 'OperationDefinition';\n        addTypenameToSelectionSet(definition.selectionSet, isRoot);\n    });\n    return docClone;\n}\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === 'connection';\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {\n                console.warn('Removing an @connection directive even though it does not have a key. ' +\n                    'You may want to use the key parameter to specify a store key.');\n            }\n        }\n        return willRemove;\n    },\n};\nfunction removeConnectionDirectiveFromDocument(doc) {\n    Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"checkDocument\"])(doc);\n    return removeDirectivesFromDocument([connectionRemoveConfig], doc);\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (!(selectionSet && selectionSet.selections)) {\n        return false;\n    }\n    var matchedSelections = selectionSet.selections.filter(function (selection) {\n        return hasDirectivesInSelection(directives, selection, nestedCheck);\n    });\n    return matchedSelections.length > 0;\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (selection.kind !== 'Field' || !selection) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    var directiveMatcher = getDirectiveMatcher(directives);\n    var matchedDirectives = selection.directives.filter(directiveMatcher);\n    return (matchedDirectives.length > 0 ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nfunction getDirectivesFromSelectionSet(directives, selectionSet) {\n    selectionSet.selections = selectionSet.selections\n        .filter(function (selection) {\n        return hasDirectivesInSelection(directives, selection, true);\n    })\n        .map(function (selection) {\n        if (hasDirectivesInSelection(directives, selection, false)) {\n            return selection;\n        }\n        if ((selection.kind === 'Field' || selection.kind === 'InlineFragment') &&\n            selection.selectionSet) {\n            selection.selectionSet = getDirectivesFromSelectionSet(directives, selection.selectionSet);\n        }\n        return selection;\n    });\n    return selectionSet;\n}\nfunction getDirectivesFromDocument(directives, doc, includeAllFragments) {\n    if (includeAllFragments === void 0) { includeAllFragments = false; }\n    Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"checkDocument\"])(doc);\n    var docClone = Object(_util_cloneDeep__WEBPACK_IMPORTED_MODULE_0__[\"cloneDeep\"])(doc);\n    docClone.definitions = docClone.definitions.map(function (definition) {\n        if ((definition.kind === 'OperationDefinition' ||\n            (definition.kind === 'FragmentDefinition' && !includeAllFragments)) &&\n            definition.selectionSet) {\n            definition.selectionSet = getDirectivesFromSelectionSet(directives, definition.selectionSet);\n        }\n        return definition;\n    });\n    var operation = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"getOperationDefinitionOrDie\"])(docClone);\n    var fragments = Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"createFragmentMap\"])(Object(_getFromAST__WEBPACK_IMPORTED_MODULE_1__[\"getFragmentDefinitions\"])(docClone));\n    return isNotEmpty(operation, fragments) ? docClone : null;\n}\n//# sourceMappingURL=transform.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/transform.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/assign.js ***!
  \**********************************************************/
/*! exports provided: assign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\nfunction assign(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        if (typeof source === 'undefined' || source === null) {\n            return;\n        }\n        Object.keys(source).forEach(function (key) {\n            target[key] = source[key];\n        });\n    });\n    return target;\n}\n//# sourceMappingURL=assign.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/assign.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/cloneDeep.js":
/*!*************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/cloneDeep.js ***!
  \*************************************************************/
/*! exports provided: cloneDeep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneDeep\", function() { return cloneDeep; });\n/* harmony import */ var fclone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fclone */ \"./node_modules/fclone/dist/fclone.js\");\n/* harmony import */ var fclone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fclone__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction cloneDeep(value) {\n    return fclone__WEBPACK_IMPORTED_MODULE_0___default()(value);\n}\n//# sourceMappingURL=cloneDeep.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/cloneDeep.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/environment.js":
/*!***************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/environment.js ***!
  \***************************************************************/
/*! exports provided: getEnv, isEnv, isProduction, isDevelopment, isTest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEnv\", function() { return getEnv; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEnv\", function() { return isEnv; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isProduction\", function() { return isProduction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDevelopment\", function() { return isDevelopment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTest\", function() { return isTest; });\nfunction getEnv() {\n    if (typeof process !== 'undefined' && \"development\") {\n        return \"development\";\n    }\n    return 'development';\n}\nfunction isEnv(env) {\n    return getEnv() === env;\n}\nfunction isProduction() {\n    return isEnv('production') === true;\n}\nfunction isDevelopment() {\n    return isEnv('development') === true;\n}\nfunction isTest() {\n    return isEnv('test') === true;\n}\n//# sourceMappingURL=environment.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/environment.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/errorHandling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/errorHandling.js ***!
  \*****************************************************************/
/*! exports provided: tryFunctionOrLogError, graphQLResultHasError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tryFunctionOrLogError\", function() { return tryFunctionOrLogError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"graphQLResultHasError\", function() { return graphQLResultHasError; });\nfunction tryFunctionOrLogError(f) {\n    try {\n        return f();\n    }\n    catch (e) {\n        if (console.error) {\n            console.error(e);\n        }\n    }\n}\nfunction graphQLResultHasError(result) {\n    return result.errors && result.errors.length;\n}\n//# sourceMappingURL=errorHandling.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/errorHandling.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/isEqual.js":
/*!***********************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/isEqual.js ***!
  \***********************************************************/
/*! exports provided: isEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEqual\", function() { return isEqual; });\nfunction isEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime();\n    }\n    if (a != null &&\n        typeof a === 'object' &&\n        b != null &&\n        typeof b === 'object') {\n        for (var key in a) {\n            if (Object.prototype.hasOwnProperty.call(a, key)) {\n                if (!Object.prototype.hasOwnProperty.call(b, key)) {\n                    return false;\n                }\n                if (!isEqual(a[key], b[key])) {\n                    return false;\n                }\n            }\n        }\n        for (var key in b) {\n            if (!Object.prototype.hasOwnProperty.call(a, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=isEqual.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/isEqual.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js":
/*!*******************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js ***!
  \*******************************************************************/
/*! exports provided: maybeDeepFreeze */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maybeDeepFreeze\", function() { return maybeDeepFreeze; });\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment */ \"./node_modules/apollo-utilities/lib/util/environment.js\");\n\nfunction deepFreeze(o) {\n    Object.freeze(o);\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (o[prop] !== null &&\n            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n            !Object.isFrozen(o[prop])) {\n            deepFreeze(o[prop]);\n        }\n    });\n    return o;\n}\nfunction maybeDeepFreeze(obj) {\n    if (Object(_environment__WEBPACK_IMPORTED_MODULE_0__[\"isDevelopment\"])() || Object(_environment__WEBPACK_IMPORTED_MODULE_0__[\"isTest\"])()) {\n        var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';\n        if (!symbolIsPolyfilled) {\n            return deepFreeze(obj);\n        }\n    }\n    return obj;\n}\n//# sourceMappingURL=maybeDeepFreeze.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/maybeDeepFreeze.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/stripSymbols.js":
/*!****************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/stripSymbols.js ***!
  \****************************************************************/
/*! exports provided: stripSymbols */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripSymbols\", function() { return stripSymbols; });\nfunction stripSymbols(data) {\n    return JSON.parse(JSON.stringify(data));\n}\n//# sourceMappingURL=stripSymbols.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/stripSymbols.js?");

/***/ }),

/***/ "./node_modules/apollo-utilities/lib/util/warnOnce.js":
/*!************************************************************!*\
  !*** ./node_modules/apollo-utilities/lib/util/warnOnce.js ***!
  \************************************************************/
/*! exports provided: warnOnceInDevelopment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"warnOnceInDevelopment\", function() { return warnOnceInDevelopment; });\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment */ \"./node_modules/apollo-utilities/lib/util/environment.js\");\n\nvar haveWarned = Object.create({});\nfunction warnOnceInDevelopment(msg, type) {\n    if (type === void 0) { type = 'warn'; }\n    if (Object(_environment__WEBPACK_IMPORTED_MODULE_0__[\"isProduction\"])()) {\n        return;\n    }\n    if (!haveWarned[msg]) {\n        if (!Object(_environment__WEBPACK_IMPORTED_MODULE_0__[\"isTest\"])()) {\n            haveWarned[msg] = true;\n        }\n        switch (type) {\n            case 'error':\n                console.error(msg);\n                break;\n            default:\n                console.warn(msg);\n        }\n    }\n}\n//# sourceMappingURL=warnOnce.js.map\n\n//# sourceURL=webpack:///./node_modules/apollo-utilities/lib/util/warnOnce.js?");

/***/ }),

/***/ "./node_modules/array-differ/index.js":
/*!********************************************!*\
  !*** ./node_modules/array-differ/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (arr) {\n\tvar rest = [].concat.apply([], [].slice.call(arguments, 1));\n\treturn arr.filter(function (el) {\n\t\treturn rest.indexOf(el) === -1;\n\t});\n};\n\n\n//# sourceURL=webpack:///./node_modules/array-differ/index.js?");

/***/ }),

/***/ "./node_modules/array-union/index.js":
/*!*******************************************!*\
  !*** ./node_modules/array-union/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar arrayUniq = __webpack_require__(/*! array-uniq */ \"./node_modules/array-uniq/index.js\");\n\nmodule.exports = function () {\n\treturn arrayUniq([].concat.apply([], arguments));\n};\n\n\n//# sourceURL=webpack:///./node_modules/array-union/index.js?");

/***/ }),

/***/ "./node_modules/array-uniq/index.js":
/*!******************************************!*\
  !*** ./node_modules/array-uniq/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// there's 3 implementations written in increasing order of efficiency\n\n// 1 - no Set type is defined\nfunction uniqNoSet(arr) {\n\tvar ret = [];\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (ret.indexOf(arr[i]) === -1) {\n\t\t\tret.push(arr[i]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// 2 - a simple Set type is defined\nfunction uniqSet(arr) {\n\tvar seen = new Set();\n\treturn arr.filter(function (el) {\n\t\tif (!seen.has(el)) {\n\t\t\tseen.add(el);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n\n// 3 - a standard Set type is defined and it has a forEach method\nfunction uniqSetWithForEach(arr) {\n\tvar ret = [];\n\n\t(new Set(arr)).forEach(function (el) {\n\t\tret.push(el);\n\t});\n\n\treturn ret;\n}\n\n// V8 currently has a broken implementation\n// https://github.com/joyent/node/issues/8449\nfunction doesForEachActuallyWork() {\n\tvar ret = false;\n\n\t(new Set([true])).forEach(function (el) {\n\t\tret = el;\n\t});\n\n\treturn ret === true;\n}\n\nif ('Set' in global) {\n\tif (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {\n\t\tmodule.exports = uniqSetWithForEach;\n\t} else {\n\t\tmodule.exports = uniqSet;\n\t}\n} else {\n\tmodule.exports = uniqNoSet;\n}\n\n\n//# sourceURL=webpack:///./node_modules/array-uniq/index.js?");

/***/ }),

/***/ "./node_modules/async-retry/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/async-retry/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Packages\nvar retrier = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\n\nfunction retry(fn, opts) {\n  function run(resolve, reject) {\n    var options = opts || {};\n    var op = retrier.operation(options);\n\n    // We allow the user to abort retrying\n    // this makes sense in the cases where\n    // knowledge is obtained that retrying\n    // would be futile (e.g.: auth errors)\n\n    function bail(err) {\n      reject(err || new Error('Aborted'));\n    }\n\n    function onError(err, num) {\n      if (err.bail) {\n        bail(err);\n        return;\n      }\n\n      if (!op.retry(err)) {\n        reject(op.mainError());\n      } else if (options.onRetry) {\n        options.onRetry(err, num);\n      }\n    }\n\n    function runAttempt(num) {\n      var val;\n\n      try {\n        val = fn(bail, num);\n      } catch (err) {\n        onError(err, num);\n        return;\n      }\n\n      Promise.resolve(val)\n        .then(resolve)\n        .catch(function catchIt(err) {\n          onError(err, num);\n        });\n    }\n\n    op.attempt(runAttempt);\n  }\n\n  return new Promise(run);\n}\n\nmodule.exports = retry;\n\n\n//# sourceURL=webpack:///./node_modules/async-retry/lib/index.js?");

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n\n//# sourceURL=webpack:///./node_modules/backo2/index.js?");

/***/ }),

/***/ "./node_modules/call-me-maybe/index.js":
/*!*********************************************!*\
  !*** ./node_modules/call-me-maybe/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar next = (global.process && process.nextTick) || global.setImmediate || function (f) {\n  setTimeout(f, 0)\n}\n\nmodule.exports = function maybe (cb, promise) {\n  if (cb) {\n    promise\n      .then(function (result) {\n        next(function () { cb(null, result) })\n      }, function (err) {\n        next(function () { cb(err) })\n      })\n    return undefined\n  }\n  else {\n    return promise\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/call-me-maybe/index.js?");

/***/ }),

/***/ "./node_modules/code-block-writer/dist/CommentChar.js":
/*!************************************************************!*\
  !*** ./node_modules/code-block-writer/dist/CommentChar.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @internal */\r\nvar CommentChar;\r\n(function (CommentChar) {\r\n    CommentChar[CommentChar[\"Line\"] = 0] = \"Line\";\r\n    CommentChar[CommentChar[\"Star\"] = 1] = \"Star\";\r\n})(CommentChar = exports.CommentChar || (exports.CommentChar = {}));\r\n//# sourceMappingURL=CommentChar.js.map\n\n//# sourceURL=webpack:///./node_modules/code-block-writer/dist/CommentChar.js?");

/***/ }),

/***/ "./node_modules/code-block-writer/dist/code-block-writer.js":
/*!******************************************************************!*\
  !*** ./node_modules/code-block-writer/dist/code-block-writer.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar stringUtils_1 = __webpack_require__(/*! ./utils/stringUtils */ \"./node_modules/code-block-writer/dist/utils/stringUtils.js\");\r\nvar CommentChar_1 = __webpack_require__(/*! ./CommentChar */ \"./node_modules/code-block-writer/dist/CommentChar.js\");\r\nvar CodeBlockWriter = /** @class */ (function () {\r\n    function CodeBlockWriter(opts) {\r\n        if (opts === void 0) { opts = {}; }\r\n        this._currentIndentation = 0;\r\n        this._text = \"\";\r\n        this._newLineOnNextWrite = false;\r\n        /** @internal */\r\n        this._currentCommentChar = undefined;\r\n        this._stringCharStack = [];\r\n        this._isInRegEx = false;\r\n        this._isOnFirstLineOfBlock = true;\r\n        this._newLine = opts.newLine || \"\\n\";\r\n        this._useTabs = opts.useTabs || false;\r\n        this._indentNumberOfSpaces = opts.indentNumberOfSpaces || 4;\r\n        this._indentationText = getIndentationText(this._useTabs, this._indentNumberOfSpaces);\r\n        this._quoteChar = opts.useSingleQuote ? \"'\" : \"\\\"\";\r\n    }\r\n    /**\r\n     * Gets the options.\r\n     */\r\n    CodeBlockWriter.prototype.getOptions = function () {\r\n        return {\r\n            indentNumberOfSpaces: this._indentNumberOfSpaces,\r\n            newLine: this._newLine,\r\n            useTabs: this._useTabs,\r\n            useSingleQuote: this._quoteChar === \"'\"\r\n        };\r\n    };\r\n    CodeBlockWriter.prototype.queueIndentationLevel = function (countOrText) {\r\n        this._queuedIndentation = this._getIndentationLevelFromArg(countOrText);\r\n        return this;\r\n    };\r\n    CodeBlockWriter.prototype.setIndentationLevel = function (countOrText) {\r\n        this._currentIndentation = this._getIndentationLevelFromArg(countOrText);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the current indentation level.\r\n     */\r\n    CodeBlockWriter.prototype.getIndentationLevel = function () {\r\n        return this._currentIndentation;\r\n    };\r\n    /**\r\n     * Writes a block using braces.\r\n     * @param block - Write using the writer within this block.\r\n     */\r\n    CodeBlockWriter.prototype.block = function (block) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this.spaceIfLastNot();\r\n        this.inlineBlock(block);\r\n        this._newLineOnNextWrite = true;\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes an inline block with braces.\r\n     * @param block - Write using the writer within this block.\r\n     */\r\n    CodeBlockWriter.prototype.inlineBlock = function (block) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this.write(\"{\");\r\n        this._indentBlockInternal(block);\r\n        this.newLineIfLastNot().write(\"}\");\r\n        return this;\r\n    };\r\n    /**\r\n     * Indents a block of code.\r\n     * @param block - Block to indent.\r\n     */\r\n    CodeBlockWriter.prototype.indentBlock = function (block) {\r\n        this._indentBlockInternal(block);\r\n        if (!this.isLastNewLine())\r\n            this._newLineOnNextWrite = true;\r\n        return this;\r\n    };\r\n    CodeBlockWriter.prototype._indentBlockInternal = function (block) {\r\n        this._currentIndentation++;\r\n        if (this.getLastChar() != null)\r\n            this.newLineIfLastNot();\r\n        this._isOnFirstLineOfBlock = true;\r\n        if (block != null)\r\n            block();\r\n        this._isOnFirstLineOfBlock = false;\r\n        this._currentIndentation = Math.max(0, this._currentIndentation - 1);\r\n    };\r\n    CodeBlockWriter.prototype.conditionalWriteLine = function (condition, strOrFunc) {\r\n        if (condition)\r\n            this.writeLine(stringUtils_1.getStringFromStrOrFunc(strOrFunc));\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a line of text.\r\n     * @param str - String to write.\r\n     */\r\n    CodeBlockWriter.prototype.writeLine = function (str) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (this._text.length > 0)\r\n            this.newLineIfLastNot();\r\n        this._writeIndentingNewLines(str);\r\n        this.newLine();\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a newline if the last line was not a newline.\r\n     */\r\n    CodeBlockWriter.prototype.newLineIfLastNot = function () {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (!this.isLastNewLine())\r\n            this.newLine();\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a blank line if the last written text was not a blank line.\r\n     */\r\n    CodeBlockWriter.prototype.blankLineIfLastNot = function () {\r\n        if (!this.isLastBlankLine())\r\n            this.blankLine();\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a blank line if the condition is true.\r\n     * @param condition - Condition to evaluate.\r\n     */\r\n    CodeBlockWriter.prototype.conditionalBlankLine = function (condition) {\r\n        if (condition)\r\n            this.blankLine();\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a blank line.\r\n     */\r\n    CodeBlockWriter.prototype.blankLine = function () {\r\n        return this.newLineIfLastNot().newLine();\r\n    };\r\n    /**\r\n     * Indents the code one level for the current line.\r\n     */\r\n    CodeBlockWriter.prototype.indent = function () {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        return this.write(this._indentationText);\r\n    };\r\n    /**\r\n     * Writes a newline if the condition is true.\r\n     * @param condition - Condition to evaluate.\r\n     */\r\n    CodeBlockWriter.prototype.conditionalNewLine = function (condition) {\r\n        if (condition)\r\n            this.newLine();\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a newline.\r\n     */\r\n    CodeBlockWriter.prototype.newLine = function () {\r\n        this._newLineOnNextWrite = false;\r\n        this._baseWriteNewline();\r\n        return this;\r\n    };\r\n    CodeBlockWriter.prototype.quote = function (text) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(text == null ? this._quoteChar : this._quoteChar + stringUtils_1.escapeForWithinString(text, this._quoteChar) + this._quoteChar);\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a space if the last character was not a space.\r\n     */\r\n    CodeBlockWriter.prototype.spaceIfLastNot = function () {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (!this.isLastSpace())\r\n            this._writeIndentingNewLines(\" \");\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a space.\r\n     * @param times - Number of times to write a space.\r\n     */\r\n    CodeBlockWriter.prototype.space = function (times) {\r\n        if (times === void 0) { times = 1; }\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(stringUtils_1.stringRepeat(\" \", times));\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a tab if the last character was not a tab.\r\n     */\r\n    CodeBlockWriter.prototype.tabIfLastNot = function () {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        if (!this.isLastTab())\r\n            this._writeIndentingNewLines(\"\\t\");\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes a tab.\r\n     * @param times - Number of times to write a tab.\r\n     */\r\n    CodeBlockWriter.prototype.tab = function (times) {\r\n        if (times === void 0) { times = 1; }\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(stringUtils_1.stringRepeat(\"\\t\", times));\r\n        return this;\r\n    };\r\n    CodeBlockWriter.prototype.conditionalWrite = function (condition, textOrFunc) {\r\n        if (condition)\r\n            this.write(stringUtils_1.getStringFromStrOrFunc(textOrFunc));\r\n        return this;\r\n    };\r\n    /**\r\n     * Writes the provided text.\r\n     * @param text - Text to write.\r\n     */\r\n    CodeBlockWriter.prototype.write = function (text) {\r\n        this._newLineIfNewLineOnNextWrite();\r\n        this._writeIndentingNewLines(text);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the length of the string in the writer.\r\n     */\r\n    CodeBlockWriter.prototype.getLength = function () {\r\n        return this._text.length;\r\n    };\r\n    /**\r\n     * Gets if the writer is currently in a comment.\r\n     */\r\n    CodeBlockWriter.prototype.isInComment = function () {\r\n        return this._currentCommentChar !== undefined;\r\n    };\r\n    /**\r\n     * Gets if the writer is currently at the start of the first line of the text, block, or indentation block.\r\n     */\r\n    CodeBlockWriter.prototype.isAtStartOfFirstLineOfBlock = function () {\r\n        return this.isOnFirstLineOfBlock() && (this.isLastNewLine() || this.getLastChar() == null);\r\n    };\r\n    /**\r\n     * Gets if the writer is currently on the first line of the text, block, or indentation block.\r\n     */\r\n    CodeBlockWriter.prototype.isOnFirstLineOfBlock = function () {\r\n        return this._isOnFirstLineOfBlock;\r\n    };\r\n    /**\r\n     * Gets if the writer is currently in a string.\r\n     */\r\n    CodeBlockWriter.prototype.isInString = function () {\r\n        return this._stringCharStack.length > 0 && this._stringCharStack[this._stringCharStack.length - 1] !== \"{\";\r\n    };\r\n    /**\r\n     * Gets if the last chars written were for a newline.\r\n     */\r\n    CodeBlockWriter.prototype.isLastNewLine = function () {\r\n        return this._text.indexOf(this._newLine, this._text.length - this._newLine.length) !== -1 || this._text[this._text.length - 1] === \"\\n\";\r\n    };\r\n    /**\r\n     * Gets if the last chars written were for a blank line.\r\n     */\r\n    CodeBlockWriter.prototype.isLastBlankLine = function () {\r\n        var foundCount = 0;\r\n        for (var i = this._text.length - 1; i >= 0; i--) {\r\n            var currentChar = this._text[i];\r\n            if (currentChar === \"\\n\") {\r\n                foundCount++;\r\n                if (foundCount === 2)\r\n                    return true;\r\n            }\r\n            else if (currentChar !== \"\\r\")\r\n                return false;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Gets if the last char written was a space.\r\n     */\r\n    CodeBlockWriter.prototype.isLastSpace = function () {\r\n        return this.getLastChar() === \" \";\r\n    };\r\n    /**\r\n     * Gets if the last char written was a tab.\r\n     */\r\n    CodeBlockWriter.prototype.isLastTab = function () {\r\n        return this.getLastChar() === \"\\t\";\r\n    };\r\n    /**\r\n     * Gets the last char written.\r\n     */\r\n    CodeBlockWriter.prototype.getLastChar = function () {\r\n        if (this._text.length === 0)\r\n            return undefined;\r\n        return this._text[this._text.length - 1];\r\n    };\r\n    /**\r\n     * Gets the writer's text.\r\n     */\r\n    CodeBlockWriter.prototype.toString = function () {\r\n        return this._text;\r\n    };\r\n    CodeBlockWriter.prototype._writeIndentingNewLines = function (text) {\r\n        var _this = this;\r\n        text = text || \"\";\r\n        if (text.length === 0) {\r\n            writeIndividual.call(this, \"\");\r\n            return;\r\n        }\r\n        var items = text.split(/\\r?\\n/);\r\n        items.forEach(function (s, i) {\r\n            if (i > 0)\r\n                _this._baseWriteNewline();\r\n            if (s.length === 0)\r\n                return;\r\n            writeIndividual.call(_this, s);\r\n        });\r\n        function writeIndividual(s) {\r\n            if (!this.isInString()) {\r\n                var isAtStartOfLine = this.isLastNewLine() || this._text.length === 0;\r\n                if (isAtStartOfLine)\r\n                    this._writeIndentation();\r\n            }\r\n            this._updateInternalState(s);\r\n            this._text += s;\r\n            this.dequeueQueuedIndentation();\r\n        }\r\n    };\r\n    CodeBlockWriter.prototype._baseWriteNewline = function () {\r\n        if (this._currentCommentChar === CommentChar_1.CommentChar.Line)\r\n            this._currentCommentChar = undefined;\r\n        this._text += this._newLine;\r\n        this._isOnFirstLineOfBlock = false;\r\n        this.dequeueQueuedIndentation();\r\n    };\r\n    CodeBlockWriter.prototype.dequeueQueuedIndentation = function () {\r\n        if (this._queuedIndentation == null)\r\n            return;\r\n        this._currentIndentation = this._queuedIndentation;\r\n        this._queuedIndentation = undefined;\r\n    };\r\n    CodeBlockWriter.prototype._updateInternalState = function (str) {\r\n        for (var i = 0; i < str.length; i++) {\r\n            var currentChar = str[i];\r\n            var pastChar = i === 0 ? this._text[this._text.length - 1] : str[i - 1];\r\n            var pastPastChar = i < 1 ? this._text[this._text.length - 2 + i] : str[i - 2];\r\n            // handle regex\r\n            if (this._isInRegEx) {\r\n                if (pastChar === \"/\" && pastPastChar !== \"\\\\\" || pastChar === \"\\n\")\r\n                    this._isInRegEx = false;\r\n                else\r\n                    continue;\r\n            }\r\n            else if (!this.isInString() && !this.isInComment() && isRegExStart(currentChar, pastChar, pastPastChar)) {\r\n                this._isInRegEx = true;\r\n                continue;\r\n            }\r\n            // handle comments\r\n            if (this._currentCommentChar == null && pastChar === \"/\" && currentChar === \"/\")\r\n                this._currentCommentChar = CommentChar_1.CommentChar.Line;\r\n            else if (this._currentCommentChar == null && pastChar === \"/\" && currentChar === \"*\")\r\n                this._currentCommentChar = CommentChar_1.CommentChar.Star;\r\n            else if (this._currentCommentChar === CommentChar_1.CommentChar.Star && pastChar === \"*\" && currentChar === \"/\")\r\n                this._currentCommentChar = undefined;\r\n            if (this.isInComment())\r\n                continue;\r\n            // handle strings\r\n            var lastStringCharOnStack = this._stringCharStack.length === 0 ? undefined : this._stringCharStack[this._stringCharStack.length - 1];\r\n            if (currentChar === \"\\\"\" || currentChar === \"'\" || currentChar === \"`\") {\r\n                if (lastStringCharOnStack === currentChar)\r\n                    this._stringCharStack.pop();\r\n                else if (lastStringCharOnStack === \"{\" || lastStringCharOnStack === undefined)\r\n                    this._stringCharStack.push(currentChar);\r\n            }\r\n            else if (pastChar === \"$\" && currentChar === \"{\" && lastStringCharOnStack === \"`\")\r\n                this._stringCharStack.push(currentChar);\r\n            else if (currentChar === \"}\" && lastStringCharOnStack === \"{\")\r\n                this._stringCharStack.pop();\r\n        }\r\n        function isRegExStart(currentChar, pastChar, pastPastChar) {\r\n            return pastChar === \"/\"\r\n                && currentChar !== \"/\"\r\n                && currentChar !== \"*\"\r\n                && pastPastChar !== \"*\"\r\n                && pastPastChar !== \"/\";\r\n        }\r\n    };\r\n    CodeBlockWriter.prototype._writeIndentation = function () {\r\n        var flooredIndentation = Math.floor(this._currentIndentation);\r\n        for (var i = 0; i < flooredIndentation; i++)\r\n            this._text += this._indentationText;\r\n        var overflow = this._currentIndentation - flooredIndentation;\r\n        if (this._useTabs) {\r\n            if (overflow > 0.5)\r\n                this._text += this._indentationText;\r\n        }\r\n        else {\r\n            var portion = Math.round(this._indentationText.length * overflow);\r\n            for (var i = 0; i < portion; i++)\r\n                this._text += this._indentationText[i];\r\n        }\r\n    };\r\n    CodeBlockWriter.prototype._newLineIfNewLineOnNextWrite = function () {\r\n        if (!this._newLineOnNextWrite)\r\n            return;\r\n        this._newLineOnNextWrite = false;\r\n        this.newLine();\r\n    };\r\n    CodeBlockWriter.prototype._getIndentationLevelFromArg = function (countOrText) {\r\n        if (typeof countOrText === \"number\") {\r\n            if (countOrText < 0)\r\n                throw new Error(\"Passed in indentation level should be greater than or equal to 0.\");\r\n            return countOrText;\r\n        }\r\n        else if (typeof countOrText === \"string\") {\r\n            if (!/^[ \\t]*$/.test(countOrText))\r\n                throw new Error(\"Provided string must be empty or only contain spaces or tabs.\");\r\n            var _a = getSpacesAndTabsCount(countOrText), spacesCount = _a.spacesCount, tabsCount = _a.tabsCount;\r\n            return tabsCount + spacesCount / this._indentNumberOfSpaces;\r\n        }\r\n        else\r\n            throw new Error(\"Argument provided must be a string or number.\");\r\n    };\r\n    return CodeBlockWriter;\r\n}());\r\nexports.default = CodeBlockWriter;\r\nfunction getIndentationText(useTabs, numberSpaces) {\r\n    if (useTabs)\r\n        return \"\\t\";\r\n    return Array(numberSpaces + 1).join(\" \");\r\n}\r\nfunction getSpacesAndTabsCount(str) {\r\n    var spacesCount = 0;\r\n    var tabsCount = 0;\r\n    for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {\r\n        var char = str_1[_i];\r\n        if (char === \"\\t\")\r\n            tabsCount++;\r\n        else if (char === \" \")\r\n            spacesCount++;\r\n    }\r\n    return { spacesCount: spacesCount, tabsCount: tabsCount };\r\n}\r\n//# sourceMappingURL=code-block-writer.js.map\n\n//# sourceURL=webpack:///./node_modules/code-block-writer/dist/code-block-writer.js?");

/***/ }),

/***/ "./node_modules/code-block-writer/dist/utils/stringUtils.js":
/*!******************************************************************!*\
  !*** ./node_modules/code-block-writer/dist/utils/stringUtils.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** @internal */\r\nfunction stringRepeat(str, times) {\r\n    /* istanbul ignore else */\r\n    if (typeof String.prototype.repeat === \"function\")\r\n        return str.repeat(times);\r\n    else\r\n        return es5StringRepeat(str, times);\r\n}\r\nexports.stringRepeat = stringRepeat;\r\n/** @internal */\r\nfunction es5StringRepeat(str, times) {\r\n    if (times < 0)\r\n        throw new Error(\"Invalid times value.\");\r\n    var newStr = \"\";\r\n    for (var i = 0; i < times; i++)\r\n        newStr += str;\r\n    return newStr;\r\n}\r\nexports.es5StringRepeat = es5StringRepeat;\r\n/** @internal */\r\nfunction escapeForWithinString(str, quoteKind) {\r\n    return escapeChar(str, quoteKind).replace(/(\\r?\\n)/g, \"\\\\$1\");\r\n}\r\nexports.escapeForWithinString = escapeForWithinString;\r\n/** @internal */\r\nfunction escapeChar(str, char) {\r\n    if (char.length !== 1)\r\n        throw new Error(\"Specified char must be one character long.\");\r\n    var result = \"\";\r\n    for (var i = 0; i < str.length; i++) {\r\n        if (str[i] === char)\r\n            result += \"\\\\\";\r\n        result += str[i];\r\n    }\r\n    return result;\r\n}\r\nexports.escapeChar = escapeChar;\r\n/** @internal */\r\nfunction getStringFromStrOrFunc(strOrFunc) {\r\n    return strOrFunc instanceof Function ? strOrFunc() : strOrFunc;\r\n}\r\nexports.getStringFromStrOrFunc = getStringFromStrOrFunc;\r\n//# sourceMappingURL=stringUtils.js.map\n\n//# sourceURL=webpack:///./node_modules/code-block-writer/dist/utils/stringUtils.js?");

/***/ }),

/***/ "./node_modules/deprecated-decorator/bld/index.js":
/*!********************************************************!*\
  !*** ./node_modules/deprecated-decorator/bld/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\r\n    Deprecated Decorator v0.1\r\n    https://github.com/vilic/deprecated-decorator\r\n*/\r\n\r\n/** @internal */\r\nexports.options = {\r\n    getWarner: undefined\r\n};\r\nfunction createWarner(type, name, alternative, version, url) {\r\n    var warnedPositions = {};\r\n    return function () {\r\n        var stack = (new Error()).stack || '';\r\n        var at = (stack.match(/(?:\\s+at\\s.+){2}\\s+at\\s(.+)/) || [undefined, ''])[1];\r\n        if (/\\)$/.test(at)) {\r\n            at = at.match(/[^(]+(?=\\)$)/)[0];\r\n        }\r\n        else {\r\n            at = at.trim();\r\n        }\r\n        if (at in warnedPositions) {\r\n            return;\r\n        }\r\n        warnedPositions[at] = true;\r\n        var message;\r\n        switch (type) {\r\n            case 'class':\r\n                message = 'Class';\r\n                break;\r\n            case 'property':\r\n                message = 'Property';\r\n                break;\r\n            case 'method':\r\n                message = 'Method';\r\n                break;\r\n            case 'function':\r\n                message = 'Function';\r\n                break;\r\n        }\r\n        message += \" `\" + name + \"` has been deprecated\";\r\n        if (version) {\r\n            message += \" since version \" + version;\r\n        }\r\n        if (alternative) {\r\n            message += \", use `\" + alternative + \"` instead\";\r\n        }\r\n        message += '.';\r\n        if (at) {\r\n            message += \"\\n    at \" + at;\r\n        }\r\n        if (url) {\r\n            message += \"\\nCheck out \" + url + \" for more information.\";\r\n        }\r\n        console.warn(message);\r\n    };\r\n}\r\nfunction decorateProperty(type, name, descriptor, alternative, version, url) {\r\n    var warner = (exports.options.getWarner || createWarner)(type, name, alternative, version, url);\r\n    descriptor = descriptor || {\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: true\r\n    };\r\n    var deprecatedDescriptor = {\r\n        enumerable: descriptor.enumerable,\r\n        configurable: descriptor.configurable\r\n    };\r\n    if (descriptor.get || descriptor.set) {\r\n        if (descriptor.get) {\r\n            deprecatedDescriptor.get = function () {\r\n                warner();\r\n                return descriptor.get.call(this);\r\n            };\r\n        }\r\n        if (descriptor.set) {\r\n            deprecatedDescriptor.set = function (value) {\r\n                warner();\r\n                return descriptor.set.call(this, value);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        var propertyValue_1 = descriptor.value;\r\n        deprecatedDescriptor.get = function () {\r\n            warner();\r\n            return propertyValue_1;\r\n        };\r\n        if (descriptor.writable) {\r\n            deprecatedDescriptor.set = function (value) {\r\n                warner();\r\n                propertyValue_1 = value;\r\n            };\r\n        }\r\n    }\r\n    return deprecatedDescriptor;\r\n}\r\nfunction decorateFunction(type, target, alternative, version, url) {\r\n    var name = target.name;\r\n    var warner = (exports.options.getWarner || createWarner)(type, name, alternative, version, url);\r\n    var fn = function () {\r\n        warner();\r\n        return target.apply(this, arguments);\r\n    };\r\n    for (var _i = 0, _a = Object.getOwnPropertyNames(target); _i < _a.length; _i++) {\r\n        var propertyName = _a[_i];\r\n        var descriptor = Object.getOwnPropertyDescriptor(target, propertyName);\r\n        if (descriptor.writable) {\r\n            fn[propertyName] = target[propertyName];\r\n        }\r\n        else if (descriptor.configurable) {\r\n            Object.defineProperty(fn, propertyName, descriptor);\r\n        }\r\n    }\r\n    return fn;\r\n}\r\nfunction deprecated() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i - 0] = arguments[_i];\r\n    }\r\n    var fn = args[args.length - 1];\r\n    if (typeof fn === 'function') {\r\n        fn = args.pop();\r\n    }\r\n    else {\r\n        fn = undefined;\r\n    }\r\n    var options = args[0];\r\n    var alternative;\r\n    var version;\r\n    var url;\r\n    if (typeof options === 'string') {\r\n        alternative = options;\r\n        version = args[1];\r\n        url = args[2];\r\n    }\r\n    else if (options) {\r\n        (alternative = options.alternative, version = options.version, url = options.url, options);\r\n    }\r\n    if (fn) {\r\n        return decorateFunction('function', fn, alternative, version, url);\r\n    }\r\n    return function (target, name, descriptor) {\r\n        if (typeof name === 'string') {\r\n            var type = descriptor && typeof descriptor.value === 'function' ?\r\n                'method' : 'property';\r\n            return decorateProperty(type, name, descriptor, alternative, version, url);\r\n        }\r\n        else if (typeof target === 'function') {\r\n            var constructor = decorateFunction('class', target, alternative, version, url);\r\n            var className = target.name;\r\n            for (var _i = 0, _a = Object.getOwnPropertyNames(constructor); _i < _a.length; _i++) {\r\n                var propertyName = _a[_i];\r\n                var descriptor_1 = Object.getOwnPropertyDescriptor(constructor, propertyName);\r\n                descriptor_1 = decorateProperty('class', className, descriptor_1, alternative, version, url);\r\n                if (descriptor_1.writable) {\r\n                    constructor[propertyName] = target[propertyName];\r\n                }\r\n                else if (descriptor_1.configurable) {\r\n                    Object.defineProperty(constructor, propertyName, descriptor_1);\r\n                }\r\n            }\r\n            return constructor;\r\n        }\r\n    };\r\n}\r\nexports.deprecated = deprecated;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = deprecated;\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/deprecated-decorator/bld/index.js?");

/***/ }),

/***/ "./node_modules/dir-glob/index.js":
/*!****************************************!*\
  !*** ./node_modules/dir-glob/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst path = __webpack_require__(/*! path */ \"path\");\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst pathType = __webpack_require__(/*! path-type */ \"path-type\");\n\nconst getExtensions = extensions => extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0];\nconst getPath = filepath => filepath[0] === '!' ? filepath.slice(1) : filepath;\n\nconst addExtensions = (file, extensions) => {\n\tif (path.extname(file)) {\n\t\treturn `**/${file}`;\n\t}\n\n\treturn `**/${file}.${getExtensions(extensions)}`;\n};\n\nconst getGlob = (dir, opts) => {\n\topts = Object.assign({}, opts);\n\n\tif (opts.files && !Array.isArray(opts.files)) {\n\t\tthrow new TypeError(`\\`options.files\\` must be an \\`Array\\`, not \\`${typeof opts.files}\\``);\n\t}\n\n\tif (opts.extensions && !Array.isArray(opts.extensions)) {\n\t\tthrow new TypeError(`\\`options.extensions\\` must be an \\`Array\\`, not \\`${typeof opts.extensions}\\``);\n\t}\n\n\tif (opts.files && opts.extensions) {\n\t\treturn opts.files.map(x => path.join(dir, addExtensions(x, opts.extensions)));\n\t} else if (opts.files) {\n\t\treturn opts.files.map(x => path.join(dir, `**/${x}`));\n\t} else if (opts.extensions) {\n\t\treturn [path.join(dir, `**/*.${getExtensions(opts.extensions)}`)];\n\t}\n\n\treturn [path.join(dir, '**')];\n};\n\nmodule.exports = (input, opts) => {\n\treturn Promise.all(arrify(input).map(x => pathType.dir(getPath(x))\n\t\t.then(isDir => isDir ? getGlob(x, opts) : x)))\n\t\t.then(globs => [].concat.apply([], globs));\n};\n\nmodule.exports.sync = (input, opts) => {\n\tconst globs = arrify(input).map(x => pathType.dirSync(getPath(x)) ? getGlob(x, opts) : x);\n\treturn [].concat.apply([], globs);\n};\n\n\n//# sourceURL=webpack:///./node_modules/dir-glob/index.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack:///./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/fast-glob/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-glob/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pkg = __webpack_require__(/*! ./out/index */ \"./node_modules/fast-glob/out/index.js\");\n\nmodule.exports = pkg.async;\nmodule.exports.default = pkg.async;\n\nmodule.exports.async = pkg.async;\nmodule.exports.sync = pkg.sync;\nmodule.exports.stream = pkg.stream;\n\nmodule.exports.generateTasks = pkg.generateTasks;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/index.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/adapters/fs-stream.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-glob/out/adapters/fs-stream.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nvar fs_1 = __webpack_require__(/*! ./fs */ \"./node_modules/fast-glob/out/adapters/fs.js\");\nvar FileSystemStream = /** @class */ (function (_super) {\n    __extends(FileSystemStream, _super);\n    function FileSystemStream() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Use stream API to read entries for Task.\n     */\n    FileSystemStream.prototype.read = function (patterns, filter) {\n        var _this = this;\n        var filepaths = patterns.map(this.getFullEntryPath, this);\n        var transform = new stream.Transform({ objectMode: true });\n        transform._transform = function (index, _enc, done) {\n            return _this.getEntry(filepaths[index], patterns[index]).then(function (entry) {\n                if (entry !== null && filter(entry)) {\n                    transform.push(entry);\n                }\n                if (index === filepaths.length - 1) {\n                    transform.end();\n                }\n                done();\n            });\n        };\n        for (var i = 0; i < filepaths.length; i++) {\n            transform.write(i);\n        }\n        return transform;\n    };\n    /**\n     * Return entry for the provided path.\n     */\n    FileSystemStream.prototype.getEntry = function (filepath, pattern) {\n        var _this = this;\n        return this.getStat(filepath)\n            .then(function (stat) { return _this.makeEntry(stat, pattern); })\n            .catch(function () { return null; });\n    };\n    /**\n     * Return fs.Stats for the provided path.\n     */\n    FileSystemStream.prototype.getStat = function (filepath) {\n        return fsStat.stat(filepath, { throwErrorOnBrokenSymlinks: false });\n    };\n    return FileSystemStream;\n}(fs_1.default));\nexports.default = FileSystemStream;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/adapters/fs-stream.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/adapters/fs-sync.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-glob/out/adapters/fs-sync.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nvar fs_1 = __webpack_require__(/*! ./fs */ \"./node_modules/fast-glob/out/adapters/fs.js\");\nvar FileSystemSync = /** @class */ (function (_super) {\n    __extends(FileSystemSync, _super);\n    function FileSystemSync() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Use sync API to read entries for Task.\n     */\n    FileSystemSync.prototype.read = function (patterns, filter) {\n        var _this = this;\n        var entries = [];\n        patterns.forEach(function (pattern) {\n            var filepath = _this.getFullEntryPath(pattern);\n            var entry = _this.getEntry(filepath, pattern);\n            if (entry === null || !filter(entry)) {\n                return;\n            }\n            entries.push(entry);\n        });\n        return entries;\n    };\n    /**\n     * Return entry for the provided path.\n     */\n    FileSystemSync.prototype.getEntry = function (filepath, pattern) {\n        try {\n            var stat = this.getStat(filepath);\n            return this.makeEntry(stat, pattern);\n        }\n        catch (err) {\n            return null;\n        }\n    };\n    /**\n     * Return fs.Stats for the provided path.\n     */\n    FileSystemSync.prototype.getStat = function (filepath) {\n        return fsStat.statSync(filepath, { throwErrorOnBrokenSymlinks: false });\n    };\n    return FileSystemSync;\n}(fs_1.default));\nexports.default = FileSystemSync;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/adapters/fs-sync.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/adapters/fs.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/adapters/fs.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = __webpack_require__(/*! path */ \"path\");\nvar FileSystem = /** @class */ (function () {\n    function FileSystem(options) {\n        this.options = options;\n    }\n    /**\n     * Return full path to entry.\n     */\n    FileSystem.prototype.getFullEntryPath = function (filepath) {\n        return path.resolve(this.options.cwd, filepath);\n    };\n    /**\n     * Return an implementation of the Entry interface.\n     */\n    FileSystem.prototype.makeEntry = function (stat, pattern) {\n        return Object.assign(stat, {\n            path: pattern,\n            depth: pattern.split('/').length\n        });\n    };\n    return FileSystem;\n}());\nexports.default = FileSystem;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/adapters/fs.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/index.js":
/*!*********************************************!*\
  !*** ./node_modules/fast-glob/out/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar merge2 = __webpack_require__(/*! merge2 */ \"./node_modules/merge2/index.js\");\nvar optionsManager = __webpack_require__(/*! ./managers/options */ \"./node_modules/fast-glob/out/managers/options.js\");\nvar taskManager = __webpack_require__(/*! ./managers/tasks */ \"./node_modules/fast-glob/out/managers/tasks.js\");\nvar reader_async_1 = __webpack_require__(/*! ./providers/reader-async */ \"./node_modules/fast-glob/out/providers/reader-async.js\");\nvar reader_stream_1 = __webpack_require__(/*! ./providers/reader-stream */ \"./node_modules/fast-glob/out/providers/reader-stream.js\");\nvar reader_sync_1 = __webpack_require__(/*! ./providers/reader-sync */ \"./node_modules/fast-glob/out/providers/reader-sync.js\");\nvar arrayUtils = __webpack_require__(/*! ./utils/array */ \"./node_modules/fast-glob/out/utils/array.js\");\n/**\n * Synchronous API.\n */\nfunction sync(source, opts) {\n    var works = getWorks(source, reader_sync_1.default, opts);\n    return arrayUtils.flatten(works);\n}\nexports.sync = sync;\n/**\n * Asynchronous API.\n */\nfunction async(source, opts) {\n    var works = getWorks(source, reader_async_1.default, opts);\n    return Promise.all(works).then(arrayUtils.flatten);\n}\nexports.async = async;\n/**\n * Stream API.\n */\nfunction stream(source, opts) {\n    var works = getWorks(source, reader_stream_1.default, opts);\n    return merge2(works);\n}\nexports.stream = stream;\n/**\n * Return a set of tasks based on provided patterns.\n */\nfunction generateTasks(source, opts) {\n    var patterns = [].concat(source);\n    var options = optionsManager.prepare(opts);\n    return taskManager.generate(patterns, options);\n}\nexports.generateTasks = generateTasks;\n/**\n * Returns a set of works based on provided tasks and class of the reader.\n */\nfunction getWorks(source, _Reader, opts) {\n    var patterns = [].concat(source);\n    var options = optionsManager.prepare(opts);\n    var tasks = taskManager.generate(patterns, options);\n    var reader = new _Reader(options);\n    return tasks.map(reader.read, reader);\n}\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/index.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/managers/options.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-glob/out/managers/options.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction prepare(options) {\n    var opts = Object.assign({\n        cwd: process.cwd(),\n        deep: true,\n        ignore: [],\n        dot: false,\n        stats: false,\n        onlyFiles: true,\n        onlyDirectories: false,\n        followSymlinkedDirectories: true,\n        unique: true,\n        markDirectories: false,\n        absolute: false,\n        nobrace: false,\n        brace: true,\n        noglobstar: false,\n        globstar: true,\n        noext: false,\n        extension: true,\n        nocase: false,\n        case: true,\n        matchBase: false,\n        transform: null\n    }, options);\n    if (opts.onlyDirectories) {\n        opts.onlyFiles = false;\n    }\n    opts.brace = !opts.nobrace;\n    opts.globstar = !opts.noglobstar;\n    opts.extension = !opts.noext;\n    opts.case = !opts.nocase;\n    if (options) {\n        opts.brace = ('brace' in options ? options.brace : opts.brace);\n        opts.globstar = ('globstar' in options ? options.globstar : opts.globstar);\n        opts.extension = ('extension' in options ? options.extension : opts.extension);\n        opts.case = ('case' in options ? options.case : opts.case);\n    }\n    return opts;\n}\nexports.prepare = prepare;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/managers/options.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/managers/tasks.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/managers/tasks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar patternUtils = __webpack_require__(/*! ../utils/pattern */ \"./node_modules/fast-glob/out/utils/pattern.js\");\n/**\n * Generate tasks based on parent directory of each pattern.\n */\nfunction generate(patterns, options) {\n    var unixPatterns = patterns.map(patternUtils.unixifyPattern);\n    var unixIgnore = options.ignore.map(patternUtils.unixifyPattern);\n    var positivePatterns = getPositivePatterns(unixPatterns);\n    var negativePatterns = getNegativePatternsAsPositive(unixPatterns, unixIgnore);\n    var staticPatterns = positivePatterns.filter(patternUtils.isStaticPattern);\n    var dynamicPatterns = positivePatterns.filter(patternUtils.isDynamicPattern);\n    var staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);\n    var dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);\n    return staticTasks.concat(dynamicTasks);\n}\nexports.generate = generate;\n/**\n * Convert patterns to tasks based on parent directory of each pattern.\n */\nfunction convertPatternsToTasks(positive, negative, dynamic) {\n    var positivePatternsGroup = groupPatternsByBaseDirectory(positive);\n    var negativePatternsGroup = groupPatternsByBaseDirectory(negative);\n    // When we have a global group – there is no reason to divide the patterns into independent tasks.\n    // In this case, the global task covers the rest.\n    if ('.' in positivePatternsGroup) {\n        var task = convertPatternGroupToTask('.', positive, negative, dynamic);\n        return [task];\n    }\n    return convertPatternGroupsToTasks(positivePatternsGroup, negativePatternsGroup, dynamic);\n}\nexports.convertPatternsToTasks = convertPatternsToTasks;\n/**\n * Return only positive patterns.\n */\nfunction getPositivePatterns(patterns) {\n    return patternUtils.getPositivePatterns(patterns);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Return only negative patterns.\n */\nfunction getNegativePatternsAsPositive(patterns, ignore) {\n    var negative = patternUtils.getNegativePatterns(patterns).concat(ignore);\n    var positive = negative.map(patternUtils.convertToPositivePattern);\n    return positive;\n}\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\n/**\n * Group patterns by base directory of each pattern.\n */\nfunction groupPatternsByBaseDirectory(patterns) {\n    return patterns.reduce(function (collection, pattern) {\n        var base = patternUtils.getBaseDirectory(pattern);\n        if (base in collection) {\n            collection[base].push(pattern);\n        }\n        else {\n            collection[base] = [pattern];\n        }\n        return collection;\n    }, {});\n}\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\n/**\n * Convert group of patterns to tasks.\n */\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\n    var globalNegative = '.' in negative ? negative['.'] : [];\n    return Object.keys(positive).map(function (base) {\n        var localNegative = findLocalNegativePatterns(base, negative);\n        var fullNegative = localNegative.concat(globalNegative);\n        return convertPatternGroupToTask(base, positive[base], fullNegative, dynamic);\n    });\n}\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\n/**\n * Returns those negative patterns whose base paths includes positive base path.\n */\nfunction findLocalNegativePatterns(positiveBase, negative) {\n    return Object.keys(negative).reduce(function (collection, base) {\n        if (base.startsWith(positiveBase)) {\n            collection.push.apply(collection, __spread(negative[base]));\n        }\n        return collection;\n    }, []);\n}\nexports.findLocalNegativePatterns = findLocalNegativePatterns;\n/**\n * Create a task for positive and negative patterns.\n */\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\n    return {\n        base: base,\n        dynamic: dynamic,\n        patterns: [].concat(positive, negative.map(patternUtils.convertToNegativePattern)),\n        positive: positive,\n        negative: negative\n    };\n}\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/managers/tasks.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/deep.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/deep.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrayUtils = __webpack_require__(/*! ../../utils/array */ \"./node_modules/fast-glob/out/utils/array.js\");\nvar pathUtils = __webpack_require__(/*! ../../utils/path */ \"./node_modules/fast-glob/out/utils/path.js\");\nvar patternUtils = __webpack_require__(/*! ../../utils/pattern */ \"./node_modules/fast-glob/out/utils/pattern.js\");\nvar DeepFilter = /** @class */ (function () {\n    function DeepFilter(options, micromatchOptions) {\n        this.options = options;\n        this.micromatchOptions = micromatchOptions;\n    }\n    /**\n     * Returns filter for directories.\n     */\n    DeepFilter.prototype.getFilter = function (positive, negative) {\n        var _this = this;\n        var maxPatternDepth = this.getMaxPatternDepth(positive);\n        var negativeRe = this.getNegativePatternsRe(negative);\n        return function (entry) { return _this.filter(entry, negativeRe, maxPatternDepth); };\n    };\n    /**\n     * Returns max depth of the provided patterns.\n     */\n    DeepFilter.prototype.getMaxPatternDepth = function (patterns) {\n        var globstar = patterns.some(patternUtils.hasGlobStar);\n        var patternDepths = patterns.map(patternUtils.getDepth);\n        return globstar ? Infinity : arrayUtils.max(patternDepths);\n    };\n    /**\n     * Returns RegExp's for patterns that can affect the depth of reading.\n     */\n    DeepFilter.prototype.getNegativePatternsRe = function (patterns) {\n        var affectDepthOfReadingPatterns = patterns.filter(patternUtils.isAffectDepthOfReadingPattern);\n        return patternUtils.convertPatternsToRe(affectDepthOfReadingPatterns, this.micromatchOptions);\n    };\n    /**\n     * Returns «true» for directory that should be readed.\n     */\n    DeepFilter.prototype.filter = function (entry, negativeRe, maxPatternDepth) {\n        if (this.isSkippedByNestingLevel(entry.depth, maxPatternDepth)) {\n            return false;\n        }\n        if (this.isSkippedSymlinkedDirectory(entry)) {\n            return false;\n        }\n        if (this.isSkippedDotDirectory(entry)) {\n            return false;\n        }\n        return this.isSkippedByNegativePatterns(entry, negativeRe);\n    };\n    /**\n     * Returns «true» when the directory can be skipped by nesting level.\n     */\n    DeepFilter.prototype.isSkippedByNestingLevel = function (entryDepth, maxPatternDepth) {\n        return this.isSkippedByDeepOption(entryDepth) || this.isSkippedByMaxPatternDepth(entryDepth, maxPatternDepth);\n    };\n    /**\n     * Returns «true» when the «deep» option is disabled or number and depth of the entry is greater that the option value.\n     */\n    DeepFilter.prototype.isSkippedByDeepOption = function (entryDepth) {\n        return !this.options.deep || (typeof this.options.deep === 'number' && entryDepth > this.options.deep);\n    };\n    /**\n     * Returns «true» when depth parameter is not an Infinity and entry depth greater that the parameter value.\n     */\n    DeepFilter.prototype.isSkippedByMaxPatternDepth = function (entryDepth, maxPatternDepth) {\n        return maxPatternDepth !== Infinity && entryDepth > maxPatternDepth;\n    };\n    /**\n     * Returns «true» for symlinked directory if the «followSymlinkedDirectories» option is disabled.\n     */\n    DeepFilter.prototype.isSkippedSymlinkedDirectory = function (entry) {\n        return !this.options.followSymlinkedDirectories && entry.isSymbolicLink();\n    };\n    /**\n     * Returns «true» for a directory whose name starts with a period if «dot» option is disabled.\n     */\n    DeepFilter.prototype.isSkippedDotDirectory = function (entry) {\n        return !this.options.dot && pathUtils.isDotDirectory(entry.path);\n    };\n    /**\n     * Returns «true» for a directory whose path math to any negative pattern.\n     */\n    DeepFilter.prototype.isSkippedByNegativePatterns = function (entry, negativeRe) {\n        return !patternUtils.matchAny(entry.path, negativeRe);\n    };\n    return DeepFilter;\n}());\nexports.default = DeepFilter;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/providers/filters/deep.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/entry.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/entry.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar patternUtils = __webpack_require__(/*! ../../utils/pattern */ \"./node_modules/fast-glob/out/utils/pattern.js\");\nvar DeepFilter = /** @class */ (function () {\n    function DeepFilter(options, micromatchOptions) {\n        this.options = options;\n        this.micromatchOptions = micromatchOptions;\n        this.index = new Map();\n    }\n    /**\n     * Returns filter for directories.\n     */\n    DeepFilter.prototype.getFilter = function (positive, negative) {\n        var _this = this;\n        var positiveRe = patternUtils.convertPatternsToRe(positive, this.micromatchOptions);\n        var negativeRe = patternUtils.convertPatternsToRe(negative, this.micromatchOptions);\n        return function (entry) { return _this.filter(entry, positiveRe, negativeRe); };\n    };\n    /**\n     * Returns true if entry must be added to result.\n     */\n    DeepFilter.prototype.filter = function (entry, positiveRe, negativeRe) {\n        // Exclude duplicate results\n        if (this.options.unique) {\n            if (this.isDuplicateEntry(entry)) {\n                return false;\n            }\n            this.createIndexRecord(entry);\n        }\n        // Filter files and directories by options\n        if (this.onlyFileFilter(entry) || this.onlyDirectoryFilter(entry)) {\n            return false;\n        }\n        return this.isMatchToPatterns(entry, positiveRe) && !this.isMatchToPatterns(entry, negativeRe);\n    };\n    /**\n     * Return true if the entry already has in the cross reader index.\n     */\n    DeepFilter.prototype.isDuplicateEntry = function (entry) {\n        return this.index.has(entry.path);\n    };\n    /**\n     * Create record in the cross reader index.\n     */\n    DeepFilter.prototype.createIndexRecord = function (entry) {\n        this.index.set(entry.path, undefined);\n    };\n    /**\n     * Returns true for non-files if the «onlyFiles» option is enabled.\n     */\n    DeepFilter.prototype.onlyFileFilter = function (entry) {\n        return this.options.onlyFiles && !entry.isFile();\n    };\n    /**\n     * Returns true for non-directories if the «onlyDirectories» option is enabled.\n     */\n    DeepFilter.prototype.onlyDirectoryFilter = function (entry) {\n        return this.options.onlyDirectories && !entry.isDirectory();\n    };\n    /**\n     * Return true when entry match to provided patterns.\n     *\n     * First, just trying to apply patterns to the path.\n     * Second, trying to apply patterns to the path with final slash (need to micromatch to support «directory/**» patterns).\n     */\n    DeepFilter.prototype.isMatchToPatterns = function (entry, patternsRe) {\n        return patternUtils.matchAny(entry.path, patternsRe) || patternUtils.matchAny(entry.path + '/', patternsRe);\n    };\n    return DeepFilter;\n}());\nexports.default = DeepFilter;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/providers/filters/entry.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/reader-async.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/reader-async.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar readdir = __webpack_require__(/*! @mrmlnc/readdir-enhanced */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/index.js\");\nvar reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/providers/reader.js\");\nvar fs_stream_1 = __webpack_require__(/*! ../adapters/fs-stream */ \"./node_modules/fast-glob/out/adapters/fs-stream.js\");\nvar ReaderAsync = /** @class */ (function (_super) {\n    __extends(ReaderAsync, _super);\n    function ReaderAsync() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ReaderAsync.prototype, \"fsAdapter\", {\n        /**\n         * Returns FileSystem adapter.\n         */\n        get: function () {\n            return new fs_stream_1.default(this.options);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Use async API to read entries for Task.\n     */\n    ReaderAsync.prototype.read = function (task) {\n        var _this = this;\n        var root = this.getRootDirectory(task);\n        var options = this.getReaderOptions(task);\n        var entries = [];\n        return new Promise(function (resolve, reject) {\n            var stream = _this.api(root, task, options);\n            stream.on('error', function (err) {\n                _this.isEnoentCodeError(err) ? resolve([]) : reject(err);\n                stream.pause();\n            });\n            stream.on('data', function (entry) { return entries.push(_this.transform(entry)); });\n            stream.on('end', function () { return resolve(entries); });\n        });\n    };\n    /**\n     * Returns founded paths.\n     */\n    ReaderAsync.prototype.api = function (root, task, options) {\n        if (task.dynamic) {\n            return this.dynamicApi(root, options);\n        }\n        return this.staticApi(task, options);\n    };\n    /**\n     * Api for dynamic tasks.\n     */\n    ReaderAsync.prototype.dynamicApi = function (root, options) {\n        return readdir.readdirStreamStat(root, options);\n    };\n    /**\n     * Api for static tasks.\n     */\n    ReaderAsync.prototype.staticApi = function (task, options) {\n        return this.fsAdapter.read(task.patterns, options.filter);\n    };\n    return ReaderAsync;\n}(reader_1.default));\nexports.default = ReaderAsync;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/providers/reader-async.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/reader-stream.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/reader-stream.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar readdir = __webpack_require__(/*! @mrmlnc/readdir-enhanced */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/index.js\");\nvar reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/providers/reader.js\");\nvar fs_stream_1 = __webpack_require__(/*! ../adapters/fs-stream */ \"./node_modules/fast-glob/out/adapters/fs-stream.js\");\nvar TransformStream = /** @class */ (function (_super) {\n    __extends(TransformStream, _super);\n    function TransformStream(reader) {\n        var _this = _super.call(this, { objectMode: true }) || this;\n        _this.reader = reader;\n        return _this;\n    }\n    TransformStream.prototype._transform = function (entry, _encoding, callback) {\n        callback(null, this.reader.transform(entry));\n    };\n    return TransformStream;\n}(stream.Transform));\nvar ReaderStream = /** @class */ (function (_super) {\n    __extends(ReaderStream, _super);\n    function ReaderStream() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ReaderStream.prototype, \"fsAdapter\", {\n        /**\n         * Returns FileSystem adapter.\n         */\n        get: function () {\n            return new fs_stream_1.default(this.options);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Use stream API to read entries for Task.\n     */\n    ReaderStream.prototype.read = function (task) {\n        var _this = this;\n        var root = this.getRootDirectory(task);\n        var options = this.getReaderOptions(task);\n        var transform = new TransformStream(this);\n        var readable = this.api(root, task, options);\n        return readable\n            .once('error', function (err) { return _this.isEnoentCodeError(err) ? null : transform.emit('error', err); })\n            .pipe(transform);\n    };\n    /**\n     * Returns founded paths.\n     */\n    ReaderStream.prototype.api = function (root, task, options) {\n        if (task.dynamic) {\n            return this.dynamicApi(root, options);\n        }\n        return this.staticApi(task, options);\n    };\n    /**\n     * Api for dynamic tasks.\n     */\n    ReaderStream.prototype.dynamicApi = function (root, options) {\n        return readdir.readdirStreamStat(root, options);\n    };\n    /**\n     * Api for static tasks.\n     */\n    ReaderStream.prototype.staticApi = function (task, options) {\n        return this.fsAdapter.read(task.patterns, options.filter);\n    };\n    return ReaderStream;\n}(reader_1.default));\nexports.default = ReaderStream;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/providers/reader-stream.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/reader-sync.js":
/*!*************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/reader-sync.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar readdir = __webpack_require__(/*! @mrmlnc/readdir-enhanced */ \"./node_modules/@mrmlnc/readdir-enhanced/lib/index.js\");\nvar reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/providers/reader.js\");\nvar fs_sync_1 = __webpack_require__(/*! ../adapters/fs-sync */ \"./node_modules/fast-glob/out/adapters/fs-sync.js\");\nvar ReaderSync = /** @class */ (function (_super) {\n    __extends(ReaderSync, _super);\n    function ReaderSync() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ReaderSync.prototype, \"fsAdapter\", {\n        /**\n         * Returns FileSystem adapter.\n         */\n        get: function () {\n            return new fs_sync_1.default(this.options);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Use sync API to read entries for Task.\n     */\n    ReaderSync.prototype.read = function (task) {\n        var root = this.getRootDirectory(task);\n        var options = this.getReaderOptions(task);\n        try {\n            var entries = this.api(root, task, options);\n            return entries.map(this.transform, this);\n        }\n        catch (err) {\n            if (this.isEnoentCodeError(err)) {\n                return [];\n            }\n            throw err;\n        }\n    };\n    /**\n     * Returns founded paths.\n     */\n    ReaderSync.prototype.api = function (root, task, options) {\n        if (task.dynamic) {\n            return this.dynamicApi(root, options);\n        }\n        return this.staticApi(task, options);\n    };\n    /**\n     * Api for dynamic tasks.\n     */\n    ReaderSync.prototype.dynamicApi = function (root, options) {\n        return readdir.readdirSyncStat(root, options);\n    };\n    /**\n     * Api for static tasks.\n     */\n    ReaderSync.prototype.staticApi = function (task, options) {\n        return this.fsAdapter.read(task.patterns, options.filter);\n    };\n    return ReaderSync;\n}(reader_1.default));\nexports.default = ReaderSync;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/providers/reader-sync.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/reader.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/reader.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = __webpack_require__(/*! path */ \"path\");\nvar deep_1 = __webpack_require__(/*! ./filters/deep */ \"./node_modules/fast-glob/out/providers/filters/deep.js\");\nvar entry_1 = __webpack_require__(/*! ./filters/entry */ \"./node_modules/fast-glob/out/providers/filters/entry.js\");\nvar pathUtil = __webpack_require__(/*! ../utils/path */ \"./node_modules/fast-glob/out/utils/path.js\");\nvar Reader = /** @class */ (function () {\n    function Reader(options) {\n        this.options = options;\n        this.micromatchOptions = this.getMicromatchOptions();\n        this.entryFilter = new entry_1.default(options, this.micromatchOptions);\n        this.deepFilter = new deep_1.default(options, this.micromatchOptions);\n    }\n    /**\n     * Returns root path to scanner.\n     */\n    Reader.prototype.getRootDirectory = function (task) {\n        return path.resolve(this.options.cwd, task.base);\n    };\n    /**\n     * Returns options for reader.\n     */\n    Reader.prototype.getReaderOptions = function (task) {\n        return {\n            basePath: task.base === '.' ? '' : task.base,\n            filter: this.entryFilter.getFilter(task.positive, task.negative),\n            deep: this.deepFilter.getFilter(task.positive, task.negative),\n            sep: '/'\n        };\n    };\n    /**\n     * Returns options for micromatch.\n     */\n    Reader.prototype.getMicromatchOptions = function () {\n        return {\n            dot: this.options.dot,\n            nobrace: !this.options.brace,\n            noglobstar: !this.options.globstar,\n            noext: !this.options.extension,\n            nocase: !this.options.case,\n            matchBase: this.options.matchBase\n        };\n    };\n    /**\n     * Returns transformed entry.\n     */\n    Reader.prototype.transform = function (entry) {\n        if (this.options.markDirectories && entry.isDirectory()) {\n            entry.path += '/';\n        }\n        if (this.options.absolute && !path.isAbsolute(entry.path)) {\n            entry.path = pathUtil.resolve(this.options.cwd, entry.path);\n            entry.path = pathUtil.normalize(entry.path);\n        }\n        var item = this.options.stats ? entry : entry.path;\n        if (this.options.transform === null) {\n            return item;\n        }\n        return this.options.transform(item);\n    };\n    /**\n     * Returns true if error has ENOENT code.\n     */\n    Reader.prototype.isEnoentCodeError = function (err) {\n        return err.code === 'ENOENT';\n    };\n    return Reader;\n}());\nexports.default = Reader;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/providers/reader.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/array.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Flatten nested arrays (max depth is 2) into a non-nested array of non-array items.\n */\nfunction flatten(items) {\n    return items.reduce(function (collection, item) { return [].concat(collection, item); }, []);\n}\nexports.flatten = flatten;\n/**\n * Returns max number from array.\n */\nfunction max(items) {\n    return Math.max.apply(null, items);\n}\nexports.max = max;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/utils/array.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/path.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/path.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = __webpack_require__(/*! path */ \"path\");\n/**\n * Returns «true» if the last partial of the path starting with a period.\n */\nfunction isDotDirectory(filepath) {\n    return path.basename(filepath).startsWith('.');\n}\nexports.isDotDirectory = isDotDirectory;\n/**\n * Return naive depth of provided filepath.\n */\nfunction getDepth(filepath) {\n    return filepath.split('/').length;\n}\nexports.getDepth = getDepth;\n/**\n * Return resolved a sequence of paths segments into an absolute path.\n */\nfunction resolve(from, to) {\n    return path.resolve(from, to);\n}\nexports.resolve = resolve;\n/**\n * Convert a windows-like path to a unix-style path.\n */\nfunction normalize(filepath) {\n    return filepath.replace(/\\\\/g, '/');\n}\nexports.normalize = normalize;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/utils/path.js?");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/pattern.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/pattern.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar path = __webpack_require__(/*! path */ \"path\");\nvar globParent = __webpack_require__(/*! glob-parent */ \"glob-parent\");\nvar isGlob = __webpack_require__(/*! is-glob */ \"is-glob\");\nvar micromatch = __webpack_require__(/*! micromatch */ \"micromatch\");\nvar GLOBSTAR = '**';\n/**\n * Return true for static pattern.\n */\nfunction isStaticPattern(pattern) {\n    return !isDynamicPattern(pattern);\n}\nexports.isStaticPattern = isStaticPattern;\n/**\n * Return true for pattern that looks like glob.\n */\nfunction isDynamicPattern(pattern) {\n    return isGlob(pattern);\n}\nexports.isDynamicPattern = isDynamicPattern;\n/**\n * Convert a windows «path» to a unix-style «path».\n */\nfunction unixifyPattern(pattern) {\n    return pattern.replace(/\\\\/g, '/');\n}\nexports.unixifyPattern = unixifyPattern;\n/**\n * Returns negative pattern as positive pattern.\n */\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\n/**\n * Returns positive pattern as negative pattern.\n */\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\n/**\n * Return true if provided pattern is negative pattern.\n */\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\n/**\n * Return true if provided pattern is positive pattern.\n */\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\n/**\n * Extracts negative patterns from array of patterns.\n */\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\n/**\n * Extracts positive patterns from array of patterns.\n */\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Extract base directory from provided pattern.\n */\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern);\n}\nexports.getBaseDirectory = getBaseDirectory;\n/**\n * Return true if provided pattern has globstar.\n */\nfunction hasGlobStar(pattern) {\n    return pattern.indexOf(GLOBSTAR) !== -1;\n}\nexports.hasGlobStar = hasGlobStar;\n/**\n * Return true if provided pattern ends with slash and globstar.\n */\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n/**\n * Returns «true» when pattern ends with a slash and globstar or the last partial of the pattern is static pattern.\n */\nfunction isAffectDepthOfReadingPattern(pattern) {\n    var basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n/**\n * Return naive depth of provided pattern.\n */\nfunction getDepth(pattern) {\n    return pattern.split('/').length;\n}\nexports.getDepth = getDepth;\n/**\n * Make RegExp for provided pattern.\n */\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\n/**\n * Convert patterns to regexps.\n */\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map(function (pattern) { return makeRe(pattern, options); });\n}\nexports.convertPatternsToRe = convertPatternsToRe;\n/**\n * Returns true if the entry match any of the given RegExp's.\n */\nfunction matchAny(entry, patternsRe) {\n    try {\n        for (var patternsRe_1 = __values(patternsRe), patternsRe_1_1 = patternsRe_1.next(); !patternsRe_1_1.done; patternsRe_1_1 = patternsRe_1.next()) {\n            var regexp = patternsRe_1_1.value;\n            if (regexp.test(entry)) {\n                return true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (patternsRe_1_1 && !patternsRe_1_1.done && (_a = patternsRe_1.return)) _a.call(patternsRe_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return false;\n    var e_1, _a;\n}\nexports.matchAny = matchAny;\n\n\n//# sourceURL=webpack:///./node_modules/fast-glob/out/utils/pattern.js?");

/***/ }),

/***/ "./node_modules/fclone/dist/fclone.js":
/*!********************************************!*\
  !*** ./node_modules/fclone/dist/fclone.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        // AMD\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n  'use strict';\n\n// see if it looks and smells like an iterable object, and do accept length === 0\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction isArrayLike(item) {\n  if (Array.isArray(item)) return true;\n\n  var len = item && item.length;\n  return typeof len === 'number' && (len === 0 || len - 1 in item) && typeof item.indexOf === 'function';\n}\n\nfunction fclone(obj, refs) {\n  if (!obj || \"object\" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;\n\n  if (obj instanceof Date) {\n    return new Date(obj);\n  }\n\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\n    return new Buffer(obj);\n  }\n\n  // typed array Int32Array etc.\n  if (typeof obj.subarray === 'function' && /[A-Z][A-Za-z\\d]+Array/.test(Object.prototype.toString.call(obj))) {\n    return obj.subarray(0);\n  }\n\n  if (!refs) {\n    refs = [];\n  }\n\n  if (isArrayLike(obj)) {\n    refs[refs.length] = obj;\n    var _l = obj.length;\n    var i = -1;\n    var _copy = [];\n\n    while (_l > ++i) {\n      _copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);\n    }\n\n    refs.length && refs.length--;\n    return _copy;\n  }\n\n  refs[refs.length] = obj;\n  var copy = {};\n\n  if (obj instanceof Error) {\n    copy.name = obj.name;\n    copy.message = obj.message;\n    copy.stack = obj.stack;\n  }\n\n  var keys = Object.keys(obj);\n  var l = keys.length;\n\n  while (l--) {\n    var k = keys[l];\n    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);\n  }\n\n  refs.length && refs.length--;\n  return copy;\n}\n\nfclone.default = fclone;\n  return fclone\n}));\n\n//# sourceURL=webpack:///./node_modules/fclone/dist/fclone.js?");

/***/ }),

/***/ "./node_modules/glob-to-regexp/index.js":
/*!**********************************************!*\
  !*** ./node_modules/glob-to-regexp/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (glob, opts) {\n  if (typeof glob !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  var str = String(glob);\n\n  // The regexp we are building, as a string.\n  var reStr = \"\";\n\n  // Whether we are matching so called \"extended\" globs (like bash) and should\n  // support single character matching, matching ranges of characters, group\n  // matching, etc.\n  var extended = opts ? !!opts.extended : false;\n\n  // When globstar is _false_ (default), '/foo/*' is translated a regexp like\n  // '^\\/foo\\/.*$' which will match any string beginning with '/foo/'\n  // When globstar is _true_, '/foo/*' is translated to regexp like\n  // '^\\/foo\\/[^/]*$' which will match any string beginning with '/foo/' BUT\n  // which does not have a '/' to the right of it.\n  // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but\n  // these will not '/foo/bar/baz', '/foo/bar/baz.txt'\n  // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when\n  // globstar is _false_\n  var globstar = opts ? !!opts.globstar : false;\n\n  // If we are doing extended matching, this boolean is true when we are inside\n  // a group (eg {*.html,*.js}), and false otherwise.\n  var inGroup = false;\n\n  // RegExp flags (eg \"i\" ) to pass in to RegExp constructor.\n  var flags = opts && typeof( opts.flags ) === \"string\" ? opts.flags : \"\";\n\n  var c;\n  for (var i = 0, len = str.length; i < len; i++) {\n    c = str[i];\n\n    switch (c) {\n    case \"\\\\\":\n    case \"/\":\n    case \"$\":\n    case \"^\":\n    case \"+\":\n    case \".\":\n    case \"(\":\n    case \")\":\n    case \"=\":\n    case \"!\":\n    case \"|\":\n      reStr += \"\\\\\" + c;\n      break;\n\n    case \"?\":\n      if (extended) {\n        reStr += \".\";\n\t    break;\n      }\n\n    case \"[\":\n    case \"]\":\n      if (extended) {\n        reStr += c;\n\t    break;\n      }\n\n    case \"{\":\n      if (extended) {\n        inGroup = true;\n\t    reStr += \"(\";\n\t    break;\n      }\n\n    case \"}\":\n      if (extended) {\n        inGroup = false;\n\t    reStr += \")\";\n\t    break;\n      }\n\n    case \",\":\n      if (inGroup) {\n        reStr += \"|\";\n\t    break;\n      }\n      reStr += \"\\\\\" + c;\n      break;\n\n    case \"*\":\n      // Move over all consecutive \"*\"'s.\n      // Also store the previous and next characters\n      var prevChar = str[i - 1];\n      var starCount = 1;\n      while(str[i + 1] === \"*\") {\n        starCount++;\n        i++;\n      }\n      var nextChar = str[i + 1];\n\n      if (!globstar) {\n        // globstar is disabled, so treat any number of \"*\" as one\n        reStr += \".*\";\n      } else {\n        // globstar is enabled, so determine if this is a globstar segment\n        var isGlobstar = starCount > 1                      // multiple \"*\"'s\n          && (prevChar === \"/\" || prevChar === undefined)   // from the start of the segment\n          && (nextChar === \"/\" || nextChar === undefined)   // to the end of the segment\n\n        if (isGlobstar) {\n          // it's a globstar, so match zero or more path segments\n          reStr += \"(?:[^/]*(?:\\/|$))*\";\n          i++; // move over the \"/\"\n        } else {\n          // it's not a globstar, so only match one path segment\n          reStr += \"[^/]*\";\n        }\n      }\n      break;\n\n    default:\n      reStr += c;\n    }\n  }\n\n  // When regexp 'g' flag is specified don't\n  // constrain the regular expression with ^ & $\n  if (!flags || !~flags.indexOf('g')) {\n    reStr = \"^\" + reStr + \"$\";\n  }\n\n  return new RegExp(reStr, flags);\n};\n\n\n//# sourceURL=webpack:///./node_modules/glob-to-regexp/index.js?");

/***/ }),

/***/ "./node_modules/globby/gitignore.js":
/*!******************************************!*\
  !*** ./node_modules/globby/gitignore.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fastGlob = __webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/index.js\");\nconst gitIgnore = __webpack_require__(/*! ignore */ \"./node_modules/ignore/ignore.js\");\nconst pify = __webpack_require__(/*! pify */ \"pify\");\nconst slash = __webpack_require__(/*! slash */ \"slash\");\n\nconst DEFAULT_IGNORE = [\n\t'**/node_modules/**',\n\t'**/bower_components/**',\n\t'**/flow-typed/**',\n\t'**/coverage/**',\n\t'**/.git'\n];\n\nconst readFileP = pify(fs.readFile);\n\nconst mapGitIgnorePatternTo = base => ignore => {\n\tif (ignore.startsWith('!')) {\n\t\treturn '!' + path.posix.join(base, ignore.substr(1));\n\t}\n\n\treturn path.posix.join(base, ignore);\n};\n\nconst parseGitIgnore = (content, opts) => {\n\tconst base = slash(path.relative(opts.cwd, path.dirname(opts.fileName)));\n\n\treturn content\n\t\t.split(/\\r?\\n/)\n\t\t.filter(Boolean)\n\t\t.filter(l => l.charAt(0) !== '#')\n\t\t.map(mapGitIgnorePatternTo(base));\n};\n\nconst reduceIgnore = files => {\n\treturn files.reduce((ignores, file) => {\n\t\tignores.add(parseGitIgnore(file.content, {\n\t\t\tcwd: file.cwd,\n\t\t\tfileName: file.filePath\n\t\t}));\n\t\treturn ignores;\n\t}, gitIgnore());\n};\n\nconst getIsIgnoredPredecate = (ignores, cwd) => {\n\treturn p => ignores.ignores(slash(path.relative(cwd, p)));\n};\n\nconst getFile = (file, cwd) => {\n\tconst filePath = path.join(cwd, file);\n\treturn readFileP(filePath, 'utf8')\n\t\t.then(content => ({\n\t\t\tcontent,\n\t\t\tcwd,\n\t\t\tfilePath\n\t\t}));\n};\n\nconst getFileSync = (file, cwd) => {\n\tconst filePath = path.join(cwd, file);\n\tconst content = fs.readFileSync(filePath, 'utf8');\n\n\treturn {\n\t\tcontent,\n\t\tcwd,\n\t\tfilePath\n\t};\n};\n\nconst normalizeOpts = opts => {\n\topts = opts || {};\n\tconst ignore = opts.ignore || [];\n\tconst cwd = opts.cwd || process.cwd();\n\treturn {ignore, cwd};\n};\n\nmodule.exports = o => {\n\tconst opts = normalizeOpts(o);\n\n\treturn fastGlob('**/.gitignore', {ignore: DEFAULT_IGNORE.concat(opts.ignore), cwd: opts.cwd})\n\t\t.then(paths => Promise.all(paths.map(file => getFile(file, opts.cwd))))\n\t\t.then(files => reduceIgnore(files))\n\t\t.then(ignores => getIsIgnoredPredecate(ignores, opts.cwd));\n};\n\nmodule.exports.sync = o => {\n\tconst opts = normalizeOpts(o);\n\n\tconst paths = fastGlob.sync('**/.gitignore', {ignore: DEFAULT_IGNORE.concat(opts.ignore), cwd: opts.cwd});\n\tconst files = paths.map(file => getFileSync(file, opts.cwd));\n\tconst ignores = reduceIgnore(files);\n\treturn getIsIgnoredPredecate(ignores, opts.cwd);\n};\n\n\n//# sourceURL=webpack:///./node_modules/globby/gitignore.js?");

/***/ }),

/***/ "./node_modules/globby/index.js":
/*!**************************************!*\
  !*** ./node_modules/globby/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst arrayUnion = __webpack_require__(/*! array-union */ \"./node_modules/array-union/index.js\");\nconst glob = __webpack_require__(/*! glob */ \"glob\");\nconst fastGlob = __webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/index.js\");\nconst dirGlob = __webpack_require__(/*! dir-glob */ \"./node_modules/dir-glob/index.js\");\nconst gitignore = __webpack_require__(/*! ./gitignore */ \"./node_modules/globby/gitignore.js\");\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(x => typeof x === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst generateGlobTasks = (patterns, taskOpts) => {\n\tpatterns = [].concat(patterns);\n\tassertPatternsInput(patterns);\n\n\tconst globTasks = [];\n\n\ttaskOpts = Object.assign({\n\t\tignore: [],\n\t\texpandDirectories: true\n\t}, taskOpts);\n\n\tpatterns.forEach((pattern, i) => {\n\t\tif (isNegative(pattern)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(i)\n\t\t\t.filter(isNegative)\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst opts = Object.assign({}, taskOpts, {\n\t\t\tignore: taskOpts.ignore.concat(ignore)\n\t\t});\n\n\t\tglobTasks.push({pattern, opts});\n\t});\n\n\treturn globTasks;\n};\n\nconst globDirs = (task, fn) => {\n\tlet opts = {cwd: task.opts.cwd};\n\n\tif (Array.isArray(task.opts.expandDirectories)) {\n\t\topts = Object.assign(opts, {files: task.opts.expandDirectories});\n\t} else if (typeof task.opts.expandDirectories === 'object') {\n\t\topts = Object.assign(opts, task.opts.expandDirectories);\n\t}\n\n\treturn fn(task.pattern, opts);\n};\n\nconst getPattern = (task, fn) => task.opts.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nmodule.exports = (patterns, opts) => {\n\tlet globTasks;\n\n\ttry {\n\t\tglobTasks = generateGlobTasks(patterns, opts);\n\t} catch (err) {\n\t\treturn Promise.reject(err);\n\t}\n\n\tconst getTasks = Promise.all(globTasks.map(task => Promise.resolve(getPattern(task, dirGlob))\n\t\t.then(globs => Promise.all(globs.map(glob => ({\n\t\t\tpattern: glob,\n\t\t\topts: task.opts\n\t\t}))))\n\t))\n\t\t.then(tasks => arrayUnion.apply(null, tasks));\n\n\tconst getFilter = () => {\n\t\treturn Promise.resolve(\n\t\t\topts && opts.gitignore ?\n\t\t\t\tgitignore({cwd: opts.cwd, ignore: opts.ignore}) :\n\t\t\t\tDEFAULT_FILTER\n\t\t);\n\t};\n\n\treturn getFilter()\n\t\t.then(filter => {\n\t\t\treturn getTasks\n\t\t\t\t.then(tasks => Promise.all(tasks.map(task => fastGlob(task.pattern, task.opts))))\n\t\t\t\t.then(paths => arrayUnion.apply(null, paths))\n\t\t\t\t.then(paths => paths.filter(p => !filter(p)));\n\t\t});\n};\n\nmodule.exports.sync = (patterns, opts) => {\n\tconst globTasks = generateGlobTasks(patterns, opts);\n\n\tconst getFilter = () => {\n\t\treturn opts && opts.gitignore ?\n\t\t\tgitignore.sync({cwd: opts.cwd, ignore: opts.ignore}) :\n\t\t\tDEFAULT_FILTER;\n\t};\n\n\tconst tasks = globTasks.reduce((tasks, task) => {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(glob => ({\n\t\t\tpattern: glob,\n\t\t\topts: task.opts\n\t\t}));\n\t\treturn tasks.concat(newTask);\n\t}, []);\n\n\tconst filter = getFilter();\n\n\treturn tasks.reduce(\n\t\t(matches, task) => arrayUnion(matches, fastGlob.sync(task.pattern, task.opts)),\n\t\t[]\n\t).filter(p => !filter(p));\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, opts) => []\n\t.concat(patterns)\n\t.some(pattern => glob.hasMagic(pattern, opts));\n\nmodule.exports.gitignore = gitignore;\n\n\n//# sourceURL=webpack:///./node_modules/globby/index.js?");

/***/ }),

/***/ "./node_modules/graphql-extensions/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphql-extensions/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar apollo_server_env_1 = __webpack_require__(/*! apollo-server-env */ \"./node_modules/apollo-server-env/dist/index.js\");\nexports.Request = apollo_server_env_1.Request;\nclass GraphQLExtension {\n}\nexports.GraphQLExtension = GraphQLExtension;\nclass GraphQLExtensionStack {\n    constructor(extensions) {\n        this.extensions = extensions;\n    }\n    requestDidStart(o) {\n        return this.handleDidStart(ext => ext.requestDidStart && ext.requestDidStart(o));\n    }\n    parsingDidStart(o) {\n        return this.handleDidStart(ext => ext.parsingDidStart && ext.parsingDidStart(o));\n    }\n    validationDidStart() {\n        return this.handleDidStart(ext => ext.validationDidStart && ext.validationDidStart());\n    }\n    executionDidStart(o) {\n        if (o.executionArgs.fieldResolver) {\n            this.fieldResolver = o.executionArgs.fieldResolver;\n        }\n        return this.handleDidStart(ext => ext.executionDidStart && ext.executionDidStart(o));\n    }\n    willSendResponse(o) {\n        let reference = o;\n        [...this.extensions].reverse().forEach(extension => {\n            if (extension.willSendResponse) {\n                const result = extension.willSendResponse(reference);\n                if (result) {\n                    reference = result;\n                }\n            }\n        });\n        return reference;\n    }\n    willResolveField(source, args, context, info) {\n        const handlers = this.extensions\n            .map(extension => extension.willResolveField &&\n            extension.willResolveField(source, args, context, info))\n            .filter(x => x)\n            .reverse();\n        return (error, result) => {\n            for (const handler of handlers) {\n                handler(error, result);\n            }\n        };\n    }\n    format() {\n        return this.extensions\n            .map(extension => extension.format && extension.format())\n            .filter(x => x).reduce((extensions, [key, value]) => Object.assign(extensions, { [key]: value }), {});\n    }\n    handleDidStart(startInvoker) {\n        const endHandlers = [];\n        this.extensions.forEach(extension => {\n            const endHandler = startInvoker(extension);\n            if (endHandler) {\n                endHandlers.push(endHandler);\n            }\n        });\n        return (...errors) => {\n            endHandlers.reverse();\n            endHandlers.forEach(endHandler => endHandler(...errors));\n        };\n    }\n}\nexports.GraphQLExtensionStack = GraphQLExtensionStack;\nfunction enableGraphQLExtensions(schema) {\n    if (schema._extensionsEnabled) {\n        return schema;\n    }\n    schema._extensionsEnabled = true;\n    forEachField(schema, wrapField);\n    return schema;\n}\nexports.enableGraphQLExtensions = enableGraphQLExtensions;\nfunction wrapField(field) {\n    const fieldResolver = field.resolve;\n    field.resolve = (source, args, context, info) => {\n        const extensionStack = context && context._extensionStack;\n        const handler = (extensionStack &&\n            extensionStack.willResolveField(source, args, context, info)) ||\n            ((_err, _result) => {\n            });\n        try {\n            const result = (fieldResolver ||\n                (extensionStack && extensionStack.fieldResolver) ||\n                graphql_1.defaultFieldResolver)(source, args, context, info);\n            whenResultIsFinished(result, handler);\n            return result;\n        }\n        catch (error) {\n            handler(error);\n            throw error;\n        }\n    };\n}\nfunction isPromise(x) {\n    return x && typeof x.then === 'function';\n}\nfunction whenResultIsFinished(result, callback) {\n    if (isPromise(result)) {\n        result.then((r) => callback(null, r), (err) => callback(err));\n    }\n    else if (Array.isArray(result)) {\n        if (result.some(isPromise)) {\n            Promise.all(result).then((r) => callback(null, r), (err) => callback(err));\n        }\n        else {\n            callback(null, result);\n        }\n    }\n    else {\n        callback(null, result);\n    }\n}\nfunction forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(typeName => {\n        const type = typeMap[typeName];\n        if (!graphql_1.getNamedType(type).name.startsWith('__') &&\n            type instanceof graphql_1.GraphQLObjectType) {\n            const fields = type.getFields();\n            Object.keys(fields).forEach(fieldName => {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            });\n        }\n    });\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-extensions/dist/index.js?");

/***/ }),

/***/ "./node_modules/graphql-subscriptions/dist/event-emitter-to-async-iterator.js":
/*!************************************************************************************!*\
  !*** ./node_modules/graphql-subscriptions/dist/event-emitter-to-async-iterator.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\nfunction eventEmitterAsyncIterator(eventEmitter, eventsNames) {\n    var pullQueue = [];\n    var pushQueue = [];\n    var eventsArray = typeof eventsNames === 'string' ? [eventsNames] : eventsNames;\n    var listening = true;\n    var pushValue = function (event) {\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value: event, done: false });\n        }\n        else {\n            pushQueue.push(event);\n        }\n    };\n    var pullValue = function () {\n        return new Promise(function (resolve) {\n            if (pushQueue.length !== 0) {\n                resolve({ value: pushQueue.shift(), done: false });\n            }\n            else {\n                pullQueue.push(resolve);\n            }\n        });\n    };\n    var emptyQueue = function () {\n        if (listening) {\n            listening = false;\n            removeEventListeners();\n            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    var addEventListeners = function () {\n        for (var _i = 0, eventsArray_1 = eventsArray; _i < eventsArray_1.length; _i++) {\n            var eventName = eventsArray_1[_i];\n            eventEmitter.addListener(eventName, pushValue);\n        }\n    };\n    var removeEventListeners = function () {\n        for (var _i = 0, eventsArray_2 = eventsArray; _i < eventsArray_2.length; _i++) {\n            var eventName = eventsArray_2[_i];\n            eventEmitter.removeListener(eventName, pushValue);\n        }\n    };\n    addEventListeners();\n    return _a = {\n            next: function () {\n                return listening ? pullValue() : this.return();\n            },\n            return: function () {\n                emptyQueue();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (error) {\n                emptyQueue();\n                return Promise.reject(error);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n    var _a;\n}\nexports.eventEmitterAsyncIterator = eventEmitterAsyncIterator;\n//# sourceMappingURL=event-emitter-to-async-iterator.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-subscriptions/dist/event-emitter-to-async-iterator.js?");

/***/ }),

/***/ "./node_modules/graphql-subscriptions/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphql-subscriptions/dist/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pubsub_1 = __webpack_require__(/*! ./pubsub */ \"./node_modules/graphql-subscriptions/dist/pubsub.js\");\nexports.PubSub = pubsub_1.PubSub;\nvar with_filter_1 = __webpack_require__(/*! ./with-filter */ \"./node_modules/graphql-subscriptions/dist/with-filter.js\");\nexports.withFilter = with_filter_1.withFilter;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-subscriptions/dist/index.js?");

/***/ }),

/***/ "./node_modules/graphql-subscriptions/dist/pubsub.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql-subscriptions/dist/pubsub.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar events_1 = __webpack_require__(/*! events */ \"events\");\nvar event_emitter_to_async_iterator_1 = __webpack_require__(/*! ./event-emitter-to-async-iterator */ \"./node_modules/graphql-subscriptions/dist/event-emitter-to-async-iterator.js\");\nvar PubSub = (function () {\n    function PubSub(options) {\n        if (options === void 0) { options = {}; }\n        this.ee = options.eventEmitter || new events_1.EventEmitter();\n        this.subscriptions = {};\n        this.subIdCounter = 0;\n    }\n    PubSub.prototype.publish = function (triggerName, payload) {\n        this.ee.emit(triggerName, payload);\n        return true;\n    };\n    PubSub.prototype.subscribe = function (triggerName, onMessage) {\n        this.ee.addListener(triggerName, onMessage);\n        this.subIdCounter = this.subIdCounter + 1;\n        this.subscriptions[this.subIdCounter] = [triggerName, onMessage];\n        return Promise.resolve(this.subIdCounter);\n    };\n    PubSub.prototype.unsubscribe = function (subId) {\n        var _a = this.subscriptions[subId], triggerName = _a[0], onMessage = _a[1];\n        delete this.subscriptions[subId];\n        this.ee.removeListener(triggerName, onMessage);\n    };\n    PubSub.prototype.asyncIterator = function (triggers) {\n        return event_emitter_to_async_iterator_1.eventEmitterAsyncIterator(this.ee, triggers);\n    };\n    return PubSub;\n}());\nexports.PubSub = PubSub;\n//# sourceMappingURL=pubsub.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-subscriptions/dist/pubsub.js?");

/***/ }),

/***/ "./node_modules/graphql-subscriptions/dist/with-filter.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphql-subscriptions/dist/with-filter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\nexports.withFilter = function (asyncIteratorFn, filterFn) {\n    return function (rootValue, args, context, info) {\n        var asyncIterator = asyncIteratorFn(rootValue, args, context, info);\n        var getNextPromise = function () {\n            return asyncIterator\n                .next()\n                .then(function (payload) { return Promise.all([\n                payload,\n                Promise.resolve(filterFn(payload.value, args, context, info)).catch(function () { return false; }),\n            ]); })\n                .then(function (_a) {\n                var payload = _a[0], filterResult = _a[1];\n                if (filterResult === true || payload.done === true) {\n                    return payload;\n                }\n                return getNextPromise();\n            });\n        };\n        return _a = {\n                next: function () {\n                    return getNextPromise();\n                },\n                return: function () {\n                    return asyncIterator.return();\n                },\n                throw: function (error) {\n                    return asyncIterator.throw(error);\n                }\n            },\n            _a[iterall_1.$$asyncIterator] = function () {\n                return this;\n            },\n            _a;\n        var _a;\n    };\n};\n//# sourceMappingURL=with-filter.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-subscriptions/dist/with-filter.js?");

/***/ }),

/***/ "./node_modules/graphql-tag/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/graphql-tag/src/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! graphql/language/parser */ \"./node_modules/graphql/language/parser.js\");\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n\n\n//# sourceURL=webpack:///./node_modules/graphql-tag/src/index.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/SchemaError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/SchemaError.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @schemaDefinition: A GraphQL type schema in shorthand\n// @resolvers: Definitions for resolvers to be merged with schema\nvar SchemaError = /** @class */ (function (_super) {\n    __extends(SchemaError, _super);\n    function SchemaError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        Error.captureStackTrace(_this, _this.constructor);\n        return _this;\n    }\n    return SchemaError;\n}(Error));\nexports.default = SchemaError;\n//# sourceMappingURL=SchemaError.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/SchemaError.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/addResolveFunctionsToSchema.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/addResolveFunctionsToSchema.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar _2 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\nfunction addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {\n    if (options instanceof graphql_1.GraphQLSchema) {\n        console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');\n        options = {\n            schema: options,\n            resolvers: legacyInputResolvers,\n            resolverValidationOptions: legacyInputValidationOptions,\n        };\n    }\n    var schema = options.schema, inputResolvers = options.resolvers, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n    var resolvers = inheritResolversFromInterfaces\n        ? _2.extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    Object.keys(resolvers).forEach(function (typeName) {\n        var resolverValue = resolvers[typeName];\n        var resolverType = typeof resolverValue;\n        if (resolverType !== 'object' && resolverType !== 'function') {\n            throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value \" +\n                \"must be of type object or function.\");\n        }\n        var type = schema.getType(typeName);\n        if (!type && typeName !== '__schema') {\n            if (allowResolversNotInSchema) {\n                return;\n            }\n            throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n        }\n        Object.keys(resolverValue).forEach(function (fieldName) {\n            if (fieldName.startsWith('__')) {\n                // this is for isTypeOf and resolveType and all the other stuff.\n                type[fieldName.substring(2)] = resolverValue[fieldName];\n                return;\n            }\n            if (type instanceof graphql_1.GraphQLScalarType) {\n                type[fieldName] = resolverValue[fieldName];\n                return;\n            }\n            if (type instanceof graphql_1.GraphQLEnumType) {\n                if (!type.getValue(fieldName)) {\n                    if (allowResolversNotInSchema) {\n                        return;\n                    }\n                    throw new _1.SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n                }\n                type.getValue(fieldName)['value'] = resolverValue[fieldName];\n                return;\n            }\n            // object type\n            var fields = getFieldsForType(type);\n            if (!fields) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new _1.SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n            }\n            if (!fields[fieldName]) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new _1.SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n            }\n            var field = fields[fieldName];\n            var fieldResolve = resolverValue[fieldName];\n            if (typeof fieldResolve === 'function') {\n                // for convenience. Allows shorter syntax in resolver definition file\n                setFieldProperties(field, { resolve: fieldResolve });\n            }\n            else {\n                if (typeof fieldResolve !== 'object') {\n                    throw new _1.SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n                }\n                setFieldProperties(field, fieldResolve);\n            }\n        });\n    });\n    _2.checkForResolveTypeResolver(schema, requireResolversForResolveType);\n}\nfunction getFieldsForType(type) {\n    if (type instanceof graphql_1.GraphQLObjectType ||\n        type instanceof graphql_1.GraphQLInterfaceType) {\n        return type.getFields();\n    }\n    else {\n        return undefined;\n    }\n}\nfunction setFieldProperties(field, propertiesObj) {\n    Object.keys(propertiesObj).forEach(function (propertyName) {\n        field[propertyName] = propertiesObj[propertyName];\n    });\n}\nexports.default = addResolveFunctionsToSchema;\n//# sourceMappingURL=addResolveFunctionsToSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/addResolveFunctionsToSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\n// wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\nfunction addSchemaLevelResolveFunction(schema, fn) {\n    // TODO test that schema is a schema, fn is a function\n    var rootTypes = [\n        schema.getQueryType(),\n        schema.getMutationType(),\n        schema.getSubscriptionType(),\n    ].filter(function (x) { return !!x; });\n    rootTypes.forEach(function (type) {\n        // XXX this should run at most once per request to simulate a true root resolver\n        // for graphql-js this is an approximation that works with queries but not mutations\n        var rootResolveFn = runAtMostOncePerRequest(fn);\n        var fields = type.getFields();\n        Object.keys(fields).forEach(function (fieldName) {\n            // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n            // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n            if (type === schema.getSubscriptionType()) {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n            }\n            else {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n            }\n        });\n    });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n    return function (obj, args, ctx, info) {\n        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n            if (innerResolver) {\n                return innerResolver(root, args, ctx, info);\n            }\n            return graphql_1.defaultFieldResolver(root, args, ctx, info);\n        });\n    };\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n    var value;\n    var randomNumber = Math.random();\n    return function (root, args, ctx, info) {\n        if (!info.operation['__runAtMostOnce']) {\n            info.operation['__runAtMostOnce'] = {};\n        }\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\n            info.operation['__runAtMostOnce'][randomNumber] = true;\n            value = fn(root, args, ctx, info);\n        }\n        return value;\n    };\n}\nexports.default = addSchemaLevelResolveFunction;\n//# sourceMappingURL=addSchemaLevelResolveFunction.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/assertResolveFunctionsPresent.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/assertResolveFunctionsPresent.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar _1 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\nfunction assertResolveFunctionsPresent(schema, resolverValidationOptions) {\n    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }\n    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;\n    if (requireResolversForAllFields &&\n        (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    _1.forEachField(schema, function (field, typeName, fieldName) {\n        // requires a resolve function for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolveFunction(field, typeName, fieldName);\n        }\n        // requires a resolve function on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolveFunction(field, typeName, fieldName);\n        }\n        // requires a resolve function on every field that returns a non-scalar type\n        if (requireResolversForNonScalar &&\n            !(graphql_1.getNamedType(field.type) instanceof graphql_1.GraphQLScalarType)) {\n            expectResolveFunction(field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolveFunction(field, typeName, fieldName) {\n    if (!field.resolve) {\n        console.warn(\n        // tslint:disable-next-line: max-line-length\n        \"Resolve function missing for \\\"\" + typeName + \".\" + fieldName + \"\\\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131\");\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new _1.SchemaError(\"Resolver \\\"\" + typeName + \".\" + fieldName + \"\\\" must be a function\");\n    }\n}\nexports.default = assertResolveFunctionsPresent;\n//# sourceMappingURL=assertResolveFunctionsPresent.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/assertResolveFunctionsPresent.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/attachConnectorsToContext.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/attachConnectorsToContext.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar deprecated_decorator_1 = __webpack_require__(/*! deprecated-decorator */ \"./node_modules/deprecated-decorator/bld/index.js\");\nvar _1 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\n// takes a GraphQL-JS schema and an object of connectors, then attaches\n// the connectors to the context by wrapping each query or mutation resolve\n// function with a function that attaches connectors if they don't exist.\n// attaches connectors only once to make sure they are singletons\nvar attachConnectorsToContext = deprecated_decorator_1.deprecated({\n    version: '0.7.0',\n    url: 'https://github.com/apollostack/graphql-tools/issues/140',\n}, function (schema, connectors) {\n    if (!schema || !(schema instanceof graphql_1.GraphQLSchema)) {\n        throw new Error('schema must be an instance of GraphQLSchema. ' +\n            'This error could be caused by installing more than one version of GraphQL-JS');\n    }\n    if (typeof connectors !== 'object') {\n        var connectorType = typeof connectors;\n        throw new Error(\"Expected connectors to be of type object, got \" + connectorType);\n    }\n    if (Object.keys(connectors).length === 0) {\n        throw new Error('Expected connectors to not be an empty object');\n    }\n    if (Array.isArray(connectors)) {\n        throw new Error('Expected connectors to be of type object, got Array');\n    }\n    if (schema['_apolloConnectorsAttached']) {\n        throw new Error('Connectors already attached to context, cannot attach more than once');\n    }\n    schema['_apolloConnectorsAttached'] = true;\n    var attachconnectorFn = function (root, args, ctx) {\n        if (typeof ctx !== 'object') {\n            // if in any way possible, we should throw an error when the attachconnectors\n            // function is called, not when a query is executed.\n            var contextType = typeof ctx;\n            throw new Error(\"Cannot attach connector because context is not an object: \" + contextType);\n        }\n        if (typeof ctx.connectors === 'undefined') {\n            ctx.connectors = {};\n        }\n        Object.keys(connectors).forEach(function (connectorName) {\n            var connector = connectors[connectorName];\n            if (!!connector.prototype) {\n                ctx.connectors[connectorName] = new connector(ctx);\n            }\n            else {\n                throw new Error(\"Connector must be a function or an class\");\n            }\n        });\n        return root;\n    };\n    _1.addSchemaLevelResolveFunction(schema, attachconnectorFn);\n});\nexports.default = attachConnectorsToContext;\n//# sourceMappingURL=attachConnectorsToContext.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/attachConnectorsToContext.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/attachDirectiveResolvers.js":
/*!******************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/attachDirectiveResolvers.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar schemaVisitor_1 = __webpack_require__(/*! ../schemaVisitor */ \"./node_modules/graphql-tools/dist/schemaVisitor.js\");\nfunction attachDirectiveResolvers(schema, directiveResolvers) {\n    if (typeof directiveResolvers !== 'object') {\n        throw new Error(\"Expected directiveResolvers to be of type object, got \" + typeof directiveResolvers);\n    }\n    if (Array.isArray(directiveResolvers)) {\n        throw new Error('Expected directiveResolvers to be of type object, got Array');\n    }\n    var schemaDirectives = Object.create(null);\n    Object.keys(directiveResolvers).forEach(function (directiveName) {\n        schemaDirectives[directiveName] = /** @class */ (function (_super) {\n            __extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.visitFieldDefinition = function (field) {\n                var _this = this;\n                var resolver = directiveResolvers[directiveName];\n                var originalResolver = field.resolve || graphql_1.defaultFieldResolver;\n                var directiveArgs = this.args;\n                field.resolve = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var source = args[0] /* original args */, context = args[2], info = args[3];\n                    return resolver(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                        return [2 /*return*/, originalResolver.apply(field, args)];\n                    }); }); }, source, directiveArgs, context, info);\n                };\n            };\n            return class_1;\n        }(schemaVisitor_1.SchemaDirectiveVisitor));\n    });\n    schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n}\nexports.default = attachDirectiveResolvers;\n//# sourceMappingURL=attachDirectiveResolvers.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/attachDirectiveResolvers.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/buildSchemaFromTypeDefinitions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/buildSchemaFromTypeDefinitions.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar _1 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\nfunction buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\n    // TODO: accept only array here, otherwise interfaces get confusing.\n    var myDefinitions = typeDefinitions;\n    var astDocument;\n    if (isDocumentNode(typeDefinitions)) {\n        astDocument = typeDefinitions;\n    }\n    else if (typeof myDefinitions !== 'string') {\n        if (!Array.isArray(myDefinitions)) {\n            var type = typeof myDefinitions;\n            throw new _1.SchemaError(\"typeDefs must be a string, array or schema AST, got \" + type);\n        }\n        myDefinitions = _1.concatenateTypeDefs(myDefinitions);\n    }\n    if (typeof myDefinitions === 'string') {\n        astDocument = graphql_1.parse(myDefinitions, parseOptions);\n    }\n    var backcompatOptions = { commentDescriptions: true };\n    // TODO fix types https://github.com/apollographql/graphql-tools/issues/542\n    var schema = graphql_1.buildASTSchema(astDocument, backcompatOptions);\n    var extensionsAst = _1.extractExtensionDefinitions(astDocument);\n    if (extensionsAst.definitions.length > 0) {\n        // TODO fix types https://github.com/apollographql/graphql-tools/issues/542\n        schema = graphql_1.extendSchema(schema, extensionsAst, backcompatOptions);\n    }\n    return schema;\n}\nfunction isDocumentNode(typeDefinitions) {\n    return typeDefinitions.kind !== undefined;\n}\nexports.default = buildSchemaFromTypeDefinitions;\n//# sourceMappingURL=buildSchemaFromTypeDefinitions.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/buildSchemaFromTypeDefinitions.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/chainResolvers.js":
/*!********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/chainResolvers.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nfunction chainResolvers(resolvers) {\n    return function (root, args, ctx, info) {\n        return resolvers.reduce(function (prev, curResolver) {\n            if (curResolver) {\n                return curResolver(prev, args, ctx, info);\n            }\n            return graphql_1.defaultFieldResolver(prev, args, ctx, info);\n        }, root);\n    };\n}\nexports.default = chainResolvers;\n//# sourceMappingURL=chainResolvers.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/chainResolvers.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/checkForResolveTypeResolver.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/checkForResolveTypeResolver.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar _1 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    Object.keys(schema.getTypeMap())\n        .map(function (typeName) { return schema.getType(typeName); })\n        .forEach(function (type) {\n        if (!(type instanceof graphql_1.GraphQLUnionType ||\n            type instanceof graphql_1.GraphQLInterfaceType)) {\n            return;\n        }\n        if (!type.resolveType) {\n            if (requireResolversForResolveType === false) {\n                return;\n            }\n            if (requireResolversForResolveType === true) {\n                throw new _1.SchemaError(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"resolveType\\\" resolver\");\n            }\n            // tslint:disable-next-line:max-line-length\n            console.warn(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"resolveType\\\" resolver. Pass false into \" +\n                \"\\\"resolverValidationOptions.requireResolversForResolveType\\\" to disable this warning.\");\n        }\n    });\n}\nexports.default = checkForResolveTypeResolver;\n//# sourceMappingURL=checkForResolveTypeResolver.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/checkForResolveTypeResolver.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/concatenateTypeDefs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/concatenateTypeDefs.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar _1 = __webpack_require__(/*! . */ \"./node_modules/graphql-tools/dist/generate/index.js\");\nfunction concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {\n    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }\n    var resolvedTypeDefinitions = [];\n    typeDefinitionsAry.forEach(function (typeDef) {\n        if (typeDef.kind !== undefined) {\n            typeDef = graphql_1.print(typeDef);\n        }\n        if (typeof typeDef === 'function') {\n            if (calledFunctionRefs.indexOf(typeDef) === -1) {\n                calledFunctionRefs.push(typeDef);\n                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\n            }\n        }\n        else if (typeof typeDef === 'string') {\n            resolvedTypeDefinitions.push(typeDef.trim());\n        }\n        else {\n            var type = typeof typeDef;\n            throw new _1.SchemaError(\"typeDef array must contain only strings and functions, got \" + type);\n        }\n    });\n    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\\n');\n}\nfunction uniq(array) {\n    return array.reduce(function (accumulator, currentValue) {\n        return accumulator.indexOf(currentValue) === -1\n            ? accumulator.concat([currentValue]) : accumulator;\n    }, []);\n}\nexports.default = concatenateTypeDefs;\n//# sourceMappingURL=concatenateTypeDefs.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/concatenateTypeDefs.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/decorateWithLogger.js":
/*!************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/decorateWithLogger.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nfunction decorateWithLogger(fn, logger, hint) {\n    if (typeof fn === 'undefined') {\n        fn = graphql_1.defaultFieldResolver;\n    }\n    var logError = function (e) {\n        // TODO: clone the error properly\n        var newE = new Error();\n        newE.stack = e.stack;\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n        if (hint) {\n            newE['originalMessage'] = e.message;\n            newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\n        }\n        logger.log(newE);\n    };\n    return function (root, args, ctx, info) {\n        try {\n            var result = fn(root, args, ctx, info);\n            // If the resolve function returns a Promise log any Promise rejects.\n            if (result &&\n                typeof result.then === 'function' &&\n                typeof result.catch === 'function') {\n                result.catch(function (reason) {\n                    // make sure that it's an error we're logging.\n                    var error = reason instanceof Error ? reason : new Error(reason);\n                    logError(error);\n                    // We don't want to leave an unhandled exception so pass on error.\n                    return reason;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            logError(e);\n            // we want to pass on the error, just in case.\n            throw e;\n        }\n    };\n}\nexports.default = decorateWithLogger;\n//# sourceMappingURL=decorateWithLogger.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/decorateWithLogger.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/extendResolversFromInterfaces.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/extendResolversFromInterfaces.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    var typeNames = Object.keys(__assign({}, schema.getTypeMap(), resolvers));\n    var extendedResolvers = {};\n    typeNames.forEach(function (typeName) {\n        var typeResolvers = resolvers[typeName];\n        var type = schema.getType(typeName);\n        if (type instanceof graphql_1.GraphQLObjectType) {\n            var interfaceResolvers = type\n                .getInterfaces()\n                .map(function (iFace) { return resolvers[iFace.name]; });\n            extendedResolvers[typeName] = Object.assign.apply(Object, [{}].concat(interfaceResolvers, [typeResolvers]));\n        }\n        else {\n            if (typeResolvers) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    return extendedResolvers;\n}\nexports.default = extendResolversFromInterfaces;\n//# sourceMappingURL=extendResolversFromInterfaces.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/extendResolversFromInterfaces.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/extractExtensionDefinitions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/extractExtensionDefinitions.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar newExtensionDefinitionKind = 'ObjectTypeExtension';\nvar interfaceExtensionDefinitionKind = 'InterfaceTypeExtension';\nfunction extractExtensionDefinitions(ast) {\n    var extensionDefs = ast.definitions.filter(function (def) {\n        return def.kind === newExtensionDefinitionKind ||\n            def.kind === interfaceExtensionDefinitionKind;\n    });\n    return Object.assign({}, ast, {\n        definitions: extensionDefs,\n    });\n}\nexports.default = extractExtensionDefinitions;\n//# sourceMappingURL=extractExtensionDefinitions.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/extractExtensionDefinitions.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/forEachField.js":
/*!******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/forEachField.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nfunction forEachField(schema, fn) {\n    var typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!graphql_1.getNamedType(type).name.startsWith('__') &&\n            type instanceof graphql_1.GraphQLObjectType) {\n            var fields_1 = type.getFields();\n            Object.keys(fields_1).forEach(function (fieldName) {\n                var field = fields_1[fieldName];\n                fn(field, typeName, fieldName);\n            });\n        }\n    });\n}\nexports.default = forEachField;\n//# sourceMappingURL=forEachField.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/forEachField.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/generate/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql-tools/dist/generate/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar addResolveFunctionsToSchema_1 = __webpack_require__(/*! ./addResolveFunctionsToSchema */ \"./node_modules/graphql-tools/dist/generate/addResolveFunctionsToSchema.js\");\nexports.addResolveFunctionsToSchema = addResolveFunctionsToSchema_1.default;\nvar addSchemaLevelResolveFunction_1 = __webpack_require__(/*! ./addSchemaLevelResolveFunction */ \"./node_modules/graphql-tools/dist/generate/addSchemaLevelResolveFunction.js\");\nexports.addSchemaLevelResolveFunction = addSchemaLevelResolveFunction_1.default;\nvar assertResolveFunctionsPresent_1 = __webpack_require__(/*! ./assertResolveFunctionsPresent */ \"./node_modules/graphql-tools/dist/generate/assertResolveFunctionsPresent.js\");\nexports.assertResolveFunctionsPresent = assertResolveFunctionsPresent_1.default;\nvar attachDirectiveResolvers_1 = __webpack_require__(/*! ./attachDirectiveResolvers */ \"./node_modules/graphql-tools/dist/generate/attachDirectiveResolvers.js\");\nexports.attachDirectiveResolvers = attachDirectiveResolvers_1.default;\nvar attachConnectorsToContext_1 = __webpack_require__(/*! ./attachConnectorsToContext */ \"./node_modules/graphql-tools/dist/generate/attachConnectorsToContext.js\");\nexports.attachConnectorsToContext = attachConnectorsToContext_1.default;\nvar buildSchemaFromTypeDefinitions_1 = __webpack_require__(/*! ./buildSchemaFromTypeDefinitions */ \"./node_modules/graphql-tools/dist/generate/buildSchemaFromTypeDefinitions.js\");\nexports.buildSchemaFromTypeDefinitions = buildSchemaFromTypeDefinitions_1.default;\nvar chainResolvers_1 = __webpack_require__(/*! ./chainResolvers */ \"./node_modules/graphql-tools/dist/generate/chainResolvers.js\");\nexports.chainResolvers = chainResolvers_1.default;\nvar checkForResolveTypeResolver_1 = __webpack_require__(/*! ./checkForResolveTypeResolver */ \"./node_modules/graphql-tools/dist/generate/checkForResolveTypeResolver.js\");\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver_1.default;\nvar concatenateTypeDefs_1 = __webpack_require__(/*! ./concatenateTypeDefs */ \"./node_modules/graphql-tools/dist/generate/concatenateTypeDefs.js\");\nexports.concatenateTypeDefs = concatenateTypeDefs_1.default;\nvar decorateWithLogger_1 = __webpack_require__(/*! ./decorateWithLogger */ \"./node_modules/graphql-tools/dist/generate/decorateWithLogger.js\");\nexports.decorateWithLogger = decorateWithLogger_1.default;\nvar extendResolversFromInterfaces_1 = __webpack_require__(/*! ./extendResolversFromInterfaces */ \"./node_modules/graphql-tools/dist/generate/extendResolversFromInterfaces.js\");\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces_1.default;\nvar extractExtensionDefinitions_1 = __webpack_require__(/*! ./extractExtensionDefinitions */ \"./node_modules/graphql-tools/dist/generate/extractExtensionDefinitions.js\");\nexports.extractExtensionDefinitions = extractExtensionDefinitions_1.default;\nvar forEachField_1 = __webpack_require__(/*! ./forEachField */ \"./node_modules/graphql-tools/dist/generate/forEachField.js\");\nexports.forEachField = forEachField_1.default;\nvar SchemaError_1 = __webpack_require__(/*! ./SchemaError */ \"./node_modules/graphql-tools/dist/generate/SchemaError.js\");\nexports.SchemaError = SchemaError_1.default;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/generate/index.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/implementsAbstractType.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/implementsAbstractType.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nfunction implementsAbstractType(schema, typeA, typeB) {\n    if (typeA === typeB) {\n        return true;\n    }\n    else if (graphql_1.isCompositeType(typeA) && graphql_1.isCompositeType(typeB)) {\n        return graphql_1.doTypesOverlap(schema, typeA, typeB);\n    }\n    else {\n        return false;\n    }\n}\nexports.default = implementsAbstractType;\n//# sourceMappingURL=implementsAbstractType.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/implementsAbstractType.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql-tools/dist/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./makeExecutableSchema */ \"./node_modules/graphql-tools/dist/makeExecutableSchema.js\"));\n__export(__webpack_require__(/*! ./mock */ \"./node_modules/graphql-tools/dist/mock.js\"));\n__export(__webpack_require__(/*! ./stitching */ \"./node_modules/graphql-tools/dist/stitching/index.js\"));\n__export(__webpack_require__(/*! ./transforms */ \"./node_modules/graphql-tools/dist/transforms/index.js\"));\nvar schemaVisitor_1 = __webpack_require__(/*! ./schemaVisitor */ \"./node_modules/graphql-tools/dist/schemaVisitor.js\");\nexports.SchemaDirectiveVisitor = schemaVisitor_1.SchemaDirectiveVisitor;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/index.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/isEmptyObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphql-tools/dist/isEmptyObject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isEmptyObject(obj) {\n    if (!obj) {\n        return true;\n    }\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.default = isEmptyObject;\n//# sourceMappingURL=isEmptyObject.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/isEmptyObject.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/isSpecifiedScalarType.js":
/*!******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/isSpecifiedScalarType.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\n// FIXME: Replace with https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L139\nexports.specifiedScalarTypes = [\n    graphql_1.GraphQLString,\n    graphql_1.GraphQLInt,\n    graphql_1.GraphQLFloat,\n    graphql_1.GraphQLBoolean,\n    graphql_1.GraphQLID,\n];\nfunction isSpecifiedScalarType(type) {\n    return (graphql_1.isNamedType(type) &&\n        // Would prefer to use specifiedScalarTypes.some(), however %checks needs\n        // a simple expression.\n        (type.name === graphql_1.GraphQLString.name ||\n            type.name === graphql_1.GraphQLInt.name ||\n            type.name === graphql_1.GraphQLFloat.name ||\n            type.name === graphql_1.GraphQLBoolean.name ||\n            type.name === graphql_1.GraphQLID.name));\n}\nexports.default = isSpecifiedScalarType;\n//# sourceMappingURL=isSpecifiedScalarType.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/isSpecifiedScalarType.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/makeExecutableSchema.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/makeExecutableSchema.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar schemaVisitor_1 = __webpack_require__(/*! ./schemaVisitor */ \"./node_modules/graphql-tools/dist/schemaVisitor.js\");\nvar mergeDeep_1 = __webpack_require__(/*! ./mergeDeep */ \"./node_modules/graphql-tools/dist/mergeDeep.js\");\nvar generate_1 = __webpack_require__(/*! ./generate */ \"./node_modules/graphql-tools/dist/generate/index.js\");\nfunction makeExecutableSchema(_a) {\n    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, _e = _a.directiveResolvers, directiveResolvers = _e === void 0 ? null : _e, _f = _a.schemaDirectives, schemaDirectives = _f === void 0 ? null : _f, _g = _a.parseOptions, parseOptions = _g === void 0 ? {} : _g, _h = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _h === void 0 ? false : _h;\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new generate_1.SchemaError('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new generate_1.SchemaError('Must provide typeDefs');\n    }\n    if (!resolvers) {\n        throw new generate_1.SchemaError('Must provide resolvers');\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    var resolverMap = Array.isArray(resolvers)\n        ? resolvers.filter(function (resolverObj) { return typeof resolverObj === 'object'; }).reduce(mergeDeep_1.default, {})\n        : resolvers;\n    // Arguments are now validated and cleaned up\n    var schema = generate_1.buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n    generate_1.addResolveFunctionsToSchema({\n        schema: schema,\n        resolvers: resolverMap,\n        resolverValidationOptions: resolverValidationOptions,\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces\n    });\n    generate_1.assertResolveFunctionsPresent(schema, resolverValidationOptions);\n    if (!allowUndefinedInResolve) {\n        addCatchUndefinedToSchema(schema);\n    }\n    if (logger) {\n        addErrorLoggingToSchema(schema, logger);\n    }\n    if (typeof resolvers['__schema'] === 'function') {\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n        // not doing that now, because I'd have to rewrite a lot of tests.\n        generate_1.addSchemaLevelResolveFunction(schema, resolvers['__schema']);\n    }\n    if (connectors) {\n        // connectors are optional, at least for now. That means you can just import them in the resolve\n        // function if you want.\n        generate_1.attachConnectorsToContext(schema, connectors);\n    }\n    if (directiveResolvers) {\n        generate_1.attachDirectiveResolvers(schema, directiveResolvers);\n    }\n    if (schemaDirectives) {\n        schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n    }\n    return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;\nfunction decorateToCatchUndefined(fn, hint) {\n    if (typeof fn === 'undefined') {\n        fn = graphql_1.defaultFieldResolver;\n    }\n    return function (root, args, ctx, info) {\n        var result = fn(root, args, ctx, info);\n        if (typeof result === 'undefined') {\n            throw new Error(\"Resolve function for \\\"\" + hint + \"\\\" returned undefined\");\n        }\n        return result;\n    };\n}\nfunction addCatchUndefinedToSchema(schema) {\n    generate_1.forEachField(schema, function (field, typeName, fieldName) {\n        var errorHint = typeName + \".\" + fieldName;\n        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n    });\n}\nexports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;\nfunction addErrorLoggingToSchema(schema, logger) {\n    if (!logger) {\n        throw new Error('Must provide a logger');\n    }\n    if (typeof logger.log !== 'function') {\n        throw new Error('Logger.log must be a function');\n    }\n    generate_1.forEachField(schema, function (field, typeName, fieldName) {\n        var errorHint = typeName + \".\" + fieldName;\n        field.resolve = generate_1.decorateWithLogger(field.resolve, logger, errorHint);\n    });\n}\nexports.addErrorLoggingToSchema = addErrorLoggingToSchema;\n__export(__webpack_require__(/*! ./generate */ \"./node_modules/graphql-tools/dist/generate/index.js\"));\n//# sourceMappingURL=makeExecutableSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/makeExecutableSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/mergeDeep.js":
/*!******************************************************!*\
  !*** ./node_modules/graphql-tools/dist/mergeDeep.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction mergeDeep(target, source) {\n    var output = Object.assign({}, target);\n    if (isObject(target) && isObject(source)) {\n        Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n                if (!(key in target)) {\n                    Object.assign(output, (_a = {}, _a[key] = source[key], _a));\n                }\n                else {\n                    output[key] = mergeDeep(target[key], source[key]);\n                }\n            }\n            else {\n                Object.assign(output, (_b = {}, _b[key] = source[key], _b));\n            }\n            var _a, _b;\n        });\n    }\n    return output;\n}\nexports.default = mergeDeep;\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n//# sourceMappingURL=mergeDeep.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/mergeDeep.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/mock.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql-tools/dist/mock.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar uuid = __webpack_require__(/*! uuid */ \"uuid\");\nvar makeExecutableSchema_1 = __webpack_require__(/*! ./makeExecutableSchema */ \"./node_modules/graphql-tools/dist/makeExecutableSchema.js\");\n// This function wraps addMockFunctionsToSchema for more convenience\nfunction mockServer(schema, mocks, preserveResolvers) {\n    if (preserveResolvers === void 0) { preserveResolvers = false; }\n    var mySchema;\n    if (!(schema instanceof graphql_1.GraphQLSchema)) {\n        // TODO: provide useful error messages here if this fails\n        mySchema = makeExecutableSchema_1.buildSchemaFromTypeDefinitions(schema);\n    }\n    else {\n        mySchema = schema;\n    }\n    addMockFunctionsToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });\n    return { query: function (query, vars) { return graphql_1.graphql(mySchema, query, {}, {}, vars); } };\n}\nexports.mockServer = mockServer;\nvar defaultMockMap = new Map();\ndefaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });\ndefaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });\ndefaultMockMap.set('String', function () { return 'Hello World'; });\ndefaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });\ndefaultMockMap.set('ID', function () { return uuid.v4(); });\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nfunction addMockFunctionsToSchema(_a) {\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!(schema instanceof graphql_1.GraphQLSchema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (!isObject(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    // use Map internally, because that API is nicer.\n    var mockFunctionMap = new Map();\n    Object.keys(mocks).forEach(function (typeName) {\n        mockFunctionMap.set(typeName, mocks[typeName]);\n    });\n    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\n        if (typeof mockFunction !== 'function') {\n            throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\n        }\n    });\n    var mockType = function (type, typeName, fieldName) {\n        // order of precendence for mocking:\n        // 1. if the object passed in already has fieldName, just use that\n        // --> if it's a function, that becomes your resolver\n        // --> if it's a value, the mock resolver will return that\n        // 2. if the nullableType is a list, recurse\n        // 2. if there's a mock defined for this typeName, that will be used\n        // 3. if there's no mock defined, use the default mocks for this type\n        return function (root, args, context, info) {\n            // nullability doesn't matter for the purpose of mocking.\n            var fieldType = graphql_1.getNullableType(type);\n            var namedFieldType = graphql_1.getNamedType(fieldType);\n            if (root && typeof root[fieldName] !== 'undefined') {\n                var result = void 0;\n                // if we're here, the field is already defined\n                if (typeof root[fieldName] === 'function') {\n                    result = root[fieldName](root, args, context, info);\n                    if (result instanceof MockList) {\n                        result = result.mock(root, args, context, info, fieldType, mockType);\n                    }\n                }\n                else {\n                    result = root[fieldName];\n                }\n                // Now we merge the result with the default mock for this type.\n                // This allows overriding defaults while writing very little code.\n                if (mockFunctionMap.has(namedFieldType.name)) {\n                    result = mergeMocks(mockFunctionMap\n                        .get(namedFieldType.name)\n                        .bind(null, root, args, context, info), result);\n                }\n                return result;\n            }\n            if (fieldType instanceof graphql_1.GraphQLList) {\n                return [\n                    mockType(fieldType.ofType)(root, args, context, info),\n                    mockType(fieldType.ofType)(root, args, context, info),\n                ];\n            }\n            if (mockFunctionMap.has(fieldType.name) &&\n                !(fieldType instanceof graphql_1.GraphQLUnionType ||\n                    fieldType instanceof graphql_1.GraphQLInterfaceType)) {\n                // the object passed doesn't have this field, so we apply the default mock\n                return mockFunctionMap.get(fieldType.name)(root, args, context, info);\n            }\n            if (fieldType instanceof graphql_1.GraphQLObjectType) {\n                // objects don't return actual data, we only need to mock scalars!\n                return {};\n            }\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n            // otherwise randomly pick a type from all implementation types\n            if (fieldType instanceof graphql_1.GraphQLUnionType ||\n                fieldType instanceof graphql_1.GraphQLInterfaceType) {\n                var implementationType = void 0;\n                if (mockFunctionMap.has(fieldType.name)) {\n                    var interfaceMockObj = mockFunctionMap.get(fieldType.name)(root, args, context, info);\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\n                        return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\n                    }\n                    implementationType = schema.getType(interfaceMockObj.__typename);\n                }\n                else {\n                    var possibleTypes = schema.getPossibleTypes(fieldType);\n                    implementationType = getRandomElement(possibleTypes);\n                }\n                return Object.assign({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));\n            }\n            if (fieldType instanceof graphql_1.GraphQLEnumType) {\n                return getRandomElement(fieldType.getValues()).value;\n            }\n            if (defaultMockMap.has(fieldType.name)) {\n                return defaultMockMap.get(fieldType.name)(root, args, context, info);\n            }\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\n            // we could return undefined, but that would be hard to debug, so we throw instead.\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n            return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\n        };\n    };\n    makeExecutableSchema_1.forEachField(schema, function (field, typeName, fieldName) {\n        assignResolveType(field.type, preserveResolvers);\n        var mockResolver;\n        // we have to handle the root mutation and root query types differently,\n        // because no resolver is called at the root.\n        /* istanbul ignore next: Must provide schema DefinitionNode with query type or a type named Query. */\n        var isOnQueryType = schema.getQueryType() && schema.getQueryType().name === typeName;\n        var isOnMutationType = schema.getMutationType() && schema.getMutationType().name === typeName;\n        if (isOnQueryType || isOnMutationType) {\n            if (mockFunctionMap.has(typeName)) {\n                var rootMock_1 = mockFunctionMap.get(typeName);\n                // XXX: BUG in here, need to provide proper signature for rootMock.\n                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] === 'function') {\n                    mockResolver = function (root, args, context, info) {\n                        var updatedRoot = root || {}; // TODO: should we clone instead?\n                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];\n                        // XXX this is a bit of a hack to still use mockType, which\n                        // lets you mock lists etc. as well\n                        // otherwise we could just set field.resolve to rootMock()[fieldName]\n                        // it's like pretending there was a resolve function that ran before\n                        // the root resolve function.\n                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\n                    };\n                }\n            }\n        }\n        if (!mockResolver) {\n            mockResolver = mockType(field.type, typeName, fieldName);\n        }\n        if (!preserveResolvers || !field.resolve) {\n            field.resolve = mockResolver;\n        }\n        else {\n            var oldResolver_1 = field.resolve;\n            field.resolve = function (rootObject, args, context, info) {\n                return Promise.all([\n                    mockResolver(rootObject, args, context, info),\n                    oldResolver_1(rootObject, args, context, info),\n                ]).then(function (values) {\n                    var mockedValue = values[0], resolvedValue = values[1];\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if (isObject(mockedValue) && isObject(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                });\n            };\n        }\n    });\n}\nexports.addMockFunctionsToSchema = addMockFunctionsToSchema;\nfunction isObject(thing) {\n    return thing === Object(thing) && !Array.isArray(thing);\n}\n// returns a random element from that ary\nfunction getRandomElement(ary) {\n    var sample = Math.floor(Math.random() * ary.length);\n    return ary[sample];\n}\nfunction mergeObjects(a, b) {\n    return Object.assign(a, b);\n}\nfunction copyOwnPropsIfNotPresent(target, source) {\n    Object.getOwnPropertyNames(source).forEach(function (prop) {\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\n            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n        }\n    });\n}\nfunction copyOwnProps(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        var chain = source;\n        while (chain) {\n            copyOwnPropsIfNotPresent(target, chain);\n            chain = Object.getPrototypeOf(chain);\n        }\n    });\n    return target;\n}\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction, customMock) {\n    if (Array.isArray(customMock)) {\n        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });\n    }\n    if (isObject(customMock)) {\n        return mergeObjects(genericMockFunction(), customMock);\n    }\n    return customMock;\n}\nfunction getResolveType(namedFieldType) {\n    if (namedFieldType instanceof graphql_1.GraphQLInterfaceType ||\n        namedFieldType instanceof graphql_1.GraphQLUnionType) {\n        return namedFieldType.resolveType;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction assignResolveType(type, preserveResolvers) {\n    var fieldType = graphql_1.getNullableType(type);\n    var namedFieldType = graphql_1.getNamedType(fieldType);\n    var oldResolveType = getResolveType(namedFieldType);\n    if (preserveResolvers && oldResolveType && oldResolveType.length) {\n        return;\n    }\n    if (namedFieldType instanceof graphql_1.GraphQLUnionType ||\n        namedFieldType instanceof graphql_1.GraphQLInterfaceType) {\n        // the default `resolveType` always returns null. We add a fallback\n        // resolution that works with how unions and interface are mocked\n        namedFieldType.resolveType = function (data, context, info) {\n            return info.schema.getType(data.__typename);\n        };\n    }\n}\nvar MockList = /** @class */ (function () {\n    // wrappedFunction can return another MockList or a value\n    function MockList(len, wrappedFunction) {\n        this.len = len;\n        if (typeof wrappedFunction !== 'undefined') {\n            if (typeof wrappedFunction !== 'function') {\n                throw new Error('Second argument to MockList must be a function or undefined');\n            }\n            this.wrappedFunction = wrappedFunction;\n        }\n    }\n    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\n        var arr;\n        if (Array.isArray(this.len)) {\n            arr = new Array(this.randint(this.len[0], this.len[1]));\n        }\n        else {\n            arr = new Array(this.len);\n        }\n        for (var i = 0; i < arr.length; i++) {\n            if (typeof this.wrappedFunction === 'function') {\n                var res = this.wrappedFunction(root, args, context, info);\n                if (res instanceof MockList) {\n                    var nullableType = graphql_1.getNullableType(fieldType.ofType);\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n                }\n                else {\n                    arr[i] = res;\n                }\n            }\n            else {\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n            }\n        }\n        return arr;\n    };\n    MockList.prototype.randint = function (low, high) {\n        return Math.floor(Math.random() * (high - low + 1) + low);\n    };\n    return MockList;\n}());\nexports.MockList = MockList;\n//# sourceMappingURL=mock.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/mock.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/schemaVisitor.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphql-tools/dist/schemaVisitor.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar values_1 = __webpack_require__(/*! graphql/execution/values */ \"./node_modules/graphql/execution/values.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nvar SchemaVisitor = /** @class */ (function () {\n    function SchemaVisitor() {\n    }\n    // Determine if this SchemaVisitor (sub)class implements a particular\n    // visitor method.\n    SchemaVisitor.implementsVisitorMethod = function (methodName) {\n        if (!methodName.startsWith('visit')) {\n            return false;\n        }\n        var method = this.prototype[methodName];\n        if (typeof method !== 'function') {\n            return false;\n        }\n        if (this === SchemaVisitor) {\n            // The SchemaVisitor class implements every visitor method.\n            return true;\n        }\n        var stub = SchemaVisitor.prototype[methodName];\n        if (method === stub) {\n            // If this.prototype[methodName] was just inherited from SchemaVisitor,\n            // then this class does not really implement the method.\n            return false;\n        }\n        return true;\n    };\n    // Concrete subclasses of SchemaVisitor should override one or more of these\n    // visitor methods, in order to express their interest in handling certain\n    // schema types/locations. Each method may return null to remove the given\n    // type from the schema, a non-null value of the same type to update the\n    // type in the schema, or nothing to leave the type as it was.\n    /* tslint:disable:no-empty */\n    SchemaVisitor.prototype.visitSchema = function (schema) { };\n    SchemaVisitor.prototype.visitScalar = function (scalar) { };\n    SchemaVisitor.prototype.visitObject = function (object) { };\n    SchemaVisitor.prototype.visitFieldDefinition = function (field, details) { };\n    SchemaVisitor.prototype.visitArgumentDefinition = function (argument, details) { };\n    SchemaVisitor.prototype.visitInterface = function (iface) { };\n    SchemaVisitor.prototype.visitUnion = function (union) { };\n    SchemaVisitor.prototype.visitEnum = function (type) { };\n    SchemaVisitor.prototype.visitEnumValue = function (value, details) { };\n    SchemaVisitor.prototype.visitInputObject = function (object) { };\n    SchemaVisitor.prototype.visitInputFieldDefinition = function (field, details) { };\n    return SchemaVisitor;\n}());\nexports.SchemaVisitor = SchemaVisitor;\n// Generic function for visiting GraphQLSchema objects.\nfunction visitSchema(schema, \n    // To accommodate as many different visitor patterns as possible, the\n    // visitSchema function does not simply accept a single instance of the\n    // SchemaVisitor class, but instead accepts a function that takes the\n    // current VisitableSchemaType object and the name of a visitor method and\n    // returns an array of SchemaVisitor instances that implement the visitor\n    // method and have an interest in handling the given VisitableSchemaType\n    // object. In the simplest case, this function can always return an array\n    // containing a single visitor object, without even looking at the type or\n    // methodName parameters. In other cases, this function might sometimes\n    // return an empty array to indicate there are no visitors that should be\n    // applied to the given VisitableSchemaType object. For an example of a\n    // visitor pattern that benefits from this abstraction, see the\n    // SchemaDirectiveVisitor class below.\n    visitorSelector) {\n    // Helper function that calls visitorSelector and applies the resulting\n    // visitors to the given type, with arguments [type, ...args].\n    function callMethod(methodName, type) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        visitorSelector(type, methodName).every(function (visitor) {\n            var newType = visitor[methodName].apply(visitor, [type].concat(args));\n            if (typeof newType === 'undefined') {\n                // Keep going without modifying type.\n                return true;\n            }\n            if (methodName === 'visitSchema' ||\n                type instanceof graphql_1.GraphQLSchema) {\n                throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\n            }\n            if (newType === null) {\n                // Stop the loop and return null form callMethod, which will cause\n                // the type to be removed from the schema.\n                type = null;\n                return false;\n            }\n            // Update type to the new type returned by the visitor method, so that\n            // later directives will see the new type, and callMethod will return\n            // the final type.\n            type = newType;\n            return true;\n        });\n        // If there were no directives for this type object, or if all visitor\n        // methods returned nothing, type will be returned unmodified.\n        return type;\n    }\n    // Recursive helper function that calls any appropriate visitor methods for\n    // each object in the schema, then traverses the object's children (if any).\n    function visit(type) {\n        if (type instanceof graphql_1.GraphQLSchema) {\n            // Unlike the other types, the root GraphQLSchema object cannot be\n            // replaced by visitor methods, because that would make life very hard\n            // for SchemaVisitor subclasses that rely on the original schema object.\n            callMethod('visitSchema', type);\n            updateEachKey(type.getTypeMap(), function (namedType, typeName) {\n                if (!typeName.startsWith('__')) {\n                    // Call visit recursively to let it determine which concrete\n                    // subclass of GraphQLNamedType we found in the type map. Because\n                    // we're using updateEachKey, the result of visit(namedType) may\n                    // cause the type to be removed or replaced.\n                    return visit(namedType);\n                }\n            });\n            return type;\n        }\n        if (type instanceof graphql_1.GraphQLObjectType) {\n            // Note that callMethod('visitObject', type) may not actually call any\n            // methods, if there are no @directive annotations associated with this\n            // type, or if this SchemaDirectiveVisitor subclass does not override\n            // the visitObject method.\n            var newObject = callMethod('visitObject', type);\n            if (newObject) {\n                visitFields(newObject);\n            }\n            return newObject;\n        }\n        if (type instanceof graphql_1.GraphQLInterfaceType) {\n            var newInterface = callMethod('visitInterface', type);\n            if (newInterface) {\n                visitFields(newInterface);\n            }\n            return newInterface;\n        }\n        if (type instanceof graphql_1.GraphQLInputObjectType) {\n            var newInputObject_1 = callMethod('visitInputObject', type);\n            if (newInputObject_1) {\n                updateEachKey(newInputObject_1.getFields(), function (field) {\n                    // Since we call a different method for input object fields, we\n                    // can't reuse the visitFields function here.\n                    return callMethod('visitInputFieldDefinition', field, {\n                        objectType: newInputObject_1,\n                    });\n                });\n            }\n            return newInputObject_1;\n        }\n        if (type instanceof graphql_1.GraphQLScalarType) {\n            return callMethod('visitScalar', type);\n        }\n        if (type instanceof graphql_1.GraphQLUnionType) {\n            return callMethod('visitUnion', type);\n        }\n        if (type instanceof graphql_1.GraphQLEnumType) {\n            var newEnum_1 = callMethod('visitEnum', type);\n            if (newEnum_1) {\n                updateEachKey(newEnum_1.getValues(), function (value) {\n                    return callMethod('visitEnumValue', value, {\n                        enumType: newEnum_1,\n                    });\n                });\n            }\n            return newEnum_1;\n        }\n        throw new Error(\"Unexpected schema type: \" + type);\n    }\n    function visitFields(type) {\n        updateEachKey(type.getFields(), function (field) {\n            // It would be nice if we could call visit(field) recursively here, but\n            // GraphQLField is merely a type, not a value that can be detected using\n            // an instanceof check, so we have to visit the fields in this lexical\n            // context, so that TypeScript can validate the call to\n            // visitFieldDefinition.\n            var newField = callMethod('visitFieldDefinition', field, {\n                // While any field visitor needs a reference to the field object, some\n                // field visitors may also need to know the enclosing (parent) type,\n                // perhaps to determine if the parent is a GraphQLObjectType or a\n                // GraphQLInterfaceType. To obtain a reference to the parent, a\n                // visitor method can have a second parameter, which will be an object\n                // with an .objectType property referring to the parent.\n                objectType: type,\n            });\n            if (newField && newField.args) {\n                updateEachKey(newField.args, function (arg) {\n                    return callMethod('visitArgumentDefinition', arg, {\n                        // Like visitFieldDefinition, visitArgumentDefinition takes a\n                        // second parameter that provides additional context, namely the\n                        // parent .field and grandparent .objectType. Remember that the\n                        // current GraphQLSchema is always available via this.schema.\n                        field: newField,\n                        objectType: type,\n                    });\n                });\n            }\n            return newField;\n        });\n    }\n    visit(schema);\n    // Return the original schema for convenience, even though it cannot have\n    // been replaced or removed by the code above.\n    return schema;\n}\nexports.visitSchema = visitSchema;\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\nfunction healSchema(schema) {\n    heal(schema);\n    return schema;\n    function heal(type) {\n        if (type instanceof graphql_1.GraphQLSchema) {\n            var originalTypeMap_1 = type.getTypeMap();\n            var actualNamedTypeMap_1 = Object.create(null);\n            // If any of the .name properties of the GraphQLNamedType objects in\n            // schema.getTypeMap() have changed, the keys of the type map need to\n            // be updated accordingly.\n            each(originalTypeMap_1, function (namedType, typeName) {\n                if (typeName.startsWith('__')) {\n                    return;\n                }\n                var actualName = namedType.name;\n                if (actualName.startsWith('__')) {\n                    return;\n                }\n                if (hasOwn.call(actualNamedTypeMap_1, actualName)) {\n                    throw new Error(\"Duplicate schema type name \" + actualName);\n                }\n                actualNamedTypeMap_1[actualName] = namedType;\n                // Note: we are deliberately leaving namedType in the schema by its\n                // original name (which might be different from actualName), so that\n                // references by that name can be healed.\n            });\n            // Now add back every named type by its actual name.\n            each(actualNamedTypeMap_1, function (namedType, typeName) {\n                originalTypeMap_1[typeName] = namedType;\n            });\n            // Directive declaration argument types can refer to named types.\n            each(type.getDirectives(), function (decl) {\n                if (decl.args) {\n                    each(decl.args, function (arg) {\n                        arg.type = healType(arg.type);\n                    });\n                }\n            });\n            each(originalTypeMap_1, function (namedType, typeName) {\n                if (!typeName.startsWith('__')) {\n                    heal(namedType);\n                }\n            });\n            updateEachKey(originalTypeMap_1, function (namedType, typeName) {\n                // Dangling references to renamed types should remain in the schema\n                // during healing, but must be removed now, so that the following\n                // invariant holds for all names: schema.getType(name).name === name\n                if (!typeName.startsWith('__') &&\n                    !hasOwn.call(actualNamedTypeMap_1, typeName)) {\n                    return null;\n                }\n            });\n        }\n        else if (type instanceof graphql_1.GraphQLObjectType) {\n            healFields(type);\n            each(type.getInterfaces(), function (iface) { return heal(iface); });\n        }\n        else if (type instanceof graphql_1.GraphQLInterfaceType) {\n            healFields(type);\n        }\n        else if (type instanceof graphql_1.GraphQLInputObjectType) {\n            each(type.getFields(), function (field) {\n                field.type = healType(field.type);\n            });\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            // Nothing to do.\n        }\n        else if (type instanceof graphql_1.GraphQLUnionType) {\n            updateEachKey(type.getTypes(), function (t) { return healType(t); });\n        }\n        else if (type instanceof graphql_1.GraphQLEnumType) {\n            // Nothing to do.\n        }\n        else {\n            throw new Error(\"Unexpected schema type: \" + type);\n        }\n    }\n    function healFields(type) {\n        each(type.getFields(), function (field) {\n            field.type = healType(field.type);\n            if (field.args) {\n                each(field.args, function (arg) {\n                    arg.type = healType(arg.type);\n                });\n            }\n        });\n    }\n    function healType(type) {\n        if (type instanceof graphql_1.GraphQLList ||\n            type instanceof graphql_1.GraphQLNonNull) {\n            // Unwrap the two known wrapper types:\n            // https://github.com/graphql/graphql-js/blob/master/src/type/wrappers.js\n            type.ofType = healType(type.ofType);\n        }\n        else if (graphql_1.isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            var namedType = type;\n            var officialType = schema.getType(namedType.name);\n            if (officialType && namedType !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\nexports.healSchema = healSchema;\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\nvar SchemaDirectiveVisitor = /** @class */ (function (_super) {\n    __extends(SchemaDirectiveVisitor, _super);\n    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n    // subclasses (not instances) to visitSchemaDirectives.\n    function SchemaDirectiveVisitor(config) {\n        var _this = _super.call(this) || this;\n        _this.name = config.name;\n        _this.args = config.args;\n        _this.visitedType = config.visitedType;\n        _this.schema = config.schema;\n        _this.context = config.context;\n        return _this;\n    }\n    // Override this method to return a custom GraphQLDirective (or modify one\n    // already present in the schema) to enforce argument types, provide default\n    // argument values, or specify schema locations where this @directive may\n    // appear. By default, any declaration found in the schema will be returned.\n    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\n        return schema.getDirective(directiveName);\n    };\n    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n    // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n    // instance to visit the object decorated by the @directive.\n    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, \n        // Optional context object that will be available to all visitor instances\n        // via this.context. Defaults to an empty null-prototype object.\n        context) {\n        // Optional context object that will be available to all visitor instances\n        // via this.context. Defaults to an empty null-prototype object.\n        if (context === void 0) { context = Object.create(null); }\n        // If the schema declares any directives for public consumption, record\n        // them here so that we can properly coerce arguments when/if we encounter\n        // an occurrence of the directive while walking the schema below.\n        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\n        // Map from directive names to lists of SchemaDirectiveVisitor instances\n        // created while visiting the schema.\n        var createdVisitors = Object.create(null);\n        Object.keys(directiveVisitors).forEach(function (directiveName) {\n            createdVisitors[directiveName] = [];\n        });\n        function visitorSelector(type, methodName) {\n            var visitors = [];\n            var directiveNodes = type.astNode && type.astNode.directives;\n            if (!directiveNodes) {\n                return visitors;\n            }\n            directiveNodes.forEach(function (directiveNode) {\n                var directiveName = directiveNode.name.value;\n                if (!hasOwn.call(directiveVisitors, directiveName)) {\n                    return;\n                }\n                var visitorClass = directiveVisitors[directiveName];\n                // Avoid creating visitor objects if visitorClass does not override\n                // the visitor method named by methodName.\n                if (!visitorClass.implementsVisitorMethod(methodName)) {\n                    return;\n                }\n                var decl = declaredDirectives[directiveName];\n                var args;\n                if (decl) {\n                    // If this directive was explicitly declared, use the declared\n                    // argument types (and any default values) to check, coerce, and/or\n                    // supply default values for the given arguments.\n                    args = values_1.getArgumentValues(decl, directiveNode);\n                }\n                else {\n                    // If this directive was not explicitly declared, just convert the\n                    // argument nodes to their corresponding JavaScript values.\n                    args = Object.create(null);\n                    directiveNode.arguments.forEach(function (arg) {\n                        args[arg.name.value] = valueFromASTUntyped(arg.value);\n                    });\n                }\n                // As foretold in comments near the top of the visitSchemaDirectives\n                // method, this is where instances of the SchemaDirectiveVisitor class\n                // get created and assigned names. While subclasses could override the\n                // constructor method, the constructor is marked as protected, so\n                // these are the only arguments that will ever be passed.\n                visitors.push(new visitorClass({\n                    name: directiveName,\n                    args: args,\n                    visitedType: type,\n                    schema: schema,\n                    context: context,\n                }));\n            });\n            if (visitors.length > 0) {\n                visitors.forEach(function (visitor) {\n                    createdVisitors[visitor.name].push(visitor);\n                });\n            }\n            return visitors;\n        }\n        visitSchema(schema, visitorSelector);\n        // Automatically update any references to named schema types replaced\n        // during the traversal, so implementors don't have to worry about that.\n        healSchema(schema);\n        return createdVisitors;\n    };\n    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\n        var declaredDirectives = Object.create(null);\n        each(schema.getDirectives(), function (decl) {\n            declaredDirectives[decl.name] = decl;\n        });\n        // If the visitor subclass overrides getDirectiveDeclaration, and it\n        // returns a non-null GraphQLDirective, use that instead of any directive\n        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n        // goes to the trouble of implementing getDirectiveDeclaration, it should\n        // be able to rely on that implementation.\n        each(directiveVisitors, function (visitorClass, directiveName) {\n            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n            if (decl) {\n                declaredDirectives[directiveName] = decl;\n            }\n        });\n        each(declaredDirectives, function (decl, name) {\n            if (!hasOwn.call(directiveVisitors, name)) {\n                // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n                // multiple times with partial directiveVisitors maps, so it's not\n                // necessarily an error for directiveVisitors to be missing an\n                // implementation of a directive that was declared in the schema.\n                return;\n            }\n            var visitorClass = directiveVisitors[name];\n            each(decl.locations, function (loc) {\n                var visitorMethodName = directiveLocationToVisitorMethodName(loc);\n                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n                    // While visitor subclasses may implement extra visitor methods,\n                    // it's definitely a mistake if the GraphQLDirective declares itself\n                    // applicable to certain schema locations, and the visitor subclass\n                    // does not implement all the corresponding methods.\n                    throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\n                }\n            });\n        });\n        return declaredDirectives;\n    };\n    return SchemaDirectiveVisitor;\n}(SchemaVisitor));\nexports.SchemaDirectiveVisitor = SchemaDirectiveVisitor;\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc) {\n    return 'visit' + loc.replace(/([^_]*)_?/g, function (wholeMatch, part) {\n        return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n    });\n}\nfunction each(arrayOrObject, callback) {\n    Object.keys(arrayOrObject).forEach(function (key) {\n        callback(arrayOrObject[key], key);\n    });\n}\n// A more powerful version of each that has the ability to replace or remove\n// array or object keys.\nfunction updateEachKey(arrayOrObject, \n    // The callback can return nothing to leave the key untouched, null to remove\n    // the key from the array or object, or a non-null V to replace the value.\n    callback) {\n    var deletedCount = 0;\n    Object.keys(arrayOrObject).forEach(function (key) {\n        var result = callback(arrayOrObject[key], key);\n        if (typeof result === 'undefined') {\n            return;\n        }\n        if (result === null) {\n            delete arrayOrObject[key];\n            deletedCount++;\n            return;\n        }\n        arrayOrObject[key] = result;\n    });\n    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n        // Remove any holes from the array due to deleted elements.\n        arrayOrObject.splice(0).forEach(function (elem) {\n            arrayOrObject.push(elem);\n        });\n    }\n}\n// Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\nfunction valueFromASTUntyped(valueNode) {\n    switch (valueNode.kind) {\n        case graphql_1.Kind.NULL:\n            return null;\n        case graphql_1.Kind.INT:\n            return parseInt(valueNode.value, 10);\n        case graphql_1.Kind.FLOAT:\n            return parseFloat(valueNode.value);\n        case graphql_1.Kind.STRING:\n        case graphql_1.Kind.ENUM:\n        case graphql_1.Kind.BOOLEAN:\n            return valueNode.value;\n        case graphql_1.Kind.LIST:\n            return valueNode.values.map(valueFromASTUntyped);\n        case graphql_1.Kind.OBJECT:\n            var obj_1 = Object.create(null);\n            valueNode.fields.forEach(function (field) {\n                obj_1[field.name.value] = valueFromASTUntyped(field.value);\n            });\n            return obj_1;\n        /* istanbul ignore next */\n        default:\n            throw new Error('Unexpected value kind: ' + valueNode.kind);\n    }\n}\n//# sourceMappingURL=schemaVisitor.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/schemaVisitor.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/defaultMergedResolver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/defaultMergedResolver.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar error_1 = __webpack_require__(/*! graphql/error */ \"./node_modules/graphql/error/index.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/graphql-tools/dist/stitching/errors.js\");\n// Resolver that knows how to:\n// a) handle aliases for proxied schemas\n// b) handle errors from proxied schemas\nvar defaultMergedResolver = function (parent, args, context, info) {\n    var responseKey = info.fieldNodes[0].alias\n        ? info.fieldNodes[0].alias.value\n        : info.fieldName;\n    var errorResult = errors_1.getErrorsFromParent(parent, responseKey);\n    if (errorResult.kind === 'OWN') {\n        throw error_1.locatedError(new Error(errorResult.error.message), info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n    }\n    else if (parent) {\n        var result = parent[responseKey];\n        // subscription result mapping\n        if (!result && parent.data && parent.data[responseKey]) {\n            result = parent.data[responseKey];\n        }\n        if (errorResult.errors) {\n            result = errors_1.annotateWithChildrenErrors(result, errorResult.errors);\n        }\n        return result;\n    }\n    else {\n        return null;\n    }\n};\nexports.default = defaultMergedResolver;\n//# sourceMappingURL=defaultMergedResolver.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/defaultMergedResolver.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/delegateToSchema.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/delegateToSchema.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar transforms_1 = __webpack_require__(/*! ../transforms/transforms */ \"./node_modules/graphql-tools/dist/transforms/transforms.js\");\nvar AddArgumentsAsVariables_1 = __webpack_require__(/*! ../transforms/AddArgumentsAsVariables */ \"./node_modules/graphql-tools/dist/transforms/AddArgumentsAsVariables.js\");\nvar FilterToSchema_1 = __webpack_require__(/*! ../transforms/FilterToSchema */ \"./node_modules/graphql-tools/dist/transforms/FilterToSchema.js\");\nvar AddTypenameToAbstract_1 = __webpack_require__(/*! ../transforms/AddTypenameToAbstract */ \"./node_modules/graphql-tools/dist/transforms/AddTypenameToAbstract.js\");\nvar CheckResultAndHandleErrors_1 = __webpack_require__(/*! ../transforms/CheckResultAndHandleErrors */ \"./node_modules/graphql-tools/dist/transforms/CheckResultAndHandleErrors.js\");\nvar mapAsyncIterator_1 = __webpack_require__(/*! ./mapAsyncIterator */ \"./node_modules/graphql-tools/dist/stitching/mapAsyncIterator.js\");\nvar ExpandAbstractTypes_1 = __webpack_require__(/*! ../transforms/ExpandAbstractTypes */ \"./node_modules/graphql-tools/dist/transforms/ExpandAbstractTypes.js\");\nvar ReplaceFieldWithFragment_1 = __webpack_require__(/*! ../transforms/ReplaceFieldWithFragment */ \"./node_modules/graphql-tools/dist/transforms/ReplaceFieldWithFragment.js\");\nfunction delegateToSchema(options) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (options instanceof graphql_1.GraphQLSchema) {\n        throw new Error('Passing positional arguments to delegateToSchema is a deprecated. ' +\n            'Please pass named parameters instead.');\n    }\n    return delegateToSchemaImplementation(options);\n}\nexports.default = delegateToSchema;\nfunction delegateToSchemaImplementation(options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var info, _a, args, operation, rawDocument, rawRequest, transforms, processedRequest, errors, _b, executionResult;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    info = options.info, _a = options.args, args = _a === void 0 ? {} : _a;\n                    operation = options.operation || info.operation.operation;\n                    rawDocument = createDocument(options.fieldName, operation, info.fieldNodes, Object.keys(info.fragments).map(function (fragmentName) { return info.fragments[fragmentName]; }), info.operation.variableDefinitions, info.operation.name);\n                    rawRequest = {\n                        document: rawDocument,\n                        variables: info.variableValues,\n                    };\n                    transforms = (options.transforms || []).concat([\n                        new ExpandAbstractTypes_1.default(info.schema, options.schema)\n                    ]);\n                    if (info.mergeInfo && info.mergeInfo.fragments) {\n                        transforms.push(new ReplaceFieldWithFragment_1.default(options.schema, info.mergeInfo.fragments));\n                    }\n                    transforms = transforms.concat([\n                        new AddArgumentsAsVariables_1.default(options.schema, args),\n                        new FilterToSchema_1.default(options.schema),\n                        new AddTypenameToAbstract_1.default(options.schema),\n                        new CheckResultAndHandleErrors_1.default(info, options.fieldName)\n                    ]);\n                    processedRequest = transforms_1.applyRequestTransforms(rawRequest, transforms);\n                    if (!options.skipValidation) {\n                        errors = graphql_1.validate(options.schema, processedRequest.document);\n                        if (errors.length > 0) {\n                            throw errors;\n                        }\n                    }\n                    if (!(operation === 'query' || operation === 'mutation')) return [3 /*break*/, 2];\n                    _b = transforms_1.applyResultTransforms;\n                    return [4 /*yield*/, graphql_1.execute(options.schema, processedRequest.document, info.rootValue, options.context, processedRequest.variables)];\n                case 1: return [2 /*return*/, _b.apply(void 0, [_c.sent(),\n                        transforms])];\n                case 2:\n                    if (!(operation === 'subscription')) return [3 /*break*/, 4];\n                    return [4 /*yield*/, graphql_1.subscribe(options.schema, processedRequest.document, info.rootValue, options.context, processedRequest.variables)];\n                case 3:\n                    executionResult = _c.sent();\n                    // \"subscribe\" to the subscription result and map the result through the transforms\n                    return [2 /*return*/, mapAsyncIterator_1.default(executionResult, function (result) {\n                            var transformedResult = transforms_1.applyResultTransforms(result, transforms);\n                            var subscriptionKey = Object.keys(result.data)[0];\n                            // for some reason the returned transformedResult needs to be nested inside the root subscription field\n                            // does not work otherwise...\n                            return _a = {},\n                                _a[subscriptionKey] = __assign({}, transformedResult),\n                                _a;\n                            var _a;\n                        })];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction createDocument(targetField, targetOperation, originalSelections, fragments, variables, operationName) {\n    var selections = [];\n    var args = [];\n    originalSelections.forEach(function (field) {\n        var fieldSelections = field.selectionSet\n            ? field.selectionSet.selections\n            : [];\n        selections = selections.concat(fieldSelections);\n        args = args.concat(field.arguments || []);\n    });\n    var selectionSet = null;\n    if (selections.length > 0) {\n        selectionSet = {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: selections,\n        };\n    }\n    var rootField = {\n        kind: graphql_1.Kind.FIELD,\n        alias: null,\n        arguments: args,\n        selectionSet: selectionSet,\n        name: {\n            kind: graphql_1.Kind.NAME,\n            value: targetField,\n        },\n    };\n    var rootSelectionSet = {\n        kind: graphql_1.Kind.SELECTION_SET,\n        selections: [rootField],\n    };\n    var operationDefinition = {\n        kind: graphql_1.Kind.OPERATION_DEFINITION,\n        operation: targetOperation,\n        variableDefinitions: variables,\n        selectionSet: rootSelectionSet,\n        name: operationName,\n    };\n    return {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [operationDefinition].concat(fragments),\n    };\n}\n//# sourceMappingURL=delegateToSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/delegateToSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/errors.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/errors.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar error_1 = __webpack_require__(/*! graphql/error */ \"./node_modules/graphql/error/index.js\");\nvar ERROR_SYMBOL;\nif ((typeof global !== 'undefined' && 'Symbol' in global) ||\n    (typeof window !== 'undefined' && 'Symbol' in window)) {\n    ERROR_SYMBOL = Symbol('subSchemaErrors');\n}\nelse {\n    ERROR_SYMBOL = '@@__subSchemaErrors';\n}\nexports.ErrorSymbol = ERROR_SYMBOL;\nfunction annotateWithChildrenErrors(object, childrenErrors) {\n    if (childrenErrors && childrenErrors.length > 0) {\n        if (Array.isArray(object)) {\n            var byIndex_1 = {};\n            childrenErrors.forEach(function (error) {\n                if (!error.path) {\n                    return;\n                }\n                var index = error.path[1];\n                var current = byIndex_1[index] || [];\n                current.push(__assign({}, error, { path: error.path.slice(1) }));\n                byIndex_1[index] = current;\n            });\n            return object.map(function (item, index) {\n                return annotateWithChildrenErrors(item, byIndex_1[index]);\n            });\n        }\n        else {\n            return __assign({}, object, (_a = {}, _a[ERROR_SYMBOL] = childrenErrors.map(function (error) { return (__assign({}, error, error.path ? { path: error.path.slice(1) } : {})); }), _a));\n        }\n    }\n    else {\n        return object;\n    }\n    var _a;\n}\nexports.annotateWithChildrenErrors = annotateWithChildrenErrors;\nfunction getErrorsFromParent(object, fieldName) {\n    var errors = (object && object[ERROR_SYMBOL]) || [];\n    var childrenErrors = [];\n    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n        var error = errors_1[_i];\n        if ((!error.path) || (error.path.length === 1 && error.path[0] === fieldName)) {\n            return {\n                kind: 'OWN',\n                error: error,\n            };\n        }\n        else if (error.path[0] === fieldName) {\n            childrenErrors.push(error);\n        }\n    }\n    return {\n        kind: 'CHILDREN',\n        errors: childrenErrors,\n    };\n}\nexports.getErrorsFromParent = getErrorsFromParent;\nvar CombinedError = /** @class */ (function (_super) {\n    __extends(CombinedError, _super);\n    function CombinedError(message, errors) {\n        var _this = _super.call(this, message) || this;\n        _this.errors = errors;\n        return _this;\n    }\n    return CombinedError;\n}(Error));\nfunction checkResultAndHandleErrors(result, info, responseKey) {\n    if (!responseKey) {\n        responseKey = info.fieldNodes[0].alias\n            ? info.fieldNodes[0].alias.value\n            : info.fieldName;\n    }\n    if (result.errors && (!result.data || result.data[responseKey] == null)) {\n        // apollo-link-http & http-link-dataloader need the\n        // result property to be passed through for better error handling.\n        // If there is only one error, which contains a result property, pass the error through\n        var newError = result.errors.length === 1 && hasResult(result.errors[0])\n            ? result.errors[0]\n            : new CombinedError(concatErrors(result.errors), result.errors);\n        throw error_1.locatedError(newError, info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n    }\n    else {\n        var resultObject = result.data[responseKey];\n        if (result.errors) {\n            resultObject = annotateWithChildrenErrors(resultObject, result.errors);\n        }\n        return resultObject;\n    }\n}\nexports.checkResultAndHandleErrors = checkResultAndHandleErrors;\nfunction concatErrors(errors) {\n    return errors.map(function (error) { return error.message; }).join('\\n');\n}\nfunction hasResult(error) {\n    return error.result || (error.originalError && error.originalError.result);\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/errors.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/index.js":
/*!************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar makeRemoteExecutableSchema_1 = __webpack_require__(/*! ./makeRemoteExecutableSchema */ \"./node_modules/graphql-tools/dist/stitching/makeRemoteExecutableSchema.js\");\nexports.makeRemoteExecutableSchema = makeRemoteExecutableSchema_1.default;\nexports.defaultCreateRemoteResolver = makeRemoteExecutableSchema_1.createResolver;\nvar introspectSchema_1 = __webpack_require__(/*! ./introspectSchema */ \"./node_modules/graphql-tools/dist/stitching/introspectSchema.js\");\nexports.introspectSchema = introspectSchema_1.default;\nvar mergeSchemas_1 = __webpack_require__(/*! ./mergeSchemas */ \"./node_modules/graphql-tools/dist/stitching/mergeSchemas.js\");\nexports.mergeSchemas = mergeSchemas_1.default;\nvar delegateToSchema_1 = __webpack_require__(/*! ./delegateToSchema */ \"./node_modules/graphql-tools/dist/stitching/delegateToSchema.js\");\nexports.delegateToSchema = delegateToSchema_1.default;\nvar defaultMergedResolver_1 = __webpack_require__(/*! ./defaultMergedResolver */ \"./node_modules/graphql-tools/dist/stitching/defaultMergedResolver.js\");\nexports.defaultMergedResolver = defaultMergedResolver_1.default;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/index.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/introspectSchema.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/introspectSchema.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar linkToFetcher_1 = __webpack_require__(/*! ./linkToFetcher */ \"./node_modules/graphql-tools/dist/stitching/linkToFetcher.js\");\nvar parsedIntrospectionQuery = graphql_1.parse(graphql_1.introspectionQuery);\nfunction introspectSchema(fetcher, linkContext) {\n    return __awaiter(this, void 0, void 0, function () {\n        var introspectionResult, schema;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // Convert link to fetcher\n                    if (fetcher.request) {\n                        fetcher = linkToFetcher_1.default(fetcher);\n                    }\n                    return [4 /*yield*/, fetcher({\n                            query: parsedIntrospectionQuery,\n                            context: linkContext,\n                        })];\n                case 1:\n                    introspectionResult = _a.sent();\n                    if ((introspectionResult.errors && introspectionResult.errors.length) ||\n                        !introspectionResult.data.__schema) {\n                        throw introspectionResult.errors;\n                    }\n                    else {\n                        schema = graphql_1.buildClientSchema(introspectionResult.data);\n                        return [2 /*return*/, schema];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.default = introspectSchema;\n//# sourceMappingURL=introspectSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/introspectSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/linkToFetcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/linkToFetcher.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar apollo_link_1 = __webpack_require__(/*! apollo-link */ \"./node_modules/apollo-link/lib/index.js\");\nvar apollo_link_2 = __webpack_require__(/*! apollo-link */ \"./node_modules/apollo-link/lib/index.js\");\nexports.execute = apollo_link_2.execute;\nfunction linkToFetcher(link) {\n    return function (fetcherOperation) {\n        return apollo_link_1.makePromise(apollo_link_1.execute(link, fetcherOperation));\n    };\n}\nexports.default = linkToFetcher;\n//# sourceMappingURL=linkToFetcher.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/linkToFetcher.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/makeRemoteExecutableSchema.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/makeRemoteExecutableSchema.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar linkToFetcher_1 = __webpack_require__(/*! ./linkToFetcher */ \"./node_modules/graphql-tools/dist/stitching/linkToFetcher.js\");\nvar isEmptyObject_1 = __webpack_require__(/*! ../isEmptyObject */ \"./node_modules/graphql-tools/dist/isEmptyObject.js\");\nvar makeExecutableSchema_1 = __webpack_require__(/*! ../makeExecutableSchema */ \"./node_modules/graphql-tools/dist/makeExecutableSchema.js\");\nvar schemaRecreation_1 = __webpack_require__(/*! ./schemaRecreation */ \"./node_modules/graphql-tools/dist/stitching/schemaRecreation.js\");\nvar resolveFromParentTypename_1 = __webpack_require__(/*! ./resolveFromParentTypename */ \"./node_modules/graphql-tools/dist/stitching/resolveFromParentTypename.js\");\nvar defaultMergedResolver_1 = __webpack_require__(/*! ./defaultMergedResolver */ \"./node_modules/graphql-tools/dist/stitching/defaultMergedResolver.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/graphql-tools/dist/stitching/errors.js\");\nvar observableToAsyncIterable_1 = __webpack_require__(/*! ./observableToAsyncIterable */ \"./node_modules/graphql-tools/dist/stitching/observableToAsyncIterable.js\");\nfunction makeRemoteExecutableSchema(_a) {\n    var schema = _a.schema, link = _a.link, fetcher = _a.fetcher, _b = _a.createResolver, customCreateResolver = _b === void 0 ? createResolver : _b;\n    if (!fetcher && link) {\n        fetcher = linkToFetcher_1.default(link);\n    }\n    var typeDefs;\n    var printOptions = { commentDescriptions: true };\n    if (typeof schema === 'string') {\n        typeDefs = schema;\n        schema = graphql_1.buildSchema(typeDefs);\n    }\n    else {\n        // TODO fix types https://github.com/apollographql/graphql-tools/issues/542\n        typeDefs = graphql_1.printSchema(schema, printOptions);\n    }\n    // prepare query resolvers\n    var queryResolvers = {};\n    var queryType = schema.getQueryType();\n    var queries = queryType.getFields();\n    Object.keys(queries).forEach(function (key) {\n        queryResolvers[key] = customCreateResolver(fetcher);\n    });\n    // prepare mutation resolvers\n    var mutationResolvers = {};\n    var mutationType = schema.getMutationType();\n    if (mutationType) {\n        var mutations = mutationType.getFields();\n        Object.keys(mutations).forEach(function (key) {\n            mutationResolvers[key] = customCreateResolver(fetcher);\n        });\n    }\n    // prepare subscription resolvers\n    var subscriptionResolvers = {};\n    var subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        var subscriptions = subscriptionType.getFields();\n        Object.keys(subscriptions).forEach(function (key) {\n            subscriptionResolvers[key] = {\n                subscribe: createSubscriptionResolver(key, link),\n            };\n        });\n    }\n    // merge resolvers into resolver map\n    var resolvers = (_c = {}, _c[queryType.name] = queryResolvers, _c);\n    if (!isEmptyObject_1.default(mutationResolvers)) {\n        resolvers[mutationType.name] = mutationResolvers;\n    }\n    if (!isEmptyObject_1.default(subscriptionResolvers)) {\n        resolvers[subscriptionType.name] = subscriptionResolvers;\n    }\n    // add missing abstract resolvers (scalar, unions, interfaces)\n    var typeMap = schema.getTypeMap();\n    var types = Object.keys(typeMap).map(function (name) { return typeMap[name]; });\n    var _loop_1 = function (type) {\n        if (type instanceof graphql_1.GraphQLInterfaceType ||\n            type instanceof graphql_1.GraphQLUnionType) {\n            resolvers[type.name] = {\n                __resolveType: function (parent, context, info) {\n                    return resolveFromParentTypename_1.default(parent, info.schema);\n                },\n            };\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            if (!(type === graphql_1.GraphQLID ||\n                type === graphql_1.GraphQLString ||\n                type === graphql_1.GraphQLFloat ||\n                type === graphql_1.GraphQLBoolean ||\n                type === graphql_1.GraphQLInt)) {\n                resolvers[type.name] = schemaRecreation_1.recreateType(type, function (name) { return null; }, false);\n            }\n        }\n        else if (type instanceof graphql_1.GraphQLObjectType &&\n            type.name.slice(0, 2) !== '__' &&\n            type !== queryType &&\n            type !== mutationType &&\n            type !== subscriptionType) {\n            var resolver_1 = {};\n            Object.keys(type.getFields()).forEach(function (field) {\n                resolver_1[field] = defaultMergedResolver_1.default;\n            });\n            resolvers[type.name] = resolver_1;\n        }\n    };\n    for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n        var type = types_1[_i];\n        _loop_1(type);\n    }\n    return makeExecutableSchema_1.makeExecutableSchema({\n        typeDefs: typeDefs,\n        resolvers: resolvers,\n    });\n    var _c;\n}\nexports.default = makeRemoteExecutableSchema;\nfunction createResolver(fetcher) {\n    var _this = this;\n    return function (root, args, context, info) { return __awaiter(_this, void 0, void 0, function () {\n        var fragments, document, result;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });\n                    document = {\n                        kind: graphql_1.Kind.DOCUMENT,\n                        definitions: [info.operation].concat(fragments),\n                    };\n                    return [4 /*yield*/, fetcher({\n                            query: document,\n                            variables: info.variableValues,\n                            context: { graphqlContext: context },\n                        })];\n                case 1:\n                    result = _a.sent();\n                    return [2 /*return*/, errors_1.checkResultAndHandleErrors(result, info)];\n            }\n        });\n    }); };\n}\nexports.createResolver = createResolver;\nfunction createSubscriptionResolver(name, link) {\n    return function (root, args, context, info) {\n        var fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });\n        var document = {\n            kind: graphql_1.Kind.DOCUMENT,\n            definitions: [info.operation].concat(fragments),\n        };\n        var operation = {\n            query: document,\n            variables: info.variableValues,\n            context: { graphqlContext: context },\n        };\n        var observable = linkToFetcher_1.execute(link, operation);\n        return observableToAsyncIterable_1.observableToAsyncIterable(observable);\n    };\n}\n//# sourceMappingURL=makeRemoteExecutableSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/makeRemoteExecutableSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/mapAsyncIterator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/mapAsyncIterator.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n    var $return;\n    var abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = function (error) {\n            var rethrow = function () { return Promise.reject(error); };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done\n            ? result\n            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    var mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        var reject_1 = rejectCallback;\n        mapReject = function (error) {\n            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\n        };\n    }\n    return _a = {\n            next: function () {\n                return iterator.next().then(mapResult, mapReject);\n            },\n            return: function () {\n                return $return\n                    ? $return.call(iterator).then(mapResult, mapReject)\n                    : Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (error) {\n                if (typeof iterator.throw === 'function') {\n                    return iterator.throw(error).then(mapResult, mapReject);\n                }\n                return Promise.reject(error).catch(abruptClose);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n    var _a;\n}\nexports.default = mapAsyncIterator;\nfunction asyncMapValue(value, callback) {\n    return new Promise(function (resolve) { return resolve(callback(value)); });\n}\nfunction iteratorResult(value) {\n    return { value: value, done: false };\n}\n//# sourceMappingURL=mapAsyncIterator.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/mapAsyncIterator.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/mergeSchemas.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/mergeSchemas.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar makeExecutableSchema_1 = __webpack_require__(/*! ../makeExecutableSchema */ \"./node_modules/graphql-tools/dist/makeExecutableSchema.js\");\nvar schemaRecreation_1 = __webpack_require__(/*! ./schemaRecreation */ \"./node_modules/graphql-tools/dist/stitching/schemaRecreation.js\");\nvar delegateToSchema_1 = __webpack_require__(/*! ./delegateToSchema */ \"./node_modules/graphql-tools/dist/stitching/delegateToSchema.js\");\nvar typeFromAST_1 = __webpack_require__(/*! ./typeFromAST */ \"./node_modules/graphql-tools/dist/stitching/typeFromAST.js\");\nvar transforms_1 = __webpack_require__(/*! ../transforms */ \"./node_modules/graphql-tools/dist/transforms/index.js\");\nvar mergeDeep_1 = __webpack_require__(/*! ../mergeDeep */ \"./node_modules/graphql-tools/dist/mergeDeep.js\");\nvar schemaVisitor_1 = __webpack_require__(/*! ../schemaVisitor */ \"./node_modules/graphql-tools/dist/schemaVisitor.js\");\nfunction mergeSchemas(_a) {\n    var schemas = _a.schemas, onTypeConflict = _a.onTypeConflict, resolvers = _a.resolvers, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces;\n    var visitType = defaultVisitType;\n    if (onTypeConflict) {\n        console.warn('`onTypeConflict` is deprecated. Use schema transforms to customize merging logic.');\n        visitType = createVisitTypeFromOnTypeConflict(onTypeConflict);\n    }\n    return mergeSchemasImplementation({ schemas: schemas, visitType: visitType, resolvers: resolvers, schemaDirectives: schemaDirectives, inheritResolversFromInterfaces: inheritResolversFromInterfaces });\n}\nexports.default = mergeSchemas;\nfunction mergeSchemasImplementation(_a) {\n    var schemas = _a.schemas, visitType = _a.visitType, resolvers = _a.resolvers, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces;\n    var allSchemas = [];\n    var typeCandidates = {};\n    var types = {};\n    var extensions = [];\n    var fragments = [];\n    if (!visitType) {\n        visitType = defaultVisitType;\n    }\n    var resolveType = schemaRecreation_1.createResolveType(function (name) {\n        if (types[name] === undefined) {\n            throw new Error(\"Can't find type \" + name + \".\");\n        }\n        return types[name];\n    });\n    var createNamedStub = function (name, type) {\n        var constructor;\n        if (type === 'object') {\n            constructor = graphql_1.GraphQLObjectType;\n        }\n        else if (type === 'interface') {\n            constructor = graphql_1.GraphQLInterfaceType;\n        }\n        else {\n            constructor = graphql_1.GraphQLInputObjectType;\n        }\n        return new constructor({\n            name: name,\n            fields: {\n                __fake: {\n                    type: graphql_1.GraphQLString,\n                },\n            },\n        });\n    };\n    schemas.forEach(function (schema) {\n        if (schema instanceof graphql_1.GraphQLSchema) {\n            allSchemas.push(schema);\n            var queryType_1 = schema.getQueryType();\n            var mutationType_1 = schema.getMutationType();\n            var subscriptionType_1 = schema.getSubscriptionType();\n            if (queryType_1) {\n                addTypeCandidate(typeCandidates, 'Query', {\n                    schema: schema,\n                    type: queryType_1,\n                });\n            }\n            if (mutationType_1) {\n                addTypeCandidate(typeCandidates, 'Mutation', {\n                    schema: schema,\n                    type: mutationType_1,\n                });\n            }\n            if (subscriptionType_1) {\n                addTypeCandidate(typeCandidates, 'Subscription', {\n                    schema: schema,\n                    type: subscriptionType_1,\n                });\n            }\n            var typeMap_1 = schema.getTypeMap();\n            Object.keys(typeMap_1).forEach(function (typeName) {\n                var type = typeMap_1[typeName];\n                if (graphql_1.isNamedType(type) &&\n                    graphql_1.getNamedType(type).name.slice(0, 2) !== '__' &&\n                    type !== queryType_1 &&\n                    type !== mutationType_1 &&\n                    type !== subscriptionType_1) {\n                    addTypeCandidate(typeCandidates, type.name, {\n                        schema: schema,\n                        type: type,\n                    });\n                }\n            });\n        }\n        else if (typeof schema === 'string') {\n            var parsedSchemaDocument = graphql_1.parse(schema);\n            parsedSchemaDocument.definitions.forEach(function (def) {\n                var type = typeFromAST_1.default(def, createNamedStub);\n                if (type) {\n                    addTypeCandidate(typeCandidates, type.name, {\n                        type: type,\n                    });\n                }\n            });\n            var extensionsDocument = makeExecutableSchema_1.extractExtensionDefinitions(parsedSchemaDocument);\n            if (extensionsDocument.definitions.length > 0) {\n                extensions.push(extensionsDocument);\n            }\n        }\n        else if (Array.isArray(schema)) {\n            schema.forEach(function (type) {\n                addTypeCandidate(typeCandidates, type.name, {\n                    type: type,\n                });\n            });\n        }\n        else {\n            throw new Error(\"Invalid schema passed\");\n        }\n    });\n    var mergeInfo = createMergeInfo(allSchemas, fragments);\n    if (!resolvers) {\n        resolvers = {};\n    }\n    else if (typeof resolvers === 'function') {\n        console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');\n        resolvers = resolvers(mergeInfo);\n    }\n    else if (Array.isArray(resolvers)) {\n        resolvers = resolvers.reduce(function (left, right) {\n            if (typeof right === 'function') {\n                console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');\n                right = right(mergeInfo);\n            }\n            return mergeDeep_1.default(left, right);\n        }, {});\n    }\n    var generatedResolvers = {};\n    Object.keys(typeCandidates).forEach(function (typeName) {\n        var resultType = visitType(typeName, typeCandidates[typeName]);\n        if (resultType === null) {\n            types[typeName] = null;\n        }\n        else {\n            var type = void 0;\n            var typeResolvers = void 0;\n            if (graphql_1.isNamedType(resultType)) {\n                type = resultType;\n            }\n            else if (resultType.type) {\n                type = resultType.type;\n                typeResolvers = resultType.resolvers;\n            }\n            else {\n                throw new Error(\"Invalid visitType result for type \" + typeName);\n            }\n            types[typeName] = schemaRecreation_1.recreateType(type, resolveType, false);\n            if (typeResolvers) {\n                generatedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    var mergedSchema = new graphql_1.GraphQLSchema({\n        query: types.Query,\n        mutation: types.Mutation,\n        subscription: types.Subscription,\n        types: Object.keys(types).map(function (key) { return types[key]; }),\n    });\n    extensions.forEach(function (extension) {\n        mergedSchema = graphql_1.extendSchema(mergedSchema, extension, {\n            commentDescriptions: true,\n        });\n    });\n    if (!resolvers) {\n        resolvers = {};\n    }\n    else if (Array.isArray(resolvers)) {\n        resolvers = resolvers.reduce(mergeDeep_1.default, {});\n    }\n    Object.keys(resolvers).forEach(function (typeName) {\n        var type = resolvers[typeName];\n        if (type instanceof graphql_1.GraphQLScalarType) {\n            return;\n        }\n        Object.keys(type).forEach(function (fieldName) {\n            var field = type[fieldName];\n            if (field.fragment) {\n                fragments.push({\n                    field: fieldName,\n                    fragment: field.fragment,\n                });\n            }\n        });\n    });\n    makeExecutableSchema_1.addResolveFunctionsToSchema({\n        schema: mergedSchema,\n        resolvers: mergeDeep_1.default(generatedResolvers, resolvers),\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces\n    });\n    forEachField(mergedSchema, function (field) {\n        if (field.resolve) {\n            var fieldResolver_1 = field.resolve;\n            field.resolve = function (parent, args, context, info) {\n                var newInfo = __assign({}, info, { mergeInfo: mergeInfo });\n                return fieldResolver_1(parent, args, context, newInfo);\n            };\n        }\n        if (field.subscribe) {\n            var fieldResolver_2 = field.subscribe;\n            field.subscribe = function (parent, args, context, info) {\n                var newInfo = __assign({}, info, { mergeInfo: mergeInfo });\n                return fieldResolver_2(parent, args, context, newInfo);\n            };\n        }\n    });\n    if (schemaDirectives) {\n        schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);\n    }\n    return mergedSchema;\n}\nfunction createMergeInfo(allSchemas, fragments) {\n    return {\n        delegate: function (operation, fieldName, args, context, info, transforms) {\n            console.warn('`mergeInfo.delegate` is deprecated. ' +\n                'Use `mergeInfo.delegateToSchema and pass explicit schema instances.');\n            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);\n            var expandTransforms = new transforms_1.ExpandAbstractTypes(info.schema, schema);\n            var fragmentTransform = new transforms_1.ReplaceFieldWithFragment(schema, fragments);\n            return delegateToSchema_1.default({\n                schema: schema,\n                operation: operation,\n                fieldName: fieldName,\n                args: args,\n                context: context,\n                info: info,\n                transforms: (transforms || []).concat([\n                    expandTransforms,\n                    fragmentTransform,\n                ]),\n            });\n        },\n        delegateToSchema: function (options) {\n            return delegateToSchema_1.default(__assign({}, options, { transforms: options.transforms }));\n        },\n        fragments: fragments\n    };\n}\nfunction guessSchemaByRootField(schemas, operation, fieldName) {\n    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {\n        var schema = schemas_1[_i];\n        var rootObject = void 0;\n        if (operation === 'subscription') {\n            rootObject = schema.getSubscriptionType();\n        }\n        else if (operation === 'mutation') {\n            rootObject = schema.getMutationType();\n        }\n        else {\n            rootObject = schema.getQueryType();\n        }\n        if (rootObject) {\n            var fields = rootObject.getFields();\n            if (fields[fieldName]) {\n                return schema;\n            }\n        }\n    }\n    throw new Error(\"Could not find subschema with field `{operation}.{fieldName}`\");\n}\nfunction createDelegatingResolver(schema, operation, fieldName) {\n    return function (root, args, context, info) {\n        return info.mergeInfo.delegateToSchema({\n            schema: schema,\n            operation: operation,\n            fieldName: fieldName,\n            args: args,\n            context: context,\n            info: info,\n        });\n    };\n}\nfunction forEachField(schema, fn) {\n    var typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        if (!graphql_1.getNamedType(type).name.startsWith('__') &&\n            type instanceof graphql_1.GraphQLObjectType) {\n            var fields_1 = type.getFields();\n            Object.keys(fields_1).forEach(function (fieldName) {\n                var field = fields_1[fieldName];\n                fn(field, typeName, fieldName);\n            });\n        }\n    });\n}\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\n    if (!typeCandidates[name]) {\n        typeCandidates[name] = [];\n    }\n    typeCandidates[name].push(typeCandidate);\n}\nfunction createVisitTypeFromOnTypeConflict(onTypeConflict) {\n    return function (name, candidates) {\n        return defaultVisitType(name, candidates, function (cands) {\n            return cands.reduce(function (prev, next) {\n                var type = onTypeConflict(prev.type, next.type, {\n                    left: {\n                        schema: prev.schema,\n                    },\n                    right: {\n                        schema: next.schema,\n                    },\n                });\n                if (prev.type === type) {\n                    return prev;\n                }\n                else if (next.type === type) {\n                    return next;\n                }\n                else {\n                    return {\n                        schemaName: 'unknown',\n                        type: type,\n                    };\n                }\n            });\n        });\n    };\n}\nvar defaultVisitType = function (name, candidates, candidateSelector) {\n    if (!candidateSelector) {\n        candidateSelector = function (cands) { return cands[cands.length - 1]; };\n    }\n    var resolveType = schemaRecreation_1.createResolveType(function (_, type) { return type; });\n    if (name === 'Query' || name === 'Mutation' || name === 'Subscription') {\n        var fields_2 = {};\n        var operationName_1;\n        switch (name) {\n            case 'Query':\n                operationName_1 = 'query';\n                break;\n            case 'Mutation':\n                operationName_1 = 'mutation';\n                break;\n            case 'Subscription':\n                operationName_1 = 'subscription';\n                break;\n            default:\n                break;\n        }\n        var resolvers_1 = {};\n        var resolverKey_1 = operationName_1 === 'subscription' ? 'subscribe' : 'resolve';\n        candidates.forEach(function (_a) {\n            var candidateType = _a.type, schema = _a.schema;\n            var candidateFields = candidateType.getFields();\n            fields_2 = __assign({}, fields_2, candidateFields);\n            Object.keys(candidateFields).forEach(function (fieldName) {\n                resolvers_1[fieldName] = (_a = {},\n                    _a[resolverKey_1] = createDelegatingResolver(schema, operationName_1, fieldName),\n                    _a);\n                var _a;\n            });\n        });\n        var type = new graphql_1.GraphQLObjectType({\n            name: name,\n            fields: schemaRecreation_1.fieldMapToFieldConfigMap(fields_2, resolveType, false),\n        });\n        return {\n            type: type,\n            resolvers: resolvers_1,\n        };\n    }\n    else {\n        var candidate = candidateSelector(candidates);\n        return candidate.type;\n    }\n};\n//# sourceMappingURL=mergeSchemas.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/mergeSchemas.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/observableToAsyncIterable.js":
/*!********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/observableToAsyncIterable.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\nfunction observableToAsyncIterable(observable) {\n    var pullQueue = [];\n    var pushQueue = [];\n    var listening = true;\n    var pushValue = function (_a) {\n        var data = _a.data;\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value: data, done: false });\n        }\n        else {\n            pushQueue.push({ value: data });\n        }\n    };\n    var pushError = function (error) {\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] } });\n        }\n    };\n    var pullValue = function () {\n        return new Promise(function (resolve) {\n            if (pushQueue.length !== 0) {\n                var element = pushQueue.shift();\n                // either {value: {errors: [...]}} or {value: ...}\n                resolve(__assign({}, element, { done: false }));\n            }\n            else {\n                pullQueue.push(resolve);\n            }\n        });\n    };\n    var subscription = observable.subscribe({\n        next: function (value) {\n            pushValue(value);\n        },\n        error: function (err) {\n            pushError(err);\n        },\n    });\n    var emptyQueue = function () {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return _a = {\n            next: function () {\n                return __awaiter(this, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        return [2 /*return*/, listening ? pullValue() : this.return()];\n                    });\n                });\n            },\n            return: function () {\n                emptyQueue();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (error) {\n                emptyQueue();\n                return Promise.reject(error);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n    var _a;\n}\nexports.observableToAsyncIterable = observableToAsyncIterable;\n//# sourceMappingURL=observableToAsyncIterable.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/observableToAsyncIterable.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/resolveFromParentTypename.js":
/*!********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/resolveFromParentTypename.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nfunction resolveFromParentTypename(parent, schema) {\n    var parentTypename = parent['__typename'];\n    if (!parentTypename) {\n        throw new Error('Did not fetch typename for object, unable to resolve interface.');\n    }\n    var resolvedType = schema.getType(parentTypename);\n    if (!(resolvedType instanceof graphql_1.GraphQLObjectType)) {\n        throw new Error('__typename did not match an object type: ' + parentTypename);\n    }\n    return resolvedType;\n}\nexports.default = resolveFromParentTypename;\n//# sourceMappingURL=resolveFromParentTypename.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/resolveFromParentTypename.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/resolvers.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/resolvers.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar delegateToSchema_1 = __webpack_require__(/*! ./delegateToSchema */ \"./node_modules/graphql-tools/dist/stitching/delegateToSchema.js\");\nfunction generateProxyingResolvers(targetSchema, transforms, mapping) {\n    var result = {};\n    Object.keys(mapping).forEach(function (name) {\n        result[name] = {};\n        var innerMapping = mapping[name];\n        Object.keys(innerMapping).forEach(function (from) {\n            var to = innerMapping[from];\n            var resolverType = to.operation === 'subscription' ? 'subscribe' : 'resolve';\n            result[name][from] = (_a = {},\n                _a[resolverType] = createProxyingResolver(targetSchema, to.operation, to.name, transforms),\n                _a);\n            var _a;\n        });\n    });\n    return result;\n}\nexports.generateProxyingResolvers = generateProxyingResolvers;\nfunction generateSimpleMapping(targetSchema) {\n    var query = targetSchema.getQueryType();\n    var mutation = targetSchema.getMutationType();\n    var subscription = targetSchema.getSubscriptionType();\n    var result = {};\n    if (query) {\n        result[query.name] = generateMappingFromObjectType(query, 'query');\n    }\n    if (mutation) {\n        result[mutation.name] = generateMappingFromObjectType(mutation, 'mutation');\n    }\n    if (subscription) {\n        result[subscription.name] = generateMappingFromObjectType(subscription, 'subscription');\n    }\n    return result;\n}\nexports.generateSimpleMapping = generateSimpleMapping;\nfunction generateMappingFromObjectType(type, operation) {\n    var result = {};\n    var fields = type.getFields();\n    Object.keys(fields).forEach(function (fieldName) {\n        result[fieldName] = {\n            name: fieldName,\n            operation: operation,\n        };\n    });\n    return result;\n}\nexports.generateMappingFromObjectType = generateMappingFromObjectType;\nfunction createProxyingResolver(schema, operation, fieldName, transforms) {\n    return function (parent, args, context, info) { return delegateToSchema_1.default({\n        schema: schema,\n        operation: operation,\n        fieldName: fieldName,\n        args: {},\n        context: context,\n        info: info,\n        transforms: transforms,\n    }); };\n}\n//# sourceMappingURL=resolvers.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/resolvers.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/schemaRecreation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/schemaRecreation.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar isSpecifiedScalarType_1 = __webpack_require__(/*! ../isSpecifiedScalarType */ \"./node_modules/graphql-tools/dist/isSpecifiedScalarType.js\");\nvar resolveFromParentTypename_1 = __webpack_require__(/*! ./resolveFromParentTypename */ \"./node_modules/graphql-tools/dist/stitching/resolveFromParentTypename.js\");\nvar defaultMergedResolver_1 = __webpack_require__(/*! ./defaultMergedResolver */ \"./node_modules/graphql-tools/dist/stitching/defaultMergedResolver.js\");\nfunction recreateType(type, resolveType, keepResolvers) {\n    if (type instanceof graphql_1.GraphQLObjectType) {\n        var fields_1 = type.getFields();\n        var interfaces_1 = type.getInterfaces();\n        return new graphql_1.GraphQLObjectType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            isTypeOf: keepResolvers ? type.isTypeOf : undefined,\n            fields: function () {\n                return fieldMapToFieldConfigMap(fields_1, resolveType, keepResolvers);\n            },\n            interfaces: function () { return interfaces_1.map(function (iface) { return resolveType(iface); }); },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLInterfaceType) {\n        var fields_2 = type.getFields();\n        return new graphql_1.GraphQLInterfaceType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            fields: function () {\n                return fieldMapToFieldConfigMap(fields_2, resolveType, keepResolvers);\n            },\n            resolveType: keepResolvers\n                ? type.resolveType\n                : function (parent, context, info) {\n                    return resolveFromParentTypename_1.default(parent, info.schema);\n                },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLUnionType) {\n        return new graphql_1.GraphQLUnionType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            types: function () { return type.getTypes().map(function (unionMember) { return resolveType(unionMember); }); },\n            resolveType: keepResolvers\n                ? type.resolveType\n                : function (parent, context, info) {\n                    return resolveFromParentTypename_1.default(parent, info.schema);\n                },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLInputObjectType) {\n        return new graphql_1.GraphQLInputObjectType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            fields: function () {\n                return inputFieldMapToFieldConfigMap(type.getFields(), resolveType);\n            },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLEnumType) {\n        var values = type.getValues();\n        var newValues_1 = {};\n        values.forEach(function (value) {\n            newValues_1[value.name] = {\n                value: value.name,\n                deprecationReason: value.deprecationReason,\n                description: value.description,\n            };\n        });\n        return new graphql_1.GraphQLEnumType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            values: newValues_1,\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLScalarType) {\n        if (isSpecifiedScalarType_1.default(type)) {\n            return type;\n        }\n        else {\n            return new graphql_1.GraphQLScalarType({\n                name: type.name,\n                description: type.description,\n                astNode: type.astNode,\n                serialize: function (value) {\n                    return value;\n                },\n                parseValue: function (value) {\n                    return value;\n                },\n                parseLiteral: function (ast) {\n                    return parseLiteral(ast);\n                },\n            });\n        }\n    }\n    else {\n        throw new Error(\"Invalid type \" + type);\n    }\n}\nexports.recreateType = recreateType;\nfunction parseLiteral(ast) {\n    switch (ast.kind) {\n        case graphql_1.Kind.STRING:\n        case graphql_1.Kind.BOOLEAN: {\n            return ast.value;\n        }\n        case graphql_1.Kind.INT:\n        case graphql_1.Kind.FLOAT: {\n            return parseFloat(ast.value);\n        }\n        case graphql_1.Kind.OBJECT: {\n            var value_1 = Object.create(null);\n            ast.fields.forEach(function (field) {\n                value_1[field.name.value] = parseLiteral(field.value);\n            });\n            return value_1;\n        }\n        case graphql_1.Kind.LIST: {\n            return ast.values.map(parseLiteral);\n        }\n        default:\n            return null;\n    }\n}\nfunction fieldMapToFieldConfigMap(fields, resolveType, keepResolvers) {\n    var result = {};\n    Object.keys(fields).forEach(function (name) {\n        var field = fields[name];\n        var type = resolveType(field.type);\n        if (type !== null) {\n            result[name] = fieldToFieldConfig(fields[name], resolveType, keepResolvers);\n        }\n    });\n    return result;\n}\nexports.fieldMapToFieldConfigMap = fieldMapToFieldConfigMap;\nfunction createResolveType(getType) {\n    var resolveType = function (type) {\n        if (type instanceof graphql_1.GraphQLList) {\n            var innerType = resolveType(type.ofType);\n            if (innerType === null) {\n                return null;\n            }\n            else {\n                return new graphql_1.GraphQLList(innerType);\n            }\n        }\n        else if (type instanceof graphql_1.GraphQLNonNull) {\n            var innerType = resolveType(type.ofType);\n            if (innerType === null) {\n                return null;\n            }\n            else {\n                return new graphql_1.GraphQLNonNull(innerType);\n            }\n        }\n        else if (graphql_1.isNamedType(type)) {\n            return getType(graphql_1.getNamedType(type).name, type);\n        }\n        else {\n            return type;\n        }\n    };\n    return resolveType;\n}\nexports.createResolveType = createResolveType;\nfunction fieldToFieldConfig(field, resolveType, keepResolvers) {\n    return {\n        type: resolveType(field.type),\n        args: argsToFieldConfigArgumentMap(field.args, resolveType),\n        resolve: keepResolvers ? field.resolve : defaultMergedResolver_1.default,\n        subscribe: keepResolvers ? field.subscribe : null,\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        astNode: field.astNode,\n    };\n}\nexports.fieldToFieldConfig = fieldToFieldConfig;\nfunction argsToFieldConfigArgumentMap(args, resolveType) {\n    var result = {};\n    args.forEach(function (arg) {\n        var newArg = argumentToArgumentConfig(arg, resolveType);\n        if (newArg) {\n            result[newArg[0]] = newArg[1];\n        }\n    });\n    return result;\n}\nexports.argsToFieldConfigArgumentMap = argsToFieldConfigArgumentMap;\nfunction argumentToArgumentConfig(argument, resolveType) {\n    var type = resolveType(argument.type);\n    if (type === null) {\n        return null;\n    }\n    else {\n        return [\n            argument.name,\n            {\n                type: type,\n                defaultValue: argument.defaultValue,\n                description: argument.description,\n            },\n        ];\n    }\n}\nexports.argumentToArgumentConfig = argumentToArgumentConfig;\nfunction inputFieldMapToFieldConfigMap(fields, resolveType) {\n    var result = {};\n    Object.keys(fields).forEach(function (name) {\n        var field = fields[name];\n        var type = resolveType(field.type);\n        if (type !== null) {\n            result[name] = inputFieldToFieldConfig(fields[name], resolveType);\n        }\n    });\n    return result;\n}\nexports.inputFieldMapToFieldConfigMap = inputFieldMapToFieldConfigMap;\nfunction inputFieldToFieldConfig(field, resolveType) {\n    return {\n        type: resolveType(field.type),\n        defaultValue: field.defaultValue,\n        description: field.description,\n        astNode: field.astNode,\n    };\n}\nexports.inputFieldToFieldConfig = inputFieldToFieldConfig;\n//# sourceMappingURL=schemaRecreation.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/schemaRecreation.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/stitching/typeFromAST.js":
/*!******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/stitching/typeFromAST.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar resolveFromParentTypename_1 = __webpack_require__(/*! ./resolveFromParentTypename */ \"./node_modules/graphql-tools/dist/stitching/resolveFromParentTypename.js\");\nvar backcompatOptions = { commentDescriptions: true };\nfunction typeFromAST(node, getType) {\n    switch (node.kind) {\n        case graphql_1.Kind.OBJECT_TYPE_DEFINITION:\n            return makeObjectType(node, getType);\n        case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:\n            return makeInterfaceType(node, getType);\n        case graphql_1.Kind.ENUM_TYPE_DEFINITION:\n            return makeEnumType(node, getType);\n        case graphql_1.Kind.UNION_TYPE_DEFINITION:\n            return makeUnionType(node, getType);\n        case graphql_1.Kind.SCALAR_TYPE_DEFINITION:\n            return makeScalarType(node, getType);\n        case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n            return makeInputObjectType(node, getType);\n        default:\n            return null;\n    }\n}\nexports.default = typeFromAST;\nfunction makeObjectType(node, getType) {\n    return new graphql_1.GraphQLObjectType({\n        name: node.name.value,\n        fields: function () { return makeFields(node.fields, getType); },\n        interfaces: function () {\n            return node.interfaces.map(function (iface) { return getType(iface.name.value, 'interface'); });\n        },\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeInterfaceType(node, getType) {\n    return new graphql_1.GraphQLInterfaceType({\n        name: node.name.value,\n        fields: function () { return makeFields(node.fields, getType); },\n        description: graphql_1.getDescription(node, backcompatOptions),\n        resolveType: function (parent, context, info) {\n            return resolveFromParentTypename_1.default(parent, info.schema);\n        },\n    });\n}\nfunction makeEnumType(node, getType) {\n    var values = {};\n    node.values.forEach(function (value) {\n        values[value.name.value] = {\n            description: graphql_1.getDescription(value, backcompatOptions),\n        };\n    });\n    return new graphql_1.GraphQLEnumType({\n        name: node.name.value,\n        values: values,\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeUnionType(node, getType) {\n    return new graphql_1.GraphQLUnionType({\n        name: node.name.value,\n        types: function () {\n            return node.types.map(function (type) { return resolveType(type, getType, 'object'); });\n        },\n        description: graphql_1.getDescription(node, backcompatOptions),\n        resolveType: function (parent, context, info) {\n            return resolveFromParentTypename_1.default(parent, info.schema);\n        },\n    });\n}\nfunction makeScalarType(node, getType) {\n    return new graphql_1.GraphQLScalarType({\n        name: node.name.value,\n        description: graphql_1.getDescription(node, backcompatOptions),\n        serialize: function () { return null; },\n        // Note: validation calls the parse functions to determine if a\n        // literal value is correct. Returning null would cause use of custom\n        // scalars to always fail validation. Returning false causes them to\n        // always pass validation.\n        parseValue: function () { return false; },\n        parseLiteral: function () { return false; },\n    });\n}\nfunction makeInputObjectType(node, getType) {\n    return new graphql_1.GraphQLInputObjectType({\n        name: node.name.value,\n        fields: function () { return makeValues(node.fields, getType); },\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeFields(nodes, getType) {\n    var result = {};\n    nodes.forEach(function (node) {\n        result[node.name.value] = {\n            type: resolveType(node.type, getType, 'object'),\n            args: makeValues(node.arguments, getType),\n            description: graphql_1.getDescription(node, backcompatOptions),\n        };\n    });\n    return result;\n}\nfunction makeValues(nodes, getType) {\n    var result = {};\n    nodes.forEach(function (node) {\n        var type = resolveType(node.type, getType, 'input');\n        result[node.name.value] = {\n            type: type,\n            defaultValue: graphql_1.valueFromAST(node.defaultValue, type),\n            description: graphql_1.getDescription(node, backcompatOptions),\n        };\n    });\n    return result;\n}\nfunction resolveType(node, getType, type) {\n    switch (node.kind) {\n        case graphql_1.Kind.LIST_TYPE:\n            return new graphql_1.GraphQLList(resolveType(node.type, getType, type));\n        case graphql_1.Kind.NON_NULL_TYPE:\n            return new graphql_1.GraphQLNonNull(resolveType(node.type, getType, type));\n        default:\n            return getType(node.name.value, type);\n    }\n}\n//# sourceMappingURL=typeFromAST.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/stitching/typeFromAST.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/AddArgumentsAsVariables.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/AddArgumentsAsVariables.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar AddArgumentsAsVariablesTransform = /** @class */ (function () {\n    function AddArgumentsAsVariablesTransform(schema, args) {\n        this.schema = schema;\n        this.args = args;\n    }\n    AddArgumentsAsVariablesTransform.prototype.transformRequest = function (originalRequest) {\n        var _a = addVariablesToRootField(this.schema, originalRequest.document, this.args), document = _a.document, newVariables = _a.newVariables;\n        var variables = __assign({}, originalRequest.variables, newVariables);\n        return {\n            document: document,\n            variables: variables,\n        };\n    };\n    return AddArgumentsAsVariablesTransform;\n}());\nexports.default = AddArgumentsAsVariablesTransform;\nfunction addVariablesToRootField(targetSchema, document, args) {\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var variableNames = {};\n    var newOperations = operations.map(function (operation) {\n        var existingVariables = operation.variableDefinitions.map(function (variableDefinition) {\n            return variableDefinition.variable.name.value;\n        });\n        var variableCounter = 0;\n        var variables = {};\n        var generateVariableName = function (argName) {\n            var varName;\n            do {\n                varName = \"_v\" + variableCounter + \"_\" + argName;\n                variableCounter++;\n            } while (existingVariables.indexOf(varName) !== -1);\n            return varName;\n        };\n        var type;\n        if (operation.operation === 'subscription') {\n            type = targetSchema.getSubscriptionType();\n        }\n        else if (operation.operation === 'mutation') {\n            type = targetSchema.getMutationType();\n        }\n        else {\n            type = targetSchema.getQueryType();\n        }\n        var newSelectionSet = [];\n        operation.selectionSet.selections.forEach(function (selection) {\n            if (selection.kind === graphql_1.Kind.FIELD) {\n                var newArgs_1 = {};\n                selection.arguments.forEach(function (argument) {\n                    newArgs_1[argument.name.value] = argument;\n                });\n                var name_1 = selection.name.value;\n                var field = type.getFields()[name_1];\n                field.args.forEach(function (argument) {\n                    if (argument.name in args) {\n                        var variableName = generateVariableName(argument.name);\n                        variableNames[argument.name] = variableName;\n                        newArgs_1[argument.name] = {\n                            kind: graphql_1.Kind.ARGUMENT,\n                            name: {\n                                kind: graphql_1.Kind.NAME,\n                                value: argument.name,\n                            },\n                            value: {\n                                kind: graphql_1.Kind.VARIABLE,\n                                name: {\n                                    kind: graphql_1.Kind.NAME,\n                                    value: variableName,\n                                },\n                            },\n                        };\n                        existingVariables.push(variableName);\n                        variables[variableName] = {\n                            kind: graphql_1.Kind.VARIABLE_DEFINITION,\n                            variable: {\n                                kind: graphql_1.Kind.VARIABLE,\n                                name: {\n                                    kind: graphql_1.Kind.NAME,\n                                    value: variableName,\n                                },\n                            },\n                            type: typeToAst(argument.type),\n                        };\n                    }\n                });\n                newSelectionSet.push(__assign({}, selection, { arguments: Object.keys(newArgs_1).map(function (argName) { return newArgs_1[argName]; }) }));\n            }\n            else {\n                newSelectionSet.push(selection);\n            }\n        });\n        return __assign({}, operation, { variableDefinitions: operation.variableDefinitions.concat(Object.keys(variables).map(function (varName) { return variables[varName]; })), selectionSet: {\n                kind: graphql_1.Kind.SELECTION_SET,\n                selections: newSelectionSet,\n            } });\n    });\n    var newVariables = {};\n    Object.keys(variableNames).forEach(function (name) {\n        newVariables[variableNames[name]] = args[name];\n    });\n    return {\n        document: __assign({}, document, { definitions: newOperations.concat(fragments) }),\n        newVariables: newVariables,\n    };\n}\nfunction typeToAst(type) {\n    if (type instanceof graphql_1.GraphQLNonNull) {\n        var innerType = typeToAst(type.ofType);\n        if (innerType.kind === graphql_1.Kind.LIST_TYPE ||\n            innerType.kind === graphql_1.Kind.NAMED_TYPE) {\n            return {\n                kind: graphql_1.Kind.NON_NULL_TYPE,\n                type: innerType,\n            };\n        }\n        else {\n            throw new Error('Incorrent inner non-null type');\n        }\n    }\n    else if (type instanceof graphql_1.GraphQLList) {\n        return {\n            kind: graphql_1.Kind.LIST_TYPE,\n            type: typeToAst(type.ofType),\n        };\n    }\n    else {\n        return {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type.toString(),\n            },\n        };\n    }\n}\n//# sourceMappingURL=AddArgumentsAsVariables.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/AddArgumentsAsVariables.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/AddTypenameToAbstract.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/AddTypenameToAbstract.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar AddTypenameToAbstract = /** @class */ (function () {\n    function AddTypenameToAbstract(targetSchema) {\n        this.targetSchema = targetSchema;\n    }\n    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {\n        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return AddTypenameToAbstract;\n}());\nexports.default = AddTypenameToAbstract;\nfunction addTypenameToAbstract(targetSchema, document) {\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var parentType = typeInfo.getParentType();\n            var selections = node.selections;\n            if (parentType &&\n                (parentType instanceof graphql_1.GraphQLInterfaceType ||\n                    parentType instanceof graphql_1.GraphQLUnionType) &&\n                !selections.find(function (_) {\n                    return _.kind === graphql_1.Kind.FIELD &&\n                        _.name.value === '__typename';\n                })) {\n                selections = selections.concat({\n                    kind: graphql_1.Kind.FIELD,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            if (selections !== node.selections) {\n                return __assign({}, node, { selections: selections });\n            }\n        },\n        _a)));\n    var _a;\n}\n//# sourceMappingURL=AddTypenameToAbstract.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/AddTypenameToAbstract.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/CheckResultAndHandleErrors.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/CheckResultAndHandleErrors.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errors_1 = __webpack_require__(/*! ../stitching/errors */ \"./node_modules/graphql-tools/dist/stitching/errors.js\");\nvar CheckResultAndHandleErrors = /** @class */ (function () {\n    function CheckResultAndHandleErrors(info, fieldName) {\n        this.info = info;\n        this.fieldName = fieldName;\n    }\n    CheckResultAndHandleErrors.prototype.transformResult = function (result) {\n        return errors_1.checkResultAndHandleErrors(result, this.info, this.fieldName);\n    };\n    return CheckResultAndHandleErrors;\n}());\nexports.default = CheckResultAndHandleErrors;\n//# sourceMappingURL=CheckResultAndHandleErrors.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/CheckResultAndHandleErrors.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/ExpandAbstractTypes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/ExpandAbstractTypes.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar implementsAbstractType_1 = __webpack_require__(/*! ../implementsAbstractType */ \"./node_modules/graphql-tools/dist/implementsAbstractType.js\");\nvar ExpandAbstractTypes = /** @class */ (function () {\n    function ExpandAbstractTypes(transformedSchema, targetSchema) {\n        this.targetSchema = targetSchema;\n        this.mapping = extractPossibleTypes(transformedSchema, targetSchema);\n        this.reverseMapping = flipMapping(this.mapping);\n    }\n    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\n        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return ExpandAbstractTypes;\n}());\nexports.default = ExpandAbstractTypes;\nfunction extractPossibleTypes(transformedSchema, targetSchema) {\n    var typeMap = transformedSchema.getTypeMap();\n    var mapping = {};\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        if (graphql_1.isAbstractType(type)) {\n            var targetType = targetSchema.getType(typeName);\n            if (!graphql_1.isAbstractType(targetType)) {\n                var implementations = transformedSchema.getPossibleTypes(type) || [];\n                mapping[typeName] = implementations\n                    .filter(function (impl) { return targetSchema.getType(impl.name); })\n                    .map(function (impl) { return impl.name; });\n            }\n        }\n    });\n    return mapping;\n}\nfunction flipMapping(mapping) {\n    var result = {};\n    Object.keys(mapping).forEach(function (typeName) {\n        var toTypeNames = mapping[typeName];\n        toTypeNames.forEach(function (toTypeName) {\n            if (!result[toTypeName]) {\n                result[toTypeName] = [];\n            }\n            result[toTypeName].push(typeName);\n        });\n    });\n    return result;\n}\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });\n    var fragmentCounter = 0;\n    var generateFragmentName = function (typeName) {\n        var fragmentName;\n        do {\n            fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter;\n            fragmentCounter++;\n        } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n        return fragmentName;\n    };\n    var newFragments = [];\n    var fragmentReplacements = {};\n    fragments.forEach(function (fragment) {\n        newFragments.push(fragment);\n        var possibleTypes = mapping[fragment.typeCondition.name.value];\n        if (possibleTypes) {\n            fragmentReplacements[fragment.name.value] = [];\n            possibleTypes.forEach(function (possibleTypeName) {\n                var name = generateFragmentName(possibleTypeName);\n                existingFragmentNames.push(name);\n                var newFragment = {\n                    kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: name,\n                    },\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: possibleTypeName,\n                        },\n                    },\n                    selectionSet: fragment.selectionSet,\n                };\n                newFragments.push(newFragment);\n                fragmentReplacements[fragment.name.value].push({\n                    fragmentName: name,\n                    typeName: possibleTypeName,\n                });\n            });\n        }\n    });\n    var newDocument = __assign({}, document, { definitions: operations.concat(newFragments) });\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(newDocument, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var newSelections = node.selections.slice();\n            var parentType = graphql_1.getNamedType(typeInfo.getParentType());\n            node.selections.forEach(function (selection) {\n                if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n                    var possibleTypes = mapping[selection.typeCondition.name.value];\n                    if (possibleTypes) {\n                        possibleTypes.forEach(function (possibleType) {\n                            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(possibleType))) {\n                                newSelections.push({\n                                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                                    typeCondition: {\n                                        kind: graphql_1.Kind.NAMED_TYPE,\n                                        name: {\n                                            kind: graphql_1.Kind.NAME,\n                                            value: possibleType,\n                                        },\n                                    },\n                                    selectionSet: selection.selectionSet,\n                                });\n                            }\n                        });\n                    }\n                }\n                else if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {\n                    var fragmentName = selection.name.value;\n                    var replacements = fragmentReplacements[fragmentName];\n                    if (replacements) {\n                        replacements.forEach(function (replacement) {\n                            var typeName = replacement.typeName;\n                            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(typeName))) {\n                                newSelections.push({\n                                    kind: graphql_1.Kind.FRAGMENT_SPREAD,\n                                    name: {\n                                        kind: graphql_1.Kind.NAME,\n                                        value: replacement.fragmentName,\n                                    },\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n            if (parentType && reverseMapping[parentType.name]) {\n                newSelections.push({\n                    kind: graphql_1.Kind.FIELD,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            if (newSelections.length !== node.selections.length) {\n                return __assign({}, node, { selections: newSelections });\n            }\n        },\n        _a)));\n    var _a;\n}\n//# sourceMappingURL=ExpandAbstractTypes.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/ExpandAbstractTypes.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/ExtractField.js":
/*!********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/ExtractField.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar ExtractField = /** @class */ (function () {\n    function ExtractField(_a) {\n        var from = _a.from, to = _a.to;\n        this.from = from;\n        this.to = to;\n    }\n    ExtractField.prototype.transformRequest = function (originalRequest) {\n        var fromSelection;\n        var ourPathFrom = JSON.stringify(this.from);\n        var ourPathTo = JSON.stringify(this.to);\n        var fieldPath = [];\n        graphql_1.visit(originalRequest.document, (_a = {},\n            _a[graphql_1.Kind.FIELD] = {\n                enter: function (node) {\n                    fieldPath.push(node.name.value);\n                    if (ourPathFrom === JSON.stringify(fieldPath)) {\n                        fromSelection = node.selectionSet;\n                        return graphql_1.BREAK;\n                    }\n                },\n                leave: function (node) {\n                    fieldPath.pop();\n                },\n            },\n            _a));\n        fieldPath = [];\n        var newDocument = graphql_1.visit(originalRequest.document, (_b = {},\n            _b[graphql_1.Kind.FIELD] = {\n                enter: function (node) {\n                    fieldPath.push(node.name.value);\n                    if (ourPathTo === JSON.stringify(fieldPath) && fromSelection) {\n                        return __assign({}, node, { selectionSet: fromSelection });\n                    }\n                },\n                leave: function (node) {\n                    fieldPath.pop();\n                },\n            },\n            _b));\n        return __assign({}, originalRequest, { document: newDocument });\n        var _a, _b;\n    };\n    return ExtractField;\n}());\nexports.default = ExtractField;\n//# sourceMappingURL=ExtractField.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/ExtractField.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/FilterRootFields.js":
/*!************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/FilterRootFields.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TransformRootFields_1 = __webpack_require__(/*! ./TransformRootFields */ \"./node_modules/graphql-tools/dist/transforms/TransformRootFields.js\");\nvar FilterRootFields = /** @class */ (function () {\n    function FilterRootFields(filter) {\n        this.transformer = new TransformRootFields_1.default(function (operation, fieldName, field) {\n            if (filter(operation, fieldName, field)) {\n                return undefined;\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    FilterRootFields.prototype.transformSchema = function (originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    };\n    return FilterRootFields;\n}());\nexports.default = FilterRootFields;\n//# sourceMappingURL=FilterRootFields.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/FilterRootFields.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/FilterToSchema.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/FilterToSchema.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar implementsAbstractType_1 = __webpack_require__(/*! ../implementsAbstractType */ \"./node_modules/graphql-tools/dist/implementsAbstractType.js\");\nvar FilterToSchema = /** @class */ (function () {\n    function FilterToSchema(targetSchema) {\n        this.targetSchema = targetSchema;\n    }\n    FilterToSchema.prototype.transformRequest = function (originalRequest) {\n        var document = filterDocumentToSchema(this.targetSchema, originalRequest.document);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return FilterToSchema;\n}());\nexports.default = FilterToSchema;\nfunction filterDocumentToSchema(targetSchema, document) {\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var usedFragments = [];\n    var newOperations = [];\n    var newFragments = [];\n    var validFragments = fragments.filter(function (fragment) {\n        var typeName = fragment.typeCondition.name.value;\n        return Boolean(targetSchema.getType(typeName));\n    });\n    var validFragmentsWithType = {};\n    validFragments.forEach(function (fragment) {\n        var typeName = fragment.typeCondition.name.value;\n        var type = targetSchema.getType(typeName);\n        validFragmentsWithType[fragment.name.value] = type;\n    });\n    var fragmentSet = Object.create(null);\n    operations.forEach(function (operation) {\n        var type;\n        if (operation.operation === 'subscription') {\n            type = targetSchema.getSubscriptionType();\n        }\n        else if (operation.operation === 'mutation') {\n            type = targetSchema.getMutationType();\n        }\n        else {\n            type = targetSchema.getQueryType();\n        }\n        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;\n        usedFragments = union(usedFragments, operationUsedFragments);\n        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;\n        var fullUsedVariables = union(operationUsedVariables, collectedUsedVariables);\n        newFragments = collectedNewFragments;\n        fragmentSet = collectedFragmentSet;\n        var variableDefinitions = operation.variableDefinitions.filter(function (variable) {\n            return fullUsedVariables.indexOf(variable.variable.name.value) !== -1;\n        });\n        newOperations.push({\n            kind: graphql_1.Kind.OPERATION_DEFINITION,\n            operation: operation.operation,\n            name: operation.name,\n            directives: operation.directives,\n            variableDefinitions: variableDefinitions,\n            selectionSet: selectionSet,\n        });\n    });\n    return {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: newOperations.concat(newFragments),\n    };\n}\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\n    var usedVariables = [];\n    var newFragments = [];\n    var _loop_1 = function () {\n        var nextFragmentName = usedFragments.pop();\n        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });\n        if (fragment) {\n            var name_1 = nextFragmentName;\n            var typeName = fragment.typeCondition.name.value;\n            var type = targetSchema.getType(typeName);\n            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;\n            usedFragments = union(usedFragments, fragmentUsedFragments);\n            usedVariables = union(usedVariables, fragmentUsedVariables);\n            if (!fragmentSet[name_1]) {\n                fragmentSet[name_1] = true;\n                newFragments.push({\n                    kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: name_1,\n                    },\n                    typeCondition: fragment.typeCondition,\n                    selectionSet: selectionSet,\n                });\n            }\n        }\n    };\n    while (usedFragments.length !== 0) {\n        _loop_1();\n    }\n    return {\n        usedVariables: usedVariables,\n        newFragments: newFragments,\n        fragmentSet: fragmentSet,\n    };\n}\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\n    var usedFragments = [];\n    var usedVariables = [];\n    var typeStack = [type];\n    // Should be rewritten using visitWithSchema\n    var filteredSelectionSet = graphql_1.visit(selectionSet, (_a = {},\n        _a[graphql_1.Kind.FIELD] = {\n            enter: function (node) {\n                var parentType = resolveType(typeStack[typeStack.length - 1]);\n                if (parentType instanceof graphql_1.GraphQLObjectType ||\n                    parentType instanceof graphql_1.GraphQLInterfaceType) {\n                    var fields = parentType.getFields();\n                    var field = node.name.value === '__typename'\n                        ? graphql_1.TypeNameMetaFieldDef\n                        : fields[node.name.value];\n                    if (!field) {\n                        return null;\n                    }\n                    else {\n                        typeStack.push(field.type);\n                    }\n                    var argNames_1 = (field.args || []).map(function (arg) { return arg.name; });\n                    if (node.arguments) {\n                        var args = node.arguments.filter(function (arg) {\n                            return argNames_1.indexOf(arg.name.value) !== -1;\n                        });\n                        if (args.length !== node.arguments.length) {\n                            return __assign({}, node, { arguments: args });\n                        }\n                    }\n                }\n                else if (parentType instanceof graphql_1.GraphQLUnionType &&\n                    node.name.value === '__typename') {\n                    typeStack.push(graphql_1.TypeNameMetaFieldDef.type);\n                }\n            },\n            leave: function (node) {\n                var currentType = typeStack.pop();\n                var resolvedType = resolveType(currentType);\n                if (resolvedType instanceof graphql_1.GraphQLObjectType ||\n                    resolvedType instanceof graphql_1.GraphQLInterfaceType) {\n                    var selections = node.selectionSet && node.selectionSet.selections || null;\n                    if (!selections || selections.length === 0) {\n                        // need to remove any added variables. Is there a better way to do this?\n                        graphql_1.visit(node, (_a = {},\n                            _a[graphql_1.Kind.VARIABLE] = function (variableNode) {\n                                var index = usedVariables.indexOf(variableNode.name.value);\n                                if (index !== -1) {\n                                    usedVariables.splice(index, 1);\n                                }\n                            },\n                            _a));\n                        return null;\n                    }\n                }\n                var _a;\n            },\n        },\n        _a[graphql_1.Kind.FRAGMENT_SPREAD] = function (node) {\n            if (node.name.value in validFragments) {\n                var parentType = resolveType(typeStack[typeStack.length - 1]);\n                var innerType = validFragments[node.name.value];\n                if (!implementsAbstractType_1.default(schema, parentType, innerType)) {\n                    return null;\n                }\n                else {\n                    usedFragments.push(node.name.value);\n                    return;\n                }\n            }\n            else {\n                return null;\n            }\n        },\n        _a[graphql_1.Kind.INLINE_FRAGMENT] = {\n            enter: function (node) {\n                if (node.typeCondition) {\n                    var innerType = schema.getType(node.typeCondition.name.value);\n                    var parentType = resolveType(typeStack[typeStack.length - 1]);\n                    if (implementsAbstractType_1.default(schema, parentType, innerType)) {\n                        typeStack.push(innerType);\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            },\n            leave: function (node) {\n                typeStack.pop();\n            },\n        },\n        _a[graphql_1.Kind.VARIABLE] = function (node) {\n            usedVariables.push(node.name.value);\n        },\n        _a));\n    return {\n        selectionSet: filteredSelectionSet,\n        usedFragments: usedFragments,\n        usedVariables: usedVariables,\n    };\n    var _a;\n}\nfunction resolveType(type) {\n    var lastType = type;\n    while (lastType instanceof graphql_1.GraphQLNonNull ||\n        lastType instanceof graphql_1.GraphQLList) {\n        lastType = lastType.ofType;\n    }\n    return lastType;\n}\nfunction union() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    var cache = {};\n    var result = [];\n    arrays.forEach(function (array) {\n        array.forEach(function (item) {\n            if (!cache[item]) {\n                cache[item] = true;\n                result.push(item);\n            }\n        });\n    });\n    return result;\n}\n//# sourceMappingURL=FilterToSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/FilterToSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/FilterTypes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/FilterTypes.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* tslint:disable:no-unused-expression */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./node_modules/graphql-tools/dist/transforms/visitSchema.js\");\nvar FilterTypes = /** @class */ (function () {\n    function FilterTypes(filter) {\n        this.filter = filter;\n    }\n    FilterTypes.prototype.transformSchema = function (schema) {\n        var _this = this;\n        return visitSchema_1.visitSchema(schema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.TYPE] = function (type) {\n                if (_this.filter(type)) {\n                    return undefined;\n                }\n                else {\n                    return null;\n                }\n            },\n            _a));\n        var _a;\n    };\n    return FilterTypes;\n}());\nexports.default = FilterTypes;\n//# sourceMappingURL=FilterTypes.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/FilterTypes.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/RenameRootFields.js":
/*!************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/RenameRootFields.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar schemaRecreation_1 = __webpack_require__(/*! ../stitching/schemaRecreation */ \"./node_modules/graphql-tools/dist/stitching/schemaRecreation.js\");\nvar TransformRootFields_1 = __webpack_require__(/*! ./TransformRootFields */ \"./node_modules/graphql-tools/dist/transforms/TransformRootFields.js\");\nvar RenameRootFields = /** @class */ (function () {\n    function RenameRootFields(renamer) {\n        var resolveType = schemaRecreation_1.createResolveType(function (name, type) { return type; });\n        this.transformer = new TransformRootFields_1.default(function (operation, fieldName, field) {\n            return {\n                name: renamer(operation, fieldName, field),\n                field: schemaRecreation_1.fieldToFieldConfig(field, resolveType, true),\n            };\n        });\n    }\n    RenameRootFields.prototype.transformSchema = function (originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    };\n    return RenameRootFields;\n}());\nexports.default = RenameRootFields;\n//# sourceMappingURL=RenameRootFields.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/RenameRootFields.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/RenameTypes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/RenameTypes.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar isSpecifiedScalarType_1 = __webpack_require__(/*! ../isSpecifiedScalarType */ \"./node_modules/graphql-tools/dist/isSpecifiedScalarType.js\");\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./node_modules/graphql-tools/dist/transforms/visitSchema.js\");\nvar RenameTypes = /** @class */ (function () {\n    function RenameTypes(renamer, options) {\n        this.renamer = renamer;\n        this.reverseMap = {};\n        var _a = options || {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;\n        this.renameBuiltins = renameBuiltins;\n        this.renameScalars = renameScalars;\n    }\n    RenameTypes.prototype.transformSchema = function (originalSchema) {\n        var _this = this;\n        return visitSchema_1.visitSchema(originalSchema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.TYPE] = function (type) {\n                if (isSpecifiedScalarType_1.default(type) && !_this.renameBuiltins) {\n                    return undefined;\n                }\n                if (type instanceof graphql_1.GraphQLScalarType && !_this.renameScalars) {\n                    return undefined;\n                }\n                var newName = _this.renamer(type.name);\n                if (newName && newName !== type.name) {\n                    _this.reverseMap[newName] = type.name;\n                    var newType = Object.assign(Object.create(type), type);\n                    newType.name = newName;\n                    return newType;\n                }\n            },\n            _a[visitSchema_1.VisitSchemaKind.ROOT_OBJECT] = function (type) {\n                return undefined;\n            },\n            _a));\n        var _a;\n    };\n    RenameTypes.prototype.transformRequest = function (originalRequest) {\n        var _this = this;\n        var newDocument = graphql_1.visit(originalRequest.document, (_a = {},\n            _a[graphql_1.Kind.NAMED_TYPE] = function (node) {\n                var name = node.name.value;\n                if (name in _this.reverseMap) {\n                    return __assign({}, node, { name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: _this.reverseMap[name],\n                        } });\n                }\n            },\n            _a));\n        return {\n            document: newDocument,\n            variables: originalRequest.variables,\n        };\n        var _a;\n    };\n    RenameTypes.prototype.transformResult = function (result) {\n        if (result.data) {\n            var data = this.renameTypes(result.data, 'data');\n            if (data !== result.data) {\n                return __assign({}, result, { data: data });\n            }\n        }\n        return result;\n    };\n    RenameTypes.prototype.renameTypes = function (value, name) {\n        var _this = this;\n        if (name === '__typename') {\n            return this.renamer(value);\n        }\n        if (value && typeof value === 'object') {\n            var newValue_1 = Array.isArray(value) ? []\n                // Create a new object with the same prototype.\n                : Object.create(Object.getPrototypeOf(value));\n            var returnNewValue_1 = false;\n            Object.keys(value).forEach(function (key) {\n                var oldChild = value[key];\n                var newChild = _this.renameTypes(oldChild, key);\n                newValue_1[key] = newChild;\n                if (newChild !== oldChild) {\n                    returnNewValue_1 = true;\n                }\n            });\n            if (returnNewValue_1) {\n                return newValue_1;\n            }\n        }\n        return value;\n    };\n    return RenameTypes;\n}());\nexports.default = RenameTypes;\n//# sourceMappingURL=RenameTypes.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/RenameTypes.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/ReplaceFieldWithFragment.js":
/*!********************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/ReplaceFieldWithFragment.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar ReplaceFieldWithFragment = /** @class */ (function () {\n    function ReplaceFieldWithFragment(targetSchema, fragments) {\n        this.targetSchema = targetSchema;\n        this.mapping = {};\n        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\n            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;\n            var parsedFragment = parseFragmentToInlineFragment(fragment);\n            var actualTypeName = parsedFragment.typeCondition.name.value;\n            this.mapping[actualTypeName] = this.mapping[actualTypeName] || {};\n            if (this.mapping[actualTypeName][field]) {\n                this.mapping[actualTypeName][field].push(parsedFragment);\n            }\n            else {\n                this.mapping[actualTypeName][field] = [parsedFragment];\n            }\n        }\n    }\n    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\n        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return ReplaceFieldWithFragment;\n}());\nexports.default = ReplaceFieldWithFragment;\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var parentType = typeInfo.getParentType();\n            if (parentType) {\n                var parentTypeName_1 = parentType.name;\n                var selections_1 = node.selections;\n                if (mapping[parentTypeName_1]) {\n                    node.selections.forEach(function (selection) {\n                        if (selection.kind === graphql_1.Kind.FIELD) {\n                            var name_1 = selection.name.value;\n                            var fragments = mapping[parentTypeName_1][name_1];\n                            if (fragments && fragments.length > 0) {\n                                var fragment = concatInlineFragments(parentTypeName_1, fragments);\n                                selections_1 = selections_1.concat(fragment);\n                            }\n                        }\n                    });\n                }\n                if (selections_1 !== node.selections) {\n                    return __assign({}, node, { selections: selections_1 });\n                }\n            }\n        },\n        _a)));\n    var _a;\n}\nfunction parseFragmentToInlineFragment(definitions) {\n    if (definitions.trim().startsWith('fragment')) {\n        var document_1 = graphql_1.parse(definitions);\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: definition.typeCondition,\n                    selectionSet: definition.selectionSet,\n                };\n            }\n        }\n    }\n    var query = graphql_1.parse(\"{\" + definitions + \"}\")\n        .definitions[0];\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n        var selection = _c[_b];\n        if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n            return selection;\n        }\n    }\n    throw new Error('Could not parse fragment');\n}\nfunction concatInlineFragments(type, fragments) {\n    var fragmentSelections = fragments.reduce(function (selections, fragment) {\n        return selections.concat(fragment.selectionSet.selections);\n    }, []);\n    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n    return {\n        kind: graphql_1.Kind.INLINE_FRAGMENT,\n        typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type,\n            },\n        },\n        selectionSet: {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: deduplicatedFragmentSelection,\n        },\n    };\n}\nfunction deduplicateSelection(nodes) {\n    var selectionMap = nodes.reduce(function (map, node) {\n        switch (node.kind) {\n            case 'Field': {\n                if (node.alias) {\n                    if (map.hasOwnProperty(node.alias.value)) {\n                        return map;\n                    }\n                    else {\n                        return __assign({}, map, (_a = {}, _a[node.alias.value] = node, _a));\n                    }\n                }\n                else {\n                    if (map.hasOwnProperty(node.name.value)) {\n                        return map;\n                    }\n                    else {\n                        return __assign({}, map, (_b = {}, _b[node.name.value] = node, _b));\n                    }\n                }\n            }\n            case 'FragmentSpread': {\n                if (map.hasOwnProperty(node.name.value)) {\n                    return map;\n                }\n                else {\n                    return __assign({}, map, (_c = {}, _c[node.name.value] = node, _c));\n                }\n            }\n            case 'InlineFragment': {\n                if (map.__fragment) {\n                    var fragment = map.__fragment;\n                    return __assign({}, map, { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });\n                }\n                else {\n                    return __assign({}, map, { __fragment: node });\n                }\n            }\n            default: {\n                return map;\n            }\n        }\n        var _a, _b, _c;\n    }, {});\n    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);\n    return selection;\n}\n//# sourceMappingURL=ReplaceFieldWithFragment.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/ReplaceFieldWithFragment.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/TransformRootFields.js":
/*!***************************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/TransformRootFields.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar isEmptyObject_1 = __webpack_require__(/*! ../isEmptyObject */ \"./node_modules/graphql-tools/dist/isEmptyObject.js\");\nvar visitSchema_1 = __webpack_require__(/*! ./visitSchema */ \"./node_modules/graphql-tools/dist/transforms/visitSchema.js\");\nvar schemaRecreation_1 = __webpack_require__(/*! ../stitching/schemaRecreation */ \"./node_modules/graphql-tools/dist/stitching/schemaRecreation.js\");\nvar TransformRootFields = /** @class */ (function () {\n    function TransformRootFields(transform) {\n        this.transform = transform;\n    }\n    TransformRootFields.prototype.transformSchema = function (originalSchema) {\n        var _this = this;\n        return visitSchema_1.visitSchema(originalSchema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.QUERY] = function (type) {\n                return transformFields(type, function (fieldName, field) {\n                    return _this.transform('Query', fieldName, field);\n                });\n            },\n            _a[visitSchema_1.VisitSchemaKind.MUTATION] = function (type) {\n                return transformFields(type, function (fieldName, field) {\n                    return _this.transform('Mutation', fieldName, field);\n                });\n            },\n            _a[visitSchema_1.VisitSchemaKind.SUBSCRIPTION] = function (type) {\n                return transformFields(type, function (fieldName, field) {\n                    return _this.transform('Subscription', fieldName, field);\n                });\n            },\n            _a));\n        var _a;\n    };\n    return TransformRootFields;\n}());\nexports.default = TransformRootFields;\nfunction transformFields(type, transformer) {\n    var resolveType = schemaRecreation_1.createResolveType(function (name, originalType) {\n        return originalType;\n    });\n    var fields = type.getFields();\n    var newFields = {};\n    Object.keys(fields).forEach(function (fieldName) {\n        var field = fields[fieldName];\n        var newField = transformer(fieldName, field);\n        if (typeof newField === 'undefined') {\n            newFields[fieldName] = schemaRecreation_1.fieldToFieldConfig(field, resolveType, true);\n        }\n        else if (newField !== null) {\n            if (newField.name) {\n                newFields[newField.name] = newField.field;\n            }\n            else {\n                newFields[fieldName] = newField;\n            }\n        }\n    });\n    if (isEmptyObject_1.default(newFields)) {\n        return null;\n    }\n    else {\n        return new graphql_1.GraphQLObjectType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            fields: newFields,\n        });\n    }\n}\n//# sourceMappingURL=TransformRootFields.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/TransformRootFields.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/WrapQuery.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/WrapQuery.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar WrapQuery = /** @class */ (function () {\n    function WrapQuery(path, wrapper, extractor) {\n        this.path = path;\n        this.wrapper = wrapper;\n        this.extractor = extractor;\n    }\n    WrapQuery.prototype.transformRequest = function (originalRequest) {\n        var _this = this;\n        var document = originalRequest.document;\n        var fieldPath = [];\n        var ourPath = JSON.stringify(this.path);\n        var newDocument = graphql_1.visit(document, (_a = {},\n            _a[graphql_1.Kind.FIELD] = {\n                enter: function (node) {\n                    fieldPath.push(node.name.value);\n                    if (ourPath === JSON.stringify(fieldPath)) {\n                        var wrapResult = _this.wrapper(node.selectionSet);\n                        // Selection can be either a single selection or a selection set. If it's just one selection,\n                        // let's wrap it in a selection set. Otherwise, keep it as is.\n                        var selectionSet = wrapResult.kind === graphql_1.Kind.SELECTION_SET\n                            ? wrapResult\n                            : {\n                                kind: graphql_1.Kind.SELECTION_SET,\n                                selections: [wrapResult]\n                            };\n                        return __assign({}, node, { selectionSet: selectionSet });\n                    }\n                },\n                leave: function (node) {\n                    fieldPath.pop();\n                }\n            },\n            _a));\n        return __assign({}, originalRequest, { document: newDocument });\n        var _a;\n    };\n    WrapQuery.prototype.transformResult = function (originalResult) {\n        var data = originalResult.data;\n        if (data) {\n            var path = this.path.slice();\n            while (path.length > 1) {\n                var next = path.unshift();\n                if (data[next]) {\n                    data = data[next];\n                }\n            }\n            data[path[0]] = this.extractor(data[path[0]]);\n        }\n        return {\n            data: data,\n            errors: originalResult.errors\n        };\n    };\n    return WrapQuery;\n}());\nexports.default = WrapQuery;\n//# sourceMappingURL=WrapQuery.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/WrapQuery.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar transformSchema_1 = __webpack_require__(/*! ./transformSchema */ \"./node_modules/graphql-tools/dist/transforms/transformSchema.js\");\nexports.transformSchema = transformSchema_1.default;\nvar AddArgumentsAsVariables_1 = __webpack_require__(/*! ./AddArgumentsAsVariables */ \"./node_modules/graphql-tools/dist/transforms/AddArgumentsAsVariables.js\");\nexports.AddArgumentsAsVariables = AddArgumentsAsVariables_1.default;\nvar CheckResultAndHandleErrors_1 = __webpack_require__(/*! ./CheckResultAndHandleErrors */ \"./node_modules/graphql-tools/dist/transforms/CheckResultAndHandleErrors.js\");\nexports.CheckResultAndHandleErrors = CheckResultAndHandleErrors_1.default;\nvar ReplaceFieldWithFragment_1 = __webpack_require__(/*! ./ReplaceFieldWithFragment */ \"./node_modules/graphql-tools/dist/transforms/ReplaceFieldWithFragment.js\");\nexports.ReplaceFieldWithFragment = ReplaceFieldWithFragment_1.default;\nvar AddTypenameToAbstract_1 = __webpack_require__(/*! ./AddTypenameToAbstract */ \"./node_modules/graphql-tools/dist/transforms/AddTypenameToAbstract.js\");\nexports.AddTypenameToAbstract = AddTypenameToAbstract_1.default;\nvar FilterToSchema_1 = __webpack_require__(/*! ./FilterToSchema */ \"./node_modules/graphql-tools/dist/transforms/FilterToSchema.js\");\nexports.FilterToSchema = FilterToSchema_1.default;\nvar RenameTypes_1 = __webpack_require__(/*! ./RenameTypes */ \"./node_modules/graphql-tools/dist/transforms/RenameTypes.js\");\nexports.RenameTypes = RenameTypes_1.default;\nvar FilterTypes_1 = __webpack_require__(/*! ./FilterTypes */ \"./node_modules/graphql-tools/dist/transforms/FilterTypes.js\");\nexports.FilterTypes = FilterTypes_1.default;\nvar TransformRootFields_1 = __webpack_require__(/*! ./TransformRootFields */ \"./node_modules/graphql-tools/dist/transforms/TransformRootFields.js\");\nexports.TransformRootFields = TransformRootFields_1.default;\nvar RenameRootFields_1 = __webpack_require__(/*! ./RenameRootFields */ \"./node_modules/graphql-tools/dist/transforms/RenameRootFields.js\");\nexports.RenameRootFields = RenameRootFields_1.default;\nvar FilterRootFields_1 = __webpack_require__(/*! ./FilterRootFields */ \"./node_modules/graphql-tools/dist/transforms/FilterRootFields.js\");\nexports.FilterRootFields = FilterRootFields_1.default;\nvar ExpandAbstractTypes_1 = __webpack_require__(/*! ./ExpandAbstractTypes */ \"./node_modules/graphql-tools/dist/transforms/ExpandAbstractTypes.js\");\nexports.ExpandAbstractTypes = ExpandAbstractTypes_1.default;\nvar ExtractField_1 = __webpack_require__(/*! ./ExtractField */ \"./node_modules/graphql-tools/dist/transforms/ExtractField.js\");\nexports.ExtractField = ExtractField_1.default;\nvar WrapQuery_1 = __webpack_require__(/*! ./WrapQuery */ \"./node_modules/graphql-tools/dist/transforms/WrapQuery.js\");\nexports.WrapQuery = WrapQuery_1.default;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/index.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/transformSchema.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/transformSchema.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar makeExecutableSchema_1 = __webpack_require__(/*! ../makeExecutableSchema */ \"./node_modules/graphql-tools/dist/makeExecutableSchema.js\");\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./node_modules/graphql-tools/dist/transforms/visitSchema.js\");\nvar transforms_1 = __webpack_require__(/*! ../transforms/transforms */ \"./node_modules/graphql-tools/dist/transforms/transforms.js\");\nvar resolvers_1 = __webpack_require__(/*! ../stitching/resolvers */ \"./node_modules/graphql-tools/dist/stitching/resolvers.js\");\nfunction transformSchema(targetSchema, transforms) {\n    var schema = visitSchema_1.visitSchema(targetSchema, {}, true);\n    var mapping = resolvers_1.generateSimpleMapping(targetSchema);\n    var resolvers = resolvers_1.generateProxyingResolvers(targetSchema, transforms, mapping);\n    makeExecutableSchema_1.addResolveFunctionsToSchema({\n        schema: schema,\n        resolvers: resolvers,\n        resolverValidationOptions: {\n            allowResolversNotInSchema: true,\n        },\n    });\n    schema = transforms_1.applySchemaTransforms(schema, transforms);\n    schema.transforms = transforms;\n    return schema;\n}\nexports.default = transformSchema;\n//# sourceMappingURL=transformSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/transformSchema.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/transforms.js":
/*!******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/transforms.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction applySchemaTransforms(originalSchema, transforms) {\n    return transforms.reduce(function (schema, transform) {\n        return transform.transformSchema ? transform.transformSchema(schema) : schema;\n    }, originalSchema);\n}\nexports.applySchemaTransforms = applySchemaTransforms;\nfunction applyRequestTransforms(originalRequest, transforms) {\n    return transforms.reduce(function (request, transform) {\n        return transform.transformRequest\n            ? transform.transformRequest(request)\n            : request;\n    }, originalRequest);\n}\nexports.applyRequestTransforms = applyRequestTransforms;\nfunction applyResultTransforms(originalResult, transforms) {\n    return transforms.reduce(function (result, transform) {\n        return transform.transformResult ? transform.transformResult(result) : result;\n    }, originalResult);\n}\nexports.applyResultTransforms = applyResultTransforms;\nfunction composeTransforms() {\n    var transforms = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        transforms[_i] = arguments[_i];\n    }\n    var reverseTransforms = transforms.slice().reverse();\n    return {\n        transformSchema: function (originalSchema) {\n            return applySchemaTransforms(originalSchema, transforms);\n        },\n        transformRequest: function (originalRequest) {\n            return applyRequestTransforms(originalRequest, reverseTransforms);\n        },\n        transformResult: function (result) {\n            return applyResultTransforms(result, reverseTransforms);\n        },\n    };\n}\nexports.composeTransforms = composeTransforms;\n//# sourceMappingURL=transforms.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/transforms.js?");

/***/ }),

/***/ "./node_modules/graphql-tools/dist/transforms/visitSchema.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql-tools/dist/transforms/visitSchema.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar schemaRecreation_1 = __webpack_require__(/*! ../stitching/schemaRecreation */ \"./node_modules/graphql-tools/dist/stitching/schemaRecreation.js\");\nvar VisitSchemaKind;\n(function (VisitSchemaKind) {\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind = exports.VisitSchemaKind || (exports.VisitSchemaKind = {}));\nfunction visitSchema(schema, visitor, stripResolvers) {\n    var types = {};\n    var resolveType = schemaRecreation_1.createResolveType(function (name) {\n        if (typeof types[name] === 'undefined') {\n            throw new Error(\"Can't find type \" + name + \".\");\n        }\n        return types[name];\n    });\n    var queryType = schema.getQueryType();\n    var mutationType = schema.getMutationType();\n    var subscriptionType = schema.getSubscriptionType();\n    var typeMap = schema.getTypeMap();\n    Object.keys(typeMap).map(function (typeName) {\n        var type = typeMap[typeName];\n        if (graphql_1.isNamedType(type) && graphql_1.getNamedType(type).name.slice(0, 2) !== '__') {\n            var specifiers = getTypeSpecifiers(type, schema);\n            var typeVisitor = getVisitor(visitor, specifiers);\n            if (typeVisitor) {\n                var result = typeVisitor(type, schema);\n                if (typeof result === 'undefined') {\n                    types[typeName] = schemaRecreation_1.recreateType(type, resolveType, !stripResolvers);\n                }\n                else if (result === null) {\n                    types[typeName] = null;\n                }\n                else {\n                    types[typeName] = schemaRecreation_1.recreateType(result, resolveType, !stripResolvers);\n                }\n            }\n            else {\n                types[typeName] = schemaRecreation_1.recreateType(type, resolveType, !stripResolvers);\n            }\n        }\n    });\n    return new graphql_1.GraphQLSchema({\n        query: queryType ? types[queryType.name] : null,\n        mutation: mutationType\n            ? types[mutationType.name]\n            : null,\n        subscription: subscriptionType\n            ? types[subscriptionType.name]\n            : null,\n        types: Object.keys(types).map(function (name) { return types[name]; }),\n    });\n}\nexports.visitSchema = visitSchema;\nfunction getTypeSpecifiers(type, schema) {\n    var specifiers = [VisitSchemaKind.TYPE];\n    if (type instanceof graphql_1.GraphQLObjectType) {\n        specifiers.unshift(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\n        var query = schema.getQueryType();\n        var mutation = schema.getMutationType();\n        var subscription = schema.getSubscriptionType();\n        if (type === query) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n        }\n        else if (type === mutation) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n        }\n        else if (type === subscription) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\n        }\n    }\n    else if (type instanceof graphql_1.GraphQLInputObjectType) {\n        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLInterfaceType) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLUnionType) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLEnumType) {\n        specifiers.push(VisitSchemaKind.ENUM_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLScalarType) {\n        specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getVisitor(visitor, specifiers) {\n    var typeVisitor = null;\n    var stack = specifiers.slice();\n    while (!typeVisitor && stack.length > 0) {\n        var next = stack.pop();\n        typeVisitor = visitor[next];\n    }\n    return typeVisitor;\n}\n//# sourceMappingURL=visitSchema.js.map\n\n//# sourceURL=webpack:///./node_modules/graphql-tools/dist/transforms/visitSchema.js?");

/***/ }),

/***/ "./node_modules/graphql/error/GraphQLError.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/error/GraphQLError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GraphQLError = GraphQLError;\n\nvar _printError = __webpack_require__(/*! ./printError */ \"./node_modules/graphql/error/printError.js\");\n\nvar _location = __webpack_require__(/*! ../language/location */ \"./node_modules/graphql/language/location.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return (0, _location.getLocation)(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push((0, _location.getLocation)(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions || originalError && originalError.extensions;\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return (0, _printError.printError)(this);\n    }\n  }\n});\n\n//# sourceURL=webpack:///./node_modules/graphql/error/GraphQLError.js?");

/***/ }),

/***/ "./node_modules/graphql/error/formatError.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/error/formatError.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatError = formatError;\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n */\nfunction formatError(error) {\n  !error ? (0, _invariant.default)(0, 'Received null or undefined error.') : void 0;\n  var message = error.message || 'An unknown error occurred.';\n  var locations = error.locations;\n  var path = error.path;\n  var extensions = error.extensions;\n  return extensions ? {\n    message: message,\n    locations: locations,\n    path: path,\n    extensions: extensions\n  } : {\n    message: message,\n    locations: locations,\n    path: path\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/error/formatError.js?");

/***/ }),

/***/ "./node_modules/graphql/error/index.js":
/*!*********************************************!*\
  !*** ./node_modules/graphql/error/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"GraphQLError\", {\n  enumerable: true,\n  get: function get() {\n    return _GraphQLError.GraphQLError;\n  }\n});\nObject.defineProperty(exports, \"syntaxError\", {\n  enumerable: true,\n  get: function get() {\n    return _syntaxError.syntaxError;\n  }\n});\nObject.defineProperty(exports, \"locatedError\", {\n  enumerable: true,\n  get: function get() {\n    return _locatedError.locatedError;\n  }\n});\nObject.defineProperty(exports, \"printError\", {\n  enumerable: true,\n  get: function get() {\n    return _printError.printError;\n  }\n});\nObject.defineProperty(exports, \"formatError\", {\n  enumerable: true,\n  get: function get() {\n    return _formatError.formatError;\n  }\n});\n\nvar _GraphQLError = __webpack_require__(/*! ./GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _syntaxError = __webpack_require__(/*! ./syntaxError */ \"./node_modules/graphql/error/syntaxError.js\");\n\nvar _locatedError = __webpack_require__(/*! ./locatedError */ \"./node_modules/graphql/error/locatedError.js\");\n\nvar _printError = __webpack_require__(/*! ./printError */ \"./node_modules/graphql/error/printError.js\");\n\nvar _formatError = __webpack_require__(/*! ./formatError */ \"./node_modules/graphql/error/formatError.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/error/index.js?");

/***/ }),

/***/ "./node_modules/graphql/error/locatedError.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/error/locatedError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.locatedError = locatedError;\n\nvar _GraphQLError = __webpack_require__(/*! ./GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Given an arbitrary Error, presumably thrown while attempting to execute a\n * GraphQL operation, produce a new GraphQLError aware of the location in the\n * document responsible for the original Error.\n */\nfunction locatedError(originalError, nodes, path) {\n  // Note: this uses a brand-check to support GraphQL errors originating from\n  // other contexts.\n  if (originalError && Array.isArray(originalError.path)) {\n    return originalError;\n  }\n\n  return new _GraphQLError.GraphQLError(originalError && originalError.message, originalError && originalError.nodes || nodes, originalError && originalError.source, originalError && originalError.positions, path, originalError);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/error/locatedError.js?");

/***/ }),

/***/ "./node_modules/graphql/error/printError.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/error/printError.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printError = printError;\n\nvar _location = __webpack_require__(/*! ../language/location */ \"./node_modules/graphql/language/location.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\nfunction printError(error) {\n  var printedLocations = [];\n\n  if (error.nodes) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = error.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var node = _step.value;\n\n        if (node.loc) {\n          printedLocations.push(highlightSourceAtLocation(node.loc.source, (0, _location.getLocation)(node.loc.source, node.loc.start)));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else if (error.source && error.locations) {\n    var source = error.source;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = error.locations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var location = _step2.value;\n        printedLocations.push(highlightSourceAtLocation(source, location));\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return printedLocations.length === 0 ? error.message : [error.message].concat(printedLocations).join('\\n\\n') + '\\n';\n}\n/**\n * Render a helpful description of the location of the error in the GraphQL\n * Source document.\n */\n\n\nfunction highlightSourceAtLocation(source, location) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = location.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = location.line + lineOffset;\n  var columnOffset = location.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = location.column + columnOffset;\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  return \"\".concat(source.name, \" (\").concat(lineNum, \":\").concat(columnNum, \")\\n\") + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1, \": \"), lines[lineIndex - 1]], [\"\".concat(lineNum, \": \"), lines[lineIndex]], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1, \": \"), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = 0;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = existingLines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _ref4 = _step3.value;\n      var prefix = _ref4[0];\n      padLen = Math.max(padLen, prefix.length);\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + line;\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/error/printError.js?");

/***/ }),

/***/ "./node_modules/graphql/error/syntaxError.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/error/syntaxError.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.syntaxError = syntaxError;\n\nvar _GraphQLError = __webpack_require__(/*! ./GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\nfunction syntaxError(source, position, description) {\n  return new _GraphQLError.GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/error/syntaxError.js?");

/***/ }),

/***/ "./node_modules/graphql/execution/execute.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/execution/execute.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.execute = execute;\nexports.responsePathAsArray = responsePathAsArray;\nexports.addPath = addPath;\nexports.assertValidExecutionArguments = assertValidExecutionArguments;\nexports.buildExecutionContext = buildExecutionContext;\nexports.collectFields = collectFields;\nexports.buildResolveInfo = buildResolveInfo;\nexports.resolveFieldValueOrError = resolveFieldValueOrError;\nexports.getFieldDef = getFieldDef;\nexports.defaultFieldResolver = void 0;\n\nvar _iterall = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _locatedError = __webpack_require__(/*! ../error/locatedError */ \"./node_modules/graphql/error/locatedError.js\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _isNullish = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isNullish */ \"./node_modules/graphql/jsutils/isNullish.js\"));\n\nvar _isPromise = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isPromise */ \"./node_modules/graphql/jsutils/isPromise.js\"));\n\nvar _memoize = _interopRequireDefault(__webpack_require__(/*! ../jsutils/memoize3 */ \"./node_modules/graphql/jsutils/memoize3.js\"));\n\nvar _promiseForObject = _interopRequireDefault(__webpack_require__(/*! ../jsutils/promiseForObject */ \"./node_modules/graphql/jsutils/promiseForObject.js\"));\n\nvar _promiseReduce = _interopRequireDefault(__webpack_require__(/*! ../jsutils/promiseReduce */ \"./node_modules/graphql/jsutils/promiseReduce.js\"));\n\nvar _getOperationRootType = __webpack_require__(/*! ../utilities/getOperationRootType */ \"./node_modules/graphql/utilities/getOperationRootType.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _values = __webpack_require__(/*! ./values */ \"./node_modules/graphql/execution/values.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _directives = __webpack_require__(/*! ../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _validate = __webpack_require__(/*! ../type/validate */ \"./node_modules/graphql/type/validate.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? executeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : executeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n}\n\nfunction executeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrect, throw an error.\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n  if (Array.isArray(exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n\n\n  var data = executeOperation(exeContext, exeContext.operation, rootValue);\n  return buildResponse(exeContext, data);\n}\n/**\n * Given a completed execution context and data, build the { errors, data }\n * response defined by the \"Response\" section of the GraphQL specification.\n */\n\n\nfunction buildResponse(exeContext, data) {\n  if ((0, _isPromise.default)(data)) {\n    return data.then(function (resolved) {\n      return buildResponse(exeContext, resolved);\n    });\n  }\n\n  return exeContext.errors.length === 0 ? {\n    data: data\n  } : {\n    errors: exeContext.errors,\n    data: data\n  };\n}\n/**\n * Given a ResponsePath (found in the `path` entry in the information provided\n * as the last argument to a field resolver), return an Array of the path keys.\n */\n\n\nfunction responsePathAsArray(path) {\n  var flattened = [];\n  var curr = path;\n\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n\n  return flattened.reverse();\n}\n/**\n * Given a ResponsePath and a key, return a new ResponsePath containing the\n * new key.\n */\n\n\nfunction addPath(prev, key) {\n  return {\n    prev: prev,\n    key: key\n  };\n}\n/**\n * Essential assertions before executing to provide developer feedback for\n * improper use of the GraphQL library.\n */\n\n\nfunction assertValidExecutionArguments(schema, document, rawVariableValues) {\n  !document ? (0, _invariant.default)(0, 'Must provide document') : void 0; // If the schema used for execution is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema); // Variables, if provided, must be an object.\n\n  !(!rawVariableValues || _typeof(rawVariableValues) === 'object') ? (0, _invariant.default)(0, 'Variables must be provided as an Object where each property is a ' + 'variable value. Perhaps look to see if an unparsed JSON string ' + 'was provided.') : void 0;\n}\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n */\n\n\nfunction buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver) {\n  var errors = [];\n  var operation;\n  var hasMultipleAssumedOperations = false;\n  var fragments = Object.create(null);\n\n  for (var i = 0; i < document.definitions.length; i++) {\n    var definition = document.definitions[i];\n\n    switch (definition.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        if (!operationName && operation) {\n          hasMultipleAssumedOperations = true;\n        } else if (!operationName || definition.name && definition.name.value === operationName) {\n          operation = definition;\n        }\n\n        break;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n    }\n  }\n\n  if (!operation) {\n    if (operationName) {\n      errors.push(new _GraphQLError.GraphQLError(\"Unknown operation named \\\"\".concat(operationName, \"\\\".\")));\n    } else {\n      errors.push(new _GraphQLError.GraphQLError('Must provide an operation.'));\n    }\n  } else if (hasMultipleAssumedOperations) {\n    errors.push(new _GraphQLError.GraphQLError('Must provide operation name if query contains multiple operations.'));\n  }\n\n  var variableValues;\n\n  if (operation) {\n    var coercedVariableValues = (0, _values.getVariableValues)(schema, operation.variableDefinitions || [], rawVariableValues || {});\n\n    if (coercedVariableValues.errors) {\n      errors.push.apply(errors, coercedVariableValues.errors);\n    } else {\n      variableValues = coercedVariableValues.coerced;\n    }\n  }\n\n  if (errors.length !== 0) {\n    return errors;\n  }\n\n  !operation ? (0, _invariant.default)(0, 'Has operation if no errors.') : void 0;\n  !variableValues ? (0, _invariant.default)(0, 'Has variables if no errors.') : void 0;\n  return {\n    schema: schema,\n    fragments: fragments,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    operation: operation,\n    variableValues: variableValues,\n    fieldResolver: fieldResolver || defaultFieldResolver,\n    errors: errors\n  };\n}\n/**\n * Implements the \"Evaluating operations\" section of the spec.\n */\n\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  var type = (0, _getOperationRootType.getOperationRootType)(exeContext.schema, operation);\n  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n  var path = undefined; // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n  //\n  // Similar to completeValueCatchingError.\n\n  try {\n    var result = operation.operation === 'mutation' ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);\n\n    if ((0, _isPromise.default)(result)) {\n      return result.then(undefined, function (error) {\n        exeContext.errors.push(error);\n        return Promise.resolve(null);\n      });\n    }\n\n    return result;\n  } catch (error) {\n    exeContext.errors.push(error);\n    return null;\n  }\n}\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"write\" mode.\n */\n\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return (0, _promiseReduce.default)(Object.keys(fields), function (results, responseName) {\n    var fieldNodes = fields[responseName];\n    var fieldPath = addPath(path, responseName);\n    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result === undefined) {\n      return results;\n    }\n\n    if ((0, _isPromise.default)(result)) {\n      return result.then(function (resolvedResult) {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"read\" mode.\n */\n\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  var results = Object.create(null);\n  var containsPromise = false;\n\n  for (var i = 0, keys = Object.keys(fields); i < keys.length; ++i) {\n    var responseName = keys[i];\n    var fieldNodes = fields[responseName];\n    var fieldPath = addPath(path, responseName);\n    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (!containsPromise && (0, _isPromise.default)(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n\n  return (0, _promiseForObject.default)(results);\n}\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n */\n\n\nfunction collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        if (!shouldIncludeNode(exeContext, selection)) {\n          continue;\n        }\n\n        var name = getFieldEntryKey(selection);\n\n        if (!fields[name]) {\n          fields[name] = [];\n        }\n\n        fields[name].push(selection);\n        break;\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n        if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n          continue;\n        }\n\n        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n        break;\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        var fragName = selection.name.value;\n\n        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n          continue;\n        }\n\n        visitedFragmentNames[fragName] = true;\n        var fragment = exeContext.fragments[fragName];\n\n        if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n          continue;\n        }\n\n        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n        break;\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\n\n\nfunction shouldIncludeNode(exeContext, node) {\n  var skip = (0, _values.getDirectiveValues)(_directives.GraphQLSkipDirective, node, exeContext.variableValues);\n\n  if (skip && skip.if === true) {\n    return false;\n  }\n\n  var include = (0, _values.getDirectiveValues)(_directives.GraphQLIncludeDirective, node, exeContext.variableValues);\n\n  if (include && include.if === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = (0, _typeFromAST.typeFromAST)(exeContext.schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(conditionalType)) {\n    return exeContext.schema.isPossibleType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n/**\n * Resolves the field on the given source object. In particular, this\n * figures out the value that the field returns by calling its resolve function,\n * then calls completeValue to complete promises, serialize scalars, or execute\n * the sub-selection-set for objects.\n */\n\n\nfunction resolveField(exeContext, parentType, source, fieldNodes, path) {\n  var fieldNode = fieldNodes[0];\n  var fieldName = fieldNode.name.value;\n  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  var resolveFn = fieldDef.resolve || exeContext.fieldResolver;\n  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal\n  // or abrupt (error).\n\n  var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info);\n  return completeValueCatchingError(exeContext, fieldDef.type, fieldNodes, info, path, result);\n}\n\nfunction buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes: fieldNodes,\n    returnType: fieldDef.type,\n    parentType: parentType,\n    path: path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n} // Isolates the \"ReturnOrAbrupt\" behavior to not de-opt the `resolveField`\n// function. Returns the result of resolveFn or the abrupt-return Error object.\n\n\nfunction resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info) {\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    var args = (0, _values.getArgumentValues)(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    var _contextValue = exeContext.contextValue;\n    var result = resolveFn(source, args, _contextValue, info);\n    return (0, _isPromise.default)(result) ? result.then(undefined, asErrorInstance) : result;\n  } catch (error) {\n    return asErrorInstance(error);\n  }\n} // Sometimes a non-error is thrown, wrap it as an Error instance to ensure a\n// consistent Error interface.\n\n\nfunction asErrorInstance(error) {\n  return error instanceof Error ? error : new Error(error || undefined);\n} // This is a small wrapper around completeValue which detects and logs errors\n// in the execution context.\n\n\nfunction completeValueCatchingError(exeContext, returnType, fieldNodes, info, path, result) {\n  try {\n    var completed;\n\n    if ((0, _isPromise.default)(result)) {\n      completed = result.then(function (resolved) {\n        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);\n      });\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n\n    if ((0, _isPromise.default)(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, function (error) {\n        return handleFieldError(error, fieldNodes, path, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (error) {\n    return handleFieldError(error, fieldNodes, path, returnType, exeContext);\n  }\n}\n\nfunction handleFieldError(rawError, fieldNodes, path, returnType, exeContext) {\n  var error = (0, _locatedError.locatedError)(asErrorInstance(rawError), fieldNodes, responsePathAsArray(path)); // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n\n  if ((0, _definition.isNonNullType)(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Field entries\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by evaluating all sub-selections.\n */\n\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n\n  if ((0, _definition.isNonNullType)(returnType)) {\n    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n\n    if (completed === null) {\n      throw new Error(\"Cannot return null for non-nullable field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\"));\n    }\n\n    return completed;\n  } // If result value is null-ish (null, undefined, or NaN) then return null.\n\n\n  if ((0, _isNullish.default)(result)) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n\n  if ((0, _definition.isListType)(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n\n  if ((0, _definition.isLeafType)(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n\n  if ((0, _definition.isAbstractType)(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n\n\n  if ((0, _definition.isObjectType)(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // Not reachable. All possible output types have been considered.\n\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Cannot complete value of unexpected type \\\"\".concat((0, _inspect.default)(returnType), \"\\\".\"));\n}\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\n\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  !(0, _iterall.isCollection)(result) ? (0, _invariant.default)(0, \"Expected Iterable, but did not find one for field \".concat(info.parentType.name, \".\").concat(info.fieldName, \".\")) : void 0; // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n  var itemType = returnType.ofType;\n  var containsPromise = false;\n  var completedResults = [];\n  (0, _iterall.forEach)(result, function (item, index) {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    var fieldPath = addPath(path, index);\n    var completedItem = completeValueCatchingError(exeContext, itemType, fieldNodes, info, fieldPath, item);\n\n    if (!containsPromise && (0, _isPromise.default)(completedItem)) {\n      containsPromise = true;\n    }\n\n    completedResults.push(completedItem);\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\n\n\nfunction completeLeafValue(returnType, result) {\n  !returnType.serialize ? (0, _invariant.default)(0, 'Missing serialize method on type') : void 0;\n  var serializedResult = returnType.serialize(result);\n\n  if ((0, _isInvalid.default)(serializedResult)) {\n    throw new Error(\"Expected a value of type \\\"\".concat((0, _inspect.default)(returnType), \"\\\" but \") + \"received: \".concat((0, _inspect.default)(result)));\n  }\n\n  return serializedResult;\n}\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\n\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var runtimeType = returnType.resolveType ? returnType.resolveType(result, exeContext.contextValue, info) : defaultResolveTypeFn(result, exeContext.contextValue, info, returnType);\n\n  if ((0, _isPromise.default)(runtimeType)) {\n    return runtimeType.then(function (resolvedRuntimeType) {\n      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n    });\n  }\n\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\n\nfunction ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {\n  var runtimeType = typeof runtimeTypeOrName === 'string' ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;\n\n  if (!(0, _definition.isObjectType)(runtimeType)) {\n    throw new _GraphQLError.GraphQLError(\"Abstract type \".concat(returnType.name, \" must resolve to an Object type at \") + \"runtime for field \".concat(info.parentType.name, \".\").concat(info.fieldName, \" with \") + \"value \".concat((0, _inspect.default)(result), \", received \\\"\").concat((0, _inspect.default)(runtimeType), \"\\\". \") + \"Either the \".concat(returnType.name, \" type should provide a \\\"resolveType\\\" \") + 'function or each possible type should provide an \"isTypeOf\" function.', fieldNodes);\n  }\n\n  if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {\n    throw new _GraphQLError.GraphQLError(\"Runtime Object type \\\"\".concat(runtimeType.name, \"\\\" is not a possible type \") + \"for \\\"\".concat(returnType.name, \"\\\".\"), fieldNodes);\n  }\n\n  return runtimeType;\n}\n/**\n * Complete an Object value by executing all sub-selections.\n */\n\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n  if (returnType.isTypeOf) {\n    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if ((0, _isPromise.default)(isTypeOf)) {\n      return isTypeOf.then(function (resolvedIsTypeOf) {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new _GraphQLError.GraphQLError(\"Expected value of type \\\"\".concat(returnType.name, \"\\\" but got: \").concat((0, _inspect.default)(result), \".\"), fieldNodes);\n}\n\nfunction collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\n\n\nvar collectSubfields = (0, _memoize.default)(_collectSubfields);\n\nfunction _collectSubfields(exeContext, returnType, fieldNodes) {\n  var subFieldNodes = Object.create(null);\n  var visitedFragmentNames = Object.create(null);\n\n  for (var i = 0; i < fieldNodes.length; i++) {\n    var selectionSet = fieldNodes[i].selectionSet;\n\n    if (selectionSet) {\n      subFieldNodes = collectFields(exeContext, returnType, selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n\n  return subFieldNodes;\n}\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\n\n\nfunction defaultResolveTypeFn(value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (value !== null && _typeof(value) === 'object' && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n\n  var possibleTypes = info.schema.getPossibleTypes(abstractType);\n  var promisedIsTypeOfResults = [];\n\n  for (var i = 0; i < possibleTypes.length; i++) {\n    var type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      var isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if ((0, _isPromise.default)(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(function (isTypeOfResults) {\n      for (var _i = 0; _i < isTypeOfResults.length; _i++) {\n        if (isTypeOfResults[_i]) {\n          return possibleTypes[_i];\n        }\n      }\n    });\n  }\n}\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\n\n\nvar defaultFieldResolver = function defaultFieldResolver(source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if (_typeof(source) === 'object' || typeof source === 'function') {\n    var property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\n * This method looks up the field on the given type definition.\n * It has special casing for the two introspection fields, __schema\n * and __typename. __typename is special because it can always be\n * queried as a field, even in situations where no other fields\n * are allowed, like on a Union. __schema could get automatically\n * added to the query type, but that would require mutating type\n * definitions, which would cause issues.\n */\n\n\nexports.defaultFieldResolver = defaultFieldResolver;\n\nfunction getFieldDef(schema, parentType, fieldName) {\n  if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/execution/execute.js?");

/***/ }),

/***/ "./node_modules/graphql/execution/index.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/execution/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"execute\", {\n  enumerable: true,\n  get: function get() {\n    return _execute.execute;\n  }\n});\nObject.defineProperty(exports, \"defaultFieldResolver\", {\n  enumerable: true,\n  get: function get() {\n    return _execute.defaultFieldResolver;\n  }\n});\nObject.defineProperty(exports, \"responsePathAsArray\", {\n  enumerable: true,\n  get: function get() {\n    return _execute.responsePathAsArray;\n  }\n});\nObject.defineProperty(exports, \"getDirectiveValues\", {\n  enumerable: true,\n  get: function get() {\n    return _values.getDirectiveValues;\n  }\n});\n\nvar _execute = __webpack_require__(/*! ./execute */ \"./node_modules/graphql/execution/execute.js\");\n\nvar _values = __webpack_require__(/*! ./values */ \"./node_modules/graphql/execution/values.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/execution/index.js?");

/***/ }),

/***/ "./node_modules/graphql/execution/values.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/execution/values.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getVariableValues = getVariableValues;\nexports.getArgumentValues = getArgumentValues;\nexports.getDirectiveValues = getDirectiveValues;\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _find = _interopRequireDefault(__webpack_require__(/*! ../jsutils/find */ \"./node_modules/graphql/jsutils/find.js\"));\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _coerceValue = __webpack_require__(/*! ../utilities/coerceValue */ \"./node_modules/graphql/utilities/coerceValue.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nvar _valueFromAST = __webpack_require__(/*! ../utilities/valueFromAST */ \"./node_modules/graphql/utilities/valueFromAST.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _printer = __webpack_require__(/*! ../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nfunction getVariableValues(schema, varDefNodes, inputs) {\n  var errors = [];\n  var coercedValues = {};\n\n  for (var i = 0; i < varDefNodes.length; i++) {\n    var varDefNode = varDefNodes[i];\n    var varName = varDefNode.variable.name.value;\n    var varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);\n\n    if (!(0, _definition.isInputType)(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      errors.push(new _GraphQLError.GraphQLError(\"Variable \\\"$\".concat(varName, \"\\\" expected value of type \") + \"\\\"\".concat((0, _printer.print)(varDefNode.type), \"\\\" which cannot be used as an input type.\"), [varDefNode.type]));\n    } else {\n      var hasValue = hasOwnProperty(inputs, varName);\n      var value = hasValue ? inputs[varName] : undefined;\n\n      if (!hasValue && varDefNode.defaultValue) {\n        // If no value was provided to a variable with a default value,\n        // use the default value.\n        coercedValues[varName] = (0, _valueFromAST.valueFromAST)(varDefNode.defaultValue, varType);\n      } else if ((!hasValue || value === null) && (0, _definition.isNonNullType)(varType)) {\n        // If no value or a nullish value was provided to a variable with a\n        // non-null type (required), produce an error.\n        errors.push(new _GraphQLError.GraphQLError(hasValue ? \"Variable \\\"$\".concat(varName, \"\\\" of non-null type \") + \"\\\"\".concat((0, _inspect.default)(varType), \"\\\" must not be null.\") : \"Variable \\\"$\".concat(varName, \"\\\" of required type \") + \"\\\"\".concat((0, _inspect.default)(varType), \"\\\" was not provided.\"), [varDefNode]));\n      } else if (hasValue) {\n        if (value === null) {\n          // If the explicit value `null` was provided, an entry in the coerced\n          // values must exist as the value `null`.\n          coercedValues[varName] = null;\n        } else {\n          // Otherwise, a non-null value was provided, coerce it to the expected\n          // type or report an error if coercion fails.\n          var coerced = (0, _coerceValue.coerceValue)(value, varType, varDefNode);\n          var coercionErrors = coerced.errors;\n\n          if (coercionErrors) {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = coercionErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var error = _step.value;\n                error.message = \"Variable \\\"$\".concat(varName, \"\\\" got invalid value \").concat((0, _inspect.default)(value), \"; \") + error.message;\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            errors.push.apply(errors, coercionErrors);\n          } else {\n            coercedValues[varName] = coerced.value;\n          }\n        }\n      }\n    }\n  }\n\n  return errors.length === 0 ? {\n    errors: undefined,\n    coerced: coercedValues\n  } : {\n    errors: errors,\n    coerced: undefined\n  };\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node, variableValues) {\n  var coercedValues = {};\n  var argDefs = def.args;\n  var argNodes = node.arguments;\n\n  if (!argDefs || !argNodes) {\n    return coercedValues;\n  }\n\n  var argNodeMap = (0, _keyMap.default)(argNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var i = 0; i < argDefs.length; i++) {\n    var argDef = argDefs[i];\n    var name = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name];\n    var hasValue = void 0;\n    var isNull = void 0;\n\n    if (argumentNode && argumentNode.value.kind === _kinds.Kind.VARIABLE) {\n      var variableName = argumentNode.value.name.value;\n      hasValue = variableValues && hasOwnProperty(variableValues, variableName);\n      isNull = variableValues && variableValues[variableName] === null;\n    } else {\n      hasValue = argumentNode != null;\n      isNull = argumentNode && argumentNode.value.kind === _kinds.Kind.NULL;\n    }\n\n    if (!hasValue && argDef.defaultValue !== undefined) {\n      // If no argument was provided where the definition has a default value,\n      // use the default value.\n      coercedValues[name] = argDef.defaultValue;\n    } else if ((!hasValue || isNull) && (0, _definition.isNonNullType)(argType)) {\n      // If no argument or a null value was provided to an argument with a\n      // non-null type (required), produce a field error.\n      if (isNull) {\n        throw new _GraphQLError.GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of non-null type \\\"\").concat((0, _inspect.default)(argType), \"\\\" \") + 'must not be null.', [argumentNode.value]);\n      } else if (argumentNode && argumentNode.value.kind === _kinds.Kind.VARIABLE) {\n        var _variableName = argumentNode.value.name.value;\n        throw new _GraphQLError.GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat((0, _inspect.default)(argType), \"\\\" \") + \"was provided the variable \\\"$\".concat(_variableName, \"\\\" \") + 'which was not provided a runtime value.', [argumentNode.value]);\n      } else {\n        throw new _GraphQLError.GraphQLError(\"Argument \\\"\".concat(name, \"\\\" of required type \\\"\").concat((0, _inspect.default)(argType), \"\\\" \") + 'was not provided.', [node]);\n      }\n    } else if (hasValue) {\n      if (argumentNode.value.kind === _kinds.Kind.NULL) {\n        // If the explicit value `null` was provided, an entry in the coerced\n        // values must exist as the value `null`.\n        coercedValues[name] = null;\n      } else if (argumentNode.value.kind === _kinds.Kind.VARIABLE) {\n        var _variableName2 = argumentNode.value.name.value;\n        !variableValues ? (0, _invariant.default)(0, 'Must exist for hasValue to be true.') : void 0; // Note: This does no further checking that this variable is correct.\n        // This assumes that this query has been validated and the variable\n        // usage here is of the correct type.\n\n        coercedValues[name] = variableValues[_variableName2];\n      } else {\n        var valueNode = argumentNode.value;\n        var coercedValue = (0, _valueFromAST.valueFromAST)(valueNode, argType, variableValues);\n\n        if (coercedValue === undefined) {\n          // Note: ValuesOfCorrectType validation should catch this before\n          // execution. This is a runtime check to ensure execution does not\n          // continue with an invalid argument value.\n          throw new _GraphQLError.GraphQLError(\"Argument \\\"\".concat(name, \"\\\" has invalid value \").concat((0, _printer.print)(valueNode), \".\"), [argumentNode.value]);\n        }\n\n        coercedValues[name] = coercedValue;\n      }\n    }\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getDirectiveValues(directiveDef, node, variableValues) {\n  var directiveNode = node.directives && (0, _find.default)(node.directives, function (directive) {\n    return directive.name.value === directiveDef.name;\n  });\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/execution/values.js?");

/***/ }),

/***/ "./node_modules/graphql/graphql.js":
/*!*****************************************!*\
  !*** ./node_modules/graphql/graphql.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.graphql = graphql;\nexports.graphqlSync = graphqlSync;\n\nvar _validate = __webpack_require__(/*! ./type/validate */ \"./node_modules/graphql/type/validate.js\");\n\nvar _parser = __webpack_require__(/*! ./language/parser */ \"./node_modules/graphql/language/parser.js\");\n\nvar _validate2 = __webpack_require__(/*! ./validation/validate */ \"./node_modules/graphql/validation/validate.js\");\n\nvar _execute = __webpack_require__(/*! ./execution/execute */ \"./node_modules/graphql/execution/execute.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  var _arguments = arguments;\n\n  /* eslint-enable no-redeclare */\n  // Always return a Promise for a consistent API.\n  return new Promise(function (resolve) {\n    return resolve( // Extract arguments from object args if provided.\n    _arguments.length === 1 ? graphqlImpl(argsOrSchema.schema, argsOrSchema.source, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : graphqlImpl(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver));\n  });\n}\n/**\n * The graphqlSync function also fulfills GraphQL operations by parsing,\n * validating, and executing a GraphQL document along side a GraphQL schema.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\n\n\nfunction graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  var result = arguments.length === 1 ? graphqlImpl(argsOrSchema.schema, argsOrSchema.source, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver) : graphqlImpl(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver); // Assert that the execution was synchronous.\n\n  if (result.then) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\nfunction graphqlImpl(schema, source, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // Validate Schema\n  var schemaValidationErrors = (0, _validate.validateSchema)(schema);\n\n  if (schemaValidationErrors.length > 0) {\n    return {\n      errors: schemaValidationErrors\n    };\n  } // Parse\n\n\n  var document;\n\n  try {\n    document = (0, _parser.parse)(source);\n  } catch (syntaxError) {\n    return {\n      errors: [syntaxError]\n    };\n  } // Validate\n\n\n  var validationErrors = (0, _validate2.validate)(schema, document);\n\n  if (validationErrors.length > 0) {\n    return {\n      errors: validationErrors\n    };\n  } // Execute\n\n\n  return (0, _execute.execute)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/graphql.js?");

/***/ }),

/***/ "./node_modules/graphql/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/graphql/index.mjs ***!
  \****************************************/
/*! exports provided: graphql, graphqlSync, GraphQLSchema, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, GraphQLDirective, TypeKind, specifiedScalarTypes, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedDirectives, GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, DEFAULT_DEPRECATION_REASON, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes, __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind, isSchema, isDirective, isType, isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isListType, isNonNullType, isInputType, isOutputType, isLeafType, isCompositeType, isAbstractType, isWrappingType, isNullableType, isNamedType, isRequiredArgument, isRequiredInputField, isSpecifiedScalarType, isIntrospectionType, isSpecifiedDirective, assertType, assertScalarType, assertObjectType, assertInterfaceType, assertUnionType, assertEnumType, assertInputObjectType, assertListType, assertNonNullType, assertInputType, assertOutputType, assertLeafType, assertCompositeType, assertAbstractType, assertWrappingType, assertNullableType, assertNamedType, getNullableType, getNamedType, validateSchema, assertValidSchema, Source, getLocation, parse, parseValue, parseType, print, visit, visitInParallel, visitWithTypeInfo, getVisitFn, Kind, TokenKind, DirectiveLocation, BREAK, isDefinitionNode, isExecutableDefinitionNode, isSelectionNode, isValueNode, isTypeNode, isTypeSystemDefinitionNode, isTypeDefinitionNode, isTypeSystemExtensionNode, isTypeExtensionNode, execute, defaultFieldResolver, responsePathAsArray, getDirectiveValues, subscribe, createSourceEventStream, validate, ValidationContext, specifiedRules, FieldsOnCorrectTypeRule, FragmentsOnCompositeTypesRule, KnownArgumentNamesRule, KnownDirectivesRule, KnownFragmentNamesRule, KnownTypeNamesRule, LoneAnonymousOperationRule, NoFragmentCyclesRule, NoUndefinedVariablesRule, NoUnusedFragmentsRule, NoUnusedVariablesRule, OverlappingFieldsCanBeMergedRule, PossibleFragmentSpreadsRule, ProvidedRequiredArgumentsRule, ScalarLeafsRule, SingleFieldSubscriptionsRule, UniqueArgumentNamesRule, UniqueDirectivesPerLocationRule, UniqueFragmentNamesRule, UniqueInputFieldNamesRule, UniqueOperationNamesRule, UniqueVariableNamesRule, ValuesOfCorrectTypeRule, VariablesAreInputTypesRule, VariablesInAllowedPositionRule, GraphQLError, formatError, printError, getIntrospectionQuery, introspectionQuery, getOperationAST, getOperationRootType, introspectionFromSchema, buildClientSchema, buildASTSchema, buildSchema, getDescription, extendSchema, lexicographicSortSchema, printSchema, printIntrospectionSchema, printType, typeFromAST, valueFromAST, valueFromASTUntyped, astFromValue, TypeInfo, coerceValue, isValidJSValue, isValidLiteralValue, concatAST, separateOperations, isEqualType, isTypeSubTypeOf, doTypesOverlap, assertValidName, isValidNameError, findBreakingChanges, findDangerousChanges, BreakingChangeType, DangerousChangeType, findDeprecatedUsages */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _graphql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphql */ \"./node_modules/graphql/graphql.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"graphql\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"graphqlSync\", function() { return undefined; });\n/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./type */ \"./node_modules/graphql/type/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLScalarType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLObjectType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLInterfaceType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLUnionType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLEnumType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLInputObjectType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLList\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLNonNull\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLDirective\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"TypeKind\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"specifiedScalarTypes\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLInt\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLFloat\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLString\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLBoolean\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLID\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"specifiedDirectives\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLIncludeDirective\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLSkipDirective\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLDeprecatedDirective\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_DEPRECATION_REASON\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"SchemaMetaFieldDef\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"TypeMetaFieldDef\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"TypeNameMetaFieldDef\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"introspectionTypes\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__Schema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__Directive\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__DirectiveLocation\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__Type\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__Field\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__InputValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__EnumValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"__TypeKind\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isDirective\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isScalarType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isObjectType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isInterfaceType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isUnionType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isEnumType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isInputObjectType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isListType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isNonNullType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isInputType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isOutputType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isLeafType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isCompositeType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isAbstractType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isWrappingType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isNullableType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isNamedType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isRequiredArgument\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isRequiredInputField\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isSpecifiedScalarType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isIntrospectionType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isSpecifiedDirective\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertScalarType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertObjectType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertInterfaceType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertUnionType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertEnumType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertInputObjectType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertListType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertNonNullType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertInputType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertOutputType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertLeafType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertCompositeType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertAbstractType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertWrappingType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertNullableType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertNamedType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getNullableType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getNamedType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"validateSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertValidSchema\", function() { return undefined; });\n/* harmony import */ var _language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./language */ \"./node_modules/graphql/language/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Source\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getLocation\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"parseValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"parseType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"print\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"visit\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"visitInParallel\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"visitWithTypeInfo\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getVisitFn\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Kind\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"TokenKind\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"DirectiveLocation\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"BREAK\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isDefinitionNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isExecutableDefinitionNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isSelectionNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isValueNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isTypeNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isTypeSystemDefinitionNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isTypeDefinitionNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isTypeSystemExtensionNode\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isTypeExtensionNode\", function() { return undefined; });\n/* harmony import */ var _execution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./execution */ \"./node_modules/graphql/execution/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"execute\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"defaultFieldResolver\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"responsePathAsArray\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getDirectiveValues\", function() { return undefined; });\n/* harmony import */ var _subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./subscription */ \"./node_modules/graphql/subscription/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"subscribe\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"createSourceEventStream\", function() { return undefined; });\n/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./validation */ \"./node_modules/graphql/validation/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"ValidationContext\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"specifiedRules\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"FieldsOnCorrectTypeRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"FragmentsOnCompositeTypesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"KnownArgumentNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"KnownDirectivesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"KnownFragmentNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"KnownTypeNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"LoneAnonymousOperationRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"NoFragmentCyclesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"NoUndefinedVariablesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"NoUnusedFragmentsRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"NoUnusedVariablesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"OverlappingFieldsCanBeMergedRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"PossibleFragmentSpreadsRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"ProvidedRequiredArgumentsRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"ScalarLeafsRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"SingleFieldSubscriptionsRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"UniqueArgumentNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"UniqueDirectivesPerLocationRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"UniqueFragmentNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"UniqueInputFieldNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"UniqueOperationNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"UniqueVariableNamesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"ValuesOfCorrectTypeRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"VariablesAreInputTypesRule\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"VariablesInAllowedPositionRule\", function() { return undefined; });\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./error */ \"./node_modules/graphql/error/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"GraphQLError\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"formatError\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"printError\", function() { return undefined; });\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utilities */ \"./node_modules/graphql/utilities/index.js\");\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getIntrospectionQuery\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"introspectionQuery\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getOperationAST\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getOperationRootType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"introspectionFromSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"buildClientSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"buildASTSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"buildSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"getDescription\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"extendSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"lexicographicSortSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"printSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"printIntrospectionSchema\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"printType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"typeFromAST\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"valueFromAST\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"valueFromASTUntyped\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"astFromValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"TypeInfo\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"coerceValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isValidJSValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isValidLiteralValue\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"concatAST\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"separateOperations\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isEqualType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isTypeSubTypeOf\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"doTypesOverlap\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"assertValidName\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"isValidNameError\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"findBreakingChanges\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"findDangerousChanges\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"BreakingChangeType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"DangerousChangeType\", function() { return undefined; });\n/* harmony reexport (non default export from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"findDeprecatedUsages\", function() { return undefined; });\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * GraphQL.js provides a reference implementation for the GraphQL specification\n * but is also a useful utility for operating on GraphQL files and building\n * sophisticated tools.\n *\n * This primary module exports a general purpose function for fulfilling all\n * steps of the GraphQL specification in a single operation, but also includes\n * utilities for every part of the GraphQL specification:\n *\n *   - Parsing the GraphQL language.\n *   - Building a GraphQL type schema.\n *   - Validating a GraphQL request against a type schema.\n *   - Executing a GraphQL request against a type schema.\n *\n * This also includes utility functions for operating on GraphQL types and\n * GraphQL documents to facilitate building tools.\n *\n * You may also import from each sub-directory directly. For example, the\n * following two import statements are equivalent:\n *\n *     import { parse } from 'graphql';\n *     import { parse } from 'graphql/language';\n */\n// The primary entry point into fulfilling a GraphQL request.\n // Create and operate on GraphQL type definitions and schema.\n\n\n// Parse and operate on GraphQL language source files.\n\n// Execute GraphQL queries.\n\n // Validate GraphQL queries.\n\n\n// Create, format, and print GraphQL errors.\n\n// Utilities for operating on GraphQL type schema and parsed sources.\n\n\n//# sourceURL=webpack:///./node_modules/graphql/index.mjs?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/defineToJSON.js":
/*!******************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineToJSON.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = applyToJSON;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * The `applyToJSON()` function defines toJSON() and inspect() prototype\n * methods which are aliases for toString().\n */\nfunction applyToJSON(classObject) {\n  classObject.prototype.toJSON = classObject.prototype.inspect = classObject.prototype.toString;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/defineToJSON.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/defineToStringTag.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineToStringTag.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = applyToStringTag;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * The `applyToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method applyToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nfunction applyToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/defineToStringTag.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/find.js":
/*!**********************************************!*\
  !*** ./node_modules/graphql/jsutils/find.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = find;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction find(list, predicate) {\n  for (var i = 0; i < list.length; i++) {\n    if (predicate(list[i])) {\n      return list[i];\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/find.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/inspect.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inspect;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Used to print values in error messages.\n */\nfunction inspect(value) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value) {\n        if (typeof value.inspect === 'function') {\n          return value.inspect();\n        } else if (Array.isArray(value)) {\n          return '[' + value.map(inspect).join(', ') + ']';\n        }\n\n        var properties = Object.keys(value).map(function (k) {\n          return \"\".concat(k, \": \").concat(inspect(value[k]));\n        }).join(', ');\n        return properties ? '{ ' + properties + ' }' : '{}';\n      }\n\n      return String(value);\n\n    default:\n      return String(value);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/inspect.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/instanceOf.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/jsutils/instanceOf.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * A replacement for instanceof which includes an error warning when multi-realm\n * constructors are detected.\n */\n// See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production\n// See: https://webpack.js.org/guides/production/\nvar _default =  false ? // eslint-disable-next-line no-shadow\nundefined : // eslint-disable-next-line no-shadow\nfunction instanceOf(value, constructor) {\n  if (value instanceof constructor) {\n    return true;\n  }\n\n  if (value) {\n    var valueClass = value.constructor;\n    var className = constructor.name;\n\n    if (className && valueClass && valueClass.name === className) {\n      throw new Error(\"Cannot use \".concat(className, \" \\\"\").concat(value, \"\\\" from another module or realm.\\n\\nEnsure that there is only one instance of \\\"graphql\\\" in the node_modules\\ndirectory. If different versions of \\\"graphql\\\" are the dependencies of other\\nrelied on modules, use \\\"resolutions\\\" to ensure only one version is installed.\\n\\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\\n\\nDuplicate \\\"graphql\\\" modules cannot be used at the same time since different\\nversions may have different capabilities and behavior. The data from one\\nversion used in the function from another could produce confusing and\\nspurious results.\"));\n    }\n  }\n\n  return false;\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/instanceOf.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/invariant.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/invariant.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = invariant;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction invariant(condition, message) {\n  /* istanbul ignore else */\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/invariant.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/isFinite.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/jsutils/isFinite.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Copyright (c) 2018-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441\nvar isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\nvar _default = isFinite;\nexports.default = _default;\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/isFinite.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/isInteger.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/isInteger.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Copyright (c) 2018-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441\nvar isInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nvar _default = isInteger;\nexports.default = _default;\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/isInteger.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/isInvalid.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/isInvalid.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isInvalid;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Returns true if a value is undefined, or NaN.\n */\nfunction isInvalid(value) {\n  return value === undefined || value !== value;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/isInvalid.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/isNullish.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/isNullish.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNullish;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Returns true if a value is null, undefined, or NaN.\n */\nfunction isNullish(value) {\n  return value === null || value === undefined || value !== value;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/isNullish.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/isPromise.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/isPromise.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isPromise;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Returns true if the value acts like a Promise, i.e. has a \"then\" function,\n * otherwise returns false.\n */\n// eslint-disable-next-line no-redeclare\nfunction isPromise(value) {\n  return Boolean(value && typeof value.then === 'function');\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/isPromise.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/keyMap.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/jsutils/keyMap.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = keyMap;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * for each value in the array.\n *\n * This provides a convenient lookup for the array items if the key function\n * produces unique results.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: { name: 'Jon', num: '555-1234' },\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\n *     const entriesByName = keyMap(\n *       phoneBook,\n *       entry => entry.name\n *     )\n *\n *     // { name: 'Jenny', num: '857-6309' }\n *     const jennyEntry = entriesByName['Jenny']\n *\n */\nfunction keyMap(list, keyFn) {\n  return list.reduce(function (map, item) {\n    return map[keyFn(item)] = item, map;\n  }, Object.create(null));\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/keyMap.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/keyValMap.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/jsutils/keyValMap.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = keyValMap;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * and a function to produce the values from each item in the array.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: '555-1234', Jenny: '867-5309' }\n *     const phonesByName = keyValMap(\n *       phoneBook,\n *       entry => entry.name,\n *       entry => entry.num\n *     )\n *\n */\nfunction keyValMap(list, keyFn, valFn) {\n  return list.reduce(function (map, item) {\n    return map[keyFn(item)] = valFn(item), map;\n  }, Object.create(null));\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/keyValMap.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/memoize3.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/jsutils/memoize3.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memoize3;\n\n/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Memoizes the provided three-argument function.\n */\nfunction memoize3(fn) {\n  var cache0;\n\n  function memoized(a1, a2, a3) {\n    if (!cache0) {\n      cache0 = new WeakMap();\n    }\n\n    var cache1 = cache0.get(a1);\n    var cache2;\n\n    if (cache1) {\n      cache2 = cache1.get(a2);\n\n      if (cache2) {\n        var cachedValue = cache2.get(a3);\n\n        if (cachedValue !== undefined) {\n          return cachedValue;\n        }\n      }\n    } else {\n      cache1 = new WeakMap();\n      cache0.set(a1, cache1);\n    }\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a2, cache2);\n    }\n\n    var newValue = fn.apply(this, arguments);\n    cache2.set(a3, newValue);\n    return newValue;\n  }\n\n  return memoized;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/memoize3.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/objectValues.js":
/*!******************************************************!*\
  !*** ./node_modules/graphql/jsutils/objectValues.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/* eslint-disable no-redeclare */\n// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/2221\nvar objectValues = Object.values || function (obj) {\n  return Object.keys(obj).map(function (key) {\n    return obj[key];\n  });\n};\n\nvar _default = objectValues;\nexports.default = _default;\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/objectValues.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/orList.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/jsutils/orList.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = orList;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nvar MAX_LENGTH = 5;\n/**\n * Given [ A, B, C ] return 'A, B, or C'.\n */\n\nfunction orList(items) {\n  var selected = items.slice(0, MAX_LENGTH);\n  return selected.reduce(function (list, quoted, index) {\n    return list + (selected.length > 2 ? ', ' : ' ') + (index === selected.length - 1 ? 'or ' : '') + quoted;\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/orList.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/promiseForObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphql/jsutils/promiseForObject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = promiseForObject;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * This function transforms a JS object `ObjMap<Promise<T>>` into\n * a `Promise<ObjMap<T>>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nfunction promiseForObject(object) {\n  var keys = Object.keys(object);\n  var valuesAndPromises = keys.map(function (name) {\n    return object[name];\n  });\n  return Promise.all(valuesAndPromises).then(function (values) {\n    return values.reduce(function (resolvedObject, value, i) {\n      resolvedObject[keys[i]] = value;\n      return resolvedObject;\n    }, Object.create(null));\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/promiseForObject.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/promiseReduce.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/jsutils/promiseReduce.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = promiseReduce;\n\nvar _isPromise = _interopRequireDefault(__webpack_require__(/*! ./isPromise */ \"./node_modules/graphql/jsutils/isPromise.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\nfunction promiseReduce(values, callback, initialValue) {\n  return values.reduce(function (previous, value) {\n    return (0, _isPromise.default)(previous) ? previous.then(function (resolved) {\n      return callback(resolved, value);\n    }) : callback(previous, value);\n  }, initialValue);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/promiseReduce.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/quotedOrList.js":
/*!******************************************************!*\
  !*** ./node_modules/graphql/jsutils/quotedOrList.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = quotedOrList;\n\nvar _orList = _interopRequireDefault(__webpack_require__(/*! ./orList */ \"./node_modules/graphql/jsutils/orList.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Given [ A, B, C ] return '\"A\", \"B\", or \"C\"'.\n */\nfunction quotedOrList(items) {\n  return (0, _orList.default)(items.map(function (item) {\n    return \"\\\"\".concat(item, \"\\\"\");\n  }));\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/quotedOrList.js?");

/***/ }),

/***/ "./node_modules/graphql/jsutils/suggestionList.js":
/*!********************************************************!*\
  !*** ./node_modules/graphql/jsutils/suggestionList.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = suggestionList;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Given an invalid input string and a list of valid options, returns a filtered\n * list of valid options sorted based on their similarity with the input.\n */\nfunction suggestionList(input, options) {\n  var optionsByDistance = Object.create(null);\n  var oLength = options.length;\n  var inputThreshold = input.length / 2;\n\n  for (var i = 0; i < oLength; i++) {\n    var distance = lexicalDistance(input, options[i]);\n    var threshold = Math.max(inputThreshold, options[i].length / 2, 1);\n\n    if (distance <= threshold) {\n      optionsByDistance[options[i]] = distance;\n    }\n  }\n\n  return Object.keys(optionsByDistance).sort(function (a, b) {\n    return optionsByDistance[a] - optionsByDistance[b];\n  });\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\n * as a single edit which helps identify mis-cased values with an edit distance\n * of 1.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\n\n\nfunction lexicalDistance(aStr, bStr) {\n  if (aStr === bStr) {\n    return 0;\n  }\n\n  var i;\n  var j;\n  var d = [];\n  var a = aStr.toLowerCase();\n  var b = bStr.toLowerCase();\n  var aLength = a.length;\n  var bLength = b.length; // Any case change counts as a single edit\n\n  if (a === b) {\n    return 1;\n  }\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      var cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/jsutils/suggestionList.js?");

/***/ }),

/***/ "./node_modules/graphql/language/blockStringValue.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/language/blockStringValue.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = blockStringValue;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nfunction blockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent < line.length && (commonIndent === null || indent < commonIndent)) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  if (commonIndent) {\n    for (var _i = 1; _i < lines.length; _i++) {\n      lines[_i] = lines[_i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/blockStringValue.js?");

/***/ }),

/***/ "./node_modules/graphql/language/directiveLocation.js":
/*!************************************************************!*\
  !*** ./node_modules/graphql/language/directiveLocation.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectiveLocation = void 0;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * The set of allowed directive location values.\n */\nvar DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n\nexports.DirectiveLocation = DirectiveLocation;\n\n//# sourceURL=webpack:///./node_modules/graphql/language/directiveLocation.js?");

/***/ }),

/***/ "./node_modules/graphql/language/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/language/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getLocation\", {\n  enumerable: true,\n  get: function get() {\n    return _location.getLocation;\n  }\n});\nObject.defineProperty(exports, \"Kind\", {\n  enumerable: true,\n  get: function get() {\n    return _kinds.Kind;\n  }\n});\nObject.defineProperty(exports, \"createLexer\", {\n  enumerable: true,\n  get: function get() {\n    return _lexer.createLexer;\n  }\n});\nObject.defineProperty(exports, \"TokenKind\", {\n  enumerable: true,\n  get: function get() {\n    return _lexer.TokenKind;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function get() {\n    return _parser.parse;\n  }\n});\nObject.defineProperty(exports, \"parseValue\", {\n  enumerable: true,\n  get: function get() {\n    return _parser.parseValue;\n  }\n});\nObject.defineProperty(exports, \"parseType\", {\n  enumerable: true,\n  get: function get() {\n    return _parser.parseType;\n  }\n});\nObject.defineProperty(exports, \"print\", {\n  enumerable: true,\n  get: function get() {\n    return _printer.print;\n  }\n});\nObject.defineProperty(exports, \"Source\", {\n  enumerable: true,\n  get: function get() {\n    return _source.Source;\n  }\n});\nObject.defineProperty(exports, \"visit\", {\n  enumerable: true,\n  get: function get() {\n    return _visitor.visit;\n  }\n});\nObject.defineProperty(exports, \"visitInParallel\", {\n  enumerable: true,\n  get: function get() {\n    return _visitor.visitInParallel;\n  }\n});\nObject.defineProperty(exports, \"visitWithTypeInfo\", {\n  enumerable: true,\n  get: function get() {\n    return _visitor.visitWithTypeInfo;\n  }\n});\nObject.defineProperty(exports, \"getVisitFn\", {\n  enumerable: true,\n  get: function get() {\n    return _visitor.getVisitFn;\n  }\n});\nObject.defineProperty(exports, \"BREAK\", {\n  enumerable: true,\n  get: function get() {\n    return _visitor.BREAK;\n  }\n});\nObject.defineProperty(exports, \"isDefinitionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isDefinitionNode;\n  }\n});\nObject.defineProperty(exports, \"isExecutableDefinitionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isExecutableDefinitionNode;\n  }\n});\nObject.defineProperty(exports, \"isSelectionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isSelectionNode;\n  }\n});\nObject.defineProperty(exports, \"isValueNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isValueNode;\n  }\n});\nObject.defineProperty(exports, \"isTypeNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isTypeNode;\n  }\n});\nObject.defineProperty(exports, \"isTypeSystemDefinitionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isTypeSystemDefinitionNode;\n  }\n});\nObject.defineProperty(exports, \"isTypeDefinitionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isTypeDefinitionNode;\n  }\n});\nObject.defineProperty(exports, \"isTypeSystemExtensionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isTypeSystemExtensionNode;\n  }\n});\nObject.defineProperty(exports, \"isTypeExtensionNode\", {\n  enumerable: true,\n  get: function get() {\n    return _predicates.isTypeExtensionNode;\n  }\n});\nObject.defineProperty(exports, \"DirectiveLocation\", {\n  enumerable: true,\n  get: function get() {\n    return _directiveLocation.DirectiveLocation;\n  }\n});\n\nvar _location = __webpack_require__(/*! ./location */ \"./node_modules/graphql/language/location.js\");\n\nvar _kinds = __webpack_require__(/*! ./kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _lexer = __webpack_require__(/*! ./lexer */ \"./node_modules/graphql/language/lexer.js\");\n\nvar _parser = __webpack_require__(/*! ./parser */ \"./node_modules/graphql/language/parser.js\");\n\nvar _printer = __webpack_require__(/*! ./printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _source = __webpack_require__(/*! ./source */ \"./node_modules/graphql/language/source.js\");\n\nvar _visitor = __webpack_require__(/*! ./visitor */ \"./node_modules/graphql/language/visitor.js\");\n\nvar _predicates = __webpack_require__(/*! ./predicates */ \"./node_modules/graphql/language/predicates.js\");\n\nvar _directiveLocation = __webpack_require__(/*! ./directiveLocation */ \"./node_modules/graphql/language/directiveLocation.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/language/index.js?");

/***/ }),

/***/ "./node_modules/graphql/language/kinds.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/language/kinds.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Kind = void 0;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * The set of allowed kind values for AST nodes.\n */\nvar Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n\nexports.Kind = Kind;\n\n//# sourceURL=webpack:///./node_modules/graphql/language/kinds.js?");

/***/ }),

/***/ "./node_modules/graphql/language/lexer.js":
/*!************************************************!*\
  !*** ./node_modules/graphql/language/lexer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLexer = createLexer;\nexports.getTokenDesc = getTokenDesc;\nexports.TokenKind = void 0;\n\nvar _error = __webpack_require__(/*! ../error */ \"./node_modules/graphql/error/index.js\");\n\nvar _blockStringValue = _interopRequireDefault(__webpack_require__(/*! ./blockStringValue */ \"./node_modules/graphql/language/blockStringValue.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nfunction createLexer(source, options) {\n  var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== TokenKind.EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === TokenKind.COMMENT);\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nvar TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n\nexports.TokenKind = TokenKind;\n\n/**\n * A helper function to describe a token as a string for debugging\n */\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, \" \\\"\").concat(value, \"\\\"\") : token.kind;\n}\n\nvar charCodeAt = String.prototype.charCodeAt;\nvar slice = String.prototype.slice;\n/**\n * Helper function for constructing the Token object.\n */\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\nTok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n};\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = charCodeAt.call(body, pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (charCodeAt.call(body, pos + 1) === 46 && charCodeAt.call(body, pos + 2) === 46) {\n        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (charCodeAt.call(body, pos + 1) === 34 && charCodeAt.call(body, pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw (0, _error.syntaxError)(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return \"Unexpected single quote character ('), did you mean to use \" + 'a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = charCodeAt.call(body, position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (charCodeAt.call(body, position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = charCodeAt.call(body, ++position);\n  } while (code !== null && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(TokenKind.COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = charCodeAt.call(body, ++position);\n\n    if (code >= 48 && code <= 57) {\n      throw (0, _error.syntaxError)(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = charCodeAt.call(body, ++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = charCodeAt.call(body, ++position);\n    }\n\n    position = readDigits(source, position, code);\n  }\n\n  return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, slice.call(body, start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw (0, _error.syntaxError)(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += slice.call(body, chunkStart, position);\n      return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw (0, _error.syntaxError)(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          // u\n          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));\n\n          if (charCode < 0) {\n            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + \"\\\\u\".concat(body.slice(position + 1, position + 5), \".\"));\n          }\n\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n\n        default:\n          throw (0, _error.syntaxError)(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && (code = charCodeAt.call(body, position)) !== null) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {\n      rawValue += slice.call(body, chunkStart, position);\n      return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockStringValue.default)(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw (0, _error.syntaxError)(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    } // Escape Triple-Quote (\\\"\"\")\n\n\n    if (code === 92 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34 && charCodeAt.call(body, position + 3) === 34) {\n      rawValue += slice.call(body, chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && (code = charCodeAt.call(body, position)) !== null && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Tok(TokenKind.NAME, start, position, line, col, prev, slice.call(body, start, position));\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/lexer.js?");

/***/ }),

/***/ "./node_modules/graphql/language/location.js":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/location.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLocation = getLocation;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/location.js?");

/***/ }),

/***/ "./node_modules/graphql/language/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/language/parser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.parseValue = parseValue;\nexports.parseType = parseType;\nexports.parseConstValue = parseConstValue;\nexports.parseTypeReference = parseTypeReference;\nexports.parseNamedType = parseNamedType;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _source = __webpack_require__(/*! ./source */ \"./node_modules/graphql/language/source.js\");\n\nvar _error = __webpack_require__(/*! ../error */ \"./node_modules/graphql/error/index.js\");\n\nvar _lexer = __webpack_require__(/*! ./lexer */ \"./node_modules/graphql/language/lexer.js\");\n\nvar _kinds = __webpack_require__(/*! ./kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _directiveLocation = __webpack_require__(/*! ./directiveLocation */ \"./node_modules/graphql/language/directiveLocation.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nfunction parse(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n\n  if (!(sourceObj instanceof _source.Source)) {\n    throw new TypeError(\"Must provide Source. Received: \".concat((0, _inspect.default)(sourceObj)));\n  }\n\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\n\nfunction parseValue(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var value = parseValueLiteral(lexer, false);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\n\nfunction parseType(source, options) {\n  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;\n  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});\n  expect(lexer, _lexer.TokenKind.SOF);\n  var type = parseTypeReference(lexer);\n  expect(lexer, _lexer.TokenKind.EOF);\n  return type;\n}\n/**\n * Converts a name lex token into a name parse node.\n */\n\n\nfunction parseName(lexer) {\n  var token = expect(lexer, _lexer.TokenKind.NAME);\n  return {\n    kind: _kinds.Kind.NAME,\n    value: token.value,\n    loc: loc(lexer, token)\n  };\n} // Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\n\n\nfunction parseDocument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.DOCUMENT,\n    definitions: many(lexer, _lexer.TokenKind.SOF, parseDefinition, _lexer.TokenKind.EOF),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Definition :\n *   - ExecutableDefinition\n *   - TypeSystemDefinition\n *   - TypeSystemExtension\n */\n\n\nfunction parseDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n      case 'fragment':\n        return parseExecutableDefinition(lexer);\n\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'directive':\n        return parseTypeSystemDefinition(lexer);\n\n      case 'extend':\n        return parseTypeSystemExtension(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseExecutableDefinition(lexer);\n  } else if (peekDescription(lexer)) {\n    return parseTypeSystemDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n}\n/**\n * ExecutableDefinition :\n *   - OperationDefinition\n *   - FragmentDefinition\n */\n\n\nfunction parseExecutableDefinition(lexer) {\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment':\n        return parseFragmentDefinition(lexer);\n    }\n  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  throw unexpected(lexer);\n} // Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\n\n\nfunction parseOperationDefinition(lexer) {\n  var start = lexer.token;\n\n  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {\n    return {\n      kind: _kinds.Kind.OPERATION_DEFINITION,\n      operation: 'query',\n      name: undefined,\n      variableDefinitions: [],\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n\n  var operation = parseOperationType(lexer);\n  var name;\n\n  if (peek(lexer, _lexer.TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.OPERATION_DEFINITION,\n    operation: operation,\n    name: name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * OperationType : one of query mutation subscription\n */\n\n\nfunction parseOperationType(lexer) {\n  var operationToken = expect(lexer, _lexer.TokenKind.NAME);\n\n  switch (operationToken.value) {\n    case 'query':\n      return 'query';\n\n    case 'mutation':\n      return 'mutation';\n\n    case 'subscription':\n      return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\n\n\nfunction parseVariableDefinitions(lexer) {\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];\n}\n/**\n * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n */\n\n\nfunction parseVariableDefinition(lexer) {\n  var start = lexer.token;\n\n  if (lexer.options.experimentalVariableDefinitionDirectives) {\n    return {\n      kind: _kinds.Kind.VARIABLE_DEFINITION,\n      variable: parseVariable(lexer),\n      type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n      defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,\n      directives: parseDirectives(lexer, true),\n      loc: loc(lexer, start)\n    };\n  }\n\n  return {\n    kind: _kinds.Kind.VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),\n    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Variable : $ Name\n */\n\n\nfunction parseVariable(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.DOLLAR);\n  return {\n    kind: _kinds.Kind.VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * SelectionSet : { Selection+ }\n */\n\n\nfunction parseSelectionSet(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.SELECTION_SET,\n    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\n\n\nfunction parseSelection(lexer) {\n  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);\n}\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\n\n\nfunction parseField(lexer) {\n  var start = lexer.token;\n  var nameOrAlias = parseName(lexer);\n  var alias;\n  var name;\n\n  if (skip(lexer, _lexer.TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: _kinds.Kind.FIELD,\n    alias: alias,\n    name: name,\n    arguments: parseArguments(lexer, false),\n    directives: parseDirectives(lexer, false),\n    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * Arguments[Const] : ( Argument[?Const]+ )\n */\n\n\nfunction parseArguments(lexer, isConst) {\n  var item = isConst ? parseConstArgument : parseArgument;\n  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, item, _lexer.TokenKind.PAREN_R) : [];\n}\n/**\n * Argument[Const] : Name : Value[?Const]\n */\n\n\nfunction parseArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\nfunction parseConstArgument(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseConstValue(lexer)),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\n\n\nfunction parseFragment(lexer) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.SPREAD);\n\n  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: _kinds.Kind.FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer, false),\n      loc: loc(lexer, start)\n    };\n  }\n\n  var typeCondition;\n\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.INLINE_FRAGMENT,\n    typeCondition: typeCondition,\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\n\n\nfunction parseFragmentDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'fragment'); // Experimental support for defining variables within fragments changes\n  // the grammar of FragmentDefinition:\n  //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n  if (lexer.options.experimentalFragmentVariables) {\n    return {\n      kind: _kinds.Kind.FRAGMENT_DEFINITION,\n      name: parseFragmentName(lexer),\n      variableDefinitions: parseVariableDefinitions(lexer),\n      typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n      directives: parseDirectives(lexer, false),\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n\n  return {\n    kind: _kinds.Kind.FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer, false),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * FragmentName : Name but not `on`\n */\n\n\nfunction parseFragmentName(lexer) {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n\n  return parseName(lexer);\n} // Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - NullValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * NullValue : `null`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\n\n\nfunction parseValueLiteral(lexer, isConst) {\n  var token = lexer.token;\n\n  switch (token.kind) {\n    case _lexer.TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n\n    case _lexer.TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n\n    case _lexer.TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: _kinds.Kind.INT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: _kinds.Kind.FLOAT,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.STRING:\n    case _lexer.TokenKind.BLOCK_STRING:\n      return parseStringLiteral(lexer);\n\n    case _lexer.TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: _kinds.Kind.BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value === 'null') {\n        lexer.advance();\n        return {\n          kind: _kinds.Kind.NULL,\n          loc: loc(lexer, token)\n        };\n      }\n\n      lexer.advance();\n      return {\n        kind: _kinds.Kind.ENUM,\n        value: token.value,\n        loc: loc(lexer, token)\n      };\n\n    case _lexer.TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n\n      break;\n  }\n\n  throw unexpected(lexer);\n}\n\nfunction parseStringLiteral(lexer) {\n  var token = lexer.token;\n  lexer.advance();\n  return {\n    kind: _kinds.Kind.STRING,\n    value: token.value,\n    block: token.kind === _lexer.TokenKind.BLOCK_STRING,\n    loc: loc(lexer, token)\n  };\n}\n\nfunction parseConstValue(lexer) {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer) {\n  return parseValueLiteral(lexer, false);\n}\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\n\n\nfunction parseList(lexer, isConst) {\n  var start = lexer.token;\n  var item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: _kinds.Kind.LIST,\n    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\n\n\nfunction parseObject(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.BRACE_L);\n  var fields = [];\n\n  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n\n  return {\n    kind: _kinds.Kind.OBJECT,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\n\n\nfunction parseObjectField(lexer, isConst) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.OBJECT_FIELD,\n    name: parseName(lexer),\n    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Directives section.\n\n/**\n * Directives[Const] : Directive[?Const]+\n */\n\n\nfunction parseDirectives(lexer, isConst) {\n  var directives = [];\n\n  while (peek(lexer, _lexer.TokenKind.AT)) {\n    directives.push(parseDirective(lexer, isConst));\n  }\n\n  return directives;\n}\n/**\n * Directive[Const] : @ Name Arguments[?Const]?\n */\n\n\nfunction parseDirective(lexer, isConst) {\n  var start = lexer.token;\n  expect(lexer, _lexer.TokenKind.AT);\n  return {\n    kind: _kinds.Kind.DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer, isConst),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\n\n\nfunction parseTypeReference(lexer) {\n  var start = lexer.token;\n  var type;\n\n  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {\n    type = parseTypeReference(lexer);\n    expect(lexer, _lexer.TokenKind.BRACKET_R);\n    type = {\n      kind: _kinds.Kind.LIST_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  } else {\n    type = parseNamedType(lexer);\n  }\n\n  if (skip(lexer, _lexer.TokenKind.BANG)) {\n    return {\n      kind: _kinds.Kind.NON_NULL_TYPE,\n      type: type,\n      loc: loc(lexer, start)\n    };\n  }\n\n  return type;\n}\n/**\n * NamedType : Name\n */\n\n\nfunction parseNamedType(lexer) {\n  var start = lexer.token;\n  return {\n    kind: _kinds.Kind.NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n} // Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\n\n\nfunction parseTypeSystemDefinition(lexer) {\n  // Many definitions begin with a description and require a lookahead.\n  var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'schema':\n        return parseSchemaDefinition(lexer);\n\n      case 'scalar':\n        return parseScalarTypeDefinition(lexer);\n\n      case 'type':\n        return parseObjectTypeDefinition(lexer);\n\n      case 'interface':\n        return parseInterfaceTypeDefinition(lexer);\n\n      case 'union':\n        return parseUnionTypeDefinition(lexer);\n\n      case 'enum':\n        return parseEnumTypeDefinition(lexer);\n\n      case 'input':\n        return parseInputObjectTypeDefinition(lexer);\n\n      case 'directive':\n        return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n\nfunction peekDescription(lexer) {\n  return peek(lexer, _lexer.TokenKind.STRING) || peek(lexer, _lexer.TokenKind.BLOCK_STRING);\n}\n/**\n * Description : StringValue\n */\n\n\nfunction parseDescription(lexer) {\n  if (peekDescription(lexer)) {\n    return parseStringLiteral(lexer);\n  }\n}\n/**\n * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n */\n\n\nfunction parseSchemaDefinition(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer, true);\n  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);\n  return {\n    kind: _kinds.Kind.SCHEMA_DEFINITION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * OperationTypeDefinition : OperationType : NamedType\n */\n\n\nfunction parseOperationTypeDefinition(lexer) {\n  var start = lexer.token;\n  var operation = parseOperationType(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseNamedType(lexer);\n  return {\n    kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,\n    operation: operation,\n    type: type,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n */\n\n\nfunction parseScalarTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectTypeDefinition :\n *   Description?\n *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n */\n\n\nfunction parseObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ImplementsInterfaces :\n *   - implements `&`? NamedType\n *   - ImplementsInterfaces & NamedType\n */\n\n\nfunction parseImplementsInterfaces(lexer) {\n  var types = [];\n\n  if (lexer.token.value === 'implements') {\n    lexer.advance(); // Optional leading ampersand\n\n    skip(lexer, _lexer.TokenKind.AMP);\n\n    do {\n      types.push(parseNamedType(lexer));\n    } while (skip(lexer, _lexer.TokenKind.AMP) || // Legacy support for the SDL?\n    lexer.options.allowLegacySDLImplementsInterfaces && peek(lexer, _lexer.TokenKind.NAME));\n  }\n\n  return types;\n}\n/**\n * FieldsDefinition : { FieldDefinition+ }\n */\n\n\nfunction parseFieldsDefinition(lexer) {\n  // Legacy support for the SDL?\n  if (lexer.options.allowLegacySDLEmptyFields && peek(lexer, _lexer.TokenKind.BRACE_L) && lexer.lookahead().kind === _lexer.TokenKind.BRACE_R) {\n    lexer.advance();\n    lexer.advance();\n    return [];\n  }\n\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n/**\n * FieldDefinition :\n *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n */\n\n\nfunction parseFieldDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.FIELD_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    type: type,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\n\n\nfunction parseArgumentDefs(lexer) {\n  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {\n    return [];\n  }\n\n  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);\n}\n/**\n * InputValueDefinition :\n *   - Description? Name : Type DefaultValue? Directives[Const]?\n */\n\n\nfunction parseInputValueDef(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  expect(lexer, _lexer.TokenKind.COLON);\n  var type = parseTypeReference(lexer);\n  var defaultValue;\n\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.INPUT_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    type: type,\n    defaultValue: defaultValue,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InterfaceTypeDefinition :\n *   - Description? interface Name Directives[Const]? FieldsDefinition?\n */\n\n\nfunction parseInterfaceTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n  return {\n    kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionTypeDefinition :\n *   - Description? union Name Directives[Const]? UnionMemberTypes?\n */\n\n\nfunction parseUnionTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseUnionMemberTypes(lexer);\n  return {\n    kind: _kinds.Kind.UNION_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionMemberTypes :\n *   - = `|`? NamedType\n *   - UnionMemberTypes | NamedType\n */\n\n\nfunction parseUnionMemberTypes(lexer) {\n  var types = [];\n\n  if (skip(lexer, _lexer.TokenKind.EQUALS)) {\n    // Optional leading pipe\n    skip(lexer, _lexer.TokenKind.PIPE);\n\n    do {\n      types.push(parseNamedType(lexer));\n    } while (skip(lexer, _lexer.TokenKind.PIPE));\n  }\n\n  return types;\n}\n/**\n * EnumTypeDefinition :\n *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n */\n\n\nfunction parseEnumTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n  return {\n    kind: _kinds.Kind.ENUM_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * EnumValuesDefinition : { EnumValueDefinition+ }\n */\n\n\nfunction parseEnumValuesDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R) : [];\n}\n/**\n * EnumValueDefinition : Description? EnumValue Directives[Const]?\n *\n * EnumValue : Name\n */\n\n\nfunction parseEnumValueDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  return {\n    kind: _kinds.Kind.ENUM_VALUE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InputObjectTypeDefinition :\n *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n */\n\n\nfunction parseInputObjectTypeDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n  return {\n    kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n    description: description,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InputFieldsDefinition : { InputValueDefinition+ }\n */\n\n\nfunction parseInputFieldsDefinition(lexer) {\n  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R) : [];\n}\n/**\n * TypeSystemExtension :\n *   - SchemaExtension\n *   - TypeExtension\n *\n * TypeExtension :\n *   - ScalarTypeExtension\n *   - ObjectTypeExtension\n *   - InterfaceTypeExtension\n *   - UnionTypeExtension\n *   - EnumTypeExtension\n *   - InputObjectTypeDefinition\n */\n\n\nfunction parseTypeSystemExtension(lexer) {\n  var keywordToken = lexer.lookahead();\n\n  if (keywordToken.kind === _lexer.TokenKind.NAME) {\n    switch (keywordToken.value) {\n      case 'schema':\n        return parseSchemaExtension(lexer);\n\n      case 'scalar':\n        return parseScalarTypeExtension(lexer);\n\n      case 'type':\n        return parseObjectTypeExtension(lexer);\n\n      case 'interface':\n        return parseInterfaceTypeExtension(lexer);\n\n      case 'union':\n        return parseUnionTypeExtension(lexer);\n\n      case 'enum':\n        return parseEnumTypeExtension(lexer);\n\n      case 'input':\n        return parseInputObjectTypeExtension(lexer);\n    }\n  }\n\n  throw unexpected(lexer, keywordToken);\n}\n/**\n * SchemaExtension :\n *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n *  - extend schema Directives[Const]\n */\n\n\nfunction parseSchemaExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'schema');\n  var directives = parseDirectives(lexer, true);\n  var operationTypes = peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R) : [];\n\n  if (directives.length === 0 && operationTypes.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.SCHEMA_EXTENSION,\n    directives: directives,\n    operationTypes: operationTypes,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ScalarTypeExtension :\n *   - extend scalar Name Directives[Const]\n */\n\n\nfunction parseScalarTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'scalar');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n\n  if (directives.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * ObjectTypeExtension :\n *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n *  - extend type Name ImplementsInterfaces? Directives[Const]\n *  - extend type Name ImplementsInterfaces\n */\n\n\nfunction parseObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'type');\n  var name = parseName(lexer);\n  var interfaces = parseImplementsInterfaces(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n\n  if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,\n    name: name,\n    interfaces: interfaces,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InterfaceTypeExtension :\n *   - extend interface Name Directives[Const]? FieldsDefinition\n *   - extend interface Name Directives[Const]\n */\n\n\nfunction parseInterfaceTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'interface');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseFieldsDefinition(lexer);\n\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * UnionTypeExtension :\n *   - extend union Name Directives[Const]? UnionMemberTypes\n *   - extend union Name Directives[Const]\n */\n\n\nfunction parseUnionTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'union');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var types = parseUnionMemberTypes(lexer);\n\n  if (directives.length === 0 && types.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.UNION_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    types: types,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * EnumTypeExtension :\n *   - extend enum Name Directives[Const]? EnumValuesDefinition\n *   - extend enum Name Directives[Const]\n */\n\n\nfunction parseEnumTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'enum');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var values = parseEnumValuesDefinition(lexer);\n\n  if (directives.length === 0 && values.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.ENUM_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    values: values,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * InputObjectTypeExtension :\n *   - extend input Name Directives[Const]? InputFieldsDefinition\n *   - extend input Name Directives[Const]\n */\n\n\nfunction parseInputObjectTypeExtension(lexer) {\n  var start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  expectKeyword(lexer, 'input');\n  var name = parseName(lexer);\n  var directives = parseDirectives(lexer, true);\n  var fields = parseInputFieldsDefinition(lexer);\n\n  if (directives.length === 0 && fields.length === 0) {\n    throw unexpected(lexer);\n  }\n\n  return {\n    kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n    name: name,\n    directives: directives,\n    fields: fields,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * DirectiveDefinition :\n *   - Description? directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\n\n\nfunction parseDirectiveDefinition(lexer) {\n  var start = lexer.token;\n  var description = parseDescription(lexer);\n  expectKeyword(lexer, 'directive');\n  expect(lexer, _lexer.TokenKind.AT);\n  var name = parseName(lexer);\n  var args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  var locations = parseDirectiveLocations(lexer);\n  return {\n    kind: _kinds.Kind.DIRECTIVE_DEFINITION,\n    description: description,\n    name: name,\n    arguments: args,\n    locations: locations,\n    loc: loc(lexer, start)\n  };\n}\n/**\n * DirectiveLocations :\n *   - `|`? DirectiveLocation\n *   - DirectiveLocations | DirectiveLocation\n */\n\n\nfunction parseDirectiveLocations(lexer) {\n  // Optional leading pipe\n  skip(lexer, _lexer.TokenKind.PIPE);\n  var locations = [];\n\n  do {\n    locations.push(parseDirectiveLocation(lexer));\n  } while (skip(lexer, _lexer.TokenKind.PIPE));\n\n  return locations;\n}\n/*\n * DirectiveLocation :\n *   - ExecutableDirectiveLocation\n *   - TypeSystemDirectiveLocation\n *\n * ExecutableDirectiveLocation : one of\n *   `QUERY`\n *   `MUTATION`\n *   `SUBSCRIPTION`\n *   `FIELD`\n *   `FRAGMENT_DEFINITION`\n *   `FRAGMENT_SPREAD`\n *   `INLINE_FRAGMENT`\n *\n * TypeSystemDirectiveLocation : one of\n *   `SCHEMA`\n *   `SCALAR`\n *   `OBJECT`\n *   `FIELD_DEFINITION`\n *   `ARGUMENT_DEFINITION`\n *   `INTERFACE`\n *   `UNION`\n *   `ENUM`\n *   `ENUM_VALUE`\n *   `INPUT_OBJECT`\n *   `INPUT_FIELD_DEFINITION`\n */\n\n\nfunction parseDirectiveLocation(lexer) {\n  var start = lexer.token;\n  var name = parseName(lexer);\n\n  if (_directiveLocation.DirectiveLocation.hasOwnProperty(name.value)) {\n    return name;\n  }\n\n  throw unexpected(lexer, start);\n} // Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\n\n\nfunction loc(lexer, startToken) {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return {\n    start: this.start,\n    end: this.end\n  };\n};\n/**\n * Determines if the next token is of a given kind\n */\n\n\nfunction peek(lexer, kind) {\n  return lexer.token.kind === kind;\n}\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\n\n\nfunction skip(lexer, kind) {\n  var match = lexer.token.kind === kind;\n\n  if (match) {\n    lexer.advance();\n  }\n\n  return match;\n}\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\n\n\nfunction expect(lexer, kind) {\n  var token = lexer.token;\n\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n\n  throw (0, _error.syntaxError)(lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat((0, _lexer.getTokenDesc)(token)));\n}\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\n\n\nfunction expectKeyword(lexer, value) {\n  var token = lexer.token;\n\n  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n\n  throw (0, _error.syntaxError)(lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat((0, _lexer.getTokenDesc)(token)));\n}\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\n\n\nfunction unexpected(lexer, atToken) {\n  var token = atToken || lexer.token;\n  return (0, _error.syntaxError)(lexer.source, token.start, \"Unexpected \".concat((0, _lexer.getTokenDesc)(token)));\n}\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\n\n\nfunction any(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [];\n\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n\n  return nodes;\n}\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\n\n\nfunction many(lexer, openKind, parseFn, closeKind) {\n  expect(lexer, openKind);\n  var nodes = [parseFn(lexer)];\n\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n\n  return nodes;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/parser.js?");

/***/ }),

/***/ "./node_modules/graphql/language/predicates.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphql/language/predicates.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDefinitionNode = isDefinitionNode;\nexports.isExecutableDefinitionNode = isExecutableDefinitionNode;\nexports.isSelectionNode = isSelectionNode;\nexports.isValueNode = isValueNode;\nexports.isTypeNode = isTypeNode;\nexports.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;\nexports.isTypeDefinitionNode = isTypeDefinitionNode;\nexports.isTypeSystemExtensionNode = isTypeSystemExtensionNode;\nexports.isTypeExtensionNode = isTypeExtensionNode;\n\nvar _kinds = __webpack_require__(/*! ./kinds */ \"./node_modules/graphql/language/kinds.js\");\n\n/**\n * Copyright (c) 2018-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction isDefinitionNode(node) {\n  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);\n}\n\nfunction isExecutableDefinitionNode(node) {\n  return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;\n}\n\nfunction isSelectionNode(node) {\n  return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;\n}\n\nfunction isValueNode(node) {\n  return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;\n}\n\nfunction isTypeNode(node) {\n  return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;\n}\n\nfunction isTypeSystemDefinitionNode(node) {\n  return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;\n}\n\nfunction isTypeDefinitionNode(node) {\n  return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;\n}\n\nfunction isTypeSystemExtensionNode(node) {\n  return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\n\nfunction isTypeExtensionNode(node) {\n  return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/predicates.js?");

/***/ }),

/***/ "./node_modules/graphql/language/printer.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/language/printer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.print = print;\n\nvar _visitor = __webpack_require__(/*! ./visitor */ \"./node_modules/graphql/language/visitor.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction print(ast) {\n  return (0, _visitor.visit)(ast, {\n    leave: printDocASTReducer\n  });\n}\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (args.every(function (arg) {\n      return arg.indexOf('\\n') === -1;\n    }) ? wrap('(', join(args, ', '), ')') : wrap('(\\n', indent(join(args, '\\n')), '\\n)')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        locations = _ref31.locations;\n    return 'directive @' + name + (args.every(function (arg) {\n      return arg.indexOf('\\n') === -1;\n    }) ? wrap('(', join(args, ', '), ')') : wrap('(\\n', indent(join(args, '\\n')), '\\n)')) + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value, isDescription) {\n  var escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? \"\\\"\\\"\\\"\".concat(escaped.replace(/\"$/, '\"\\n'), \"\\\"\\\"\\\"\") : \"\\\"\\\"\\\"\\n\".concat(isDescription ? escaped : indent(escaped), \"\\n\\\"\\\"\\\"\");\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/printer.js?");

/***/ }),

/***/ "./node_modules/graphql/language/source.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/language/source.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Source = void 0;\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _defineToStringTag = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineToStringTag */ \"./node_modules/graphql/jsutils/defineToStringTag.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nvar Source = function Source(body, name, locationOffset) {\n  _defineProperty(this, \"body\", void 0);\n\n  _defineProperty(this, \"name\", void 0);\n\n  _defineProperty(this, \"locationOffset\", void 0);\n\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  !(this.locationOffset.line > 0) ? (0, _invariant.default)(0, 'line in locationOffset is 1-indexed and must be positive') : void 0;\n  !(this.locationOffset.column > 0) ? (0, _invariant.default)(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.Source = Source;\n(0, _defineToStringTag.default)(Source);\n\n//# sourceURL=webpack:///./node_modules/graphql/language/source.js?");

/***/ }),

/***/ "./node_modules/graphql/language/visitor.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/language/visitor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visit = visit;\nexports.visitInParallel = visitInParallel;\nexports.visitWithTypeInfo = visitWithTypeInfo;\nexports.getVisitFn = getVisitFn;\nexports.BREAK = exports.QueryDocumentKeys = void 0;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nvar QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexports.QueryDocumentKeys = QueryDocumentKeys;\nvar BREAK = {};\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexports.BREAK = BREAK;\n\nfunction visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var k in node) {\n            if (node.hasOwnProperty(k)) {\n              clone[k] = node[k];\n            }\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + (0, _inspect.default)(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nfunction visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nfunction visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\n\nfunction getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/language/visitor.js?");

/***/ }),

/***/ "./node_modules/graphql/subscription/index.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/subscription/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"subscribe\", {\n  enumerable: true,\n  get: function get() {\n    return _subscribe.subscribe;\n  }\n});\nObject.defineProperty(exports, \"createSourceEventStream\", {\n  enumerable: true,\n  get: function get() {\n    return _subscribe.createSourceEventStream;\n  }\n});\n\nvar _subscribe = __webpack_require__(/*! ./subscribe */ \"./node_modules/graphql/subscription/subscribe.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/subscription/index.js?");

/***/ }),

/***/ "./node_modules/graphql/subscription/mapAsyncIterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphql/subscription/mapAsyncIterator.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mapAsyncIterator;\n\nvar _iterall = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterable, callback, rejectCallback) {\n  var iterator = (0, _iterall.getAsyncIterator)(iterable);\n  var $return;\n  var abruptClose; // $FlowFixMe(>=0.68.0)\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = function abruptClose(error) {\n      var rethrow = function rethrow() {\n        return Promise.reject(error);\n      };\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  var mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    var reject = rejectCallback;\n\n    mapReject = function mapReject(error) {\n      return asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    };\n  }\n  /* TODO: Flow doesn't support symbols as keys:\n     https://github.com/facebook/flow/issues/3258 */\n\n\n  return _defineProperty({\n    next: function next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return: function _return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    throw: function _throw(error) {\n      // $FlowFixMe(>=0.68.0)\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    }\n  }, _iterall.$$asyncIterator, function () {\n    return this;\n  });\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(function (resolve) {\n    return resolve(callback(value));\n  });\n}\n\nfunction iteratorResult(value) {\n  return {\n    value: value,\n    done: false\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/subscription/mapAsyncIterator.js?");

/***/ }),

/***/ "./node_modules/graphql/subscription/subscribe.js":
/*!********************************************************!*\
  !*** ./node_modules/graphql/subscription/subscribe.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subscribe = subscribe;\nexports.createSourceEventStream = createSourceEventStream;\n\nvar _iterall = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _locatedError = __webpack_require__(/*! ../error/locatedError */ \"./node_modules/graphql/error/locatedError.js\");\n\nvar _execute = __webpack_require__(/*! ../execution/execute */ \"./node_modules/graphql/execution/execute.js\");\n\nvar _mapAsyncIterator = _interopRequireDefault(__webpack_require__(/*! ./mapAsyncIterator */ \"./node_modules/graphql/subscription/mapAsyncIterator.js\"));\n\nvar _getOperationRootType = __webpack_require__(/*! ../utilities/getOperationRootType */ \"./node_modules/graphql/utilities/getOperationRootType.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema.schema, argsOrSchema.document, argsOrSchema.rootValue, argsOrSchema.contextValue, argsOrSchema.variableValues, argsOrSchema.operationName, argsOrSchema.fieldResolver, argsOrSchema.subscribeFieldResolver) : subscribeImpl(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver);\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\n\nfunction reportGraphQLError(error) {\n  if (error instanceof _GraphQLError.GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return (0, _execute.execute)(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      (0, _iterall.isAsyncIterable)(resultOrStream) ? (0, _mapAsyncIterator.default)(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  }, reportGraphQLError);\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise<AsyncIterable>.\n *\n * If the client-provided invalid arguments, the source stream could not be\n * created, or the resolver did not return an AsyncIterable, this function will\n * will throw an error, which should be caught and handled by the caller.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nfunction createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);\n\n  try {\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = (0, _execute.buildExecutionContext)(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({\n        errors: exeContext\n      });\n    }\n\n    var type = (0, _getOperationRootType.getOperationRootType)(schema, exeContext.operation);\n    var fields = (0, _execute.collectFields)(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = (0, _execute.getFieldDef)(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new _GraphQLError.GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n    } // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n\n    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;\n    var path = (0, _execute.addPath)(undefined, responseName);\n    var info = (0, _execute.buildResolveInfo)(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    var result = (0, _execute.resolveFieldValueOrError)(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.\n\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        throw (0, _locatedError.locatedError)(eventStream, fieldNodes, (0, _execute.responsePathAsArray)(path));\n      } // Assert field returned an event stream, otherwise yield an error.\n\n\n      if ((0, _iterall.isAsyncIterable)(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n\n      throw new Error('Subscription field must return Async Iterable. Received: ' + (0, _inspect.default)(eventStream));\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/subscription/subscribe.js?");

/***/ }),

/***/ "./node_modules/graphql/type/definition.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/type/definition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isType = isType;\nexports.assertType = assertType;\nexports.isScalarType = isScalarType;\nexports.assertScalarType = assertScalarType;\nexports.isObjectType = isObjectType;\nexports.assertObjectType = assertObjectType;\nexports.isInterfaceType = isInterfaceType;\nexports.assertInterfaceType = assertInterfaceType;\nexports.isUnionType = isUnionType;\nexports.assertUnionType = assertUnionType;\nexports.isEnumType = isEnumType;\nexports.assertEnumType = assertEnumType;\nexports.isInputObjectType = isInputObjectType;\nexports.assertInputObjectType = assertInputObjectType;\nexports.isListType = isListType;\nexports.assertListType = assertListType;\nexports.isNonNullType = isNonNullType;\nexports.assertNonNullType = assertNonNullType;\nexports.isInputType = isInputType;\nexports.assertInputType = assertInputType;\nexports.isOutputType = isOutputType;\nexports.assertOutputType = assertOutputType;\nexports.isLeafType = isLeafType;\nexports.assertLeafType = assertLeafType;\nexports.isCompositeType = isCompositeType;\nexports.assertCompositeType = assertCompositeType;\nexports.isAbstractType = isAbstractType;\nexports.assertAbstractType = assertAbstractType;\nexports.GraphQLList = GraphQLList;\nexports.GraphQLNonNull = GraphQLNonNull;\nexports.isWrappingType = isWrappingType;\nexports.assertWrappingType = assertWrappingType;\nexports.isNullableType = isNullableType;\nexports.assertNullableType = assertNullableType;\nexports.getNullableType = getNullableType;\nexports.isNamedType = isNamedType;\nexports.assertNamedType = assertNamedType;\nexports.getNamedType = getNamedType;\nexports.isRequiredArgument = isRequiredArgument;\nexports.isRequiredInputField = isRequiredInputField;\nexports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = void 0;\n\nvar _defineToJSON = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineToJSON */ \"./node_modules/graphql/jsutils/defineToJSON.js\"));\n\nvar _defineToStringTag = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineToStringTag */ \"./node_modules/graphql/jsutils/defineToStringTag.js\"));\n\nvar _instanceOf = _interopRequireDefault(__webpack_require__(/*! ../jsutils/instanceOf */ \"./node_modules/graphql/jsutils/instanceOf.js\"));\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _valueFromASTUntyped = __webpack_require__(/*! ../utilities/valueFromASTUntyped */ \"./node_modules/graphql/utilities/valueFromASTUntyped.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction isType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);\n}\n\nfunction assertType(type) {\n  !isType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL type.\")) : void 0;\n  return type;\n}\n/**\n * There are predicates for each kind of GraphQL type.\n */\n\n\n// eslint-disable-next-line no-redeclare\nfunction isScalarType(type) {\n  return (0, _instanceOf.default)(type, GraphQLScalarType);\n}\n\nfunction assertScalarType(type) {\n  !isScalarType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Scalar type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isObjectType(type) {\n  return (0, _instanceOf.default)(type, GraphQLObjectType);\n}\n\nfunction assertObjectType(type) {\n  !isObjectType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Object type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isInterfaceType(type) {\n  return (0, _instanceOf.default)(type, GraphQLInterfaceType);\n}\n\nfunction assertInterfaceType(type) {\n  !isInterfaceType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Interface type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isUnionType(type) {\n  return (0, _instanceOf.default)(type, GraphQLUnionType);\n}\n\nfunction assertUnionType(type) {\n  !isUnionType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Union type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isEnumType(type) {\n  return (0, _instanceOf.default)(type, GraphQLEnumType);\n}\n\nfunction assertEnumType(type) {\n  !isEnumType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Enum type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isInputObjectType(type) {\n  return (0, _instanceOf.default)(type, GraphQLInputObjectType);\n}\n\nfunction assertInputObjectType(type) {\n  !isInputObjectType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Input Object type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isListType(type) {\n  return (0, _instanceOf.default)(type, GraphQLList);\n}\n\nfunction assertListType(type) {\n  !isListType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL List type.\")) : void 0;\n  return type;\n}\n\n// eslint-disable-next-line no-redeclare\nfunction isNonNullType(type) {\n  return (0, _instanceOf.default)(type, GraphQLNonNull);\n}\n\nfunction assertNonNullType(type) {\n  !isNonNullType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL Non-Null type.\")) : void 0;\n  return type;\n}\n/**\n * These types may be used as input types for arguments and directives.\n */\n\n\nfunction isInputType(type) {\n  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);\n}\n\nfunction assertInputType(type) {\n  !isInputType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL input type.\")) : void 0;\n  return type;\n}\n/**\n * These types may be used as output types as the result of fields.\n */\n\n\nfunction isOutputType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);\n}\n\nfunction assertOutputType(type) {\n  !isOutputType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL output type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe types which may be leaf values.\n */\n\n\nfunction isLeafType(type) {\n  return isScalarType(type) || isEnumType(type);\n}\n\nfunction assertLeafType(type) {\n  !isLeafType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL leaf type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nfunction isCompositeType(type) {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\n\nfunction assertCompositeType(type) {\n  !isCompositeType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL composite type.\")) : void 0;\n  return type;\n}\n/**\n * These types may describe the parent context of a selection set.\n */\n\n\nfunction isAbstractType(type) {\n  return isInterfaceType(type) || isUnionType(type);\n}\n\nfunction assertAbstractType(type) {\n  !isAbstractType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL abstract type.\")) : void 0;\n  return type;\n}\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */\n\n\n// eslint-disable-next-line no-redeclare\nfunction GraphQLList(ofType) {\n  if (this instanceof GraphQLList) {\n    this.ofType = assertType(ofType);\n  } else {\n    return new GraphQLList(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\n\nGraphQLList.prototype.toString = function toString() {\n  return '[' + String(this.ofType) + ']';\n};\n\n(0, _defineToJSON.default)(GraphQLList);\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\n\n// eslint-disable-next-line no-redeclare\nfunction GraphQLNonNull(ofType) {\n  if (this instanceof GraphQLNonNull) {\n    this.ofType = assertNullableType(ofType);\n  } else {\n    return new GraphQLNonNull(ofType);\n  }\n} // Need to cast through any to alter the prototype.\n\n\nGraphQLNonNull.prototype.toString = function toString() {\n  return String(this.ofType) + '!';\n};\n\n(0, _defineToJSON.default)(GraphQLNonNull);\n/**\n * These types wrap and modify other types\n */\n\nfunction isWrappingType(type) {\n  return isListType(type) || isNonNullType(type);\n}\n\nfunction assertWrappingType(type) {\n  !isWrappingType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL wrapping type.\")) : void 0;\n  return type;\n}\n/**\n * These types can all accept null as a value.\n */\n\n\nfunction isNullableType(type) {\n  return isType(type) && !isNonNullType(type);\n}\n\nfunction assertNullableType(type) {\n  !isNullableType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL nullable type.\")) : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\n\nfunction getNullableType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n/**\n * These named types do not include modifiers like List or NonNull.\n */\n\n\nfunction isNamedType(type) {\n  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);\n}\n\nfunction assertNamedType(type) {\n  !isNamedType(type) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(type), \" to be a GraphQL named type.\")) : void 0;\n  return type;\n}\n/* eslint-disable no-redeclare */\n\n\nfunction getNamedType(type) {\n  /* eslint-enable no-redeclare */\n  if (type) {\n    var unwrappedType = type;\n\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n\n    return unwrappedType;\n  }\n}\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\n\n\nfunction resolveThunk(thunk) {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */\n\n\nvar GraphQLScalarType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLScalarType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"serialize\", void 0);\n\n    _defineProperty(this, \"parseValue\", void 0);\n\n    _defineProperty(this, \"parseLiteral\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.serialize = config.serialize;\n\n    this.parseValue = config.parseValue || function (value) {\n      return value;\n    };\n\n    this.parseLiteral = config.parseLiteral || _valueFromASTUntyped.valueFromASTUntyped;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;\n    !(typeof config.serialize === 'function') ? (0, _invariant.default)(0, \"\".concat(this.name, \" must provide \\\"serialize\\\" function. If this custom Scalar \") + 'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' + 'functions are also provided.') : void 0;\n\n    if (config.parseValue || config.parseLiteral) {\n      !(typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function') ? (0, _invariant.default)(0, \"\".concat(this.name, \" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" \") + 'functions.') : void 0;\n    }\n  }\n\n  var _proto = GraphQLScalarType.prototype;\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLScalarType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLScalarType = GraphQLScalarType;\n(0, _defineToStringTag.default)(GraphQLScalarType);\n(0, _defineToJSON.default)(GraphQLScalarType);\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nvar GraphQLObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLObjectType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"isTypeOf\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    _defineProperty(this, \"_interfaces\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.isTypeOf = config.isTypeOf;\n    this._fields = defineFieldMap.bind(undefined, config);\n    this._interfaces = defineInterfaces.bind(undefined, config);\n    !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;\n    !(config.isTypeOf == null || typeof config.isTypeOf === 'function') ? (0, _invariant.default)(0, \"\".concat(this.name, \" must provide \\\"isTypeOf\\\" as a function, \") + \"but got: \".concat((0, _inspect.default)(config.isTypeOf), \".\")) : void 0;\n  }\n\n  var _proto2 = GraphQLObjectType.prototype;\n\n  _proto2.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto2.getInterfaces = function getInterfaces() {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n\n    return this._interfaces;\n  };\n\n  _proto2.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLObjectType = GraphQLObjectType;\n(0, _defineToStringTag.default)(GraphQLObjectType);\n(0, _defineToJSON.default)(GraphQLObjectType);\n\nfunction defineInterfaces(config) {\n  var interfaces = resolveThunk(config.interfaces) || [];\n  !Array.isArray(interfaces) ? (0, _invariant.default)(0, \"\".concat(config.name, \" interfaces must be an Array or a function which returns \") + 'an Array.') : void 0;\n  return interfaces;\n}\n\nfunction defineFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  !isPlainObj(fieldMap) ? (0, _invariant.default)(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a \") + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n\n  var _arr = Object.keys(fieldMap);\n\n  var _loop = function _loop() {\n    var fieldName = _arr[_i];\n    var fieldConfig = fieldMap[fieldName];\n    !isPlainObj(fieldConfig) ? (0, _invariant.default)(0, \"\".concat(config.name, \".\").concat(fieldName, \" field config must be an object\")) : void 0;\n    !!fieldConfig.hasOwnProperty('isDeprecated') ? (0, _invariant.default)(0, \"\".concat(config.name, \".\").concat(fieldName, \" should provide \\\"deprecationReason\\\" \") + 'instead of \"isDeprecated\".') : void 0;\n\n    var field = _objectSpread({}, fieldConfig, {\n      isDeprecated: Boolean(fieldConfig.deprecationReason),\n      name: fieldName\n    });\n\n    !(field.resolve == null || typeof field.resolve === 'function') ? (0, _invariant.default)(0, \"\".concat(config.name, \".\").concat(fieldName, \" field resolver must be a function if \") + \"provided, but got: \".concat((0, _inspect.default)(field.resolve), \".\")) : void 0;\n    var argsConfig = fieldConfig.args;\n\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      !isPlainObj(argsConfig) ? (0, _invariant.default)(0, \"\".concat(config.name, \".\").concat(fieldName, \" args must be an object with argument \") + 'names as keys.') : void 0;\n      field.args = Object.keys(argsConfig).map(function (argName) {\n        var arg = argsConfig[argName];\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n\n    resultFieldMap[fieldName] = field;\n  };\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    _loop();\n  }\n\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);\n}\n\nfunction isRequiredArgument(arg) {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nvar GraphQLInterfaceType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInterfaceType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"resolveType\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._fields = defineFieldMap.bind(undefined, config);\n    !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;\n    !(config.resolveType == null || typeof config.resolveType === 'function') ? (0, _invariant.default)(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat((0, _inspect.default)(config.resolveType), \".\")) : void 0;\n  }\n\n  var _proto3 = GraphQLInterfaceType.prototype;\n\n  _proto3.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto3.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInterfaceType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLInterfaceType = GraphQLInterfaceType;\n(0, _defineToStringTag.default)(GraphQLInterfaceType);\n(0, _defineToJSON.default)(GraphQLInterfaceType);\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nvar GraphQLUnionType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLUnionType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"resolveType\", void 0);\n\n    _defineProperty(this, \"_types\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this.resolveType = config.resolveType;\n    this._types = defineTypes.bind(undefined, config);\n    !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;\n    !(config.resolveType == null || typeof config.resolveType === 'function') ? (0, _invariant.default)(0, \"\".concat(this.name, \" must provide \\\"resolveType\\\" as a function, \") + \"but got: \".concat((0, _inspect.default)(config.resolveType), \".\")) : void 0;\n  }\n\n  var _proto4 = GraphQLUnionType.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n\n    return this._types;\n  };\n\n  _proto4.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLUnionType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLUnionType = GraphQLUnionType;\n(0, _defineToStringTag.default)(GraphQLUnionType);\n(0, _defineToJSON.default)(GraphQLUnionType);\n\nfunction defineTypes(config) {\n  var types = resolveThunk(config.types) || [];\n  !Array.isArray(types) ? (0, _invariant.default)(0, 'Must provide Array of types or a function which returns ' + \"such an array for Union \".concat(config.name, \".\")) : void 0;\n  return types;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nvar GraphQLEnumType\n/* <T> */\n=\n/*#__PURE__*/\nfunction () {\n  function GraphQLEnumType(config\n  /* <T> */\n  ) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    _defineProperty(this, \"_valueLookup\", void 0);\n\n    _defineProperty(this, \"_nameLookup\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._values = defineEnumValues(this, config.values);\n    this._valueLookup = new Map(this._values.map(function (enumValue) {\n      return [enumValue.value, enumValue];\n    }));\n    this._nameLookup = (0, _keyMap.default)(this._values, function (value) {\n      return value.name;\n    });\n    !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;\n  }\n\n  var _proto5 = GraphQLEnumType.prototype;\n\n  _proto5.getValues = function getValues() {\n    return this._values;\n  };\n\n  _proto5.getValue = function getValue(name) {\n    return this._nameLookup[name];\n  };\n\n  _proto5.serialize = function serialize(value\n  /* T */\n  ) {\n    var enumValue = this._valueLookup.get(value);\n\n    if (enumValue) {\n      return enumValue.name;\n    }\n  };\n\n  _proto5.parseValue = function parseValue(value)\n  /* T */\n  {\n    if (typeof value === 'string') {\n      var enumValue = this.getValue(value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)\n  /* T */\n  {\n    // Note: variables will be resolved to a value before calling this function.\n    if (valueNode.kind === _kinds.Kind.ENUM) {\n      var enumValue = this.getValue(valueNode.value);\n\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  };\n\n  _proto5.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLEnumType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLEnumType = GraphQLEnumType;\n(0, _defineToStringTag.default)(GraphQLEnumType);\n(0, _defineToJSON.default)(GraphQLEnumType);\n\nfunction defineEnumValues(type, valueMap\n/* <T> */\n) {\n  !isPlainObj(valueMap) ? (0, _invariant.default)(0, \"\".concat(type.name, \" values must be an object with value names as keys.\")) : void 0;\n  return Object.keys(valueMap).map(function (valueName) {\n    var value = valueMap[valueName];\n    !isPlainObj(value) ? (0, _invariant.default)(0, \"\".concat(type.name, \".\").concat(valueName, \" must refer to an object with a \\\"value\\\" key \") + \"representing an internal value but got: \".concat((0, _inspect.default)(value), \".\")) : void 0;\n    !!value.hasOwnProperty('isDeprecated') ? (0, _invariant.default)(0, \"\".concat(type.name, \".\").concat(valueName, \" should provide \\\"deprecationReason\\\" instead \") + 'of \"isDeprecated\".') : void 0;\n    return {\n      name: valueName,\n      description: value.description,\n      isDeprecated: Boolean(value.deprecationReason),\n      deprecationReason: value.deprecationReason,\n      astNode: value.astNode,\n      value: value.hasOwnProperty('value') ? value.value : valueName\n    };\n  });\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nvar GraphQLInputObjectType =\n/*#__PURE__*/\nfunction () {\n  function GraphQLInputObjectType(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_fields\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes;\n    this._fields = defineInputFieldMap.bind(undefined, config);\n    !(typeof config.name === 'string') ? (0, _invariant.default)(0, 'Must provide name.') : void 0;\n  }\n\n  var _proto6 = GraphQLInputObjectType.prototype;\n\n  _proto6.getFields = function getFields() {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n\n    return this._fields;\n  };\n\n  _proto6.toString = function toString() {\n    return this.name;\n  };\n\n  return GraphQLInputObjectType;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLInputObjectType = GraphQLInputObjectType;\n(0, _defineToStringTag.default)(GraphQLInputObjectType);\n(0, _defineToJSON.default)(GraphQLInputObjectType);\n\nfunction defineInputFieldMap(config) {\n  var fieldMap = resolveThunk(config.fields) || {};\n  !isPlainObj(fieldMap) ? (0, _invariant.default)(0, \"\".concat(config.name, \" fields must be an object with field names as keys or a \") + 'function which returns such an object.') : void 0;\n  var resultFieldMap = Object.create(null);\n\n  var _arr2 = Object.keys(fieldMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var fieldName = _arr2[_i2];\n\n    var field = _objectSpread({}, fieldMap[fieldName], {\n      name: fieldName\n    });\n\n    !!field.hasOwnProperty('resolve') ? (0, _invariant.default)(0, \"\".concat(config.name, \".\").concat(fieldName, \" field has a resolve property, but \") + 'Input Types cannot define resolvers.') : void 0;\n    resultFieldMap[fieldName] = field;\n  }\n\n  return resultFieldMap;\n}\n\nfunction isRequiredInputField(field) {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/type/definition.js?");

/***/ }),

/***/ "./node_modules/graphql/type/directives.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/type/directives.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDirective = isDirective;\nexports.isSpecifiedDirective = isSpecifiedDirective;\nexports.specifiedDirectives = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = void 0;\n\nvar _definition = __webpack_require__(/*! ./definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _scalars = __webpack_require__(/*! ./scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _defineToStringTag = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineToStringTag */ \"./node_modules/graphql/jsutils/defineToStringTag.js\"));\n\nvar _defineToJSON = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineToJSON */ \"./node_modules/graphql/jsutils/defineToJSON.js\"));\n\nvar _instanceOf = _interopRequireDefault(__webpack_require__(/*! ../jsutils/instanceOf */ \"./node_modules/graphql/jsutils/instanceOf.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _directiveLocation = __webpack_require__(/*! ../language/directiveLocation */ \"./node_modules/graphql/language/directiveLocation.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// eslint-disable-next-line no-redeclare\nfunction isDirective(directive) {\n  return (0, _instanceOf.default)(directive, GraphQLDirective);\n}\n/**\n * Directives are used by the GraphQL runtime as a way of modifying execution\n * behavior. Type system creators will usually not create these directly.\n */\n\n\nvar GraphQLDirective =\n/*#__PURE__*/\nfunction () {\n  function GraphQLDirective(config) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"description\", void 0);\n\n    _defineProperty(this, \"locations\", void 0);\n\n    _defineProperty(this, \"args\", void 0);\n\n    _defineProperty(this, \"astNode\", void 0);\n\n    this.name = config.name;\n    this.description = config.description;\n    this.locations = config.locations;\n    this.astNode = config.astNode;\n    !config.name ? (0, _invariant.default)(0, 'Directive must be named.') : void 0;\n    !Array.isArray(config.locations) ? (0, _invariant.default)(0, 'Must provide locations for directive.') : void 0;\n    var args = config.args;\n\n    if (!args) {\n      this.args = [];\n    } else {\n      !!Array.isArray(args) ? (0, _invariant.default)(0, \"@\".concat(config.name, \" args must be an object with argument names as keys.\")) : void 0;\n      this.args = Object.keys(args).map(function (argName) {\n        var arg = args[argName];\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue,\n          astNode: arg.astNode\n        };\n      });\n    }\n  }\n\n  var _proto = GraphQLDirective.prototype;\n\n  _proto.toString = function toString() {\n    return '@' + this.name;\n  };\n\n  return GraphQLDirective;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLDirective = GraphQLDirective;\n(0, _defineToStringTag.default)(GraphQLDirective);\n(0, _defineToJSON.default)(GraphQLDirective);\n\n/**\n * Used to conditionally include fields or fragments.\n */\nvar GraphQLIncludeDirective = new GraphQLDirective({\n  name: 'include',\n  description: 'Directs the executor to include this field or fragment only when ' + 'the `if` argument is true.',\n  locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],\n  args: {\n    if: {\n      type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),\n      description: 'Included when true.'\n    }\n  }\n});\n/**\n * Used to conditionally skip (exclude) fields or fragments.\n */\n\nexports.GraphQLIncludeDirective = GraphQLIncludeDirective;\nvar GraphQLSkipDirective = new GraphQLDirective({\n  name: 'skip',\n  description: 'Directs the executor to skip this field or fragment when the `if` ' + 'argument is true.',\n  locations: [_directiveLocation.DirectiveLocation.FIELD, _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD, _directiveLocation.DirectiveLocation.INLINE_FRAGMENT],\n  args: {\n    if: {\n      type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),\n      description: 'Skipped when true.'\n    }\n  }\n});\n/**\n * Constant string used for default reason for a deprecation.\n */\n\nexports.GraphQLSkipDirective = GraphQLSkipDirective;\nvar DEFAULT_DEPRECATION_REASON = 'No longer supported';\n/**\n * Used to declare element of a GraphQL schema as deprecated.\n */\n\nexports.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;\nvar GraphQLDeprecatedDirective = new GraphQLDirective({\n  name: 'deprecated',\n  description: 'Marks an element of a GraphQL schema as no longer supported.',\n  locations: [_directiveLocation.DirectiveLocation.FIELD_DEFINITION, _directiveLocation.DirectiveLocation.ENUM_VALUE],\n  args: {\n    reason: {\n      type: _scalars.GraphQLString,\n      description: 'Explains why this element was deprecated, usually also including a ' + 'suggestion for how to access supported similar data. Formatted using ' + 'the Markdown syntax (as specified by [CommonMark](https://commonmark.org/).',\n      defaultValue: DEFAULT_DEPRECATION_REASON\n    }\n  }\n});\n/**\n * The full list of specified directives.\n */\n\nexports.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective;\nvar specifiedDirectives = [GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective];\nexports.specifiedDirectives = specifiedDirectives;\n\nfunction isSpecifiedDirective(directive) {\n  return specifiedDirectives.some(function (specifiedDirective) {\n    return specifiedDirective.name === directive.name;\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/type/directives.js?");

/***/ }),

/***/ "./node_modules/graphql/type/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphql/type/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"isSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _schema.isSchema;\n  }\n});\nObject.defineProperty(exports, \"GraphQLSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _schema.GraphQLSchema;\n  }\n});\nObject.defineProperty(exports, \"isType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isType;\n  }\n});\nObject.defineProperty(exports, \"isScalarType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isScalarType;\n  }\n});\nObject.defineProperty(exports, \"isObjectType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isObjectType;\n  }\n});\nObject.defineProperty(exports, \"isInterfaceType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isInterfaceType;\n  }\n});\nObject.defineProperty(exports, \"isUnionType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isUnionType;\n  }\n});\nObject.defineProperty(exports, \"isEnumType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isEnumType;\n  }\n});\nObject.defineProperty(exports, \"isInputObjectType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isInputObjectType;\n  }\n});\nObject.defineProperty(exports, \"isListType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isListType;\n  }\n});\nObject.defineProperty(exports, \"isNonNullType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isNonNullType;\n  }\n});\nObject.defineProperty(exports, \"isInputType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isInputType;\n  }\n});\nObject.defineProperty(exports, \"isOutputType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isOutputType;\n  }\n});\nObject.defineProperty(exports, \"isLeafType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isLeafType;\n  }\n});\nObject.defineProperty(exports, \"isCompositeType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isCompositeType;\n  }\n});\nObject.defineProperty(exports, \"isAbstractType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isAbstractType;\n  }\n});\nObject.defineProperty(exports, \"isWrappingType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isWrappingType;\n  }\n});\nObject.defineProperty(exports, \"isNullableType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isNullableType;\n  }\n});\nObject.defineProperty(exports, \"isNamedType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isNamedType;\n  }\n});\nObject.defineProperty(exports, \"isRequiredArgument\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isRequiredArgument;\n  }\n});\nObject.defineProperty(exports, \"isRequiredInputField\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.isRequiredInputField;\n  }\n});\nObject.defineProperty(exports, \"assertType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertType;\n  }\n});\nObject.defineProperty(exports, \"assertScalarType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertScalarType;\n  }\n});\nObject.defineProperty(exports, \"assertObjectType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertObjectType;\n  }\n});\nObject.defineProperty(exports, \"assertInterfaceType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertInterfaceType;\n  }\n});\nObject.defineProperty(exports, \"assertUnionType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertUnionType;\n  }\n});\nObject.defineProperty(exports, \"assertEnumType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertEnumType;\n  }\n});\nObject.defineProperty(exports, \"assertInputObjectType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertInputObjectType;\n  }\n});\nObject.defineProperty(exports, \"assertListType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertListType;\n  }\n});\nObject.defineProperty(exports, \"assertNonNullType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertNonNullType;\n  }\n});\nObject.defineProperty(exports, \"assertInputType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertInputType;\n  }\n});\nObject.defineProperty(exports, \"assertOutputType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertOutputType;\n  }\n});\nObject.defineProperty(exports, \"assertLeafType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertLeafType;\n  }\n});\nObject.defineProperty(exports, \"assertCompositeType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertCompositeType;\n  }\n});\nObject.defineProperty(exports, \"assertAbstractType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertAbstractType;\n  }\n});\nObject.defineProperty(exports, \"assertWrappingType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertWrappingType;\n  }\n});\nObject.defineProperty(exports, \"assertNullableType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertNullableType;\n  }\n});\nObject.defineProperty(exports, \"assertNamedType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.assertNamedType;\n  }\n});\nObject.defineProperty(exports, \"getNullableType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.getNullableType;\n  }\n});\nObject.defineProperty(exports, \"getNamedType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.getNamedType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLScalarType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLScalarType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLObjectType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLObjectType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLInterfaceType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLInterfaceType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLUnionType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLUnionType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLEnumType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLEnumType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLInputObjectType\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLInputObjectType;\n  }\n});\nObject.defineProperty(exports, \"GraphQLList\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLList;\n  }\n});\nObject.defineProperty(exports, \"GraphQLNonNull\", {\n  enumerable: true,\n  get: function get() {\n    return _definition.GraphQLNonNull;\n  }\n});\nObject.defineProperty(exports, \"isDirective\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.isDirective;\n  }\n});\nObject.defineProperty(exports, \"GraphQLDirective\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.GraphQLDirective;\n  }\n});\nObject.defineProperty(exports, \"isSpecifiedDirective\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.isSpecifiedDirective;\n  }\n});\nObject.defineProperty(exports, \"specifiedDirectives\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.specifiedDirectives;\n  }\n});\nObject.defineProperty(exports, \"GraphQLIncludeDirective\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.GraphQLIncludeDirective;\n  }\n});\nObject.defineProperty(exports, \"GraphQLSkipDirective\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.GraphQLSkipDirective;\n  }\n});\nObject.defineProperty(exports, \"GraphQLDeprecatedDirective\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.GraphQLDeprecatedDirective;\n  }\n});\nObject.defineProperty(exports, \"DEFAULT_DEPRECATION_REASON\", {\n  enumerable: true,\n  get: function get() {\n    return _directives.DEFAULT_DEPRECATION_REASON;\n  }\n});\nObject.defineProperty(exports, \"isSpecifiedScalarType\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.isSpecifiedScalarType;\n  }\n});\nObject.defineProperty(exports, \"specifiedScalarTypes\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.specifiedScalarTypes;\n  }\n});\nObject.defineProperty(exports, \"GraphQLInt\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLInt;\n  }\n});\nObject.defineProperty(exports, \"GraphQLFloat\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLFloat;\n  }\n});\nObject.defineProperty(exports, \"GraphQLString\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLString;\n  }\n});\nObject.defineProperty(exports, \"GraphQLBoolean\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLBoolean;\n  }\n});\nObject.defineProperty(exports, \"GraphQLID\", {\n  enumerable: true,\n  get: function get() {\n    return _scalars.GraphQLID;\n  }\n});\nObject.defineProperty(exports, \"TypeKind\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.TypeKind;\n  }\n});\nObject.defineProperty(exports, \"isIntrospectionType\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.isIntrospectionType;\n  }\n});\nObject.defineProperty(exports, \"introspectionTypes\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.introspectionTypes;\n  }\n});\nObject.defineProperty(exports, \"__Schema\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__Schema;\n  }\n});\nObject.defineProperty(exports, \"__Directive\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__Directive;\n  }\n});\nObject.defineProperty(exports, \"__DirectiveLocation\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__DirectiveLocation;\n  }\n});\nObject.defineProperty(exports, \"__Type\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__Type;\n  }\n});\nObject.defineProperty(exports, \"__Field\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__Field;\n  }\n});\nObject.defineProperty(exports, \"__InputValue\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__InputValue;\n  }\n});\nObject.defineProperty(exports, \"__EnumValue\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__EnumValue;\n  }\n});\nObject.defineProperty(exports, \"__TypeKind\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.__TypeKind;\n  }\n});\nObject.defineProperty(exports, \"SchemaMetaFieldDef\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.SchemaMetaFieldDef;\n  }\n});\nObject.defineProperty(exports, \"TypeMetaFieldDef\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.TypeMetaFieldDef;\n  }\n});\nObject.defineProperty(exports, \"TypeNameMetaFieldDef\", {\n  enumerable: true,\n  get: function get() {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n});\nObject.defineProperty(exports, \"validateSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _validate.validateSchema;\n  }\n});\nObject.defineProperty(exports, \"assertValidSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _validate.assertValidSchema;\n  }\n});\n\nvar _schema = __webpack_require__(/*! ./schema */ \"./node_modules/graphql/type/schema.js\");\n\nvar _definition = __webpack_require__(/*! ./definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _directives = __webpack_require__(/*! ./directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _scalars = __webpack_require__(/*! ./scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _introspection = __webpack_require__(/*! ./introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _validate = __webpack_require__(/*! ./validate */ \"./node_modules/graphql/type/validate.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/type/index.js?");

/***/ }),

/***/ "./node_modules/graphql/type/introspection.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/type/introspection.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isIntrospectionType = isIntrospectionType;\nexports.introspectionTypes = exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = void 0;\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _astFromValue = __webpack_require__(/*! ../utilities/astFromValue */ \"./node_modules/graphql/utilities/astFromValue.js\");\n\nvar _printer = __webpack_require__(/*! ../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ./definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _scalars = __webpack_require__(/*! ./scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _directiveLocation = __webpack_require__(/*! ../language/directiveLocation */ \"./node_modules/graphql/language/directiveLocation.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nvar __Schema = new _definition.GraphQLObjectType({\n  name: '__Schema',\n  description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It ' + 'exposes all available types and directives on the server, as well as ' + 'the entry points for query, mutation, and subscription operations.',\n  fields: function fields() {\n    return {\n      types: {\n        description: 'A list of all types supported by this server.',\n        type: (0, _definition.GraphQLNonNull)((0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__Type))),\n        resolve: function resolve(schema) {\n          return (0, _objectValues.default)(schema.getTypeMap());\n        }\n      },\n      queryType: {\n        description: 'The type that query operations will be rooted at.',\n        type: (0, _definition.GraphQLNonNull)(__Type),\n        resolve: function resolve(schema) {\n          return schema.getQueryType();\n        }\n      },\n      mutationType: {\n        description: 'If this server supports mutation, the type that ' + 'mutation operations will be rooted at.',\n        type: __Type,\n        resolve: function resolve(schema) {\n          return schema.getMutationType();\n        }\n      },\n      subscriptionType: {\n        description: 'If this server support subscription, the type that ' + 'subscription operations will be rooted at.',\n        type: __Type,\n        resolve: function resolve(schema) {\n          return schema.getSubscriptionType();\n        }\n      },\n      directives: {\n        description: 'A list of all directives supported by this server.',\n        type: (0, _definition.GraphQLNonNull)((0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__Directive))),\n        resolve: function resolve(schema) {\n          return schema.getDirectives();\n        }\n      }\n    };\n  }\n});\n\nexports.__Schema = __Schema;\n\nvar __Directive = new _definition.GraphQLObjectType({\n  name: '__Directive',\n  description: 'A Directive provides a way to describe alternate runtime execution and ' + 'type validation behavior in a GraphQL document.' + \"\\n\\nIn some cases, you need to provide options to alter GraphQL's \" + 'execution behavior in ways field arguments will not suffice, such as ' + 'conditionally including or skipping a field. Directives provide this by ' + 'describing additional information to the executor.',\n  fields: function fields() {\n    return {\n      name: {\n        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLString),\n        resolve: function resolve(obj) {\n          return obj.name;\n        }\n      },\n      description: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.description;\n        }\n      },\n      locations: {\n        type: (0, _definition.GraphQLNonNull)((0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__DirectiveLocation))),\n        resolve: function resolve(obj) {\n          return obj.locations;\n        }\n      },\n      args: {\n        type: (0, _definition.GraphQLNonNull)((0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__InputValue))),\n        resolve: function resolve(directive) {\n          return directive.args || [];\n        }\n      }\n    };\n  }\n});\n\nexports.__Directive = __Directive;\n\nvar __DirectiveLocation = new _definition.GraphQLEnumType({\n  name: '__DirectiveLocation',\n  description: 'A Directive can be adjacent to many parts of the GraphQL language, a ' + '__DirectiveLocation describes one such possible adjacencies.',\n  values: {\n    QUERY: {\n      value: _directiveLocation.DirectiveLocation.QUERY,\n      description: 'Location adjacent to a query operation.'\n    },\n    MUTATION: {\n      value: _directiveLocation.DirectiveLocation.MUTATION,\n      description: 'Location adjacent to a mutation operation.'\n    },\n    SUBSCRIPTION: {\n      value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,\n      description: 'Location adjacent to a subscription operation.'\n    },\n    FIELD: {\n      value: _directiveLocation.DirectiveLocation.FIELD,\n      description: 'Location adjacent to a field.'\n    },\n    FRAGMENT_DEFINITION: {\n      value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,\n      description: 'Location adjacent to a fragment definition.'\n    },\n    FRAGMENT_SPREAD: {\n      value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,\n      description: 'Location adjacent to a fragment spread.'\n    },\n    INLINE_FRAGMENT: {\n      value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,\n      description: 'Location adjacent to an inline fragment.'\n    },\n    VARIABLE_DEFINITION: {\n      value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,\n      description: 'Location adjacent to a variable definition.'\n    },\n    SCHEMA: {\n      value: _directiveLocation.DirectiveLocation.SCHEMA,\n      description: 'Location adjacent to a schema definition.'\n    },\n    SCALAR: {\n      value: _directiveLocation.DirectiveLocation.SCALAR,\n      description: 'Location adjacent to a scalar definition.'\n    },\n    OBJECT: {\n      value: _directiveLocation.DirectiveLocation.OBJECT,\n      description: 'Location adjacent to an object type definition.'\n    },\n    FIELD_DEFINITION: {\n      value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,\n      description: 'Location adjacent to a field definition.'\n    },\n    ARGUMENT_DEFINITION: {\n      value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,\n      description: 'Location adjacent to an argument definition.'\n    },\n    INTERFACE: {\n      value: _directiveLocation.DirectiveLocation.INTERFACE,\n      description: 'Location adjacent to an interface definition.'\n    },\n    UNION: {\n      value: _directiveLocation.DirectiveLocation.UNION,\n      description: 'Location adjacent to a union definition.'\n    },\n    ENUM: {\n      value: _directiveLocation.DirectiveLocation.ENUM,\n      description: 'Location adjacent to an enum definition.'\n    },\n    ENUM_VALUE: {\n      value: _directiveLocation.DirectiveLocation.ENUM_VALUE,\n      description: 'Location adjacent to an enum value definition.'\n    },\n    INPUT_OBJECT: {\n      value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,\n      description: 'Location adjacent to an input object type definition.'\n    },\n    INPUT_FIELD_DEFINITION: {\n      value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,\n      description: 'Location adjacent to an input object field definition.'\n    }\n  }\n});\n\nexports.__DirectiveLocation = __DirectiveLocation;\n\nvar __Type = new _definition.GraphQLObjectType({\n  name: '__Type',\n  description: 'The fundamental unit of any GraphQL Schema is the type. There are ' + 'many kinds of types in GraphQL as represented by the `__TypeKind` enum.' + '\\n\\nDepending on the kind of a type, certain fields describe ' + 'information about that type. Scalar types provide no information ' + 'beyond a name and description, while Enum types provide their values. ' + 'Object and Interface types provide the fields they describe. Abstract ' + 'types, Union and Interface, provide the Object types possible ' + 'at runtime. List and NonNull types compose other types.',\n  fields: function fields() {\n    return {\n      kind: {\n        type: (0, _definition.GraphQLNonNull)(__TypeKind),\n        resolve: function resolve(type) {\n          if ((0, _definition.isScalarType)(type)) {\n            return TypeKind.SCALAR;\n          } else if ((0, _definition.isObjectType)(type)) {\n            return TypeKind.OBJECT;\n          } else if ((0, _definition.isInterfaceType)(type)) {\n            return TypeKind.INTERFACE;\n          } else if ((0, _definition.isUnionType)(type)) {\n            return TypeKind.UNION;\n          } else if ((0, _definition.isEnumType)(type)) {\n            return TypeKind.ENUM;\n          } else if ((0, _definition.isInputObjectType)(type)) {\n            return TypeKind.INPUT_OBJECT;\n          } else if ((0, _definition.isListType)(type)) {\n            return TypeKind.LIST;\n          } else if ((0, _definition.isNonNullType)(type)) {\n            return TypeKind.NON_NULL;\n          }\n\n          throw new Error('Unknown kind of type: ' + type);\n        }\n      },\n      name: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.name;\n        }\n      },\n      description: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.description;\n        }\n      },\n      fields: {\n        type: (0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__Field)),\n        args: {\n          includeDeprecated: {\n            type: _scalars.GraphQLBoolean,\n            defaultValue: false\n          }\n        },\n        resolve: function resolve(type, _ref) {\n          var includeDeprecated = _ref.includeDeprecated;\n\n          if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {\n            var fields = (0, _objectValues.default)(type.getFields());\n\n            if (!includeDeprecated) {\n              fields = fields.filter(function (field) {\n                return !field.deprecationReason;\n              });\n            }\n\n            return fields;\n          }\n\n          return null;\n        }\n      },\n      interfaces: {\n        type: (0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__Type)),\n        resolve: function resolve(type) {\n          if ((0, _definition.isObjectType)(type)) {\n            return type.getInterfaces();\n          }\n        }\n      },\n      possibleTypes: {\n        type: (0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__Type)),\n        resolve: function resolve(type, args, context, _ref2) {\n          var schema = _ref2.schema;\n\n          if ((0, _definition.isAbstractType)(type)) {\n            return schema.getPossibleTypes(type);\n          }\n        }\n      },\n      enumValues: {\n        type: (0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__EnumValue)),\n        args: {\n          includeDeprecated: {\n            type: _scalars.GraphQLBoolean,\n            defaultValue: false\n          }\n        },\n        resolve: function resolve(type, _ref3) {\n          var includeDeprecated = _ref3.includeDeprecated;\n\n          if ((0, _definition.isEnumType)(type)) {\n            var values = type.getValues();\n\n            if (!includeDeprecated) {\n              values = values.filter(function (value) {\n                return !value.deprecationReason;\n              });\n            }\n\n            return values;\n          }\n        }\n      },\n      inputFields: {\n        type: (0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__InputValue)),\n        resolve: function resolve(type) {\n          if ((0, _definition.isInputObjectType)(type)) {\n            return (0, _objectValues.default)(type.getFields());\n          }\n        }\n      },\n      ofType: {\n        type: __Type,\n        resolve: function resolve(obj) {\n          return obj.ofType;\n        }\n      }\n    };\n  }\n});\n\nexports.__Type = __Type;\n\nvar __Field = new _definition.GraphQLObjectType({\n  name: '__Field',\n  description: 'Object and Interface types are described by a list of Fields, each of ' + 'which has a name, potentially a list of arguments, and a return type.',\n  fields: function fields() {\n    return {\n      name: {\n        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLString),\n        resolve: function resolve(obj) {\n          return obj.name;\n        }\n      },\n      description: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.description;\n        }\n      },\n      args: {\n        type: (0, _definition.GraphQLNonNull)((0, _definition.GraphQLList)((0, _definition.GraphQLNonNull)(__InputValue))),\n        resolve: function resolve(field) {\n          return field.args || [];\n        }\n      },\n      type: {\n        type: (0, _definition.GraphQLNonNull)(__Type),\n        resolve: function resolve(obj) {\n          return obj.type;\n        }\n      },\n      isDeprecated: {\n        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),\n        resolve: function resolve(obj) {\n          return obj.isDeprecated;\n        }\n      },\n      deprecationReason: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.deprecationReason;\n        }\n      }\n    };\n  }\n});\n\nexports.__Field = __Field;\n\nvar __InputValue = new _definition.GraphQLObjectType({\n  name: '__InputValue',\n  description: 'Arguments provided to Fields or Directives and the input fields of an ' + 'InputObject are represented as Input Values which describe their type ' + 'and optionally a default value.',\n  fields: function fields() {\n    return {\n      name: {\n        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLString),\n        resolve: function resolve(obj) {\n          return obj.name;\n        }\n      },\n      description: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.description;\n        }\n      },\n      type: {\n        type: (0, _definition.GraphQLNonNull)(__Type),\n        resolve: function resolve(obj) {\n          return obj.type;\n        }\n      },\n      defaultValue: {\n        type: _scalars.GraphQLString,\n        description: 'A GraphQL-formatted string representing the default value for this ' + 'input value.',\n        resolve: function resolve(inputVal) {\n          return (0, _isInvalid.default)(inputVal.defaultValue) ? null : (0, _printer.print)((0, _astFromValue.astFromValue)(inputVal.defaultValue, inputVal.type));\n        }\n      }\n    };\n  }\n});\n\nexports.__InputValue = __InputValue;\n\nvar __EnumValue = new _definition.GraphQLObjectType({\n  name: '__EnumValue',\n  description: 'One possible value for a given Enum. Enum values are unique values, not ' + 'a placeholder for a string or numeric value. However an Enum value is ' + 'returned in a JSON response as a string.',\n  fields: function fields() {\n    return {\n      name: {\n        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLString),\n        resolve: function resolve(obj) {\n          return obj.name;\n        }\n      },\n      description: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.description;\n        }\n      },\n      isDeprecated: {\n        type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLBoolean),\n        resolve: function resolve(obj) {\n          return obj.isDeprecated;\n        }\n      },\n      deprecationReason: {\n        type: _scalars.GraphQLString,\n        resolve: function resolve(obj) {\n          return obj.deprecationReason;\n        }\n      }\n    };\n  }\n});\n\nexports.__EnumValue = __EnumValue;\nvar TypeKind = {\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  LIST: 'LIST',\n  NON_NULL: 'NON_NULL'\n};\nexports.TypeKind = TypeKind;\n\nvar __TypeKind = new _definition.GraphQLEnumType({\n  name: '__TypeKind',\n  description: 'An enum describing what kind of type a given `__Type` is.',\n  values: {\n    SCALAR: {\n      value: TypeKind.SCALAR,\n      description: 'Indicates this type is a scalar.'\n    },\n    OBJECT: {\n      value: TypeKind.OBJECT,\n      description: 'Indicates this type is an object. ' + '`fields` and `interfaces` are valid fields.'\n    },\n    INTERFACE: {\n      value: TypeKind.INTERFACE,\n      description: 'Indicates this type is an interface. ' + '`fields` and `possibleTypes` are valid fields.'\n    },\n    UNION: {\n      value: TypeKind.UNION,\n      description: 'Indicates this type is a union. `possibleTypes` is a valid field.'\n    },\n    ENUM: {\n      value: TypeKind.ENUM,\n      description: 'Indicates this type is an enum. `enumValues` is a valid field.'\n    },\n    INPUT_OBJECT: {\n      value: TypeKind.INPUT_OBJECT,\n      description: 'Indicates this type is an input object. ' + '`inputFields` is a valid field.'\n    },\n    LIST: {\n      value: TypeKind.LIST,\n      description: 'Indicates this type is a list. `ofType` is a valid field.'\n    },\n    NON_NULL: {\n      value: TypeKind.NON_NULL,\n      description: 'Indicates this type is a non-null. `ofType` is a valid field.'\n    }\n  }\n});\n/**\n * Note that these are GraphQLField and not GraphQLFieldConfig,\n * so the format for args is different.\n */\n\n\nexports.__TypeKind = __TypeKind;\nvar SchemaMetaFieldDef = {\n  name: '__schema',\n  type: (0, _definition.GraphQLNonNull)(__Schema),\n  description: 'Access the current type schema of this server.',\n  args: [],\n  resolve: function resolve(source, args, context, _ref4) {\n    var schema = _ref4.schema;\n    return schema;\n  }\n};\nexports.SchemaMetaFieldDef = SchemaMetaFieldDef;\nvar TypeMetaFieldDef = {\n  name: '__type',\n  type: __Type,\n  description: 'Request the type information of a single type.',\n  args: [{\n    name: 'name',\n    type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLString)\n  }],\n  resolve: function resolve(source, _ref5, context, _ref6) {\n    var name = _ref5.name;\n    var schema = _ref6.schema;\n    return schema.getType(name);\n  }\n};\nexports.TypeMetaFieldDef = TypeMetaFieldDef;\nvar TypeNameMetaFieldDef = {\n  name: '__typename',\n  type: (0, _definition.GraphQLNonNull)(_scalars.GraphQLString),\n  description: 'The name of the current Object type at runtime.',\n  args: [],\n  resolve: function resolve(source, args, context, _ref7) {\n    var parentType = _ref7.parentType;\n    return parentType.name;\n  }\n};\nexports.TypeNameMetaFieldDef = TypeNameMetaFieldDef;\nvar introspectionTypes = [__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind];\nexports.introspectionTypes = introspectionTypes;\n\nfunction isIntrospectionType(type) {\n  return (0, _definition.isNamedType)(type) && ( // Would prefer to use introspectionTypes.some(), however %checks needs\n  // a simple expression.\n  type.name === __Schema.name || type.name === __Directive.name || type.name === __DirectiveLocation.name || type.name === __Type.name || type.name === __Field.name || type.name === __InputValue.name || type.name === __EnumValue.name || type.name === __TypeKind.name);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/type/introspection.js?");

/***/ }),

/***/ "./node_modules/graphql/type/scalars.js":
/*!**********************************************!*\
  !*** ./node_modules/graphql/type/scalars.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSpecifiedScalarType = isSpecifiedScalarType;\nexports.specifiedScalarTypes = exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = void 0;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _isFinite = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isFinite */ \"./node_modules/graphql/jsutils/isFinite.js\"));\n\nvar _isInteger = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInteger */ \"./node_modules/graphql/jsutils/isInteger.js\"));\n\nvar _definition = __webpack_require__(/*! ./definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n// As per the GraphQL Spec, Integers are only treated as valid when a valid\n// 32-bit signed integer, providing the broadest support across platforms.\n//\n// n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because\n// they are internally represented as IEEE 754 doubles.\nvar MAX_INT = 2147483647;\nvar MIN_INT = -2147483648;\n\nfunction serializeInt(value) {\n  if (typeof value === 'boolean') {\n    return value ? 1 : 0;\n  }\n\n  var num = value;\n\n  if (typeof value === 'string' && value !== '') {\n    num = Number(value);\n  }\n\n  if (!(0, _isInteger.default)(num)) {\n    throw new TypeError(\"Int cannot represent non-integer value: \".concat((0, _inspect.default)(value)));\n  }\n\n  if (num > MAX_INT || num < MIN_INT) {\n    throw new TypeError(\"Int cannot represent non 32-bit signed integer value: \".concat((0, _inspect.default)(value)));\n  }\n\n  return num;\n}\n\nfunction coerceInt(value) {\n  if (!(0, _isInteger.default)(value)) {\n    throw new TypeError(\"Int cannot represent non-integer value: \".concat((0, _inspect.default)(value)));\n  }\n\n  if (value > MAX_INT || value < MIN_INT) {\n    throw new TypeError(\"Int cannot represent non 32-bit signed integer value: \".concat((0, _inspect.default)(value)));\n  }\n\n  return value;\n}\n\nvar GraphQLInt = new _definition.GraphQLScalarType({\n  name: 'Int',\n  description: 'The `Int` scalar type represents non-fractional signed whole numeric ' + 'values. Int can represent values between -(2^31) and 2^31 - 1. ',\n  serialize: serializeInt,\n  parseValue: coerceInt,\n  parseLiteral: function parseLiteral(ast) {\n    if (ast.kind === _kinds.Kind.INT) {\n      var num = parseInt(ast.value, 10);\n\n      if (num <= MAX_INT && num >= MIN_INT) {\n        return num;\n      }\n    }\n\n    return undefined;\n  }\n});\nexports.GraphQLInt = GraphQLInt;\n\nfunction serializeFloat(value) {\n  if (typeof value === 'boolean') {\n    return value ? 1 : 0;\n  }\n\n  var num = value;\n\n  if (typeof value === 'string' && value !== '') {\n    num = Number(value);\n  }\n\n  if (!(0, _isFinite.default)(num)) {\n    throw new TypeError(\"Float cannot represent non numeric value: \".concat((0, _inspect.default)(value)));\n  }\n\n  return num;\n}\n\nfunction coerceFloat(value) {\n  if (!(0, _isFinite.default)(value)) {\n    throw new TypeError(\"Float cannot represent non numeric value: \".concat((0, _inspect.default)(value)));\n  }\n\n  return value;\n}\n\nvar GraphQLFloat = new _definition.GraphQLScalarType({\n  name: 'Float',\n  description: 'The `Float` scalar type represents signed double-precision fractional ' + 'values as specified by ' + '[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ',\n  serialize: serializeFloat,\n  parseValue: coerceFloat,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _kinds.Kind.FLOAT || ast.kind === _kinds.Kind.INT ? parseFloat(ast.value) : undefined;\n  }\n});\nexports.GraphQLFloat = GraphQLFloat;\n\nfunction serializeString(value) {\n  // Support serializing objects with custom valueOf() functions - a common way\n  // to represent an complex value which can be represented as a string\n  // (ex: MongoDB id objects).\n  var result = value && typeof value.valueOf === 'function' ? value.valueOf() : value; // Serialize string, boolean and number values to a string, but do not\n  // attempt to coerce object, function, symbol, or other types as strings.\n\n  if (typeof result === 'string') {\n    return result;\n  }\n\n  if (typeof result === 'boolean') {\n    return result ? 'true' : 'false';\n  }\n\n  if ((0, _isFinite.default)(result)) {\n    return result.toString();\n  }\n\n  throw new TypeError(\"String cannot represent value: \".concat((0, _inspect.default)(value)));\n}\n\nfunction coerceString(value) {\n  if (typeof value !== 'string') {\n    throw new TypeError(\"String cannot represent a non string value: \".concat((0, _inspect.default)(value)));\n  }\n\n  return value;\n}\n\nvar GraphQLString = new _definition.GraphQLScalarType({\n  name: 'String',\n  description: 'The `String` scalar type represents textual data, represented as UTF-8 ' + 'character sequences. The String type is most often used by GraphQL to ' + 'represent free-form human-readable text.',\n  serialize: serializeString,\n  parseValue: coerceString,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _kinds.Kind.STRING ? ast.value : undefined;\n  }\n});\nexports.GraphQLString = GraphQLString;\n\nfunction serializeBoolean(value) {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if ((0, _isFinite.default)(value)) {\n    return value !== 0;\n  }\n\n  throw new TypeError(\"Boolean cannot represent a non boolean value: \".concat((0, _inspect.default)(value)));\n}\n\nfunction coerceBoolean(value) {\n  if (typeof value !== 'boolean') {\n    throw new TypeError(\"Boolean cannot represent a non boolean value: \".concat((0, _inspect.default)(value)));\n  }\n\n  return value;\n}\n\nvar GraphQLBoolean = new _definition.GraphQLScalarType({\n  name: 'Boolean',\n  description: 'The `Boolean` scalar type represents `true` or `false`.',\n  serialize: serializeBoolean,\n  parseValue: coerceBoolean,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _kinds.Kind.BOOLEAN ? ast.value : undefined;\n  }\n});\nexports.GraphQLBoolean = GraphQLBoolean;\n\nfunction serializeID(value) {\n  // Support serializing objects with custom valueOf() functions - a common way\n  // to represent an object identifier (ex. MongoDB).\n  var result = value && typeof value.valueOf === 'function' ? value.valueOf() : value;\n\n  if (typeof result === 'string') {\n    return result;\n  }\n\n  if ((0, _isInteger.default)(result)) {\n    return String(result);\n  }\n\n  throw new TypeError(\"ID cannot represent value: \".concat((0, _inspect.default)(value)));\n}\n\nfunction coerceID(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if ((0, _isInteger.default)(value)) {\n    return value.toString();\n  }\n\n  throw new TypeError(\"ID cannot represent value: \".concat((0, _inspect.default)(value)));\n}\n\nvar GraphQLID = new _definition.GraphQLScalarType({\n  name: 'ID',\n  description: 'The `ID` scalar type represents a unique identifier, often used to ' + 'refetch an object or as key for a cache. The ID type appears in a JSON ' + 'response as a String; however, it is not intended to be human-readable. ' + 'When expected as an input type, any string (such as `\"4\"`) or integer ' + '(such as `4`) input value will be accepted as an ID.',\n  serialize: serializeID,\n  parseValue: coerceID,\n  parseLiteral: function parseLiteral(ast) {\n    return ast.kind === _kinds.Kind.STRING || ast.kind === _kinds.Kind.INT ? ast.value : undefined;\n  }\n});\nexports.GraphQLID = GraphQLID;\nvar specifiedScalarTypes = [GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID];\nexports.specifiedScalarTypes = specifiedScalarTypes;\n\nfunction isSpecifiedScalarType(type) {\n  return (0, _definition.isNamedType)(type) && ( // Would prefer to use specifiedScalarTypes.some(), however %checks needs\n  // a simple expression.\n  type.name === GraphQLString.name || type.name === GraphQLInt.name || type.name === GraphQLFloat.name || type.name === GraphQLBoolean.name || type.name === GraphQLID.name);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/type/scalars.js?");

/***/ }),

/***/ "./node_modules/graphql/type/schema.js":
/*!*********************************************!*\
  !*** ./node_modules/graphql/type/schema.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSchema = isSchema;\nexports.GraphQLSchema = void 0;\n\nvar _definition = __webpack_require__(/*! ./definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _directives = __webpack_require__(/*! ./directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _introspection = __webpack_require__(/*! ./introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _defineToStringTag = _interopRequireDefault(__webpack_require__(/*! ../jsutils/defineToStringTag */ \"./node_modules/graphql/jsutils/defineToStringTag.js\"));\n\nvar _find = _interopRequireDefault(__webpack_require__(/*! ../jsutils/find */ \"./node_modules/graphql/jsutils/find.js\"));\n\nvar _instanceOf = _interopRequireDefault(__webpack_require__(/*! ../jsutils/instanceOf */ \"./node_modules/graphql/jsutils/instanceOf.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// eslint-disable-next-line no-redeclare\nfunction isSchema(schema) {\n  return (0, _instanceOf.default)(schema, GraphQLSchema);\n}\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\n\n\nvar GraphQLSchema =\n/*#__PURE__*/\nfunction () {\n  // Used as a cache for validateSchema().\n  // Referenced by validateSchema().\n  function GraphQLSchema(config) {\n    _defineProperty(this, \"astNode\", void 0);\n\n    _defineProperty(this, \"extensionASTNodes\", void 0);\n\n    _defineProperty(this, \"_queryType\", void 0);\n\n    _defineProperty(this, \"_mutationType\", void 0);\n\n    _defineProperty(this, \"_subscriptionType\", void 0);\n\n    _defineProperty(this, \"_directives\", void 0);\n\n    _defineProperty(this, \"_typeMap\", void 0);\n\n    _defineProperty(this, \"_implementations\", void 0);\n\n    _defineProperty(this, \"_possibleTypeMap\", void 0);\n\n    _defineProperty(this, \"__validationErrors\", void 0);\n\n    _defineProperty(this, \"__allowedLegacyNames\", void 0);\n\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    if (config && config.assumeValid) {\n      this.__validationErrors = [];\n    } else {\n      // Otherwise check for common mistakes during construction to produce\n      // clear and early error messages.\n      !(_typeof(config) === 'object') ? (0, _invariant.default)(0, 'Must provide configuration object.') : void 0;\n      !(!config.types || Array.isArray(config.types)) ? (0, _invariant.default)(0, \"\\\"types\\\" must be Array if provided but got: \".concat((0, _inspect.default)(config.types), \".\")) : void 0;\n      !(!config.directives || Array.isArray(config.directives)) ? (0, _invariant.default)(0, '\"directives\" must be Array if provided but got: ' + \"\".concat((0, _inspect.default)(config.directives), \".\")) : void 0;\n      !(!config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames)) ? (0, _invariant.default)(0, '\"allowedLegacyNames\" must be Array if provided but got: ' + \"\".concat((0, _inspect.default)(config.allowedLegacyNames), \".\")) : void 0;\n    }\n\n    this.__allowedLegacyNames = config.allowedLegacyNames || [];\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.\n\n    this._directives = config.directives || _directives.specifiedDirectives;\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes; // Build type map now to detect any errors within this schema.\n\n    var initialTypes = [this.getQueryType(), this.getMutationType(), this.getSubscriptionType(), _introspection.__Schema];\n    var types = config.types;\n\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    } // Keep track of all types referenced within the schema.\n\n\n    var typeMap = Object.create(null); // First by deeply visiting all initial types.\n\n    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.\n\n    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.\n\n    this._typeMap = typeMap; // Keep track of all implementations by interface name.\n\n    this._implementations = Object.create(null);\n\n    var _arr = Object.keys(this._typeMap);\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var typeName = _arr[_i];\n      var type = this._typeMap[typeName];\n\n      if ((0, _definition.isObjectType)(type)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = type.getInterfaces()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var iface = _step.value;\n\n            if ((0, _definition.isInterfaceType)(iface)) {\n              var impls = this._implementations[iface.name];\n\n              if (impls) {\n                impls.push(type);\n              } else {\n                this._implementations[iface.name] = [type];\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else if ((0, _definition.isAbstractType)(type) && !this._implementations[type.name]) {\n        this._implementations[type.name] = [];\n      }\n    }\n  }\n\n  var _proto = GraphQLSchema.prototype;\n\n  _proto.getQueryType = function getQueryType() {\n    return this._queryType;\n  };\n\n  _proto.getMutationType = function getMutationType() {\n    return this._mutationType;\n  };\n\n  _proto.getSubscriptionType = function getSubscriptionType() {\n    return this._subscriptionType;\n  };\n\n  _proto.getTypeMap = function getTypeMap() {\n    return this._typeMap;\n  };\n\n  _proto.getType = function getType(name) {\n    return this.getTypeMap()[name];\n  };\n\n  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {\n    if ((0, _definition.isUnionType)(abstractType)) {\n      return abstractType.getTypes();\n    }\n\n    return this._implementations[abstractType.name];\n  };\n\n  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {\n    var possibleTypeMap = this._possibleTypeMap;\n\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      var possibleTypes = this.getPossibleTypes(abstractType);\n      possibleTypeMap[abstractType.name] = possibleTypes.reduce(function (map, type) {\n        return map[type.name] = true, map;\n      }, Object.create(null));\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  };\n\n  _proto.getDirectives = function getDirectives() {\n    return this._directives;\n  };\n\n  _proto.getDirective = function getDirective(name) {\n    return (0, _find.default)(this.getDirectives(), function (directive) {\n      return directive.name === name;\n    });\n  };\n\n  return GraphQLSchema;\n}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\n\nexports.GraphQLSchema = GraphQLSchema;\n(0, _defineToStringTag.default)(GraphQLSchema);\n\nfunction typeMapReducer(map, type) {\n  if (!type) {\n    return map;\n  }\n\n  if ((0, _definition.isWrappingType)(type)) {\n    return typeMapReducer(map, type.ofType);\n  }\n\n  if (map[type.name]) {\n    !(map[type.name] === type) ? (0, _invariant.default)(0, 'Schema must contain unique named types but contains multiple ' + \"types named \\\"\".concat(type.name, \"\\\".\")) : void 0;\n    return map;\n  }\n\n  map[type.name] = type;\n  var reducedMap = map;\n\n  if ((0, _definition.isUnionType)(type)) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = (0, _objectValues.default)(type.getFields())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var field = _step2.value;\n\n        if (field.args) {\n          var fieldArgTypes = field.args.map(function (arg) {\n            return arg.type;\n          });\n          reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n        }\n\n        reducedMap = typeMapReducer(reducedMap, field.type);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = (0, _objectValues.default)(type.getFields())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _field = _step3.value;\n        reducedMap = typeMapReducer(reducedMap, _field.type);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  return reducedMap;\n}\n\nfunction typeMapDirectiveReducer(map, directive) {\n  // Directives are not validated until validateSchema() is called.\n  if (!(0, _directives.isDirective)(directive)) {\n    return map;\n  }\n\n  return directive.args.reduce(function (_map, arg) {\n    return typeMapReducer(_map, arg.type);\n  }, map);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/type/schema.js?");

/***/ }),

/***/ "./node_modules/graphql/type/validate.js":
/*!***********************************************!*\
  !*** ./node_modules/graphql/type/validate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchema = validateSchema;\nexports.assertValidSchema = assertValidSchema;\n\nvar _definition = __webpack_require__(/*! ./definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _directives = __webpack_require__(/*! ./directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _introspection = __webpack_require__(/*! ./introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _schema = __webpack_require__(/*! ./schema */ \"./node_modules/graphql/type/schema.js\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _find = _interopRequireDefault(__webpack_require__(/*! ../jsutils/find */ \"./node_modules/graphql/jsutils/find.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _assertValidName = __webpack_require__(/*! ../utilities/assertValidName */ \"./node_modules/graphql/utilities/assertValidName.js\");\n\nvar _typeComparators = __webpack_require__(/*! ../utilities/typeComparators */ \"./node_modules/graphql/utilities/typeComparators.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nfunction validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  !(0, _schema.isSchema)(schema) ? (0, _invariant.default)(0, \"Expected \".concat((0, _inspect.default)(schema), \" to be a GraphQL schema.\")) : void 0; // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\n\nfunction assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext =\n/*#__PURE__*/\nfunction () {\n  function SchemaValidationContext(schema) {\n    _defineProperty(this, \"_errors\", void 0);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = (Array.isArray(nodes) ? nodes : [nodes]).filter(Boolean);\n\n    this.addError(new _GraphQLError.GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError(\"Query root type must be provided.\", schema.astNode);\n  } else if (!(0, _definition.isObjectType)(queryType)) {\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat((0, _inspect.default)(queryType), \".\"), getOperationTypeNode(schema, queryType, 'query'));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !(0, _definition.isObjectType)(mutationType)) {\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat((0, _inspect.default)(mutationType), \".\"), getOperationTypeNode(schema, mutationType, 'mutation'));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat((0, _inspect.default)(subscriptionType), \".\"), getOperationTypeNode(schema, subscriptionType, 'subscription'));\n  }\n}\n\nfunction getOperationTypeNode(schema, type, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = operationNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var node = _step.value;\n\n      if (node.operation === operation) {\n        return node.type;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return type.astNode;\n}\n\nfunction validateDirectives(context) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = context.schema.getDirectives()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value;\n\n      // Ensure all directives are in fact GraphQL directives.\n      if (!(0, _directives.isDirective)(directive)) {\n        context.reportError(\"Expected directive but got: \".concat((0, _inspect.default)(directive), \".\"), directive && directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = directive.args[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var arg = _step3.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per directive.\n\n          if (argNames[argName]) {\n            context.reportError(\"Argument @\".concat(directive.name, \"(\").concat(argName, \":) can only be defined once.\"), getAllDirectiveArgNodes(directive, argName));\n            continue;\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type.\n\n          if (!(0, _definition.isInputType)(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(argName, \":) must be Input Type \") + \"but got: \".concat((0, _inspect.default)(arg.type), \".\"), getDirectiveArgTypeNode(directive, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // If a schema explicitly allows some legacy name which is no longer valid,\n  // allow it to be assumed valid.\n  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {\n    return;\n  } // Ensure names are valid, however introspection types opt out.\n\n\n  var error = (0, _assertValidName.isValidNameError)(node.name, node.astNode || undefined);\n\n  if (error) {\n    context.addError(error);\n  }\n}\n\nfunction validateTypes(context) {\n  var typeMap = context.schema.getTypeMap();\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = (0, _objectValues.default)(typeMap)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var type = _step4.value;\n\n      // Ensure all provided types are in fact GraphQL type.\n      if (!(0, _definition.isNamedType)(type)) {\n        context.reportError(\"Expected GraphQL named type but got: \".concat((0, _inspect.default)(type), \".\"), type && type.astNode);\n        continue;\n      } // Ensure it is named correctly (excluding introspection types).\n\n\n      if (!(0, _introspection.isIntrospectionType)(type)) {\n        validateName(context, type);\n      }\n\n      if ((0, _definition.isObjectType)(type)) {\n        // Ensure fields are valid\n        validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n        validateObjectInterfaces(context, type);\n      } else if ((0, _definition.isInterfaceType)(type)) {\n        // Ensure fields are valid.\n        validateFields(context, type);\n      } else if ((0, _definition.isUnionType)(type)) {\n        // Ensure Unions include valid member types.\n        validateUnionMembers(context, type);\n      } else if ((0, _definition.isEnumType)(type)) {\n        // Ensure Enums have valid values.\n        validateEnumValues(context, type);\n      } else if ((0, _definition.isInputObjectType)(type)) {\n        // Ensure Input Object fields are valid.\n        validateInputFields(context, type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = (0, _objectValues.default)(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = fields[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var field = _step5.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // Ensure they were defined at most once.\n\n      var fieldNodes = getAllFieldNodes(type, field.name);\n\n      if (fieldNodes.length > 1) {\n        context.reportError(\"Field \".concat(type.name, \".\").concat(field.name, \" can only be defined once.\"), fieldNodes);\n        continue;\n      } // Ensure the type is an output type\n\n\n      if (!(0, _definition.isOutputType)(field.type)) {\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat((0, _inspect.default)(field.type), \".\"), getFieldTypeNode(type, field.name));\n      } // Ensure the arguments are valid\n\n\n      var argNames = Object.create(null);\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = field.args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var arg = _step6.value;\n          var argName = arg.name; // Ensure they are named correctly.\n\n          validateName(context, arg); // Ensure they are unique per field.\n\n          if (argNames[argName]) {\n            context.reportError(\"Field argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) can only \") + 'be defined once.', getAllFieldArgNodes(type, field.name, argName));\n          }\n\n          argNames[argName] = true; // Ensure the type is an input type\n\n          if (!(0, _definition.isInputType)(arg.type)) {\n            context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat((0, _inspect.default)(arg.type), \".\"), getFieldArgTypeNode(type, field.name, argName));\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\nfunction validateObjectInterfaces(context, object) {\n  var implementedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion7 = true;\n  var _didIteratorError7 = false;\n  var _iteratorError7 = undefined;\n\n  try {\n    for (var _iterator7 = object.getInterfaces()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n      var iface = _step7.value;\n\n      if (!(0, _definition.isInterfaceType)(iface)) {\n        context.reportError(\"Type \".concat((0, _inspect.default)(object), \" must only implement Interface types, \") + \"it cannot implement \".concat((0, _inspect.default)(iface), \".\"), getImplementsInterfaceNode(object, iface));\n        continue;\n      }\n\n      if (implementedTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(object.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(object, iface));\n        continue;\n      }\n\n      implementedTypeNames[iface.name] = true;\n      validateObjectImplementsInterface(context, object, iface);\n    }\n  } catch (err) {\n    _didIteratorError7 = true;\n    _iteratorError7 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n        _iterator7.return();\n      }\n    } finally {\n      if (_didIteratorError7) {\n        throw _iteratorError7;\n      }\n    }\n  }\n}\n\nfunction validateObjectImplementsInterface(context, object, iface) {\n  var objectFieldMap = object.getFields();\n  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.\n\n  var _arr = Object.keys(ifaceFieldMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fieldName = _arr[_i];\n    var objectField = objectFieldMap[fieldName];\n    var ifaceField = ifaceFieldMap[fieldName]; // Assert interface field exists on object.\n\n    if (!objectField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \") + \"\".concat(object.name, \" does not provide it.\"), [getFieldNode(iface, fieldName)].concat(getAllNodes(object)));\n      continue;\n    } // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!(0, _typeComparators.isTypeSubTypeOf)(context.schema, objectField.type, ifaceField.type)) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat((0, _inspect.default)(ifaceField.type), \" but \").concat(object.name, \".\").concat(fieldName, \" \") + \"is type \".concat((0, _inspect.default)(objectField.type), \".\"), [getFieldTypeNode(iface, fieldName), getFieldTypeNode(object, fieldName)]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step8.value;\n        var argName = ifaceArg.name;\n        var objectArg = (0, _find.default)(objectField.args, function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!objectArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expected but \".concat(object.name, \".\").concat(fieldName, \" does not provide it.\"), [getFieldArgNode(iface, fieldName, argName), getFieldNode(object, fieldName)]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n\n        if (!(0, _typeComparators.isEqualType)(ifaceArg.type, objectArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat((0, _inspect.default)(ifaceArg.type), \" but \") + \"\".concat(object.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat((0, _inspect.default)(objectArg.type), \".\"), [getFieldArgTypeNode(iface, fieldName, argName), getFieldArgTypeNode(object, fieldName, argName)]);\n        } // TODO: validate default values?\n\n      };\n\n      for (var _iterator8 = ifaceField.args[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var objectArg = _step9.value;\n        var argName = objectArg.name;\n        var ifaceArg = (0, _find.default)(ifaceField.args, function (arg) {\n          return arg.name === argName;\n        });\n\n        if (!ifaceArg && (0, _definition.isRequiredArgument)(objectArg)) {\n          context.reportError(\"Object field \".concat(object.name, \".\").concat(fieldName, \" includes required \") + \"argument \".concat(argName, \" that is missing from the Interface field \") + \"\".concat(iface.name, \".\").concat(fieldName, \".\"), [getFieldArgNode(object, fieldName, argName), getFieldNode(iface, fieldName)]);\n        }\n      };\n\n      for (var _iterator9 = objectField.args[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        _loop2();\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n  var _iteratorNormalCompletion10 = true;\n  var _didIteratorError10 = false;\n  var _iteratorError10 = undefined;\n\n  try {\n    for (var _iterator10 = memberTypes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n      var memberType = _step10.value;\n\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \") + \"\".concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n\n      includedTypeNames[memberType.name] = true;\n\n      if (!(0, _definition.isObjectType)(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat((0, _inspect.default)(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _didIteratorError10 = true;\n    _iteratorError10 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n        _iterator10.return();\n      }\n    } finally {\n      if (_didIteratorError10) {\n        throw _iteratorError10;\n      }\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  var _iteratorNormalCompletion11 = true;\n  var _didIteratorError11 = false;\n  var _iteratorError11 = undefined;\n\n  try {\n    for (var _iterator11 = enumValues[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n      var enumValue = _step11.value;\n      var valueName = enumValue.name; // Ensure no duplicates.\n\n      var allNodes = getEnumValueNodes(enumType, valueName);\n\n      if (allNodes && allNodes.length > 1) {\n        context.reportError(\"Enum type \".concat(enumType.name, \" can include value \").concat(valueName, \" only once.\"), allNodes);\n      } // Ensure valid name.\n\n\n      validateName(context, enumValue);\n\n      if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n        context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n      }\n    }\n  } catch (err) {\n    _didIteratorError11 = true;\n    _iteratorError11 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n        _iterator11.return();\n      }\n    } finally {\n      if (_didIteratorError11) {\n        throw _iteratorError11;\n      }\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = (0, _objectValues.default)(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  var _iteratorNormalCompletion12 = true;\n  var _didIteratorError12 = false;\n  var _iteratorError12 = undefined;\n\n  try {\n    for (var _iterator12 = fields[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n      var field = _step12.value;\n      // Ensure they are named correctly.\n      validateName(context, field); // TODO: Ensure they are unique per field.\n      // Ensure the type is an input type\n\n      if (!(0, _definition.isInputType)(field.type)) {\n        context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat((0, _inspect.default)(field.type), \".\"), field.astNode && field.astNode.type);\n      }\n    }\n  } catch (err) {\n    _didIteratorError12 = true;\n    _iteratorError12 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n        _iterator12.return();\n      }\n    } finally {\n      if (_didIteratorError12) {\n        throw _iteratorError12;\n      }\n    }\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var result = [];\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = getAllNodes(object)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var astNode = _step13.value;\n\n      if (astNode) {\n        var subNodes = getter(astNode);\n\n        if (subNodes) {\n          result = result.concat(subNodes);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementsInterfaceNode(type, iface) {\n  return getAllImplementsInterfaceNodes(type, iface)[0];\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getFieldNode(type, fieldName) {\n  return getAllFieldNodes(type, fieldName)[0];\n}\n\nfunction getAllFieldNodes(type, fieldName) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.fields;\n  }).filter(function (fieldNode) {\n    return fieldNode.name.value === fieldName;\n  });\n}\n\nfunction getFieldTypeNode(type, fieldName) {\n  var fieldNode = getFieldNode(type, fieldName);\n  return fieldNode && fieldNode.type;\n}\n\nfunction getFieldArgNode(type, fieldName, argName) {\n  return getAllFieldArgNodes(type, fieldName, argName)[0];\n}\n\nfunction getAllFieldArgNodes(type, fieldName, argName) {\n  var argNodes = [];\n  var fieldNode = getFieldNode(type, fieldName);\n\n  if (fieldNode && fieldNode.arguments) {\n    var _iteratorNormalCompletion14 = true;\n    var _didIteratorError14 = false;\n    var _iteratorError14 = undefined;\n\n    try {\n      for (var _iterator14 = fieldNode.arguments[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n        var node = _step14.value;\n\n        if (node.name.value === argName) {\n          argNodes.push(node);\n        }\n      }\n    } catch (err) {\n      _didIteratorError14 = true;\n      _iteratorError14 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n          _iterator14.return();\n        }\n      } finally {\n        if (_didIteratorError14) {\n          throw _iteratorError14;\n        }\n      }\n    }\n  }\n\n  return argNodes;\n}\n\nfunction getFieldArgTypeNode(type, fieldName, argName) {\n  var fieldArgNode = getFieldArgNode(type, fieldName, argName);\n  return fieldArgNode && fieldArgNode.type;\n}\n\nfunction getAllDirectiveArgNodes(directive, argName) {\n  return getAllSubNodes(directive, function (directiveNode) {\n    return directiveNode.arguments;\n  }).filter(function (argNode) {\n    return argNode.name.value === argName;\n  });\n}\n\nfunction getDirectiveArgTypeNode(directive, argName) {\n  var argNode = getAllDirectiveArgNodes(directive, argName)[0];\n  return argNode && argNode.type;\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getEnumValueNodes(enumType, valueName) {\n  return getAllSubNodes(enumType, function (enumNode) {\n    return enumNode.values;\n  }).filter(function (valueNode) {\n    return valueNode.name.value === valueName;\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/type/validate.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/TypeInfo.js":
/*!****************************************************!*\
  !*** ./node_modules/graphql/utilities/TypeInfo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeInfo = void 0;\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ./typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nvar _find = _interopRequireDefault(__webpack_require__(/*! ../jsutils/find */ \"./node_modules/graphql/jsutils/find.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\nvar TypeInfo =\n/*#__PURE__*/\nfunction () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant codebases. You should never need to use it.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  initialType) {\n    _defineProperty(this, \"_schema\", void 0);\n\n    _defineProperty(this, \"_typeStack\", void 0);\n\n    _defineProperty(this, \"_parentTypeStack\", void 0);\n\n    _defineProperty(this, \"_inputTypeStack\", void 0);\n\n    _defineProperty(this, \"_fieldDefStack\", void 0);\n\n    _defineProperty(this, \"_defaultValueStack\", void 0);\n\n    _defineProperty(this, \"_directive\", void 0);\n\n    _defineProperty(this, \"_argument\", void 0);\n\n    _defineProperty(this, \"_enumValue\", void 0);\n\n    _defineProperty(this, \"_getFieldDef\", void 0);\n\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn || getFieldDef;\n\n    if (initialType) {\n      if ((0, _definition.isInputType)(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isCompositeType)(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if ((0, _definition.isOutputType)(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        var namedType = (0, _definition.getNamedType)(this.getType());\n\n        this._parentTypeStack.push((0, _definition.isCompositeType)(namedType) ? namedType : undefined);\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        var parentType = this.getParentType();\n        var fieldDef;\n        var fieldType;\n\n        if (parentType) {\n          fieldDef = this._getFieldDef(schema, parentType, node);\n\n          if (fieldDef) {\n            fieldType = fieldDef.type;\n          }\n        }\n\n        this._fieldDefStack.push(fieldDef);\n\n        this._typeStack.push((0, _definition.isOutputType)(fieldType) ? fieldType : undefined);\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n        var type;\n\n        if (node.operation === 'query') {\n          type = schema.getQueryType();\n        } else if (node.operation === 'mutation') {\n          type = schema.getMutationType();\n        } else if (node.operation === 'subscription') {\n          type = schema.getSubscriptionType();\n        }\n\n        this._typeStack.push((0, _definition.isObjectType)(type) ? type : undefined);\n\n        break;\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        var typeConditionAST = node.typeCondition;\n        var outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());\n\n        this._typeStack.push((0, _definition.isOutputType)(outputType) ? outputType : undefined);\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        var inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);\n\n        this._inputTypeStack.push((0, _definition.isInputType)(inputType) ? inputType : undefined);\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        var argDef;\n        var argType;\n        var fieldOrDirective = this.getDirective() || this.getFieldDef();\n\n        if (fieldOrDirective) {\n          argDef = (0, _find.default)(fieldOrDirective.args, function (arg) {\n            return arg.name === node.name.value;\n          });\n\n          if (argDef) {\n            argType = argDef.type;\n          }\n        }\n\n        this._argument = argDef;\n\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n        this._inputTypeStack.push((0, _definition.isInputType)(argType) ? argType : undefined);\n\n        break;\n\n      case _kinds.Kind.LIST:\n        var listType = (0, _definition.getNullableType)(this.getInputType());\n        var itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n        this._defaultValueStack.push(undefined);\n\n        this._inputTypeStack.push((0, _definition.isInputType)(itemType) ? itemType : undefined);\n\n        break;\n\n      case _kinds.Kind.OBJECT_FIELD:\n        var objectType = (0, _definition.getNamedType)(this.getInputType());\n        var inputFieldType;\n        var inputField;\n\n        if ((0, _definition.isInputObjectType)(objectType)) {\n          inputField = objectType.getFields()[node.name.value];\n\n          if (inputField) {\n            inputFieldType = inputField.type;\n          }\n        }\n\n        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n        this._inputTypeStack.push((0, _definition.isInputType)(inputFieldType) ? inputFieldType : undefined);\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        var enumType = (0, _definition.getNamedType)(this.getInputType());\n        var enumValue;\n\n        if ((0, _definition.isEnumType)(enumType)) {\n          enumValue = enumType.getValue(node.value);\n        }\n\n        this._enumValue = enumValue;\n        break;\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case _kinds.Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case _kinds.Kind.OPERATION_DEFINITION:\n      case _kinds.Kind.INLINE_FRAGMENT:\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.LIST:\n      case _kinds.Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case _kinds.Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\n\nexports.TypeInfo = TypeInfo;\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return _introspection.TypeMetaFieldDef;\n  }\n\n  if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n\n  if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/TypeInfo.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/assertValidName.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/utilities/assertValidName.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertValidName = assertValidName;\nexports.isValidNameError = isValidNameError;\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nvar NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/**\n * Upholds the spec rules about naming.\n */\n\nfunction assertValidName(name) {\n  var error = isValidNameError(name);\n\n  if (error) {\n    throw error;\n  }\n\n  return name;\n}\n/**\n * Returns an Error if a name is invalid.\n */\n\n\nfunction isValidNameError(name, node) {\n  !(typeof name === 'string') ? (0, _invariant.default)(0, 'Expected string') : void 0;\n\n  if (name.length > 1 && name[0] === '_' && name[1] === '_') {\n    return new _GraphQLError.GraphQLError(\"Name \\\"\".concat(name, \"\\\" must not begin with \\\"__\\\", which is reserved by \") + 'GraphQL introspection.', node);\n  }\n\n  if (!NAME_RX.test(name)) {\n    return new _GraphQLError.GraphQLError(\"Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \\\"\".concat(name, \"\\\" does not.\"), node);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/assertValidName.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/astFromValue.js":
/*!********************************************************!*\
  !*** ./node_modules/graphql/utilities/astFromValue.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.astFromValue = astFromValue;\n\nvar _iterall = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _isNullish = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isNullish */ \"./node_modules/graphql/jsutils/isNullish.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _scalars = __webpack_require__(/*! ../type/scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Produces a GraphQL Value AST given a JavaScript value.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | Mixed         | Enum Value           |\n * | null          | NullValue            |\n *\n */\nfunction astFromValue(value, type) {\n  if ((0, _definition.isNonNullType)(type)) {\n    var astValue = astFromValue(value, type.ofType);\n\n    if (astValue && astValue.kind === _kinds.Kind.NULL) {\n      return null;\n    }\n\n    return astValue;\n  } // only explicit null, not undefined, NaN\n\n\n  if (value === null) {\n    return {\n      kind: _kinds.Kind.NULL\n    };\n  } // undefined, NaN\n\n\n  if ((0, _isInvalid.default)(value)) {\n    return null;\n  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n  // the value is not an array, convert the value using the list's item type.\n\n\n  if ((0, _definition.isListType)(type)) {\n    var itemType = type.ofType;\n\n    if ((0, _iterall.isCollection)(value)) {\n      var valuesNodes = [];\n      (0, _iterall.forEach)(value, function (item) {\n        var itemNode = astFromValue(item, itemType);\n\n        if (itemNode) {\n          valuesNodes.push(itemNode);\n        }\n      });\n      return {\n        kind: _kinds.Kind.LIST,\n        values: valuesNodes\n      };\n    }\n\n    return astFromValue(value, itemType);\n  } // Populate the fields of the input object by creating ASTs from each value\n  // in the JavaScript object according to the fields in the input type.\n\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (value === null || _typeof(value) !== 'object') {\n      return null;\n    }\n\n    var fields = (0, _objectValues.default)(type.getFields());\n    var fieldNodes = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var field = _step.value;\n        var fieldValue = astFromValue(value[field.name], field.type);\n\n        if (fieldValue) {\n          fieldNodes.push({\n            kind: _kinds.Kind.OBJECT_FIELD,\n            name: {\n              kind: _kinds.Kind.NAME,\n              value: field.name\n            },\n            value: fieldValue\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      kind: _kinds.Kind.OBJECT,\n      fields: fieldNodes\n    };\n  }\n\n  if ((0, _definition.isScalarType)(type) || (0, _definition.isEnumType)(type)) {\n    // Since value is an internally represented value, it must be serialized\n    // to an externally represented value before converting into an AST.\n    var serialized = type.serialize(value);\n\n    if ((0, _isNullish.default)(serialized)) {\n      return null;\n    } // Others serialize based on their corresponding JavaScript scalar types.\n\n\n    if (typeof serialized === 'boolean') {\n      return {\n        kind: _kinds.Kind.BOOLEAN,\n        value: serialized\n      };\n    } // JavaScript numbers can be Int or Float values.\n\n\n    if (typeof serialized === 'number') {\n      var stringNum = String(serialized);\n      return integerStringRegExp.test(stringNum) ? {\n        kind: _kinds.Kind.INT,\n        value: stringNum\n      } : {\n        kind: _kinds.Kind.FLOAT,\n        value: stringNum\n      };\n    }\n\n    if (typeof serialized === 'string') {\n      // Enum types use Enum literals.\n      if ((0, _definition.isEnumType)(type)) {\n        return {\n          kind: _kinds.Kind.ENUM,\n          value: serialized\n        };\n      } // ID types can use Int literals.\n\n\n      if (type === _scalars.GraphQLID && integerStringRegExp.test(serialized)) {\n        return {\n          kind: _kinds.Kind.INT,\n          value: serialized\n        };\n      }\n\n      return {\n        kind: _kinds.Kind.STRING,\n        value: serialized\n      };\n    }\n\n    throw new TypeError(\"Cannot convert value to AST: \".concat((0, _inspect.default)(serialized)));\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unknown type: \".concat(type, \".\"));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\n\n\nvar integerStringRegExp = /^-?(0|[1-9][0-9]*)$/;\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/astFromValue.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/buildASTSchema.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphql/utilities/buildASTSchema.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildASTSchema = buildASTSchema;\nexports.getDescription = getDescription;\nexports.buildSchema = buildSchema;\nexports.ASTDefinitionBuilder = void 0;\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _keyValMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyValMap */ \"./node_modules/graphql/jsutils/keyValMap.js\"));\n\nvar _valueFromAST = __webpack_require__(/*! ./valueFromAST */ \"./node_modules/graphql/utilities/valueFromAST.js\");\n\nvar _validate = __webpack_require__(/*! ../validation/validate */ \"./node_modules/graphql/validation/validate.js\");\n\nvar _blockStringValue = _interopRequireDefault(__webpack_require__(/*! ../language/blockStringValue */ \"./node_modules/graphql/language/blockStringValue.js\"));\n\nvar _lexer = __webpack_require__(/*! ../language/lexer */ \"./node_modules/graphql/language/lexer.js\");\n\nvar _parser = __webpack_require__(/*! ../language/parser */ \"./node_modules/graphql/language/parser.js\");\n\nvar _values = __webpack_require__(/*! ../execution/values */ \"./node_modules/graphql/execution/values.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _predicates = __webpack_require__(/*! ../language/predicates */ \"./node_modules/graphql/language/predicates.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _directives = __webpack_require__(/*! ../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _scalars = __webpack_require__(/*! ../type/scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _schema = __webpack_require__(/*! ../type/schema */ \"./node_modules/graphql/type/schema.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nfunction buildASTSchema(documentAST, options) {\n  !(documentAST && documentAST.kind === _kinds.Kind.DOCUMENT) ? (0, _invariant.default)(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    (0, _validate.assertValidSDL)(documentAST);\n  }\n\n  var schemaDef;\n  var typeDefs = [];\n  var nodeMap = Object.create(null);\n  var directiveDefs = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      var typeName = def.name.value;\n\n      if (nodeMap[typeName]) {\n        throw new Error(\"Type \\\"\".concat(typeName, \"\\\" was defined more than once.\"));\n      }\n\n      typeDefs.push(def);\n      nodeMap[typeName] = def;\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  }\n\n  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {\n    query: nodeMap.Query,\n    mutation: nodeMap.Mutation,\n    subscription: nodeMap.Subscription\n  };\n  var definitionBuilder = new ASTDefinitionBuilder(nodeMap, options, function (typeRef) {\n    throw new Error(\"Type \\\"\".concat(typeRef.name.value, \"\\\" not found in document.\"));\n  });\n  var directives = directiveDefs.map(function (def) {\n    return definitionBuilder.buildDirective(def);\n  }); // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(_directives.GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(_directives.GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(_directives.GraphQLDeprecatedDirective);\n  } // Note: While this could make early assertions to get the correctly\n  // typed values below, that would throw immediately while type system\n  // validation with validateSchema() will produce more actionable results.\n\n\n  return new _schema.GraphQLSchema({\n    query: operationTypes.query ? definitionBuilder.buildType(operationTypes.query) : null,\n    mutation: operationTypes.mutation ? definitionBuilder.buildType(operationTypes.mutation) : null,\n    subscription: operationTypes.subscription ? definitionBuilder.buildType(operationTypes.subscription) : null,\n    types: typeDefs.map(function (node) {\n      return definitionBuilder.buildType(node);\n    }),\n    directives: directives,\n    astNode: schemaDef,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n\n  function getOperationTypes(schema) {\n    var opTypes = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var operationType = _step.value;\n        var _typeName = operationType.type.name.value;\n        var operation = operationType.operation;\n\n        if (opTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        }\n\n        if (!nodeMap[_typeName]) {\n          throw new Error(\"Specified \".concat(operation, \" type \\\"\").concat(_typeName, \"\\\" not found in document.\"));\n        }\n\n        opTypes[operation] = operationType.type;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return opTypes;\n  }\n}\n\nvar ASTDefinitionBuilder =\n/*#__PURE__*/\nfunction () {\n  function ASTDefinitionBuilder(typeDefinitionsMap, options, resolveType) {\n    _defineProperty(this, \"_typeDefinitionsMap\", void 0);\n\n    _defineProperty(this, \"_options\", void 0);\n\n    _defineProperty(this, \"_resolveType\", void 0);\n\n    _defineProperty(this, \"_cache\", void 0);\n\n    this._typeDefinitionsMap = typeDefinitionsMap;\n    this._options = options;\n    this._resolveType = resolveType; // Initialize to the GraphQL built in scalars and introspection types.\n\n    this._cache = (0, _keyMap.default)(_scalars.specifiedScalarTypes.concat(_introspection.introspectionTypes), function (type) {\n      return type.name;\n    });\n  }\n\n  var _proto = ASTDefinitionBuilder.prototype;\n\n  _proto.buildType = function buildType(node) {\n    var typeName = node.name.value;\n\n    if (!this._cache[typeName]) {\n      if (node.kind === _kinds.Kind.NAMED_TYPE) {\n        var defNode = this._typeDefinitionsMap[typeName];\n        this._cache[typeName] = defNode ? this._makeSchemaDef(defNode) : this._resolveType(node);\n      } else {\n        this._cache[typeName] = this._makeSchemaDef(node);\n      }\n    }\n\n    return this._cache[typeName];\n  };\n\n  _proto._buildWrappedType = function _buildWrappedType(typeNode) {\n    if (typeNode.kind === _kinds.Kind.LIST_TYPE) {\n      return (0, _definition.GraphQLList)(this._buildWrappedType(typeNode.type));\n    }\n\n    if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {\n      return (0, _definition.GraphQLNonNull)( // Note: GraphQLNonNull constructor validates this type\n      this._buildWrappedType(typeNode.type));\n    }\n\n    return this.buildType(typeNode);\n  };\n\n  _proto.buildDirective = function buildDirective(directiveNode) {\n    return new _directives.GraphQLDirective({\n      name: directiveNode.name.value,\n      description: getDescription(directiveNode, this._options),\n      locations: directiveNode.locations.map(function (node) {\n        return node.value;\n      }),\n      args: directiveNode.arguments && this._makeInputValues(directiveNode.arguments),\n      astNode: directiveNode\n    });\n  };\n\n  _proto.buildField = function buildField(field) {\n    return {\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      type: this._buildWrappedType(field.type),\n      description: getDescription(field, this._options),\n      args: field.arguments && this._makeInputValues(field.arguments),\n      deprecationReason: getDeprecationReason(field),\n      astNode: field\n    };\n  };\n\n  _proto.buildInputField = function buildInputField(value) {\n    // Note: While this could make assertions to get the correctly typed\n    // value, that would throw immediately while type system validation\n    var type = this._buildWrappedType(value.type);\n\n    return {\n      name: value.name.value,\n      type: type,\n      description: getDescription(value, this._options),\n      defaultValue: (0, _valueFromAST.valueFromAST)(value.defaultValue, type),\n      astNode: value\n    };\n  };\n\n  _proto.buildEnumValue = function buildEnumValue(value) {\n    return {\n      description: getDescription(value, this._options),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    };\n  };\n\n  _proto._makeSchemaDef = function _makeSchemaDef(def) {\n    switch (def.kind) {\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n        return this._makeTypeDef(def);\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n        return this._makeInterfaceDef(def);\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n        return this._makeEnumDef(def);\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n        return this._makeUnionDef(def);\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n        return this._makeScalarDef(def);\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        return this._makeInputObjectDef(def);\n\n      default:\n        throw new Error(\"Type kind \\\"\".concat(def.kind, \"\\\" not supported.\"));\n    }\n  };\n\n  _proto._makeTypeDef = function _makeTypeDef(def) {\n    var _this = this;\n\n    var interfaces = def.interfaces;\n    return new _definition.GraphQLObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this._makeFieldDefMap(def);\n      },\n      // Note: While this could make early assertions to get the correctly\n      // typed values, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      interfaces: interfaces ? function () {\n        return interfaces.map(function (ref) {\n          return _this.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeFieldDefMap = function _makeFieldDefMap(def) {\n    var _this2 = this;\n\n    return def.fields ? (0, _keyValMap.default)(def.fields, function (field) {\n      return field.name.value;\n    }, function (field) {\n      return _this2.buildField(field);\n    }) : {};\n  };\n\n  _proto._makeInputValues = function _makeInputValues(values) {\n    var _this3 = this;\n\n    return (0, _keyValMap.default)(values, function (value) {\n      return value.name.value;\n    }, function (value) {\n      return _this3.buildInputField(value);\n    });\n  };\n\n  _proto._makeInterfaceDef = function _makeInterfaceDef(def) {\n    var _this4 = this;\n\n    return new _definition.GraphQLInterfaceType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return _this4._makeFieldDefMap(def);\n      },\n      astNode: def\n    });\n  };\n\n  _proto._makeEnumDef = function _makeEnumDef(def) {\n    return new _definition.GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      values: this._makeValueDefMap(def),\n      astNode: def\n    });\n  };\n\n  _proto._makeValueDefMap = function _makeValueDefMap(def) {\n    var _this5 = this;\n\n    return def.values ? (0, _keyValMap.default)(def.values, function (enumValue) {\n      return enumValue.name.value;\n    }, function (enumValue) {\n      return _this5.buildEnumValue(enumValue);\n    }) : {};\n  };\n\n  _proto._makeUnionDef = function _makeUnionDef(def) {\n    var _this6 = this;\n\n    var types = def.types;\n    return new _definition.GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      types: types ? function () {\n        return types.map(function (ref) {\n          return _this6.buildType(ref);\n        });\n      } : [],\n      astNode: def\n    });\n  };\n\n  _proto._makeScalarDef = function _makeScalarDef(def) {\n    return new _definition.GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      astNode: def,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  };\n\n  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {\n    var _this7 = this;\n\n    return new _definition.GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def, this._options),\n      fields: function fields() {\n        return def.fields ? _this7._makeInputValues(def.fields) : {};\n      },\n      astNode: def\n    });\n  };\n\n  return ASTDefinitionBuilder;\n}();\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\n\nexports.ASTDefinitionBuilder = ASTDefinitionBuilder;\n\nfunction getDeprecationReason(node) {\n  var deprecated = (0, _values.getDirectiveValues)(_directives.GraphQLDeprecatedDirective, node);\n  return deprecated && deprecated.reason;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nfunction getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if (options && options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return (0, _blockStringValue.default)('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token && token.kind === _lexer.TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.reverse().join('\\n');\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\n\nfunction buildSchema(source, options) {\n  return buildASTSchema((0, _parser.parse)(source, options), options);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/buildASTSchema.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/buildClientSchema.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphql/utilities/buildClientSchema.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildClientSchema = buildClientSchema;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _keyValMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyValMap */ \"./node_modules/graphql/jsutils/keyValMap.js\"));\n\nvar _valueFromAST = __webpack_require__(/*! ./valueFromAST */ \"./node_modules/graphql/utilities/valueFromAST.js\");\n\nvar _parser = __webpack_require__(/*! ../language/parser */ \"./node_modules/graphql/language/parser.js\");\n\nvar _schema = __webpack_require__(/*! ../type/schema */ \"./node_modules/graphql/type/schema.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _directives = __webpack_require__(/*! ../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _scalars = __webpack_require__(/*! ../type/scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nfunction buildClientSchema(introspection, options) {\n  // Get the schema from the introspection result.\n  var schemaIntrospection = introspection.__schema; // Converts the list of types into a keyMap based on the type names.\n\n  var typeIntrospectionMap = (0, _keyMap.default)(schemaIntrospection.types, function (type) {\n    return type.name;\n  }); // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars. All functions below are inline\n  // so that this type def cache is within the scope of the closure.\n\n  var typeDefCache = (0, _keyMap.default)(_scalars.specifiedScalarTypes.concat(_introspection.introspectionTypes), function (type) {\n    return type.name;\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === _introspection.TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return (0, _definition.GraphQLList)(getType(itemRef));\n    }\n\n    if (typeRef.kind === _introspection.TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return (0, _definition.GraphQLNonNull)((0, _definition.assertNullableType)(nullableType));\n    }\n\n    if (!typeRef.name) {\n      throw new Error('Unknown type reference: ' + (0, _inspect.default)(typeRef));\n    }\n\n    return getNamedType(typeRef.name);\n  }\n\n  function getNamedType(typeName) {\n    if (typeDefCache[typeName]) {\n      return typeDefCache[typeName];\n    }\n\n    var typeIntrospection = typeIntrospectionMap[typeName];\n\n    if (!typeIntrospection) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure \") + 'that a full introspection query is used in order to build a ' + 'client schema.');\n    }\n\n    var typeDef = buildType(typeIntrospection);\n    typeDefCache[typeName] = typeDef;\n    return typeDef;\n  }\n\n  function getInputType(typeRef) {\n    var type = getType(typeRef);\n    !(0, _definition.isInputType)(type) ? (0, _invariant.default)(0, 'Introspection must provide input type for arguments.') : void 0;\n    return type;\n  }\n\n  function getOutputType(typeRef) {\n    var type = getType(typeRef);\n    !(0, _definition.isOutputType)(type) ? (0, _invariant.default)(0, 'Introspection must provide output type for fields.') : void 0;\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    var type = getType(typeRef);\n    return (0, _definition.assertObjectType)(type);\n  }\n\n  function getInterfaceType(typeRef) {\n    var type = getType(typeRef);\n    return (0, _definition.assertInterfaceType)(type);\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type && type.name && type.kind) {\n      switch (type.kind) {\n        case _introspection.TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case _introspection.TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case _introspection.TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case _introspection.TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case _introspection.TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case _introspection.TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    throw new Error('Invalid or incomplete introspection result. Ensure that a full ' + 'introspection query is used in order to build a client schema:' + (0, _inspect.default)(type));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new _definition.GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      serialize: function serialize(value) {\n        return value;\n      }\n    });\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    if (!objectIntrospection.interfaces) {\n      throw new Error('Introspection result missing interfaces: ' + (0, _inspect.default)(objectIntrospection));\n    }\n\n    return new _definition.GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return objectIntrospection.interfaces.map(getInterfaceType);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new _definition.GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      throw new Error('Introspection result missing possibleTypes: ' + (0, _inspect.default)(unionIntrospection));\n    }\n\n    return new _definition.GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      throw new Error('Introspection result missing enumValues: ' + (0, _inspect.default)(enumIntrospection));\n    }\n\n    return new _definition.GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: (0, _keyValMap.default)(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      throw new Error('Introspection result missing inputFields: ' + (0, _inspect.default)(inputObjectIntrospection));\n    }\n\n    return new _definition.GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error('Introspection result missing fields: ' + (0, _inspect.default)(typeIntrospection));\n    }\n\n    return (0, _keyValMap.default)(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, function (fieldIntrospection) {\n      if (!fieldIntrospection.args) {\n        throw new Error('Introspection result missing field args: ' + (0, _inspect.default)(fieldIntrospection));\n      }\n\n      return {\n        description: fieldIntrospection.description,\n        deprecationReason: fieldIntrospection.deprecationReason,\n        type: getOutputType(fieldIntrospection.type),\n        args: buildInputValueDefMap(fieldIntrospection.args)\n      };\n    });\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return (0, _keyValMap.default)(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getInputType(inputValueIntrospection.type);\n    var defaultValue = inputValueIntrospection.defaultValue ? (0, _valueFromAST.valueFromAST)((0, _parser.parseValue)(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      throw new Error('Introspection result missing directive args: ' + (0, _inspect.default)(directiveIntrospection));\n    }\n\n    if (!directiveIntrospection.locations) {\n      throw new Error('Introspection result missing directive locations: ' + (0, _inspect.default)(directiveIntrospection));\n    }\n\n    return new _directives.GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  } // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n\n\n  var types = schemaIntrospection.types.map(function (typeIntrospection) {\n    return getNamedType(typeIntrospection.name);\n  }); // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new _schema.GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: types,\n    directives: directives,\n    assumeValid: options && options.assumeValid,\n    allowedLegacyNames: options && options.allowedLegacyNames\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/buildClientSchema.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/coerceValue.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/utilities/coerceValue.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coerceValue = coerceValue;\n\nvar _iterall = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _orList = _interopRequireDefault(__webpack_require__(/*! ../jsutils/orList */ \"./node_modules/graphql/jsutils/orList.js\"));\n\nvar _suggestionList = _interopRequireDefault(__webpack_require__(/*! ../jsutils/suggestionList */ \"./node_modules/graphql/jsutils/suggestionList.js\"));\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Coerces a JavaScript value given a GraphQL Type.\n *\n * Returns either a value which is valid for the provided type or a list of\n * encountered coercion errors.\n *\n */\nfunction coerceValue(value, type, blameNode, path) {\n  // A value must be provided if the type is non-null.\n  if ((0, _definition.isNonNullType)(type)) {\n    if (value == null) {\n      return ofErrors([coercionError(\"Expected non-nullable type \".concat((0, _inspect.default)(type), \" not to be null\"), blameNode, path)]);\n    }\n\n    return coerceValue(value, type.ofType, blameNode, path);\n  }\n\n  if (value == null) {\n    // Explicitly return the value null.\n    return ofValue(null);\n  }\n\n  if ((0, _definition.isScalarType)(type)) {\n    // Scalars determine if a value is valid via parseValue(), which can\n    // throw to indicate failure. If it throws, maintain a reference to\n    // the original error.\n    try {\n      var parseResult = type.parseValue(value);\n\n      if ((0, _isInvalid.default)(parseResult)) {\n        return ofErrors([coercionError(\"Expected type \".concat(type.name), blameNode, path)]);\n      }\n\n      return ofValue(parseResult);\n    } catch (error) {\n      return ofErrors([coercionError(\"Expected type \".concat(type.name), blameNode, path, error.message, error)]);\n    }\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    if (typeof value === 'string') {\n      var enumValue = type.getValue(value);\n\n      if (enumValue) {\n        return ofValue(enumValue.value);\n      }\n    }\n\n    var suggestions = (0, _suggestionList.default)(String(value), type.getValues().map(function (enumValue) {\n      return enumValue.name;\n    }));\n    var didYouMean = suggestions.length !== 0 ? \"did you mean \".concat((0, _orList.default)(suggestions), \"?\") : undefined;\n    return ofErrors([coercionError(\"Expected type \".concat(type.name), blameNode, path, didYouMean)]);\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    var itemType = type.ofType;\n\n    if ((0, _iterall.isCollection)(value)) {\n      var errors;\n      var coercedValue = [];\n      (0, _iterall.forEach)(value, function (itemValue, index) {\n        var coercedItem = coerceValue(itemValue, itemType, blameNode, atPath(path, index));\n\n        if (coercedItem.errors) {\n          errors = add(errors, coercedItem.errors);\n        } else if (!errors) {\n          coercedValue.push(coercedItem.value);\n        }\n      });\n      return errors ? ofErrors(errors) : ofValue(coercedValue);\n    } // Lists accept a non-list value as a list of one.\n\n\n    var coercedItem = coerceValue(value, itemType, blameNode);\n    return coercedItem.errors ? coercedItem : ofValue([coercedItem.value]);\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (_typeof(value) !== 'object') {\n      return ofErrors([coercionError(\"Expected type \".concat(type.name, \" to be an object\"), blameNode, path)]);\n    }\n\n    var _errors;\n\n    var _coercedValue = {};\n    var fields = type.getFields(); // Ensure every defined field is valid.\n\n    for (var fieldName in fields) {\n      if (hasOwnProperty.call(fields, fieldName)) {\n        var field = fields[fieldName];\n        var fieldValue = value[fieldName];\n\n        if ((0, _isInvalid.default)(fieldValue)) {\n          if (!(0, _isInvalid.default)(field.defaultValue)) {\n            _coercedValue[fieldName] = field.defaultValue;\n          } else if ((0, _definition.isNonNullType)(field.type)) {\n            _errors = add(_errors, coercionError(\"Field \".concat(printPath(atPath(path, fieldName)), \" of required \") + \"type \".concat((0, _inspect.default)(field.type), \" was not provided\"), blameNode));\n          }\n        } else {\n          var coercedField = coerceValue(fieldValue, field.type, blameNode, atPath(path, fieldName));\n\n          if (coercedField.errors) {\n            _errors = add(_errors, coercedField.errors);\n          } else if (!_errors) {\n            _coercedValue[fieldName] = coercedField.value;\n          }\n        }\n      }\n    } // Ensure every provided field is defined.\n\n\n    for (var _fieldName in value) {\n      if (hasOwnProperty.call(value, _fieldName)) {\n        if (!fields[_fieldName]) {\n          var _suggestions = (0, _suggestionList.default)(_fieldName, Object.keys(fields));\n\n          var _didYouMean = _suggestions.length !== 0 ? \"did you mean \".concat((0, _orList.default)(_suggestions), \"?\") : undefined;\n\n          _errors = add(_errors, coercionError(\"Field \\\"\".concat(_fieldName, \"\\\" is not defined by type \").concat(type.name), blameNode, path, _didYouMean));\n        }\n      }\n    }\n\n    return _errors ? ofErrors(_errors) : ofValue(_coercedValue);\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unexpected type: \".concat(type, \".\"));\n}\n\nfunction ofValue(value) {\n  return {\n    errors: undefined,\n    value: value\n  };\n}\n\nfunction ofErrors(errors) {\n  return {\n    errors: errors,\n    value: undefined\n  };\n}\n\nfunction add(errors, moreErrors) {\n  return (errors || []).concat(moreErrors);\n}\n\nfunction atPath(prev, key) {\n  return {\n    prev: prev,\n    key: key\n  };\n}\n\nfunction coercionError(message, blameNode, path, subMessage, originalError) {\n  var pathStr = printPath(path); // Return a GraphQLError instance\n\n  return new _GraphQLError.GraphQLError(message + (pathStr ? ' at ' + pathStr : '') + (subMessage ? '; ' + subMessage : '.'), blameNode, undefined, undefined, undefined, originalError);\n} // Build a string describing the path into the value where the error was found\n\n\nfunction printPath(path) {\n  var pathStr = '';\n  var currentPath = path;\n\n  while (currentPath) {\n    pathStr = (typeof currentPath.key === 'string' ? '.' + currentPath.key : '[' + String(currentPath.key) + ']') + pathStr;\n    currentPath = currentPath.prev;\n  }\n\n  return pathStr ? 'value' + pathStr : '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/coerceValue.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/concatAST.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphql/utilities/concatAST.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concatAST = concatAST;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n */\nfunction concatAST(asts) {\n  var batchDefinitions = [];\n\n  for (var i = 0; i < asts.length; i++) {\n    var definitions = asts[i].definitions;\n\n    for (var j = 0; j < definitions.length; j++) {\n      batchDefinitions.push(definitions[j]);\n    }\n  }\n\n  return {\n    kind: 'Document',\n    definitions: batchDefinitions\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/concatAST.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/extendSchema.js":
/*!********************************************************!*\
  !*** ./node_modules/graphql/utilities/extendSchema.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSchema = extendSchema;\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _keyValMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyValMap */ \"./node_modules/graphql/jsutils/keyValMap.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _buildASTSchema = __webpack_require__(/*! ./buildASTSchema */ \"./node_modules/graphql/utilities/buildASTSchema.js\");\n\nvar _validate = __webpack_require__(/*! ../validation/validate */ \"./node_modules/graphql/validation/validate.js\");\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _schema = __webpack_require__(/*! ../type/schema */ \"./node_modules/graphql/type/schema.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nvar _scalars = __webpack_require__(/*! ../type/scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _directives = __webpack_require__(/*! ../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _predicates = __webpack_require__(/*! ../language/predicates */ \"./node_modules/graphql/language/predicates.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nfunction extendSchema(schema, documentAST, options) {\n  !(0, _schema.isSchema)(schema) ? (0, _invariant.default)(0, 'Must provide valid GraphQLSchema') : void 0;\n  !(documentAST && documentAST.kind === _kinds.Kind.DOCUMENT) ? (0, _invariant.default)(0, 'Must provide valid Document AST') : void 0;\n\n  if (!options || !(options.assumeValid || options.assumeValidSDL)) {\n    (0, _validate.assertValidSDLExtension)(documentAST, schema);\n  } // Collect the type definitions and extensions found in the document.\n\n\n  var typeDefinitionMap = Object.create(null);\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefinitions = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var def = documentAST.definitions[i];\n\n    if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if ((0, _predicates.isTypeDefinitionNode)(def)) {\n      // Sanity check that none of the defined types conflict with the\n      // schema's existing types.\n      var typeName = def.name.value;\n\n      if (schema.getType(typeName)) {\n        throw new _GraphQLError.GraphQLError(\"Type \\\"\".concat(typeName, \"\\\" already exists in the schema. It cannot also \") + 'be defined in this type definition.', [def]);\n      }\n\n      typeDefinitionMap[typeName] = def;\n    } else if ((0, _predicates.isTypeExtensionNode)(def)) {\n      // Sanity check that this type extension exists within the\n      // schema's existing types.\n      var extendedTypeName = def.name.value;\n      var existingType = schema.getType(extendedTypeName);\n\n      if (!existingType) {\n        throw new _GraphQLError.GraphQLError(\"Cannot extend type \\\"\".concat(extendedTypeName, \"\\\" because it does not \") + 'exist in the existing schema.', [def]);\n      }\n\n      checkExtensionNode(existingType, def);\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n      var directiveName = def.name.value;\n      var existingDirective = schema.getDirective(directiveName);\n\n      if (existingDirective) {\n        throw new _GraphQLError.GraphQLError(\"Directive \\\"\".concat(directiveName, \"\\\" already exists in the schema. It \") + 'cannot be redefined.', [def]);\n      }\n\n      directiveDefinitions.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && Object.keys(typeDefinitionMap).length === 0 && directiveDefinitions.length === 0 && schemaExtensions.length === 0 && !schemaDef) {\n    return schema;\n  }\n\n  var astBuilder = new _buildASTSchema.ASTDefinitionBuilder(typeDefinitionMap, options, function (typeRef) {\n    var typeName = typeRef.name.value;\n    var existingType = schema.getType(typeName);\n\n    if (existingType) {\n      return extendNamedType(existingType);\n    }\n\n    throw new _GraphQLError.GraphQLError(\"Unknown type: \\\"\".concat(typeName, \"\\\". Ensure that this type exists \") + 'either in the original schema, or is added in a type definition.', [typeRef]);\n  });\n  var extendTypeCache = Object.create(null); // Get the extended root operation types.\n\n  var operationTypes = {\n    query: extendMaybeNamedType(schema.getQueryType()),\n    mutation: extendMaybeNamedType(schema.getMutationType()),\n    subscription: extendMaybeNamedType(schema.getSubscriptionType())\n  };\n\n  if (schemaDef) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schemaDef.operationTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref2 = _step.value;\n        var operation = _ref2.operation,\n            type = _ref2.type;\n\n        if (operationTypes[operation]) {\n          throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n        } // Note: While this could make early assertions to get the correctly\n        // typed values, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n\n\n        operationTypes[operation] = astBuilder.buildType(type);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } // Then, incorporate schema definition and all schema extensions.\n\n\n  for (var _i = 0; _i < schemaExtensions.length; _i++) {\n    var schemaExtension = schemaExtensions[_i];\n\n    if (schemaExtension.operationTypes) {\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = schemaExtension.operationTypes[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _ref4 = _step12.value;\n          var operation = _ref4.operation,\n              type = _ref4.type;\n\n          if (operationTypes[operation]) {\n            throw new Error(\"Must provide only one \".concat(operation, \" type in schema.\"));\n          } // Note: While this could make early assertions to get the correctly\n          // typed values, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n\n\n          operationTypes[operation] = astBuilder.buildType(type);\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n    }\n  }\n\n  var schemaExtensionASTNodes = schemaExtensions ? schema.extensionASTNodes ? schema.extensionASTNodes.concat(schemaExtensions) : schemaExtensions : schema.extensionASTNodes;\n  var types = (0, _objectValues.default)(schema.getTypeMap()).map(function (type) {\n    return extendNamedType(type);\n  }).concat((0, _objectValues.default)(typeDefinitionMap).map(function (type) {\n    return astBuilder.buildType(type);\n  })); // Support both original legacy names and extended legacy names.\n\n  var allowedLegacyNames = schema.__allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.\n\n\n  return new _schema.GraphQLSchema(_objectSpread({}, operationTypes, {\n    types: types,\n    directives: getMergedDirectives(),\n    astNode: schema.astNode,\n    extensionASTNodes: schemaExtensionASTNodes,\n    allowedLegacyNames: allowedLegacyNames\n  })); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives() {\n    var existingDirectives = schema.getDirectives().map(extendDirective);\n    !existingDirectives ? (0, _invariant.default)(0, 'schema must have default directives') : void 0;\n    return existingDirectives.concat(directiveDefinitions.map(function (node) {\n      return astBuilder.buildDirective(node);\n    }));\n  }\n\n  function extendMaybeNamedType(type) {\n    return type ? extendNamedType(type) : null;\n  }\n\n  function extendNamedType(type) {\n    if ((0, _introspection.isIntrospectionType)(type) || (0, _scalars.isSpecifiedScalarType)(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    var name = type.name;\n\n    if (!extendTypeCache[name]) {\n      if ((0, _definition.isScalarType)(type)) {\n        extendTypeCache[name] = extendScalarType(type);\n      } else if ((0, _definition.isObjectType)(type)) {\n        extendTypeCache[name] = extendObjectType(type);\n      } else if ((0, _definition.isInterfaceType)(type)) {\n        extendTypeCache[name] = extendInterfaceType(type);\n      } else if ((0, _definition.isUnionType)(type)) {\n        extendTypeCache[name] = extendUnionType(type);\n      } else if ((0, _definition.isEnumType)(type)) {\n        extendTypeCache[name] = extendEnumType(type);\n      } else if ((0, _definition.isInputObjectType)(type)) {\n        extendTypeCache[name] = extendInputObjectType(type);\n      }\n    }\n\n    return extendTypeCache[name];\n  }\n\n  function extendDirective(directive) {\n    return new _directives.GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: directive.locations,\n      args: extendArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function extendInputObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLInputObjectType({\n      name: name,\n      description: type.description,\n      fields: function fields() {\n        return extendInputFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendInputFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr = Object.keys(oldFieldMap);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var _fieldName = _arr[_i2];\n      var _field = oldFieldMap[_fieldName];\n      newFieldMap[_fieldName] = {\n        description: _field.description,\n        type: extendType(_field.type),\n        defaultValue: _field.defaultValue,\n        astNode: _field.astNode\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var extension = _step2.value;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = extension.fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var field = _step3.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new _GraphQLError.GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildInputField(field);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendEnumType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLEnumType({\n      name: name,\n      description: type.description,\n      values: extendValueMap(type),\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendValueMap(type) {\n    var newValueMap = Object.create(null);\n    var oldValueMap = (0, _keyMap.default)(type.getValues(), function (value) {\n      return value.name;\n    });\n\n    var _arr2 = Object.keys(oldValueMap);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var _valueName = _arr2[_i3];\n      var _value = oldValueMap[_valueName];\n      newValueMap[_valueName] = {\n        name: _value.name,\n        description: _value.description,\n        value: _value.value,\n        deprecationReason: _value.deprecationReason,\n        astNode: _value.astNode\n      };\n    } // If there are any extensions to the values, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var extension = _step4.value;\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = extension.values[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var value = _step5.value;\n              var valueName = value.name.value;\n\n              if (oldValueMap[valueName]) {\n                throw new _GraphQLError.GraphQLError(\"Enum value \\\"\".concat(type.name, \".\").concat(valueName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [value]);\n              }\n\n              newValueMap[valueName] = astBuilder.buildEnumValue(value);\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n\n    return newValueMap;\n  }\n\n  function extendScalarType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLScalarType({\n      name: name,\n      description: type.description,\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      serialize: type.serialize,\n      parseValue: type.parseValue,\n      parseLiteral: type.parseLiteral\n    });\n  }\n\n  function extendObjectType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLObjectType({\n      name: name,\n      description: type.description,\n      interfaces: function interfaces() {\n        return extendImplementedInterfaces(type);\n      },\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      isTypeOf: type.isTypeOf\n    });\n  }\n\n  function extendArgs(args) {\n    return (0, _keyValMap.default)(args, function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return {\n        type: extendType(arg.type),\n        defaultValue: arg.defaultValue,\n        description: arg.description,\n        astNode: arg.astNode\n      };\n    });\n  }\n\n  function extendInterfaceType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: function fields() {\n        return extendFieldMap(type);\n      },\n      astNode: type.astNode,\n      extensionASTNodes: extensionASTNodes,\n      resolveType: type.resolveType\n    });\n  }\n\n  function extendUnionType(type) {\n    var name = type.name;\n    var extensionASTNodes = typeExtensionsMap[name] ? type.extensionASTNodes ? type.extensionASTNodes.concat(typeExtensionsMap[name]) : typeExtensionsMap[name] : type.extensionASTNodes;\n    return new _definition.GraphQLUnionType({\n      name: name,\n      description: type.description,\n      types: function types() {\n        return extendPossibleTypes(type);\n      },\n      astNode: type.astNode,\n      resolveType: type.resolveType,\n      extensionASTNodes: extensionASTNodes\n    });\n  }\n\n  function extendPossibleTypes(type) {\n    var possibleTypes = type.getTypes().map(extendNamedType); // If there are any extensions to the union, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var extension = _step6.value;\n          var _iteratorNormalCompletion7 = true;\n          var _didIteratorError7 = false;\n          var _iteratorError7 = undefined;\n\n          try {\n            for (var _iterator7 = extension.types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n              var namedType = _step7.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              possibleTypes.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError7 = true;\n            _iteratorError7 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                _iterator7.return();\n              }\n            } finally {\n              if (_didIteratorError7) {\n                throw _iteratorError7;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n\n    return possibleTypes;\n  }\n\n  function extendImplementedInterfaces(type) {\n    var interfaces = type.getInterfaces().map(extendNamedType); // If there are any extensions to the interfaces, apply those here.\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var extension = _step8.value;\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = extension.interfaces[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var namedType = _step9.value;\n              // Note: While this could make early assertions to get the correctly\n              // typed values, that would throw immediately while type system\n              // validation with validateSchema() will produce more actionable results.\n              interfaces.push(astBuilder.buildType(namedType));\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type) {\n    var newFieldMap = Object.create(null);\n    var oldFieldMap = type.getFields();\n\n    var _arr3 = Object.keys(oldFieldMap);\n\n    for (var _i4 = 0; _i4 < _arr3.length; _i4++) {\n      var _fieldName2 = _arr3[_i4];\n      var _field2 = oldFieldMap[_fieldName2];\n      newFieldMap[_fieldName2] = {\n        description: _field2.description,\n        deprecationReason: _field2.deprecationReason,\n        type: extendType(_field2.type),\n        args: extendArgs(_field2.args),\n        astNode: _field2.astNode,\n        resolve: _field2.resolve\n      };\n    } // If there are any extensions to the fields, apply those here.\n\n\n    var extensions = typeExtensionsMap[type.name];\n\n    if (extensions) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extensions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var extension = _step10.value;\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = extension.fields[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var field = _step11.value;\n              var fieldName = field.name.value;\n\n              if (oldFieldMap[fieldName]) {\n                throw new _GraphQLError.GraphQLError(\"Field \\\"\".concat(type.name, \".\").concat(fieldName, \"\\\" already exists in the \") + 'schema. It cannot also be defined in this type extension.', [field]);\n              }\n\n              newFieldMap[fieldName] = astBuilder.buildField(field);\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n\n    return newFieldMap;\n  }\n\n  function extendType(typeDef) {\n    if ((0, _definition.isListType)(typeDef)) {\n      return (0, _definition.GraphQLList)(extendType(typeDef.ofType));\n    }\n\n    if ((0, _definition.isNonNullType)(typeDef)) {\n      return (0, _definition.GraphQLNonNull)(extendType(typeDef.ofType));\n    }\n\n    return extendNamedType(typeDef);\n  }\n}\n\nfunction checkExtensionNode(type, node) {\n  switch (node.kind) {\n    case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n      if (!(0, _definition.isObjectType)(type)) {\n        throw new _GraphQLError.GraphQLError(\"Cannot extend non-object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n      if (!(0, _definition.isInterfaceType)(type)) {\n        throw new _GraphQLError.GraphQLError(\"Cannot extend non-interface type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case _kinds.Kind.ENUM_TYPE_EXTENSION:\n      if (!(0, _definition.isEnumType)(type)) {\n        throw new _GraphQLError.GraphQLError(\"Cannot extend non-enum type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case _kinds.Kind.UNION_TYPE_EXTENSION:\n      if (!(0, _definition.isUnionType)(type)) {\n        throw new _GraphQLError.GraphQLError(\"Cannot extend non-union type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n\n    case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      if (!(0, _definition.isInputObjectType)(type)) {\n        throw new _GraphQLError.GraphQLError(\"Cannot extend non-input object type \\\"\".concat(type.name, \"\\\".\"), [node]);\n      }\n\n      break;\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/extendSchema.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/findBreakingChanges.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphql/utilities/findBreakingChanges.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findBreakingChanges = findBreakingChanges;\nexports.findDangerousChanges = findDangerousChanges;\nexports.findRemovedTypes = findRemovedTypes;\nexports.findTypesThatChangedKind = findTypesThatChangedKind;\nexports.findArgChanges = findArgChanges;\nexports.findFieldsThatChangedTypeOnObjectOrInterfaceTypes = findFieldsThatChangedTypeOnObjectOrInterfaceTypes;\nexports.findFieldsThatChangedTypeOnInputObjectTypes = findFieldsThatChangedTypeOnInputObjectTypes;\nexports.findTypesRemovedFromUnions = findTypesRemovedFromUnions;\nexports.findTypesAddedToUnions = findTypesAddedToUnions;\nexports.findValuesRemovedFromEnums = findValuesRemovedFromEnums;\nexports.findValuesAddedToEnums = findValuesAddedToEnums;\nexports.findInterfacesRemovedFromObjectTypes = findInterfacesRemovedFromObjectTypes;\nexports.findInterfacesAddedToObjectTypes = findInterfacesAddedToObjectTypes;\nexports.findRemovedDirectives = findRemovedDirectives;\nexports.findRemovedDirectiveArgs = findRemovedDirectiveArgs;\nexports.findAddedNonNullDirectiveArgs = findAddedNonNullDirectiveArgs;\nexports.findRemovedLocationsForDirective = findRemovedLocationsForDirective;\nexports.findRemovedDirectiveLocations = findRemovedDirectiveLocations;\nexports.DangerousChangeType = exports.BreakingChangeType = void 0;\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2016-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nvar BreakingChangeType = {\n  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',\n  FIELD_REMOVED: 'FIELD_REMOVED',\n  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',\n  TYPE_REMOVED: 'TYPE_REMOVED',\n  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',\n  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',\n  ARG_REMOVED: 'ARG_REMOVED',\n  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',\n  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',\n  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',\n  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',\n  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',\n  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',\n  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED',\n  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED'\n};\nexports.BreakingChangeType = BreakingChangeType;\nvar DangerousChangeType = {\n  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE',\n  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',\n  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',\n  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',\n  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',\n  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED'\n};\nexports.DangerousChangeType = DangerousChangeType;\n\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of breaking changes covered by the other functions down below.\n */\nfunction findBreakingChanges(oldSchema, newSchema) {\n  return findRemovedTypes(oldSchema, newSchema).concat(findTypesThatChangedKind(oldSchema, newSchema), findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).breakingChanges, findTypesRemovedFromUnions(oldSchema, newSchema), findValuesRemovedFromEnums(oldSchema, newSchema), findArgChanges(oldSchema, newSchema).breakingChanges, findInterfacesRemovedFromObjectTypes(oldSchema, newSchema), findRemovedDirectives(oldSchema, newSchema), findRemovedDirectiveArgs(oldSchema, newSchema), findAddedNonNullDirectiveArgs(oldSchema, newSchema), findRemovedDirectiveLocations(oldSchema, newSchema));\n}\n/**\n * Given two schemas, returns an Array containing descriptions of all the types\n * of potentially dangerous changes covered by the other functions down below.\n */\n\n\nfunction findDangerousChanges(oldSchema, newSchema) {\n  return findArgChanges(oldSchema, newSchema).dangerousChanges.concat(findValuesAddedToEnums(oldSchema, newSchema), findInterfacesAddedToObjectTypes(oldSchema, newSchema), findTypesAddedToUnions(oldSchema, newSchema), findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema).dangerousChanges);\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing an entire type.\n */\n\n\nfunction findRemovedTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr = Object.keys(oldTypeMap);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var typeName = _arr[_i];\n\n    if (!newTypeMap[typeName]) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_REMOVED,\n        description: \"\".concat(typeName, \" was removed.\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to changing the type of a type.\n */\n\n\nfunction findTypesThatChangedKind(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr2 = Object.keys(oldTypeMap);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var typeName = _arr2[_i2];\n\n    if (!newTypeMap[typeName]) {\n      continue;\n    }\n\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (oldType.constructor !== newType.constructor) {\n      breakingChanges.push({\n        type: BreakingChangeType.TYPE_CHANGED_KIND,\n        description: \"\".concat(typeName, \" changed from \") + \"\".concat(typeKindName(oldType), \" to \").concat(typeKindName(newType), \".\")\n      });\n    }\n  }\n\n  return breakingChanges;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any\n * breaking or dangerous changes in the newSchema related to arguments\n * (such as removal or change of type of an argument, or a change in an\n * argument's default value).\n */\n\n\nfunction findArgChanges(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr3 = Object.keys(oldTypeMap);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var typeName = _arr3[_i3];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!((0, _definition.isObjectType)(oldType) || (0, _definition.isInterfaceType)(oldType)) || !((0, _definition.isObjectType)(newType) || (0, _definition.isInterfaceType)(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFields = oldType.getFields();\n    var newTypeFields = newType.getFields();\n\n    var _arr4 = Object.keys(oldTypeFields);\n\n    for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n      var fieldName = _arr4[_i4];\n\n      if (!newTypeFields[fieldName]) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var oldArgDef = _step.value;\n          var newArgs = newTypeFields[fieldName].args;\n          var newArgDef = newArgs.find(function (arg) {\n            return arg.name === oldArgDef.name;\n          }); // Arg not present\n\n          if (!newArgDef) {\n            breakingChanges.push({\n              type: BreakingChangeType.ARG_REMOVED,\n              description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" was removed\")\n            });\n          } else {\n            var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArgDef.type, newArgDef.type);\n\n            if (!isSafe) {\n              breakingChanges.push({\n                type: BreakingChangeType.ARG_CHANGED_KIND,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed type from \") + \"\".concat(oldArgDef.type.toString(), \" to \").concat(newArgDef.type.toString())\n              });\n            } else if (oldArgDef.defaultValue !== undefined && oldArgDef.defaultValue !== newArgDef.defaultValue) {\n              dangerousChanges.push({\n                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,\n                description: \"\".concat(oldType.name, \".\").concat(fieldName, \" arg \") + \"\".concat(oldArgDef.name, \" has changed defaultValue\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator = oldTypeFields[fieldName].args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Check if arg was added to the field\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop2 = function _loop2() {\n          var newArgDef = _step2.value;\n          var oldArgs = oldTypeFields[fieldName].args;\n          var oldArgDef = oldArgs.find(function (arg) {\n            return arg.name === newArgDef.name;\n          });\n\n          if (!oldArgDef) {\n            var argName = newArgDef.name;\n\n            if ((0, _definition.isRequiredArgument)(newArgDef)) {\n              breakingChanges.push({\n                type: BreakingChangeType.REQUIRED_ARG_ADDED,\n                description: \"A required arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            } else {\n              dangerousChanges.push({\n                type: DangerousChangeType.OPTIONAL_ARG_ADDED,\n                description: \"An optional arg \".concat(argName, \" on \") + \"\".concat(typeName, \".\").concat(fieldName, \" was added\")\n              });\n            }\n          }\n        };\n\n        for (var _iterator2 = newTypeFields[fieldName].args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop2();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction typeKindName(type) {\n  if ((0, _definition.isScalarType)(type)) {\n    return 'a Scalar type';\n  }\n\n  if ((0, _definition.isObjectType)(type)) {\n    return 'an Object type';\n  }\n\n  if ((0, _definition.isInterfaceType)(type)) {\n    return 'an Interface type';\n  }\n\n  if ((0, _definition.isUnionType)(type)) {\n    return 'a Union type';\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    return 'an Enum type';\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    return 'an Input type';\n  }\n\n  throw new TypeError('Unknown type ' + type.constructor.name);\n}\n\nfunction findFieldsThatChangedTypeOnObjectOrInterfaceTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr5 = Object.keys(oldTypeMap);\n\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var typeName = _arr5[_i5];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!((0, _definition.isObjectType)(oldType) || (0, _definition.isInterfaceType)(oldType)) || !((0, _definition.isObjectType)(newType) || (0, _definition.isInterfaceType)(newType)) || newType.constructor !== oldType.constructor) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr6 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var fieldName = _arr6[_i6];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForObjectOrInterfaceField(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = (0, _definition.isNamedType)(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = (0, _definition.isNamedType)(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\n\nfunction findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n  var dangerousChanges = [];\n\n  var _arr7 = Object.keys(oldTypeMap);\n\n  for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n    var typeName = _arr7[_i7];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isInputObjectType)(oldType) || !(0, _definition.isInputObjectType)(newType)) {\n      continue;\n    }\n\n    var oldTypeFieldsDef = oldType.getFields();\n    var newTypeFieldsDef = newType.getFields();\n\n    var _arr8 = Object.keys(oldTypeFieldsDef);\n\n    for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n      var fieldName = _arr8[_i8];\n\n      // Check if the field is missing on the type in the new schema.\n      if (!(fieldName in newTypeFieldsDef)) {\n        breakingChanges.push({\n          type: BreakingChangeType.FIELD_REMOVED,\n          description: \"\".concat(typeName, \".\").concat(fieldName, \" was removed.\")\n        });\n      } else {\n        var oldFieldType = oldTypeFieldsDef[fieldName].type;\n        var newFieldType = newTypeFieldsDef[fieldName].type;\n        var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldFieldType, newFieldType);\n\n        if (!isSafe) {\n          var oldFieldTypeString = (0, _definition.isNamedType)(oldFieldType) ? oldFieldType.name : oldFieldType.toString();\n          var newFieldTypeString = (0, _definition.isNamedType)(newFieldType) ? newFieldType.name : newFieldType.toString();\n          breakingChanges.push({\n            type: BreakingChangeType.FIELD_CHANGED_KIND,\n            description: \"\".concat(typeName, \".\").concat(fieldName, \" changed type from \") + \"\".concat(oldFieldTypeString, \" to \").concat(newFieldTypeString, \".\")\n          });\n        }\n      }\n    } // Check if a field was added to the input object type\n\n\n    var _arr9 = Object.keys(newTypeFieldsDef);\n\n    for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n      var _fieldName = _arr9[_i9];\n\n      if (!(_fieldName in oldTypeFieldsDef)) {\n        if ((0, _definition.isRequiredInputField)(newTypeFieldsDef[_fieldName])) {\n          breakingChanges.push({\n            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,\n            description: \"A required field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        } else {\n          dangerousChanges.push({\n            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,\n            description: \"An optional field \".concat(_fieldName, \" on \") + \"input type \".concat(typeName, \" was added.\")\n          });\n        }\n      }\n    }\n  }\n\n  return {\n    breakingChanges: breakingChanges,\n    dangerousChanges: dangerousChanges\n  };\n}\n\nfunction isChangeSafeForObjectOrInterfaceField(oldType, newType) {\n  if ((0, _definition.isNamedType)(oldType)) {\n    return (// if they're both named types, see if their names are equivalent\n      (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if ((0, _definition.isListType)(oldType)) {\n    return (// if they're both lists, make sure the underlying types are compatible\n      (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)\n    );\n  } else if ((0, _definition.isNonNullType)(oldType)) {\n    // if they're both non-null, make sure the underlying types are compatible\n    return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);\n  }\n\n  return false;\n}\n\nfunction isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {\n  if ((0, _definition.isNamedType)(oldType)) {\n    // if they're both named types, see if their names are equivalent\n    return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;\n  } else if ((0, _definition.isListType)(oldType)) {\n    // if they're both lists, make sure the underlying types are compatible\n    return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);\n  } else if ((0, _definition.isNonNullType)(oldType)) {\n    return (// if they're both non-null, make sure the underlying types are\n      // compatible\n      (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe\n      !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)\n    );\n  }\n\n  return false;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing types from a union type.\n */\n\n\nfunction findTypesRemovedFromUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesRemovedFromUnion = [];\n\n  var _arr10 = Object.keys(oldTypeMap);\n\n  for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n    var typeName = _arr10[_i10];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isUnionType)(oldType) || !(0, _definition.isUnionType)(newType)) {\n      continue;\n    }\n\n    var typeNamesInNewUnion = Object.create(null);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = newType.getTypes()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var type = _step3.value;\n        typeNamesInNewUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = oldType.getTypes()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _type = _step4.value;\n\n        if (!typeNamesInNewUnion[_type.name]) {\n          typesRemovedFromUnion.push({\n            type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,\n            description: \"\".concat(_type.name, \" was removed from union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  }\n\n  return typesRemovedFromUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding types to a union type.\n */\n\n\nfunction findTypesAddedToUnions(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var typesAddedToUnion = [];\n\n  var _arr11 = Object.keys(newTypeMap);\n\n  for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n    var typeName = _arr11[_i11];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isUnionType)(oldType) || !(0, _definition.isUnionType)(newType)) {\n      continue;\n    }\n\n    var typeNamesInOldUnion = Object.create(null);\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = oldType.getTypes()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var type = _step5.value;\n        typeNamesInOldUnion[type.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = newType.getTypes()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var _type2 = _step6.value;\n\n        if (!typeNamesInOldUnion[_type2.name]) {\n          typesAddedToUnion.push({\n            type: DangerousChangeType.TYPE_ADDED_TO_UNION,\n            description: \"\".concat(_type2.name, \" was added to union type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  return typesAddedToUnion;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any breaking\n * changes in the newSchema related to removing values from an enum type.\n */\n\n\nfunction findValuesRemovedFromEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesRemovedFromEnums = [];\n\n  var _arr12 = Object.keys(oldTypeMap);\n\n  for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n    var typeName = _arr12[_i12];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isEnumType)(oldType) || !(0, _definition.isEnumType)(newType)) {\n      continue;\n    }\n\n    var valuesInNewEnum = Object.create(null);\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = newType.getValues()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var value = _step7.value;\n        valuesInNewEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = oldType.getValues()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var _value = _step8.value;\n\n        if (!valuesInNewEnum[_value.name]) {\n          valuesRemovedFromEnums.push({\n            type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,\n            description: \"\".concat(_value.name, \" was removed from enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n\n  return valuesRemovedFromEnums;\n}\n/**\n * Given two schemas, returns an Array containing descriptions of any dangerous\n * changes in the newSchema related to adding values to an enum type.\n */\n\n\nfunction findValuesAddedToEnums(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var valuesAddedToEnums = [];\n\n  var _arr13 = Object.keys(oldTypeMap);\n\n  for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n    var typeName = _arr13[_i13];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isEnumType)(oldType) || !(0, _definition.isEnumType)(newType)) {\n      continue;\n    }\n\n    var valuesInOldEnum = Object.create(null);\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = oldType.getValues()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var value = _step9.value;\n        valuesInOldEnum[value.name] = true;\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      for (var _iterator10 = newType.getValues()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _value2 = _step10.value;\n\n        if (!valuesInOldEnum[_value2.name]) {\n          valuesAddedToEnums.push({\n            type: DangerousChangeType.VALUE_ADDED_TO_ENUM,\n            description: \"\".concat(_value2.name, \" was added to enum type \").concat(typeName, \".\")\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n  }\n\n  return valuesAddedToEnums;\n}\n\nfunction findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var breakingChanges = [];\n\n  var _arr14 = Object.keys(oldTypeMap);\n\n  for (var _i14 = 0; _i14 < _arr14.length; _i14++) {\n    var typeName = _arr14[_i14];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isObjectType)(oldType) || !(0, _definition.isObjectType)(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion11 = true;\n    var _didIteratorError11 = false;\n    var _iteratorError11 = undefined;\n\n    try {\n      var _loop3 = function _loop3() {\n        var oldInterface = _step11.value;\n\n        if (!newInterfaces.some(function (int) {\n          return int.name === oldInterface.name;\n        })) {\n          breakingChanges.push({\n            type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,\n            description: \"\".concat(typeName, \" no longer implements interface \") + \"\".concat(oldInterface.name, \".\")\n          });\n        }\n      };\n\n      for (var _iterator11 = oldInterfaces[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n        _loop3();\n      }\n    } catch (err) {\n      _didIteratorError11 = true;\n      _iteratorError11 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n          _iterator11.return();\n        }\n      } finally {\n        if (_didIteratorError11) {\n          throw _iteratorError11;\n        }\n      }\n    }\n  }\n\n  return breakingChanges;\n}\n\nfunction findInterfacesAddedToObjectTypes(oldSchema, newSchema) {\n  var oldTypeMap = oldSchema.getTypeMap();\n  var newTypeMap = newSchema.getTypeMap();\n  var interfacesAddedToObjectTypes = [];\n\n  var _arr15 = Object.keys(newTypeMap);\n\n  for (var _i15 = 0; _i15 < _arr15.length; _i15++) {\n    var typeName = _arr15[_i15];\n    var oldType = oldTypeMap[typeName];\n    var newType = newTypeMap[typeName];\n\n    if (!(0, _definition.isObjectType)(oldType) || !(0, _definition.isObjectType)(newType)) {\n      continue;\n    }\n\n    var oldInterfaces = oldType.getInterfaces();\n    var newInterfaces = newType.getInterfaces();\n    var _iteratorNormalCompletion12 = true;\n    var _didIteratorError12 = false;\n    var _iteratorError12 = undefined;\n\n    try {\n      var _loop4 = function _loop4() {\n        var newInterface = _step12.value;\n\n        if (!oldInterfaces.some(function (int) {\n          return int.name === newInterface.name;\n        })) {\n          interfacesAddedToObjectTypes.push({\n            type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,\n            description: \"\".concat(newInterface.name, \" added to interfaces implemented \") + \"by \".concat(typeName, \".\")\n          });\n        }\n      };\n\n      for (var _iterator12 = newInterfaces[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n        _loop4();\n      }\n    } catch (err) {\n      _didIteratorError12 = true;\n      _iteratorError12 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n          _iterator12.return();\n        }\n      } finally {\n        if (_didIteratorError12) {\n          throw _iteratorError12;\n        }\n      }\n    }\n  }\n\n  return interfacesAddedToObjectTypes;\n}\n\nfunction findRemovedDirectives(oldSchema, newSchema) {\n  var removedDirectives = [];\n  var newSchemaDirectiveMap = getDirectiveMapForSchema(newSchema);\n  var _iteratorNormalCompletion13 = true;\n  var _didIteratorError13 = false;\n  var _iteratorError13 = undefined;\n\n  try {\n    for (var _iterator13 = oldSchema.getDirectives()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n      var directive = _step13.value;\n\n      if (!newSchemaDirectiveMap[directive.name]) {\n        removedDirectives.push({\n          type: BreakingChangeType.DIRECTIVE_REMOVED,\n          description: \"\".concat(directive.name, \" was removed\")\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError13 = true;\n    _iteratorError13 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n        _iterator13.return();\n      }\n    } finally {\n      if (_didIteratorError13) {\n        throw _iteratorError13;\n      }\n    }\n  }\n\n  return removedDirectives;\n}\n\nfunction findRemovedArgsForDirective(oldDirective, newDirective) {\n  var removedArgs = [];\n  var newArgMap = getArgumentMapForDirective(newDirective);\n  var _iteratorNormalCompletion14 = true;\n  var _didIteratorError14 = false;\n  var _iteratorError14 = undefined;\n\n  try {\n    for (var _iterator14 = oldDirective.args[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n      var arg = _step14.value;\n\n      if (!newArgMap[arg.name]) {\n        removedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError14 = true;\n    _iteratorError14 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n        _iterator14.return();\n      }\n    } finally {\n      if (_didIteratorError14) {\n        throw _iteratorError14;\n      }\n    }\n  }\n\n  return removedArgs;\n}\n\nfunction findRemovedDirectiveArgs(oldSchema, newSchema) {\n  var removedDirectiveArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion15 = true;\n  var _didIteratorError15 = false;\n  var _iteratorError15 = undefined;\n\n  try {\n    for (var _iterator15 = newSchema.getDirectives()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n      var newDirective = _step15.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = findRemovedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var arg = _step16.value;\n          removedDirectiveArgs.push({\n            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,\n            description: \"\".concat(arg.name, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError15 = true;\n    _iteratorError15 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n        _iterator15.return();\n      }\n    } finally {\n      if (_didIteratorError15) {\n        throw _iteratorError15;\n      }\n    }\n  }\n\n  return removedDirectiveArgs;\n}\n\nfunction findAddedArgsForDirective(oldDirective, newDirective) {\n  var addedArgs = [];\n  var oldArgMap = getArgumentMapForDirective(oldDirective);\n  var _iteratorNormalCompletion17 = true;\n  var _didIteratorError17 = false;\n  var _iteratorError17 = undefined;\n\n  try {\n    for (var _iterator17 = newDirective.args[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n      var arg = _step17.value;\n\n      if (!oldArgMap[arg.name]) {\n        addedArgs.push(arg);\n      }\n    }\n  } catch (err) {\n    _didIteratorError17 = true;\n    _iteratorError17 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n        _iterator17.return();\n      }\n    } finally {\n      if (_didIteratorError17) {\n        throw _iteratorError17;\n      }\n    }\n  }\n\n  return addedArgs;\n}\n\nfunction findAddedNonNullDirectiveArgs(oldSchema, newSchema) {\n  var addedNonNullableArgs = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion18 = true;\n  var _didIteratorError18 = false;\n  var _iteratorError18 = undefined;\n\n  try {\n    for (var _iterator18 = newSchema.getDirectives()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n      var newDirective = _step18.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = findAddedArgsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var arg = _step19.value;\n\n          if ((0, _definition.isRequiredArgument)(arg)) {\n            addedNonNullableArgs.push({\n              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,\n              description: \"A required arg \".concat(arg.name, \" on directive \") + \"\".concat(newDirective.name, \" was added\")\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError18 = true;\n    _iteratorError18 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n        _iterator18.return();\n      }\n    } finally {\n      if (_didIteratorError18) {\n        throw _iteratorError18;\n      }\n    }\n  }\n\n  return addedNonNullableArgs;\n}\n\nfunction findRemovedLocationsForDirective(oldDirective, newDirective) {\n  var removedLocations = [];\n  var newLocationSet = new Set(newDirective.locations);\n  var _iteratorNormalCompletion20 = true;\n  var _didIteratorError20 = false;\n  var _iteratorError20 = undefined;\n\n  try {\n    for (var _iterator20 = oldDirective.locations[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n      var oldLocation = _step20.value;\n\n      if (!newLocationSet.has(oldLocation)) {\n        removedLocations.push(oldLocation);\n      }\n    }\n  } catch (err) {\n    _didIteratorError20 = true;\n    _iteratorError20 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n        _iterator20.return();\n      }\n    } finally {\n      if (_didIteratorError20) {\n        throw _iteratorError20;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction findRemovedDirectiveLocations(oldSchema, newSchema) {\n  var removedLocations = [];\n  var oldSchemaDirectiveMap = getDirectiveMapForSchema(oldSchema);\n  var _iteratorNormalCompletion21 = true;\n  var _didIteratorError21 = false;\n  var _iteratorError21 = undefined;\n\n  try {\n    for (var _iterator21 = newSchema.getDirectives()[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n      var newDirective = _step21.value;\n      var oldDirective = oldSchemaDirectiveMap[newDirective.name];\n\n      if (!oldDirective) {\n        continue;\n      }\n\n      var _iteratorNormalCompletion22 = true;\n      var _didIteratorError22 = false;\n      var _iteratorError22 = undefined;\n\n      try {\n        for (var _iterator22 = findRemovedLocationsForDirective(oldDirective, newDirective)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n          var location = _step22.value;\n          removedLocations.push({\n            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,\n            description: \"\".concat(location, \" was removed from \").concat(newDirective.name)\n          });\n        }\n      } catch (err) {\n        _didIteratorError22 = true;\n        _iteratorError22 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n            _iterator22.return();\n          }\n        } finally {\n          if (_didIteratorError22) {\n            throw _iteratorError22;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError21 = true;\n    _iteratorError21 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n        _iterator21.return();\n      }\n    } finally {\n      if (_didIteratorError21) {\n        throw _iteratorError21;\n      }\n    }\n  }\n\n  return removedLocations;\n}\n\nfunction getDirectiveMapForSchema(schema) {\n  return (0, _keyMap.default)(schema.getDirectives(), function (dir) {\n    return dir.name;\n  });\n}\n\nfunction getArgumentMapForDirective(directive) {\n  return (0, _keyMap.default)(directive.args, function (arg) {\n    return arg.name;\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/findBreakingChanges.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/findDeprecatedUsages.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphql/utilities/findDeprecatedUsages.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDeprecatedUsages = findDeprecatedUsages;\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _visitor = __webpack_require__(/*! ../language/visitor */ \"./node_modules/graphql/language/visitor.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _TypeInfo = __webpack_require__(/*! ./TypeInfo */ \"./node_modules/graphql/utilities/TypeInfo.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * A validation rule which reports deprecated usages.\n *\n * Returns a list of GraphQLError instances describing each deprecated use.\n */\nfunction findDeprecatedUsages(schema, ast) {\n  var errors = [];\n  var typeInfo = new _TypeInfo.TypeInfo(schema);\n  (0, _visitor.visit)(ast, (0, _visitor.visitWithTypeInfo)(typeInfo, {\n    Field: function Field(node) {\n      var fieldDef = typeInfo.getFieldDef();\n\n      if (fieldDef && fieldDef.isDeprecated) {\n        var parentType = typeInfo.getParentType();\n\n        if (parentType) {\n          var reason = fieldDef.deprecationReason;\n          errors.push(new _GraphQLError.GraphQLError(\"The field \".concat(parentType.name, \".\").concat(fieldDef.name, \" is deprecated.\") + (reason ? ' ' + reason : ''), [node]));\n        }\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var enumVal = typeInfo.getEnumValue();\n\n      if (enumVal && enumVal.isDeprecated) {\n        var type = (0, _definition.getNamedType)(typeInfo.getInputType());\n\n        if (type) {\n          var reason = enumVal.deprecationReason;\n          errors.push(new _GraphQLError.GraphQLError(\"The enum value \".concat(type.name, \".\").concat(enumVal.name, \" is deprecated.\") + (reason ? ' ' + reason : ''), [node]));\n        }\n      }\n    }\n  }));\n  return errors;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/findDeprecatedUsages.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/getOperationAST.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/utilities/getOperationAST.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOperationAST = getOperationAST;\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Returns an operation AST given a document AST and optionally an operation\n * name. If a name is not provided, an operation is only returned if only one is\n * provided in the document.\n */\nfunction getOperationAST(documentAST, operationName) {\n  var operation = null;\n\n  for (var i = 0; i < documentAST.definitions.length; i++) {\n    var definition = documentAST.definitions[i];\n\n    if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {\n      if (!operationName) {\n        // If no operation name was provided, only return an Operation if there\n        // is one defined in the document. Upon encountering the second, return\n        // null.\n        if (operation) {\n          return null;\n        }\n\n        operation = definition;\n      } else if (definition.name && definition.name.value === operationName) {\n        return definition;\n      }\n    }\n  }\n\n  return operation;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/getOperationAST.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/getOperationRootType.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphql/utilities/getOperationRootType.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOperationRootType = getOperationRootType;\n\nvar _GraphQLError = __webpack_require__(/*! ../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Extracts the root type of the operation from the schema.\n */\nfunction getOperationRootType(schema, operation) {\n  switch (operation.operation) {\n    case 'query':\n      var queryType = schema.getQueryType();\n\n      if (!queryType) {\n        throw new _GraphQLError.GraphQLError('Schema does not define the required query root type.', [operation]);\n      }\n\n      return queryType;\n\n    case 'mutation':\n      var mutationType = schema.getMutationType();\n\n      if (!mutationType) {\n        throw new _GraphQLError.GraphQLError('Schema is not configured for mutations.', [operation]);\n      }\n\n      return mutationType;\n\n    case 'subscription':\n      var subscriptionType = schema.getSubscriptionType();\n\n      if (!subscriptionType) {\n        throw new _GraphQLError.GraphQLError('Schema is not configured for subscriptions.', [operation]);\n      }\n\n      return subscriptionType;\n\n    default:\n      throw new _GraphQLError.GraphQLError('Can only have query, mutation and subscription operations.', [operation]);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/getOperationRootType.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/index.js":
/*!*************************************************!*\
  !*** ./node_modules/graphql/utilities/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"getIntrospectionQuery\", {\n  enumerable: true,\n  get: function get() {\n    return _introspectionQuery.getIntrospectionQuery;\n  }\n});\nObject.defineProperty(exports, \"introspectionQuery\", {\n  enumerable: true,\n  get: function get() {\n    return _introspectionQuery.introspectionQuery;\n  }\n});\nObject.defineProperty(exports, \"getOperationAST\", {\n  enumerable: true,\n  get: function get() {\n    return _getOperationAST.getOperationAST;\n  }\n});\nObject.defineProperty(exports, \"getOperationRootType\", {\n  enumerable: true,\n  get: function get() {\n    return _getOperationRootType.getOperationRootType;\n  }\n});\nObject.defineProperty(exports, \"introspectionFromSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _introspectionFromSchema.introspectionFromSchema;\n  }\n});\nObject.defineProperty(exports, \"buildClientSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _buildClientSchema.buildClientSchema;\n  }\n});\nObject.defineProperty(exports, \"buildASTSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _buildASTSchema.buildASTSchema;\n  }\n});\nObject.defineProperty(exports, \"buildSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _buildASTSchema.buildSchema;\n  }\n});\nObject.defineProperty(exports, \"getDescription\", {\n  enumerable: true,\n  get: function get() {\n    return _buildASTSchema.getDescription;\n  }\n});\nObject.defineProperty(exports, \"extendSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _extendSchema.extendSchema;\n  }\n});\nObject.defineProperty(exports, \"lexicographicSortSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _lexicographicSortSchema.lexicographicSortSchema;\n  }\n});\nObject.defineProperty(exports, \"printSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _schemaPrinter.printSchema;\n  }\n});\nObject.defineProperty(exports, \"printType\", {\n  enumerable: true,\n  get: function get() {\n    return _schemaPrinter.printType;\n  }\n});\nObject.defineProperty(exports, \"printIntrospectionSchema\", {\n  enumerable: true,\n  get: function get() {\n    return _schemaPrinter.printIntrospectionSchema;\n  }\n});\nObject.defineProperty(exports, \"typeFromAST\", {\n  enumerable: true,\n  get: function get() {\n    return _typeFromAST.typeFromAST;\n  }\n});\nObject.defineProperty(exports, \"valueFromAST\", {\n  enumerable: true,\n  get: function get() {\n    return _valueFromAST.valueFromAST;\n  }\n});\nObject.defineProperty(exports, \"valueFromASTUntyped\", {\n  enumerable: true,\n  get: function get() {\n    return _valueFromASTUntyped.valueFromASTUntyped;\n  }\n});\nObject.defineProperty(exports, \"astFromValue\", {\n  enumerable: true,\n  get: function get() {\n    return _astFromValue.astFromValue;\n  }\n});\nObject.defineProperty(exports, \"TypeInfo\", {\n  enumerable: true,\n  get: function get() {\n    return _TypeInfo.TypeInfo;\n  }\n});\nObject.defineProperty(exports, \"coerceValue\", {\n  enumerable: true,\n  get: function get() {\n    return _coerceValue.coerceValue;\n  }\n});\nObject.defineProperty(exports, \"isValidJSValue\", {\n  enumerable: true,\n  get: function get() {\n    return _isValidJSValue.isValidJSValue;\n  }\n});\nObject.defineProperty(exports, \"isValidLiteralValue\", {\n  enumerable: true,\n  get: function get() {\n    return _isValidLiteralValue.isValidLiteralValue;\n  }\n});\nObject.defineProperty(exports, \"concatAST\", {\n  enumerable: true,\n  get: function get() {\n    return _concatAST.concatAST;\n  }\n});\nObject.defineProperty(exports, \"separateOperations\", {\n  enumerable: true,\n  get: function get() {\n    return _separateOperations.separateOperations;\n  }\n});\nObject.defineProperty(exports, \"isEqualType\", {\n  enumerable: true,\n  get: function get() {\n    return _typeComparators.isEqualType;\n  }\n});\nObject.defineProperty(exports, \"isTypeSubTypeOf\", {\n  enumerable: true,\n  get: function get() {\n    return _typeComparators.isTypeSubTypeOf;\n  }\n});\nObject.defineProperty(exports, \"doTypesOverlap\", {\n  enumerable: true,\n  get: function get() {\n    return _typeComparators.doTypesOverlap;\n  }\n});\nObject.defineProperty(exports, \"assertValidName\", {\n  enumerable: true,\n  get: function get() {\n    return _assertValidName.assertValidName;\n  }\n});\nObject.defineProperty(exports, \"isValidNameError\", {\n  enumerable: true,\n  get: function get() {\n    return _assertValidName.isValidNameError;\n  }\n});\nObject.defineProperty(exports, \"BreakingChangeType\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.BreakingChangeType;\n  }\n});\nObject.defineProperty(exports, \"DangerousChangeType\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.DangerousChangeType;\n  }\n});\nObject.defineProperty(exports, \"findBreakingChanges\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.findBreakingChanges;\n  }\n});\nObject.defineProperty(exports, \"findDangerousChanges\", {\n  enumerable: true,\n  get: function get() {\n    return _findBreakingChanges.findDangerousChanges;\n  }\n});\nObject.defineProperty(exports, \"findDeprecatedUsages\", {\n  enumerable: true,\n  get: function get() {\n    return _findDeprecatedUsages.findDeprecatedUsages;\n  }\n});\n\nvar _introspectionQuery = __webpack_require__(/*! ./introspectionQuery */ \"./node_modules/graphql/utilities/introspectionQuery.js\");\n\nvar _getOperationAST = __webpack_require__(/*! ./getOperationAST */ \"./node_modules/graphql/utilities/getOperationAST.js\");\n\nvar _getOperationRootType = __webpack_require__(/*! ./getOperationRootType */ \"./node_modules/graphql/utilities/getOperationRootType.js\");\n\nvar _introspectionFromSchema = __webpack_require__(/*! ./introspectionFromSchema */ \"./node_modules/graphql/utilities/introspectionFromSchema.js\");\n\nvar _buildClientSchema = __webpack_require__(/*! ./buildClientSchema */ \"./node_modules/graphql/utilities/buildClientSchema.js\");\n\nvar _buildASTSchema = __webpack_require__(/*! ./buildASTSchema */ \"./node_modules/graphql/utilities/buildASTSchema.js\");\n\nvar _extendSchema = __webpack_require__(/*! ./extendSchema */ \"./node_modules/graphql/utilities/extendSchema.js\");\n\nvar _lexicographicSortSchema = __webpack_require__(/*! ./lexicographicSortSchema */ \"./node_modules/graphql/utilities/lexicographicSortSchema.js\");\n\nvar _schemaPrinter = __webpack_require__(/*! ./schemaPrinter */ \"./node_modules/graphql/utilities/schemaPrinter.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ./typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nvar _valueFromAST = __webpack_require__(/*! ./valueFromAST */ \"./node_modules/graphql/utilities/valueFromAST.js\");\n\nvar _valueFromASTUntyped = __webpack_require__(/*! ./valueFromASTUntyped */ \"./node_modules/graphql/utilities/valueFromASTUntyped.js\");\n\nvar _astFromValue = __webpack_require__(/*! ./astFromValue */ \"./node_modules/graphql/utilities/astFromValue.js\");\n\nvar _TypeInfo = __webpack_require__(/*! ./TypeInfo */ \"./node_modules/graphql/utilities/TypeInfo.js\");\n\nvar _coerceValue = __webpack_require__(/*! ./coerceValue */ \"./node_modules/graphql/utilities/coerceValue.js\");\n\nvar _isValidJSValue = __webpack_require__(/*! ./isValidJSValue */ \"./node_modules/graphql/utilities/isValidJSValue.js\");\n\nvar _isValidLiteralValue = __webpack_require__(/*! ./isValidLiteralValue */ \"./node_modules/graphql/utilities/isValidLiteralValue.js\");\n\nvar _concatAST = __webpack_require__(/*! ./concatAST */ \"./node_modules/graphql/utilities/concatAST.js\");\n\nvar _separateOperations = __webpack_require__(/*! ./separateOperations */ \"./node_modules/graphql/utilities/separateOperations.js\");\n\nvar _typeComparators = __webpack_require__(/*! ./typeComparators */ \"./node_modules/graphql/utilities/typeComparators.js\");\n\nvar _assertValidName = __webpack_require__(/*! ./assertValidName */ \"./node_modules/graphql/utilities/assertValidName.js\");\n\nvar _findBreakingChanges = __webpack_require__(/*! ./findBreakingChanges */ \"./node_modules/graphql/utilities/findBreakingChanges.js\");\n\nvar _findDeprecatedUsages = __webpack_require__(/*! ./findDeprecatedUsages */ \"./node_modules/graphql/utilities/findDeprecatedUsages.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/index.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/introspectionFromSchema.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql/utilities/introspectionFromSchema.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.introspectionFromSchema = introspectionFromSchema;\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _introspectionQuery = __webpack_require__(/*! ./introspectionQuery */ \"./node_modules/graphql/utilities/introspectionQuery.js\");\n\nvar _execute = __webpack_require__(/*! ../execution/execute */ \"./node_modules/graphql/execution/execute.js\");\n\nvar _parser = __webpack_require__(/*! ../language/parser */ \"./node_modules/graphql/language/parser.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Build an IntrospectionQuery from a GraphQLSchema\n *\n * IntrospectionQuery is useful for utilities that care about type and field\n * relationships, but do not need to traverse through those relationships.\n *\n * This is the inverse of buildClientSchema. The primary use case is outside\n * of the server context, for instance when doing schema comparisons.\n */\nfunction introspectionFromSchema(schema, options) {\n  var queryAST = (0, _parser.parse)((0, _introspectionQuery.getIntrospectionQuery)(options));\n  var result = (0, _execute.execute)(schema, queryAST);\n  !(!result.then && !result.errors && result.data) ? (0, _invariant.default)(0) : void 0;\n  return result.data;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/introspectionFromSchema.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/introspectionQuery.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphql/utilities/introspectionQuery.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIntrospectionQuery = getIntrospectionQuery;\nexports.introspectionQuery = void 0;\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction getIntrospectionQuery(options) {\n  var descriptions = !(options && options.descriptions === false);\n  return \"\\n    query IntrospectionQuery {\\n      __schema {\\n        queryType { name }\\n        mutationType { name }\\n        subscriptionType { name }\\n        types {\\n          ...FullType\\n        }\\n        directives {\\n          name\\n          \".concat(descriptions ? 'description' : '', \"\\n          locations\\n          args {\\n            ...InputValue\\n          }\\n        }\\n      }\\n    }\\n\\n    fragment FullType on __Type {\\n      kind\\n      name\\n      \").concat(descriptions ? 'description' : '', \"\\n      fields(includeDeprecated: true) {\\n        name\\n        \").concat(descriptions ? 'description' : '', \"\\n        args {\\n          ...InputValue\\n        }\\n        type {\\n          ...TypeRef\\n        }\\n        isDeprecated\\n        deprecationReason\\n      }\\n      inputFields {\\n        ...InputValue\\n      }\\n      interfaces {\\n        ...TypeRef\\n      }\\n      enumValues(includeDeprecated: true) {\\n        name\\n        \").concat(descriptions ? 'description' : '', \"\\n        isDeprecated\\n        deprecationReason\\n      }\\n      possibleTypes {\\n        ...TypeRef\\n      }\\n    }\\n\\n    fragment InputValue on __InputValue {\\n      name\\n      \").concat(descriptions ? 'description' : '', \"\\n      type { ...TypeRef }\\n      defaultValue\\n    }\\n\\n    fragment TypeRef on __Type {\\n      kind\\n      name\\n      ofType {\\n        kind\\n        name\\n        ofType {\\n          kind\\n          name\\n          ofType {\\n            kind\\n            name\\n            ofType {\\n              kind\\n              name\\n              ofType {\\n                kind\\n                name\\n                ofType {\\n                  kind\\n                  name\\n                  ofType {\\n                    kind\\n                    name\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  \");\n}\n/**\n * Deprecated, call getIntrospectionQuery directly.\n *\n * This function will be removed in v15\n */\n\n\nvar introspectionQuery = getIntrospectionQuery();\nexports.introspectionQuery = introspectionQuery;\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/introspectionQuery.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/isValidJSValue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphql/utilities/isValidJSValue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidJSValue = isValidJSValue;\n\nvar _coerceValue = __webpack_require__(/*! ./coerceValue */ \"./node_modules/graphql/utilities/coerceValue.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Deprecated. Use coerceValue() directly for richer information.\n *\n * This function will be removed in v15\n */\nfunction isValidJSValue(value, type) {\n  var errors = (0, _coerceValue.coerceValue)(value, type).errors;\n  return errors ? errors.map(function (error) {\n    return error.message;\n  }) : [];\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/isValidJSValue.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/isValidLiteralValue.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphql/utilities/isValidLiteralValue.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidLiteralValue = isValidLiteralValue;\n\nvar _TypeInfo = __webpack_require__(/*! ./TypeInfo */ \"./node_modules/graphql/utilities/TypeInfo.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _visitor = __webpack_require__(/*! ../language/visitor */ \"./node_modules/graphql/language/visitor.js\");\n\nvar _schema = __webpack_require__(/*! ../type/schema */ \"./node_modules/graphql/type/schema.js\");\n\nvar _ValuesOfCorrectType = __webpack_require__(/*! ../validation/rules/ValuesOfCorrectType */ \"./node_modules/graphql/validation/rules/ValuesOfCorrectType.js\");\n\nvar _ValidationContext = __webpack_require__(/*! ../validation/ValidationContext */ \"./node_modules/graphql/validation/ValidationContext.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Utility which determines if a value literal node is valid for an input type.\n *\n * Deprecated. Rely on validation for documents containing literal values.\n *\n * This function will be removed in v15\n */\nfunction isValidLiteralValue(type, valueNode) {\n  var emptySchema = new _schema.GraphQLSchema({});\n  var emptyDoc = {\n    kind: _kinds.Kind.DOCUMENT,\n    definitions: []\n  };\n  var typeInfo = new _TypeInfo.TypeInfo(emptySchema, undefined, type);\n  var context = new _ValidationContext.ValidationContext(emptySchema, emptyDoc, typeInfo);\n  var visitor = (0, _ValuesOfCorrectType.ValuesOfCorrectType)(context);\n  (0, _visitor.visit)(valueNode, (0, _visitor.visitWithTypeInfo)(typeInfo, visitor));\n  return context.getErrors();\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/isValidLiteralValue.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/lexicographicSortSchema.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql/utilities/lexicographicSortSchema.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lexicographicSortSchema = lexicographicSortSchema;\n\nvar _keyValMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyValMap */ \"./node_modules/graphql/jsutils/keyValMap.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _schema = __webpack_require__(/*! ../type/schema */ \"./node_modules/graphql/type/schema.js\");\n\nvar _directives = __webpack_require__(/*! ../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _scalars = __webpack_require__(/*! ../type/scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Sort GraphQLSchema.\n */\nfunction lexicographicSortSchema(schema) {\n  var cache = Object.create(null);\n\n  var sortMaybeType = function sortMaybeType(maybeType) {\n    return maybeType && sortNamedType(maybeType);\n  };\n\n  return new _schema.GraphQLSchema({\n    types: sortTypes((0, _objectValues.default)(schema.getTypeMap())),\n    directives: sortByName(schema.getDirectives()).map(sortDirective),\n    query: sortMaybeType(schema.getQueryType()),\n    mutation: sortMaybeType(schema.getMutationType()),\n    subscription: sortMaybeType(schema.getSubscriptionType()),\n    astNode: schema.astNode\n  });\n\n  function sortDirective(directive) {\n    return new _directives.GraphQLDirective({\n      name: directive.name,\n      description: directive.description,\n      locations: sortBy(directive.locations, function (x) {\n        return x;\n      }),\n      args: sortArgs(directive.args),\n      astNode: directive.astNode\n    });\n  }\n\n  function sortArgs(args) {\n    return (0, _keyValMap.default)(sortByName(args), function (arg) {\n      return arg.name;\n    }, function (arg) {\n      return _objectSpread({}, arg, {\n        type: sortType(arg.type)\n      });\n    });\n  }\n\n  function sortFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return {\n        type: sortType(field.type),\n        args: sortArgs(field.args),\n        resolve: field.resolve,\n        subscribe: field.subscribe,\n        deprecationReason: field.deprecationReason,\n        description: field.description,\n        astNode: field.astNode\n      };\n    });\n  }\n\n  function sortInputFields(fieldsMap) {\n    return sortObjMap(fieldsMap, function (field) {\n      return {\n        type: sortType(field.type),\n        defaultValue: field.defaultValue,\n        description: field.description,\n        astNode: field.astNode\n      };\n    });\n  }\n\n  function sortType(type) {\n    if ((0, _definition.isListType)(type)) {\n      return new _definition.GraphQLList(sortType(type.ofType));\n    } else if ((0, _definition.isNonNullType)(type)) {\n      return new _definition.GraphQLNonNull(sortType(type.ofType));\n    }\n\n    return sortNamedType(type);\n  }\n\n  function sortTypes(arr) {\n    return sortByName(arr).map(sortNamedType);\n  }\n\n  function sortNamedType(type) {\n    if ((0, _scalars.isSpecifiedScalarType)(type) || (0, _introspection.isIntrospectionType)(type)) {\n      return type;\n    }\n\n    var sortedType = cache[type.name];\n\n    if (!sortedType) {\n      sortedType = sortNamedTypeImpl(type);\n      cache[type.name] = sortedType;\n    }\n\n    return sortedType;\n  }\n\n  function sortNamedTypeImpl(type) {\n    if ((0, _definition.isScalarType)(type)) {\n      return type;\n    } else if ((0, _definition.isObjectType)(type)) {\n      return new _definition.GraphQLObjectType({\n        name: type.name,\n        interfaces: function interfaces() {\n          return sortTypes(type.getInterfaces());\n        },\n        fields: function fields() {\n          return sortFields(type.getFields());\n        },\n        isTypeOf: type.isTypeOf,\n        description: type.description,\n        astNode: type.astNode,\n        extensionASTNodes: type.extensionASTNodes\n      });\n    } else if ((0, _definition.isInterfaceType)(type)) {\n      return new _definition.GraphQLInterfaceType({\n        name: type.name,\n        fields: function fields() {\n          return sortFields(type.getFields());\n        },\n        resolveType: type.resolveType,\n        description: type.description,\n        astNode: type.astNode,\n        extensionASTNodes: type.extensionASTNodes\n      });\n    } else if ((0, _definition.isUnionType)(type)) {\n      return new _definition.GraphQLUnionType({\n        name: type.name,\n        types: function types() {\n          return sortTypes(type.getTypes());\n        },\n        resolveType: type.resolveType,\n        description: type.description,\n        astNode: type.astNode\n      });\n    } else if ((0, _definition.isEnumType)(type)) {\n      return new _definition.GraphQLEnumType({\n        name: type.name,\n        values: (0, _keyValMap.default)(sortByName(type.getValues()), function (val) {\n          return val.name;\n        }, function (val) {\n          return {\n            value: val.value,\n            deprecationReason: val.deprecationReason,\n            description: val.description,\n            astNode: val.astNode\n          };\n        }),\n        description: type.description,\n        astNode: type.astNode\n      });\n    } else if ((0, _definition.isInputObjectType)(type)) {\n      return new _definition.GraphQLInputObjectType({\n        name: type.name,\n        fields: function fields() {\n          return sortInputFields(type.getFields());\n        },\n        description: type.description,\n        astNode: type.astNode\n      });\n    }\n\n    throw new Error(\"Unknown type: \\\"\".concat(type, \"\\\"\"));\n  }\n}\n\nfunction sortObjMap(map, sortValueFn) {\n  var sortedMap = Object.create(null);\n  var sortedKeys = sortBy(Object.keys(map), function (x) {\n    return x;\n  });\n\n  for (var _i = 0; _i < sortedKeys.length; _i++) {\n    var key = sortedKeys[_i];\n    var value = map[key];\n    sortedMap[key] = sortValueFn ? sortValueFn(value) : value;\n  }\n\n  return sortedMap;\n}\n\nfunction sortByName(array) {\n  return sortBy(array, function (obj) {\n    return obj.name;\n  });\n}\n\nfunction sortBy(array, mapToKey) {\n  return array.slice().sort(function (obj1, obj2) {\n    var key1 = mapToKey(obj1);\n    var key2 = mapToKey(obj2);\n    return key1.localeCompare(key2);\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/lexicographicSortSchema.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/schemaPrinter.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphql/utilities/schemaPrinter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printSchema = printSchema;\nexports.printIntrospectionSchema = printIntrospectionSchema;\nexports.printType = printType;\n\nvar _isNullish = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isNullish */ \"./node_modules/graphql/jsutils/isNullish.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _astFromValue = __webpack_require__(/*! ../utilities/astFromValue */ \"./node_modules/graphql/utilities/astFromValue.js\");\n\nvar _printer = __webpack_require__(/*! ../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _scalars = __webpack_require__(/*! ../type/scalars */ \"./node_modules/graphql/type/scalars.js\");\n\nvar _directives = __webpack_require__(/*! ../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nvar _introspection = __webpack_require__(/*! ../type/introspection */ \"./node_modules/graphql/type/introspection.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nfunction printSchema(schema, options) {\n  return printFilteredSchema(schema, function (n) {\n    return !(0, _directives.isSpecifiedDirective)(n);\n  }, isDefinedType, options);\n}\n\nfunction printIntrospectionSchema(schema, options) {\n  return printFilteredSchema(schema, _directives.isSpecifiedDirective, _introspection.isIntrospectionType, options);\n}\n\nfunction isDefinedType(type) {\n  return !(0, _scalars.isSpecifiedScalarType)(type) && !(0, _introspection.isIntrospectionType)(type);\n}\n\nfunction printFilteredSchema(schema, directiveFilter, typeFilter, options) {\n  var directives = schema.getDirectives().filter(directiveFilter);\n  var typeMap = schema.getTypeMap();\n  var types = (0, _objectValues.default)(typeMap).sort(function (type1, type2) {\n    return type1.name.localeCompare(type2.name);\n  }).filter(typeFilter);\n  return [printSchemaDefinition(schema)].concat(directives.map(function (directive) {\n    return printDirective(directive, options);\n  }), types.map(function (type) {\n    return printType(type, options);\n  })).filter(Boolean).join('\\n\\n') + '\\n';\n}\n\nfunction printSchemaDefinition(schema) {\n  if (isSchemaOfCommonNames(schema)) {\n    return;\n  }\n\n  var operationTypes = [];\n  var queryType = schema.getQueryType();\n\n  if (queryType) {\n    operationTypes.push(\"  query: \".concat(queryType.name));\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType) {\n    operationTypes.push(\"  mutation: \".concat(mutationType.name));\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType) {\n    operationTypes.push(\"  subscription: \".concat(subscriptionType.name));\n  }\n\n  return \"schema {\\n\".concat(operationTypes.join('\\n'), \"\\n}\");\n}\n/**\n * GraphQL schema define root types for each type of operation. These types are\n * the same as any other type and can be named in any manner, however there is\n * a common naming convention:\n *\n *   schema {\n *     query: Query\n *     mutation: Mutation\n *   }\n *\n * When using this naming convention, the schema description can be omitted.\n */\n\n\nfunction isSchemaOfCommonNames(schema) {\n  var queryType = schema.getQueryType();\n\n  if (queryType && queryType.name !== 'Query') {\n    return false;\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && mutationType.name !== 'Mutation') {\n    return false;\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && subscriptionType.name !== 'Subscription') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction printType(type, options) {\n  if ((0, _definition.isScalarType)(type)) {\n    return printScalar(type, options);\n  } else if ((0, _definition.isObjectType)(type)) {\n    return printObject(type, options);\n  } else if ((0, _definition.isInterfaceType)(type)) {\n    return printInterface(type, options);\n  } else if ((0, _definition.isUnionType)(type)) {\n    return printUnion(type, options);\n  } else if ((0, _definition.isEnumType)(type)) {\n    return printEnum(type, options);\n  } else if ((0, _definition.isInputObjectType)(type)) {\n    return printInputObject(type, options);\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unknown type: \".concat(type, \".\"));\n}\n\nfunction printScalar(type, options) {\n  return printDescription(options, type) + \"scalar \".concat(type.name);\n}\n\nfunction printObject(type, options) {\n  var interfaces = type.getInterfaces();\n  var implementedInterfaces = interfaces.length ? ' implements ' + interfaces.map(function (i) {\n    return i.name;\n  }).join(' & ') : '';\n  return printDescription(options, type) + \"type \".concat(type.name).concat(implementedInterfaces, \" {\\n\") + printFields(options, type) + '\\n' + '}';\n}\n\nfunction printInterface(type, options) {\n  return printDescription(options, type) + \"interface \".concat(type.name, \" {\\n\") + printFields(options, type) + '\\n' + '}';\n}\n\nfunction printUnion(type, options) {\n  return printDescription(options, type) + \"union \".concat(type.name, \" = \").concat(type.getTypes().join(' | '));\n}\n\nfunction printEnum(type, options) {\n  return printDescription(options, type) + \"enum \".concat(type.name, \" {\\n\") + printEnumValues(type.getValues(), options) + '\\n' + '}';\n}\n\nfunction printEnumValues(values, options) {\n  return values.map(function (value, i) {\n    return printDescription(options, value, '  ', !i) + '  ' + value.name + printDeprecated(value);\n  }).join('\\n');\n}\n\nfunction printInputObject(type, options) {\n  var fields = (0, _objectValues.default)(type.getFields());\n  return printDescription(options, type) + \"input \".concat(type.name, \" {\\n\") + fields.map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + printInputValue(f);\n  }).join('\\n') + '\\n' + '}';\n}\n\nfunction printFields(options, type) {\n  var fields = (0, _objectValues.default)(type.getFields());\n  return fields.map(function (f, i) {\n    return printDescription(options, f, '  ', !i) + '  ' + f.name + printArgs(options, f.args, '  ') + ': ' + String(f.type) + printDeprecated(f);\n  }).join('\\n');\n}\n\nfunction printArgs(options, args) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n  if (args.length === 0) {\n    return '';\n  } // If every arg does not have a description, print them on one line.\n\n\n  if (args.every(function (arg) {\n    return !arg.description;\n  })) {\n    return '(' + args.map(printInputValue).join(', ') + ')';\n  }\n\n  return '(\\n' + args.map(function (arg, i) {\n    return printDescription(options, arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);\n  }).join('\\n') + '\\n' + indentation + ')';\n}\n\nfunction printInputValue(arg) {\n  var argDecl = arg.name + ': ' + String(arg.type);\n\n  if (!(0, _isInvalid.default)(arg.defaultValue)) {\n    argDecl += \" = \".concat((0, _printer.print)((0, _astFromValue.astFromValue)(arg.defaultValue, arg.type)));\n  }\n\n  return argDecl;\n}\n\nfunction printDirective(directive, options) {\n  return printDescription(options, directive) + 'directive @' + directive.name + printArgs(options, directive.args) + ' on ' + directive.locations.join(' | ');\n}\n\nfunction printDeprecated(fieldOrEnumVal) {\n  if (!fieldOrEnumVal.isDeprecated) {\n    return '';\n  }\n\n  var reason = fieldOrEnumVal.deprecationReason;\n\n  if ((0, _isNullish.default)(reason) || reason === '' || reason === _directives.DEFAULT_DEPRECATION_REASON) {\n    return ' @deprecated';\n  }\n\n  return ' @deprecated(reason: ' + (0, _printer.print)((0, _astFromValue.astFromValue)(reason, _scalars.GraphQLString)) + ')';\n}\n\nfunction printDescription(options, def) {\n  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var firstInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n  if (!def.description) {\n    return '';\n  }\n\n  var lines = descriptionLines(def.description, 120 - indentation.length);\n\n  if (options && options.commentDescriptions) {\n    return printDescriptionWithComments(lines, indentation, firstInBlock);\n  }\n\n  var description = indentation && !firstInBlock ? '\\n' + indentation + '\"\"\"' : indentation + '\"\"\"'; // In some circumstances, a single line can be used for the description.\n\n  if (lines.length === 1 && lines[0].length < 70 && lines[0][lines[0].length - 1] !== '\"') {\n    return description + escapeQuote(lines[0]) + '\"\"\"\\n';\n  } // Format a multi-line block quote to account for leading space.\n\n\n  var hasLeadingSpace = lines[0][0] === ' ' || lines[0][0] === '\\t';\n\n  if (!hasLeadingSpace) {\n    description += '\\n';\n  }\n\n  for (var i = 0; i < lines.length; i++) {\n    if (i !== 0 || !hasLeadingSpace) {\n      description += indentation;\n    }\n\n    description += escapeQuote(lines[i]) + '\\n';\n  }\n\n  description += indentation + '\"\"\"\\n';\n  return description;\n}\n\nfunction escapeQuote(line) {\n  return line.replace(/\"\"\"/g, '\\\\\"\"\"');\n}\n\nfunction printDescriptionWithComments(lines, indentation, firstInBlock) {\n  var description = indentation && !firstInBlock ? '\\n' : '';\n\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i] === '') {\n      description += indentation + '#\\n';\n    } else {\n      description += indentation + '# ' + lines[i] + '\\n';\n    }\n  }\n\n  return description;\n}\n\nfunction descriptionLines(description, maxLen) {\n  var lines = [];\n  var rawLines = description.split('\\n');\n\n  for (var i = 0; i < rawLines.length; i++) {\n    if (rawLines[i] === '') {\n      lines.push(rawLines[i]);\n    } else {\n      // For > 120 character long lines, cut at space boundaries into sublines\n      // of ~80 chars.\n      var sublines = breakLine(rawLines[i], maxLen);\n\n      for (var j = 0; j < sublines.length; j++) {\n        lines.push(sublines[j]);\n      }\n    }\n  }\n\n  return lines;\n}\n\nfunction breakLine(line, maxLen) {\n  if (line.length < maxLen + 5) {\n    return [line];\n  }\n\n  var parts = line.split(new RegExp(\"((?: |^).{15,\".concat(maxLen - 40, \"}(?= |$))\")));\n\n  if (parts.length < 4) {\n    return [line];\n  }\n\n  var sublines = [parts[0] + parts[1] + parts[2]];\n\n  for (var i = 3; i < parts.length; i += 2) {\n    sublines.push(parts[i].slice(1) + parts[i + 1]);\n  }\n\n  return sublines;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/schemaPrinter.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/separateOperations.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphql/utilities/separateOperations.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.separateOperations = separateOperations;\n\nvar _visitor = __webpack_require__(/*! ../language/visitor */ \"./node_modules/graphql/language/visitor.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nfunction separateOperations(documentAST) {\n  var operations = [];\n  var fragments = Object.create(null);\n  var positions = new Map();\n  var depGraph = Object.create(null);\n  var fromName;\n  var idx = 0; // Populate metadata and build a dependency graph.\n\n  (0, _visitor.visit)(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n      positions.set(node, idx++);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n      fragments[fromName] = node;\n      positions.set(node, idx++);\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  for (var _i = 0; _i < operations.length; _i++) {\n    var operation = operations[_i];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    var definitions = [operation];\n\n    var _arr = Object.keys(dependencies);\n\n    for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n      var name = _arr[_i2];\n      definitions.push(fragments[name]);\n    }\n\n    definitions.sort(function (n1, n2) {\n      return (positions.get(n1) || 0) - (positions.get(n2) || 0);\n    });\n    separatedDocumentASTs[operationName] = {\n      kind: 'Document',\n      definitions: definitions\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    var _arr2 = Object.keys(immediateDeps);\n\n    for (var _i3 = 0; _i3 < _arr2.length; _i3++) {\n      var toName = _arr2[_i3];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/separateOperations.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/typeComparators.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/utilities/typeComparators.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEqualType = isEqualType;\nexports.isTypeSubTypeOf = isTypeSubTypeOf;\nexports.doTypesOverlap = doTypesOverlap;\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nfunction isEqualType(typeA, typeB) {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  } // If either type is non-null, the other must also be non-null.\n\n\n  if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // If either type is a list, the other must also be a list.\n\n\n  if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  } // Otherwise the types are not equal.\n\n\n  return false;\n}\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\n\n\nfunction isTypeSubTypeOf(schema, maybeSubType, superType) {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  } // If superType is non-null, maybeSubType must also be non-null.\n\n\n  if ((0, _definition.isNonNullType)(superType)) {\n    if ((0, _definition.isNonNullType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isNonNullType)(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  } // If superType type is a list, maybeSubType type must also be a list.\n\n\n  if ((0, _definition.isListType)(superType)) {\n    if ((0, _definition.isListType)(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n\n    return false;\n  }\n\n  if ((0, _definition.isListType)(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  } // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n\n\n  if ((0, _definition.isAbstractType)(superType) && (0, _definition.isObjectType)(maybeSubType) && schema.isPossibleType(superType, maybeSubType)) {\n    return true;\n  } // Otherwise, the child type is not a valid subtype of the parent type.\n\n\n  return false;\n}\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\n\n\nfunction doTypesOverlap(schema, typeA, typeB) {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if ((0, _definition.isAbstractType)(typeA)) {\n    if ((0, _definition.isAbstractType)(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(function (type) {\n        return schema.isPossibleType(typeB, type);\n      });\n    } // Determine if the latter type is a possible concrete type of the former.\n\n\n    return schema.isPossibleType(typeA, typeB);\n  }\n\n  if ((0, _definition.isAbstractType)(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(typeB, typeA);\n  } // Otherwise the types do not overlap.\n\n\n  return false;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/typeComparators.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/typeFromAST.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/utilities/typeFromAST.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeFromAST = typeFromAST;\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction typeFromAST(schema, typeNode) {\n  /* eslint-enable no-redeclare */\n  var innerType;\n\n  if (typeNode.kind === _kinds.Kind.LIST_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && (0, _definition.GraphQLList)(innerType);\n  }\n\n  if (typeNode.kind === _kinds.Kind.NON_NULL_TYPE) {\n    innerType = typeFromAST(schema, typeNode.type);\n    return innerType && (0, _definition.GraphQLNonNull)(innerType);\n  }\n\n  if (typeNode.kind === _kinds.Kind.NAMED_TYPE) {\n    return schema.getType(typeNode.name.value);\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unexpected type kind: \".concat(typeNode.kind, \".\"));\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/typeFromAST.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/valueFromAST.js":
/*!********************************************************!*\
  !*** ./node_modules/graphql/utilities/valueFromAST.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.valueFromAST = valueFromAST;\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _objectValues = _interopRequireDefault(__webpack_require__(/*! ../jsutils/objectValues */ \"./node_modules/graphql/jsutils/objectValues.js\"));\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _definition = __webpack_require__(/*! ../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Mixed         |\n * | NullValue            | null          |\n *\n */\nfunction valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if ((0, _definition.isNonNullType)(type)) {\n    if (valueNode.kind === _kinds.Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === _kinds.Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (valueNode.kind === _kinds.Kind.VARIABLE) {\n    var variableName = valueNode.name.value;\n\n    if (!variables || (0, _isInvalid.default)(variables[variableName])) {\n      // No valid return value.\n      return;\n    }\n\n    var variableValue = variables[variableName];\n\n    if (variableValue === null && (0, _definition.isNonNullType)(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if ((0, _definition.isListType)(type)) {\n    var itemType = type.ofType;\n\n    if (valueNode.kind === _kinds.Kind.LIST) {\n      var coercedValues = [];\n      var itemNodes = valueNode.values;\n\n      for (var i = 0; i < itemNodes.length; i++) {\n        if (isMissingVariable(itemNodes[i], variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if ((0, _definition.isNonNullType)(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          var itemValue = valueFromAST(itemNodes[i], itemType, variables);\n\n          if ((0, _isInvalid.default)(itemValue)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    var coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if ((0, _isInvalid.default)(coercedValue)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if ((0, _definition.isInputObjectType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var coercedObj = Object.create(null);\n    var fieldNodes = (0, _keyMap.default)(valueNode.fields, function (field) {\n      return field.name.value;\n    });\n    var fields = (0, _objectValues.default)(type.getFields());\n\n    for (var _i = 0; _i < fields.length; _i++) {\n      var field = fields[_i];\n      var fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if ((0, _definition.isNonNullType)(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if ((0, _isInvalid.default)(fieldValue)) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if ((0, _definition.isEnumType)(type)) {\n    if (valueNode.kind !== _kinds.Kind.ENUM) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    var enumValue = type.getValue(valueNode.value);\n\n    if (!enumValue) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return enumValue.value;\n  }\n\n  if ((0, _definition.isScalarType)(type)) {\n    // Scalars fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    var result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if ((0, _isInvalid.default)(result)) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"Unknown type: \".concat(type, \".\"));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === _kinds.Kind.VARIABLE && (!variables || (0, _isInvalid.default)(variables[valueNode.name.value]));\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/valueFromAST.js?");

/***/ }),

/***/ "./node_modules/graphql/utilities/valueFromASTUntyped.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphql/utilities/valueFromASTUntyped.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.valueFromASTUntyped = valueFromASTUntyped;\n\nvar _keyValMap = _interopRequireDefault(__webpack_require__(/*! ../jsutils/keyValMap */ \"./node_modules/graphql/jsutils/keyValMap.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | JavaScript Value |\n * | -------------------- | ---------------- |\n * | Input Object         | Object           |\n * | List                 | Array            |\n * | Boolean              | Boolean          |\n * | String / Enum        | String           |\n * | Int / Float          | Number           |\n * | Null                 | null             |\n *\n */\nfunction valueFromASTUntyped(valueNode, variables) {\n  switch (valueNode.kind) {\n    case _kinds.Kind.NULL:\n      return null;\n\n    case _kinds.Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case _kinds.Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case _kinds.Kind.STRING:\n    case _kinds.Kind.ENUM:\n    case _kinds.Kind.BOOLEAN:\n      return valueNode.value;\n\n    case _kinds.Kind.LIST:\n      return valueNode.values.map(function (node) {\n        return valueFromASTUntyped(node, variables);\n      });\n\n    case _kinds.Kind.OBJECT:\n      return (0, _keyValMap.default)(valueNode.fields, function (field) {\n        return field.name.value;\n      }, function (field) {\n        return valueFromASTUntyped(field.value, variables);\n      });\n\n    case _kinds.Kind.VARIABLE:\n      var variableName = valueNode.name.value;\n      return variables && !(0, _isInvalid.default)(variables[variableName]) ? variables[variableName] : undefined;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error('Unexpected value kind: ' + valueNode.kind);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/utilities/valueFromASTUntyped.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/ValidationContext.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphql/validation/ValidationContext.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidationContext = exports.SDLValidationContext = exports.ASTValidationContext = void 0;\n\nvar _visitor = __webpack_require__(/*! ../language/visitor */ \"./node_modules/graphql/language/visitor.js\");\n\nvar _kinds = __webpack_require__(/*! ../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _TypeInfo = __webpack_require__(/*! ../utilities/TypeInfo */ \"./node_modules/graphql/utilities/TypeInfo.js\");\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nvar ASTValidationContext =\n/*#__PURE__*/\nfunction () {\n  function ASTValidationContext(ast) {\n    _defineProperty(this, \"_ast\", void 0);\n\n    _defineProperty(this, \"_errors\", void 0);\n\n    this._ast = ast;\n    this._errors = [];\n  }\n\n  var _proto = ASTValidationContext.prototype;\n\n  _proto.reportError = function reportError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  _proto.getDocument = function getDocument() {\n    return this._ast;\n  };\n\n  return ASTValidationContext;\n}();\n\nexports.ASTValidationContext = ASTValidationContext;\n\nvar SDLValidationContext =\n/*#__PURE__*/\nfunction (_ASTValidationContext) {\n  _inheritsLoose(SDLValidationContext, _ASTValidationContext);\n\n  function SDLValidationContext(ast, schema) {\n    var _this;\n\n    _this = _ASTValidationContext.call(this, ast) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_schema\", void 0);\n\n    _this._schema = schema;\n    return _this;\n  }\n\n  var _proto2 = SDLValidationContext.prototype;\n\n  _proto2.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  return SDLValidationContext;\n}(ASTValidationContext);\n\nexports.SDLValidationContext = SDLValidationContext;\n\nvar ValidationContext =\n/*#__PURE__*/\nfunction (_ASTValidationContext2) {\n  _inheritsLoose(ValidationContext, _ASTValidationContext2);\n\n  function ValidationContext(schema, ast, typeInfo) {\n    var _this2;\n\n    _this2 = _ASTValidationContext2.call(this, ast) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_schema\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_typeInfo\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_fragments\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_fragmentSpreads\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_recursivelyReferencedFragments\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_variableUsages\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"_recursiveVariableUsages\", void 0);\n\n    _this2._schema = schema;\n    _this2._typeInfo = typeInfo;\n    _this2._fragmentSpreads = new Map();\n    _this2._recursivelyReferencedFragments = new Map();\n    _this2._variableUsages = new Map();\n    _this2._recursiveVariableUsages = new Map();\n    return _this2;\n  }\n\n  var _proto3 = ValidationContext.prototype;\n\n  _proto3.getSchema = function getSchema() {\n    return this._schema;\n  };\n\n  _proto3.getFragment = function getFragment(name) {\n    var fragments = this._fragments;\n\n    if (!fragments) {\n      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {\n        if (statement.kind === _kinds.Kind.FRAGMENT_DEFINITION) {\n          frags[statement.name.value] = statement;\n        }\n\n        return frags;\n      }, Object.create(null));\n    }\n\n    return fragments[name];\n  };\n\n  _proto3.getFragmentSpreads = function getFragmentSpreads(node) {\n    var spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      var setsToVisit = [node];\n\n      while (setsToVisit.length !== 0) {\n        var set = setsToVisit.pop();\n\n        for (var i = 0; i < set.selections.length; i++) {\n          var selection = set.selections[i];\n\n          if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  };\n\n  _proto3.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {\n    var fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      var collectedNames = Object.create(null);\n      var nodesToVisit = [operation.selectionSet];\n\n      while (nodesToVisit.length !== 0) {\n        var node = nodesToVisit.pop();\n        var spreads = this.getFragmentSpreads(node);\n\n        for (var i = 0; i < spreads.length; i++) {\n          var fragName = spreads[i].name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            var fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  };\n\n  _proto3.getVariableUsages = function getVariableUsages(node) {\n    var usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      var newUsages = [];\n      var typeInfo = new _TypeInfo.TypeInfo(this._schema);\n      (0, _visitor.visit)(node, (0, _visitor.visitWithTypeInfo)(typeInfo, {\n        VariableDefinition: function VariableDefinition() {\n          return false;\n        },\n        Variable: function Variable(variable) {\n          newUsages.push({\n            node: variable,\n            type: typeInfo.getInputType(),\n            defaultValue: typeInfo.getDefaultValue()\n          });\n        }\n      }));\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {\n    var usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      var fragments = this.getRecursivelyReferencedFragments(operation);\n\n      for (var i = 0; i < fragments.length; i++) {\n        Array.prototype.push.apply(usages, this.getVariableUsages(fragments[i]));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  };\n\n  _proto3.getType = function getType() {\n    return this._typeInfo.getType();\n  };\n\n  _proto3.getParentType = function getParentType() {\n    return this._typeInfo.getParentType();\n  };\n\n  _proto3.getInputType = function getInputType() {\n    return this._typeInfo.getInputType();\n  };\n\n  _proto3.getParentInputType = function getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  };\n\n  _proto3.getFieldDef = function getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  };\n\n  _proto3.getDirective = function getDirective() {\n    return this._typeInfo.getDirective();\n  };\n\n  _proto3.getArgument = function getArgument() {\n    return this._typeInfo.getArgument();\n  };\n\n  return ValidationContext;\n}(ASTValidationContext);\n\nexports.ValidationContext = ValidationContext;\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/ValidationContext.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/index.js":
/*!**************************************************!*\
  !*** ./node_modules/graphql/validation/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function get() {\n    return _validate.validate;\n  }\n});\nObject.defineProperty(exports, \"ValidationContext\", {\n  enumerable: true,\n  get: function get() {\n    return _ValidationContext.ValidationContext;\n  }\n});\nObject.defineProperty(exports, \"specifiedRules\", {\n  enumerable: true,\n  get: function get() {\n    return _specifiedRules.specifiedRules;\n  }\n});\nObject.defineProperty(exports, \"FieldsOnCorrectTypeRule\", {\n  enumerable: true,\n  get: function get() {\n    return _FieldsOnCorrectType.FieldsOnCorrectType;\n  }\n});\nObject.defineProperty(exports, \"FragmentsOnCompositeTypesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes;\n  }\n});\nObject.defineProperty(exports, \"KnownArgumentNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _KnownArgumentNames.KnownArgumentNames;\n  }\n});\nObject.defineProperty(exports, \"KnownDirectivesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _KnownDirectives.KnownDirectives;\n  }\n});\nObject.defineProperty(exports, \"KnownFragmentNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _KnownFragmentNames.KnownFragmentNames;\n  }\n});\nObject.defineProperty(exports, \"KnownTypeNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _KnownTypeNames.KnownTypeNames;\n  }\n});\nObject.defineProperty(exports, \"LoneAnonymousOperationRule\", {\n  enumerable: true,\n  get: function get() {\n    return _LoneAnonymousOperation.LoneAnonymousOperation;\n  }\n});\nObject.defineProperty(exports, \"NoFragmentCyclesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _NoFragmentCycles.NoFragmentCycles;\n  }\n});\nObject.defineProperty(exports, \"NoUndefinedVariablesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _NoUndefinedVariables.NoUndefinedVariables;\n  }\n});\nObject.defineProperty(exports, \"NoUnusedFragmentsRule\", {\n  enumerable: true,\n  get: function get() {\n    return _NoUnusedFragments.NoUnusedFragments;\n  }\n});\nObject.defineProperty(exports, \"NoUnusedVariablesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _NoUnusedVariables.NoUnusedVariables;\n  }\n});\nObject.defineProperty(exports, \"OverlappingFieldsCanBeMergedRule\", {\n  enumerable: true,\n  get: function get() {\n    return _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged;\n  }\n});\nObject.defineProperty(exports, \"PossibleFragmentSpreadsRule\", {\n  enumerable: true,\n  get: function get() {\n    return _PossibleFragmentSpreads.PossibleFragmentSpreads;\n  }\n});\nObject.defineProperty(exports, \"ProvidedRequiredArgumentsRule\", {\n  enumerable: true,\n  get: function get() {\n    return _ProvidedRequiredArguments.ProvidedRequiredArguments;\n  }\n});\nObject.defineProperty(exports, \"ScalarLeafsRule\", {\n  enumerable: true,\n  get: function get() {\n    return _ScalarLeafs.ScalarLeafs;\n  }\n});\nObject.defineProperty(exports, \"SingleFieldSubscriptionsRule\", {\n  enumerable: true,\n  get: function get() {\n    return _SingleFieldSubscriptions.SingleFieldSubscriptions;\n  }\n});\nObject.defineProperty(exports, \"UniqueArgumentNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _UniqueArgumentNames.UniqueArgumentNames;\n  }\n});\nObject.defineProperty(exports, \"UniqueDirectivesPerLocationRule\", {\n  enumerable: true,\n  get: function get() {\n    return _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation;\n  }\n});\nObject.defineProperty(exports, \"UniqueFragmentNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _UniqueFragmentNames.UniqueFragmentNames;\n  }\n});\nObject.defineProperty(exports, \"UniqueInputFieldNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _UniqueInputFieldNames.UniqueInputFieldNames;\n  }\n});\nObject.defineProperty(exports, \"UniqueOperationNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _UniqueOperationNames.UniqueOperationNames;\n  }\n});\nObject.defineProperty(exports, \"UniqueVariableNamesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _UniqueVariableNames.UniqueVariableNames;\n  }\n});\nObject.defineProperty(exports, \"ValuesOfCorrectTypeRule\", {\n  enumerable: true,\n  get: function get() {\n    return _ValuesOfCorrectType.ValuesOfCorrectType;\n  }\n});\nObject.defineProperty(exports, \"VariablesAreInputTypesRule\", {\n  enumerable: true,\n  get: function get() {\n    return _VariablesAreInputTypes.VariablesAreInputTypes;\n  }\n});\nObject.defineProperty(exports, \"VariablesInAllowedPositionRule\", {\n  enumerable: true,\n  get: function get() {\n    return _VariablesInAllowedPosition.VariablesInAllowedPosition;\n  }\n});\n\nvar _validate = __webpack_require__(/*! ./validate */ \"./node_modules/graphql/validation/validate.js\");\n\nvar _ValidationContext = __webpack_require__(/*! ./ValidationContext */ \"./node_modules/graphql/validation/ValidationContext.js\");\n\nvar _specifiedRules = __webpack_require__(/*! ./specifiedRules */ \"./node_modules/graphql/validation/specifiedRules.js\");\n\nvar _FieldsOnCorrectType = __webpack_require__(/*! ./rules/FieldsOnCorrectType */ \"./node_modules/graphql/validation/rules/FieldsOnCorrectType.js\");\n\nvar _FragmentsOnCompositeTypes = __webpack_require__(/*! ./rules/FragmentsOnCompositeTypes */ \"./node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.js\");\n\nvar _KnownArgumentNames = __webpack_require__(/*! ./rules/KnownArgumentNames */ \"./node_modules/graphql/validation/rules/KnownArgumentNames.js\");\n\nvar _KnownDirectives = __webpack_require__(/*! ./rules/KnownDirectives */ \"./node_modules/graphql/validation/rules/KnownDirectives.js\");\n\nvar _KnownFragmentNames = __webpack_require__(/*! ./rules/KnownFragmentNames */ \"./node_modules/graphql/validation/rules/KnownFragmentNames.js\");\n\nvar _KnownTypeNames = __webpack_require__(/*! ./rules/KnownTypeNames */ \"./node_modules/graphql/validation/rules/KnownTypeNames.js\");\n\nvar _LoneAnonymousOperation = __webpack_require__(/*! ./rules/LoneAnonymousOperation */ \"./node_modules/graphql/validation/rules/LoneAnonymousOperation.js\");\n\nvar _NoFragmentCycles = __webpack_require__(/*! ./rules/NoFragmentCycles */ \"./node_modules/graphql/validation/rules/NoFragmentCycles.js\");\n\nvar _NoUndefinedVariables = __webpack_require__(/*! ./rules/NoUndefinedVariables */ \"./node_modules/graphql/validation/rules/NoUndefinedVariables.js\");\n\nvar _NoUnusedFragments = __webpack_require__(/*! ./rules/NoUnusedFragments */ \"./node_modules/graphql/validation/rules/NoUnusedFragments.js\");\n\nvar _NoUnusedVariables = __webpack_require__(/*! ./rules/NoUnusedVariables */ \"./node_modules/graphql/validation/rules/NoUnusedVariables.js\");\n\nvar _OverlappingFieldsCanBeMerged = __webpack_require__(/*! ./rules/OverlappingFieldsCanBeMerged */ \"./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js\");\n\nvar _PossibleFragmentSpreads = __webpack_require__(/*! ./rules/PossibleFragmentSpreads */ \"./node_modules/graphql/validation/rules/PossibleFragmentSpreads.js\");\n\nvar _ProvidedRequiredArguments = __webpack_require__(/*! ./rules/ProvidedRequiredArguments */ \"./node_modules/graphql/validation/rules/ProvidedRequiredArguments.js\");\n\nvar _ScalarLeafs = __webpack_require__(/*! ./rules/ScalarLeafs */ \"./node_modules/graphql/validation/rules/ScalarLeafs.js\");\n\nvar _SingleFieldSubscriptions = __webpack_require__(/*! ./rules/SingleFieldSubscriptions */ \"./node_modules/graphql/validation/rules/SingleFieldSubscriptions.js\");\n\nvar _UniqueArgumentNames = __webpack_require__(/*! ./rules/UniqueArgumentNames */ \"./node_modules/graphql/validation/rules/UniqueArgumentNames.js\");\n\nvar _UniqueDirectivesPerLocation = __webpack_require__(/*! ./rules/UniqueDirectivesPerLocation */ \"./node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.js\");\n\nvar _UniqueFragmentNames = __webpack_require__(/*! ./rules/UniqueFragmentNames */ \"./node_modules/graphql/validation/rules/UniqueFragmentNames.js\");\n\nvar _UniqueInputFieldNames = __webpack_require__(/*! ./rules/UniqueInputFieldNames */ \"./node_modules/graphql/validation/rules/UniqueInputFieldNames.js\");\n\nvar _UniqueOperationNames = __webpack_require__(/*! ./rules/UniqueOperationNames */ \"./node_modules/graphql/validation/rules/UniqueOperationNames.js\");\n\nvar _UniqueVariableNames = __webpack_require__(/*! ./rules/UniqueVariableNames */ \"./node_modules/graphql/validation/rules/UniqueVariableNames.js\");\n\nvar _ValuesOfCorrectType = __webpack_require__(/*! ./rules/ValuesOfCorrectType */ \"./node_modules/graphql/validation/rules/ValuesOfCorrectType.js\");\n\nvar _VariablesAreInputTypes = __webpack_require__(/*! ./rules/VariablesAreInputTypes */ \"./node_modules/graphql/validation/rules/VariablesAreInputTypes.js\");\n\nvar _VariablesInAllowedPosition = __webpack_require__(/*! ./rules/VariablesInAllowedPosition */ \"./node_modules/graphql/validation/rules/VariablesInAllowedPosition.js\");\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/index.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/ExecutableDefinitions.js":
/*!************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/ExecutableDefinitions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nonExecutableDefinitionMessage = nonExecutableDefinitionMessage;\nexports.ExecutableDefinitions = ExecutableDefinitions;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _predicates = __webpack_require__(/*! ../../language/predicates */ \"./node_modules/graphql/language/predicates.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction nonExecutableDefinitionMessage(defName) {\n  return \"The \".concat(defName, \" definition is not executable.\");\n}\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n */\n\n\nfunction ExecutableDefinitions(context) {\n  return {\n    Document: function Document(node) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = node.definitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var definition = _step.value;\n\n          if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {\n            context.reportError(new _GraphQLError.GraphQLError(nonExecutableDefinitionMessage(definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? 'schema' : definition.name.value), [definition]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/ExecutableDefinitions.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/FieldsOnCorrectType.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/FieldsOnCorrectType.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.undefinedFieldMessage = undefinedFieldMessage;\nexports.FieldsOnCorrectType = FieldsOnCorrectType;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _suggestionList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/suggestionList */ \"./node_modules/graphql/jsutils/suggestionList.js\"));\n\nvar _quotedOrList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/quotedOrList */ \"./node_modules/graphql/jsutils/quotedOrList.js\"));\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {\n  var message = \"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type, \"\\\".\");\n\n  if (suggestedTypeNames.length !== 0) {\n    var suggestions = (0, _quotedOrList.default)(suggestedTypeNames);\n    message += \" Did you mean to use an inline fragment on \".concat(suggestions, \"?\");\n  } else if (suggestedFieldNames.length !== 0) {\n    message += \" Did you mean \".concat((0, _quotedOrList.default)(suggestedFieldNames), \"?\");\n  }\n\n  return message;\n}\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\n\nfunction FieldsOnCorrectType(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?\n\n          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.\n\n          context.reportError(new _GraphQLError.GraphQLError(undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), [node]));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest\n * them, sorted by how often the type is referenced, starting with Interfaces.\n */\n\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if ((0, _definition.isAbstractType)(type)) {\n    var suggestedObjectTypes = [];\n    var interfaceUsageCount = Object.create(null);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = schema.getPossibleTypes(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var possibleType = _step.value;\n\n        if (!possibleType.getFields()[fieldName]) {\n          continue;\n        } // This object type defines this field.\n\n\n        suggestedObjectTypes.push(possibleType.name);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = possibleType.getInterfaces()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var possibleInterface = _step2.value;\n\n            if (!possibleInterface.getFields()[fieldName]) {\n              continue;\n            } // This interface type defines this field.\n\n\n            interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } // Suggest interface types based on how common they are.\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {\n      return interfaceUsageCount[b] - interfaceUsageCount[a];\n    }); // Suggest both interface and object types.\n\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  } // Otherwise, must be an Object type, which does not have possible fields.\n\n\n  return [];\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(schema, type, fieldName) {\n  if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return (0, _suggestionList.default)(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/FieldsOnCorrectType.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.js":
/*!****************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage;\nexports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage;\nexports.FragmentsOnCompositeTypes = FragmentsOnCompositeTypes;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _printer = __webpack_require__(/*! ../../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction inlineFragmentOnNonCompositeErrorMessage(type) {\n  return \"Fragment cannot condition on non composite type \\\"\".concat(type, \"\\\".\");\n}\n\nfunction fragmentOnNonCompositeErrorMessage(fragName, type) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot condition on non composite \") + \"type \\\"\".concat(type, \"\\\".\");\n}\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */\n\n\nfunction FragmentsOnCompositeTypes(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition);\n\n        if (type && !(0, _definition.isCompositeType)(type)) {\n          context.reportError(new _GraphQLError.GraphQLError(inlineFragmentOnNonCompositeErrorMessage((0, _printer.print)(typeCondition)), [typeCondition]));\n        }\n      }\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.typeCondition);\n\n      if (type && !(0, _definition.isCompositeType)(type)) {\n        context.reportError(new _GraphQLError.GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value, (0, _printer.print)(node.typeCondition)), [node.typeCondition]));\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/KnownArgumentNames.js":
/*!*********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/KnownArgumentNames.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unknownArgMessage = unknownArgMessage;\nexports.unknownDirectiveArgMessage = unknownDirectiveArgMessage;\nexports.KnownArgumentNames = KnownArgumentNames;\nexports.KnownArgumentNamesOnDirectives = KnownArgumentNamesOnDirectives;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _suggestionList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/suggestionList */ \"./node_modules/graphql/jsutils/suggestionList.js\"));\n\nvar _quotedOrList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/quotedOrList */ \"./node_modules/graphql/jsutils/quotedOrList.js\"));\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _directives = __webpack_require__(/*! ../../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction unknownArgMessage(argName, fieldName, typeName, suggestedArgs) {\n  var message = \"Unknown argument \\\"\".concat(argName, \"\\\" on field \\\"\").concat(fieldName, \"\\\" of \") + \"type \\\"\".concat(typeName, \"\\\".\");\n\n  if (suggestedArgs.length) {\n    message += \" Did you mean \".concat((0, _quotedOrList.default)(suggestedArgs), \"?\");\n  }\n\n  return message;\n}\n\nfunction unknownDirectiveArgMessage(argName, directiveName, suggestedArgs) {\n  var message = \"Unknown argument \\\"\".concat(argName, \"\\\" on directive \\\"@\").concat(directiveName, \"\\\".\");\n\n  if (suggestedArgs.length) {\n    message += \" Did you mean \".concat((0, _quotedOrList.default)(suggestedArgs), \"?\");\n  }\n\n  return message;\n}\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n */\n\n\nfunction KnownArgumentNames(context) {\n  return _objectSpread({}, KnownArgumentNamesOnDirectives(context), {\n    Argument: function Argument(argNode) {\n      var argDef = context.getArgument();\n      var fieldDef = context.getFieldDef();\n      var parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        var argName = argNode.name.value;\n        var knownArgsNames = fieldDef.args.map(function (arg) {\n          return arg.name;\n        });\n        context.reportError(new _GraphQLError.GraphQLError(unknownArgMessage(argName, fieldDef.name, parentType.name, (0, _suggestionList.default)(argName, knownArgsNames)), argNode));\n      }\n    }\n  });\n} // @internal\n\n\nfunction KnownArgumentNamesOnDirectives(context) {\n  var directiveArgs = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = definedDirectives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var directive = _step.value;\n      directiveArgs[directive.name] = directive.args.map(function (arg) {\n        return arg.name;\n      });\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = astDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var def = _step2.value;\n\n      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n        directiveArgs[def.name.value] = def.arguments ? def.arguments.map(function (arg) {\n          return arg.name.value;\n        }) : [];\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    Directive: function Directive(directiveNode) {\n      var directiveName = directiveNode.name.value;\n      var knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = directiveNode.arguments[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var argNode = _step3.value;\n            var argName = argNode.name.value;\n\n            if (knownArgs.indexOf(argName) === -1) {\n              var suggestions = (0, _suggestionList.default)(argName, knownArgs);\n              context.reportError(new _GraphQLError.GraphQLError(unknownDirectiveArgMessage(argName, directiveName, suggestions), argNode));\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/KnownArgumentNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/KnownDirectives.js":
/*!******************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/KnownDirectives.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unknownDirectiveMessage = unknownDirectiveMessage;\nexports.misplacedDirectiveMessage = misplacedDirectiveMessage;\nexports.KnownDirectives = KnownDirectives;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _directiveLocation = __webpack_require__(/*! ../../language/directiveLocation */ \"./node_modules/graphql/language/directiveLocation.js\");\n\nvar _directives = __webpack_require__(/*! ../../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction unknownDirectiveMessage(directiveName) {\n  return \"Unknown directive \\\"\".concat(directiveName, \"\\\".\");\n}\n\nfunction misplacedDirectiveMessage(directiveName, location) {\n  return \"Directive \\\"\".concat(directiveName, \"\\\" may not be used on \").concat(location, \".\");\n}\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n */\n\n\nfunction KnownDirectives(context) {\n  var locationsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = definedDirectives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var directive = _step.value;\n      locationsMap[directive.name] = directive.locations;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = astDefinitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var def = _step2.value;\n\n      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n        locationsMap[def.name.value] = def.locations.map(function (name) {\n          return name.value;\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    Directive: function Directive(node, key, parent, path, ancestors) {\n      var name = node.name.value;\n      var locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(new _GraphQLError.GraphQLError(unknownDirectiveMessage(name), [node]));\n        return;\n      }\n\n      var candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {\n        context.reportError(new _GraphQLError.GraphQLError(misplacedDirectiveMessage(name, candidateLocation), [node]));\n      }\n    }\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  var appliedTo = ancestors[ancestors.length - 1];\n\n  if (!Array.isArray(appliedTo)) {\n    switch (appliedTo.kind) {\n      case _kinds.Kind.OPERATION_DEFINITION:\n        switch (appliedTo.operation) {\n          case 'query':\n            return _directiveLocation.DirectiveLocation.QUERY;\n\n          case 'mutation':\n            return _directiveLocation.DirectiveLocation.MUTATION;\n\n          case 'subscription':\n            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;\n        }\n\n        break;\n\n      case _kinds.Kind.FIELD:\n        return _directiveLocation.DirectiveLocation.FIELD;\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n        return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;\n\n      case _kinds.Kind.FRAGMENT_DEFINITION:\n        return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;\n\n      case _kinds.Kind.VARIABLE_DEFINITION:\n        return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;\n\n      case _kinds.Kind.SCHEMA_DEFINITION:\n      case _kinds.Kind.SCHEMA_EXTENSION:\n        return _directiveLocation.DirectiveLocation.SCHEMA;\n\n      case _kinds.Kind.SCALAR_TYPE_DEFINITION:\n      case _kinds.Kind.SCALAR_TYPE_EXTENSION:\n        return _directiveLocation.DirectiveLocation.SCALAR;\n\n      case _kinds.Kind.OBJECT_TYPE_DEFINITION:\n      case _kinds.Kind.OBJECT_TYPE_EXTENSION:\n        return _directiveLocation.DirectiveLocation.OBJECT;\n\n      case _kinds.Kind.FIELD_DEFINITION:\n        return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;\n\n      case _kinds.Kind.INTERFACE_TYPE_DEFINITION:\n      case _kinds.Kind.INTERFACE_TYPE_EXTENSION:\n        return _directiveLocation.DirectiveLocation.INTERFACE;\n\n      case _kinds.Kind.UNION_TYPE_DEFINITION:\n      case _kinds.Kind.UNION_TYPE_EXTENSION:\n        return _directiveLocation.DirectiveLocation.UNION;\n\n      case _kinds.Kind.ENUM_TYPE_DEFINITION:\n      case _kinds.Kind.ENUM_TYPE_EXTENSION:\n        return _directiveLocation.DirectiveLocation.ENUM;\n\n      case _kinds.Kind.ENUM_VALUE_DEFINITION:\n        return _directiveLocation.DirectiveLocation.ENUM_VALUE;\n\n      case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        return _directiveLocation.DirectiveLocation.INPUT_OBJECT;\n\n      case _kinds.Kind.INPUT_VALUE_DEFINITION:\n        var parentNode = ancestors[ancestors.length - 3];\n        return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/KnownDirectives.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/KnownFragmentNames.js":
/*!*********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/KnownFragmentNames.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unknownFragmentMessage = unknownFragmentMessage;\nexports.KnownFragmentNames = KnownFragmentNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction unknownFragmentMessage(fragName) {\n  return \"Unknown fragment \\\"\".concat(fragName, \"\\\".\");\n}\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n */\n\n\nfunction KnownFragmentNames(context) {\n  return {\n    FragmentSpread: function FragmentSpread(node) {\n      var fragmentName = node.name.value;\n      var fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(new _GraphQLError.GraphQLError(unknownFragmentMessage(fragmentName), [node.name]));\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/KnownFragmentNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/KnownTypeNames.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/KnownTypeNames.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unknownTypeMessage = unknownTypeMessage;\nexports.KnownTypeNames = KnownTypeNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _suggestionList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/suggestionList */ \"./node_modules/graphql/jsutils/suggestionList.js\"));\n\nvar _quotedOrList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/quotedOrList */ \"./node_modules/graphql/jsutils/quotedOrList.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction unknownTypeMessage(typeName, suggestedTypes) {\n  var message = \"Unknown type \\\"\".concat(typeName, \"\\\".\");\n\n  if (suggestedTypes.length) {\n    message += \" Did you mean \".concat((0, _quotedOrList.default)(suggestedTypes), \"?\");\n  }\n\n  return message;\n}\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\n\nfunction KnownTypeNames(context) {\n  return {\n    // TODO: when validating IDL, re-enable these. Experimental version does not\n    // add unreferenced types, resulting in false-positive errors. Squelched\n    // errors for now.\n    ObjectTypeDefinition: function ObjectTypeDefinition() {\n      return false;\n    },\n    InterfaceTypeDefinition: function InterfaceTypeDefinition() {\n      return false;\n    },\n    UnionTypeDefinition: function UnionTypeDefinition() {\n      return false;\n    },\n    InputObjectTypeDefinition: function InputObjectTypeDefinition() {\n      return false;\n    },\n    NamedType: function NamedType(node) {\n      var schema = context.getSchema();\n      var typeName = node.name.value;\n      var type = schema.getType(typeName);\n\n      if (!type) {\n        context.reportError(new _GraphQLError.GraphQLError(unknownTypeMessage(typeName, (0, _suggestionList.default)(typeName, Object.keys(schema.getTypeMap()))), [node]));\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/KnownTypeNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/LoneAnonymousOperation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/LoneAnonymousOperation.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.anonOperationNotAloneMessage = anonOperationNotAloneMessage;\nexports.LoneAnonymousOperation = LoneAnonymousOperation;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction anonOperationNotAloneMessage() {\n  return 'This anonymous operation must be the only defined operation.';\n}\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n */\n\n\nfunction LoneAnonymousOperation(context) {\n  var operationCount = 0;\n  return {\n    Document: function Document(node) {\n      operationCount = node.definitions.filter(function (definition) {\n        return definition.kind === _kinds.Kind.OPERATION_DEFINITION;\n      }).length;\n    },\n    OperationDefinition: function OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(new _GraphQLError.GraphQLError(anonOperationNotAloneMessage(), [node]));\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/LoneAnonymousOperation.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/LoneSchemaDefinition.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/LoneSchemaDefinition.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.schemaDefinitionNotAloneMessage = schemaDefinitionNotAloneMessage;\nexports.canNotDefineSchemaWithinExtensionMessage = canNotDefineSchemaWithinExtensionMessage;\nexports.LoneSchemaDefinition = LoneSchemaDefinition;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2018-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction schemaDefinitionNotAloneMessage() {\n  return 'Must provide only one schema definition.';\n}\n\nfunction canNotDefineSchemaWithinExtensionMessage() {\n  return 'Cannot define a new schema within a schema extension.';\n}\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\n\n\nfunction LoneSchemaDefinition(context) {\n  var oldSchema = context.getSchema();\n  var alreadyDefined = oldSchema && (oldSchema.astNode || oldSchema.getQueryType() || oldSchema.getMutationType() || oldSchema.getSubscriptionType());\n  var schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition: function SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(new _GraphQLError.GraphQLError(canNotDefineSchemaWithinExtensionMessage(), node));\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(new _GraphQLError.GraphQLError(schemaDefinitionNotAloneMessage(), node));\n      }\n\n      ++schemaDefinitionsCount;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/LoneSchemaDefinition.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/NoFragmentCycles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/NoFragmentCycles.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cycleErrorMessage = cycleErrorMessage;\nexports.NoFragmentCycles = NoFragmentCycles;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction cycleErrorMessage(fragName, spreadNames) {\n  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';\n  return \"Cannot spread fragment \\\"\".concat(fragName, \"\\\" within itself\").concat(via, \".\");\n}\n\nfunction NoFragmentCycles(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  var spreadPath = []; // Position in the spread path\n\n  var spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    }\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    var fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (var i = 0; i < spreadNodes.length; i++) {\n      var spreadNode = spreadNodes[i];\n      var spreadName = spreadNode.name.value;\n      var cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        var spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        var cyclePath = spreadPath.slice(cycleIndex);\n        var fragmentNames = cyclePath.slice(0, -1).map(function (s) {\n          return s.name.value;\n        });\n        context.reportError(new _GraphQLError.GraphQLError(cycleErrorMessage(spreadName, fragmentNames), cyclePath));\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/NoFragmentCycles.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/NoUndefinedVariables.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/NoUndefinedVariables.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.undefinedVarMessage = undefinedVarMessage;\nexports.NoUndefinedVariables = NoUndefinedVariables;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction undefinedVarMessage(varName, opName) {\n  return opName ? \"Variable \\\"$\".concat(varName, \"\\\" is not defined by operation \\\"\").concat(opName, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is not defined.\");\n}\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n */\n\n\nfunction NoUndefinedVariables(context) {\n  var variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableNameDefined = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n            var node = _ref2.node;\n            var varName = node.name.value;\n\n            if (variableNameDefined[varName] !== true) {\n              context.reportError(new _GraphQLError.GraphQLError(undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/NoUndefinedVariables.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/NoUnusedFragments.js":
/*!********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/NoUnusedFragments.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unusedFragMessage = unusedFragMessage;\nexports.NoUnusedFragments = NoUnusedFragments;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction unusedFragMessage(fragName) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" is never used.\");\n}\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n */\n\n\nfunction NoUnusedFragments(context) {\n  var operationDefs = [];\n  var fragmentDefs = [];\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n    Document: {\n      leave: function leave() {\n        var fragmentNameUsed = Object.create(null);\n\n        for (var _i = 0; _i < operationDefs.length; _i++) {\n          var operation = operationDefs[_i];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = context.getRecursivelyReferencedFragments(operation)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var fragment = _step.value;\n              fragmentNameUsed[fragment.name.value] = true;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        for (var _i2 = 0; _i2 < fragmentDefs.length; _i2++) {\n          var fragmentDef = fragmentDefs[_i2];\n          var fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(new _GraphQLError.GraphQLError(unusedFragMessage(fragName), [fragmentDef]));\n          }\n        }\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/NoUnusedFragments.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/NoUnusedVariables.js":
/*!********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/NoUnusedVariables.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unusedVariableMessage = unusedVariableMessage;\nexports.NoUnusedVariables = NoUnusedVariables;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction unusedVariableMessage(varName, opName) {\n  return opName ? \"Variable \\\"$\".concat(varName, \"\\\" is never used in operation \\\"\").concat(opName, \"\\\".\") : \"Variable \\\"$\".concat(varName, \"\\\" is never used.\");\n}\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n */\n\n\nfunction NoUnusedVariables(context) {\n  var variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        variableDefs = [];\n      },\n      leave: function leave(operation) {\n        var variableNameUsed = Object.create(null);\n        var usages = context.getRecursiveVariableUsages(operation);\n        var opName = operation.name ? operation.name.value : null;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n            var node = _ref2.node;\n            variableNameUsed[node.name.value] = true;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        for (var _i = 0; _i < variableDefs.length; _i++) {\n          var variableDef = variableDefs[_i];\n          var variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(new _GraphQLError.GraphQLError(unusedVariableMessage(variableName, opName), [variableDef]));\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(def) {\n      variableDefs.push(def);\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/NoUnusedVariables.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fieldsConflictMessage = fieldsConflictMessage;\nexports.OverlappingFieldsCanBeMerged = OverlappingFieldsCanBeMerged;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _find = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/find */ \"./node_modules/graphql/jsutils/find.js\"));\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _printer = __webpack_require__(/*! ../../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction fieldsConflictMessage(responseName, reason) {\n  return \"Fields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(reason), \". \") + 'Use different aliases on the fields to fetch both if this was intentional.';\n}\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(function (_ref) {\n      var responseName = _ref[0],\n          subreason = _ref[1];\n      return \"subfields \\\"\".concat(responseName, \"\\\" conflict because \").concat(reasonMessage(subreason));\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\n\n\nfunction OverlappingFieldsCanBeMerged(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  var comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  var cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet: function SelectionSet(selectionSet) {\n      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (var _i = 0; _i < conflicts.length; _i++) {\n        var _ref3 = conflicts[_i];\n        var _ref2$ = _ref3[0];\n        var responseName = _ref2$[0];\n        var reason = _ref2$[1];\n        var fields1 = _ref3[1];\n        var fields2 = _ref3[2];\n        context.reportError(new _GraphQLError.GraphQLError(fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));\n      }\n    }\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),\n      fieldMap = _getFieldsAndFragment[0],\n      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    var comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (var j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  // Memoize so a fragment is not compared for conflicts more than once.\n  if (comparedFragments[fragmentName]) {\n    return;\n  }\n\n  comparedFragments[fragmentName] = true;\n  var fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),\n      fieldMap2 = _getReferencedFieldsA[0],\n      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.\n\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (var i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  var fragment1 = context.getFragment(fragmentName1);\n  var fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),\n      fieldMap1 = _getReferencedFieldsA2[0],\n      fragmentNames1 = _getReferencedFieldsA2[1];\n\n  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),\n      fieldMap2 = _getReferencedFieldsA3[0],\n      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (var j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (var i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  var conflicts = [];\n\n  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),\n      fieldMap1 = _getFieldsAndFragment2[0],\n      fragmentNames1 = _getFieldsAndFragment2[1];\n\n  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),\n      fieldMap2 = _getFieldsAndFragment3[0],\n      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  if (fragmentNames2.length !== 0) {\n    var comparedFragments = Object.create(null);\n\n    for (var j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);\n    }\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  if (fragmentNames1.length !== 0) {\n    var _comparedFragments = Object.create(null);\n\n    for (var i = 0; i < fragmentNames1.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);\n    }\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (var _i2 = 0; _i2 < fragmentNames1.length; _i2++) {\n    for (var _j = 0; _j < fragmentNames2.length; _j++) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i2], fragmentNames2[_j]);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  var _arr = Object.keys(fieldMap);\n\n  for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n    var responseName = _arr[_i3];\n    var fields = fieldMap[responseName]; // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n\n    if (fields.length > 1) {\n      for (var i = 0; i < fields.length; i++) {\n        for (var j = i + 1; j < fields.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  var _arr2 = Object.keys(fieldMap1);\n\n  for (var _i4 = 0; _i4 < _arr2.length; _i4++) {\n    var responseName = _arr2[_i4];\n    var fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      var fields1 = fieldMap1[responseName];\n\n      for (var i = 0; i < fields1.length; i++) {\n        for (var j = 0; j < fields2.length; j++) {\n          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  var parentType1 = field1[0],\n      node1 = field1[1],\n      def1 = field1[2];\n  var parentType2 = field2[0],\n      node2 = field2[1],\n      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2); // The return type for each field.\n\n  var type1 = def1 && def1.type;\n  var type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    var name1 = node1.name.value;\n    var name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, \"\".concat(name1, \" and \").concat(name2, \" are different fields\")], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, \"they return conflicting types \".concat((0, _inspect.default)(type1), \" and \").concat((0, _inspect.default)(type2))], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  var selectionSet1 = node1.selectionSet;\n  var selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, (0, _definition.getNamedType)(type1), selectionSet1, (0, _definition.getNamedType)(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments(arguments1, arguments2) {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n\n  return arguments1.every(function (argument1) {\n    var argument2 = (0, _find.default)(arguments2, function (argument) {\n      return argument.name.value === argument1.name.value;\n    });\n\n    if (!argument2) {\n      return false;\n    }\n\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return !value1 && !value2 || (0, _printer.print)(value1) === (0, _printer.print)(value2);\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if ((0, _definition.isListType)(type1)) {\n    return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if ((0, _definition.isListType)(type2)) {\n    return true;\n  }\n\n  if ((0, _definition.isNonNullType)(type1)) {\n    return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if ((0, _definition.isNonNullType)(type2)) {\n    return true;\n  }\n\n  if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  var cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (!cached) {\n    var nodeAndDefs = Object.create(null);\n    var fragmentNames = Object.create(null);\n\n    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n    cached = [nodeAndDefs, Object.keys(fragmentNames)];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n\n  return cached;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  var fragmentType = (0, _typeFromAST.typeFromAST)(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (var i = 0; i < selectionSet.selections.length; i++) {\n    var selection = selectionSet.selections[i];\n\n    switch (selection.kind) {\n      case _kinds.Kind.FIELD:\n        var fieldName = selection.name.value;\n        var fieldDef = void 0;\n\n        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        var responseName = selection.alias ? selection.alias.value : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n\n      case _kinds.Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case _kinds.Kind.INLINE_FRAGMENT:\n        var typeCondition = selection.typeCondition;\n        var inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;\n\n        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n        break;\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(function (_ref4) {\n      var reason = _ref4[0];\n      return reason;\n    })], conflicts.reduce(function (allFields, _ref5) {\n      var fields1 = _ref5[1];\n      return allFields.concat(fields1);\n    }, [node1]), conflicts.reduce(function (allFields, _ref6) {\n      var fields2 = _ref6[2];\n      return allFields.concat(fields2);\n    }, [node2])];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\n\n\nvar PairSet =\n/*#__PURE__*/\nfunction () {\n  function PairSet() {\n    _defineProperty(this, \"_data\", void 0);\n\n    this._data = Object.create(null);\n  }\n\n  var _proto = PairSet.prototype;\n\n  _proto.has = function has(a, b, areMutuallyExclusive) {\n    var first = this._data[a];\n    var result = first && first[b];\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n\n\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n\n    return true;\n  };\n\n  _proto.add = function add(a, b, areMutuallyExclusive) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  };\n\n  return PairSet;\n}();\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  var map = data[a];\n\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n\n  map[b] = areMutuallyExclusive;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/PossibleFragmentSpreads.js":
/*!**************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/PossibleFragmentSpreads.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage;\nexports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage;\nexports.PossibleFragmentSpreads = PossibleFragmentSpreads;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _typeComparators = __webpack_require__(/*! ../../utilities/typeComparators */ \"./node_modules/graphql/utilities/typeComparators.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction typeIncompatibleSpreadMessage(fragName, parentType, fragType) {\n  return \"Fragment \\\"\".concat(fragName, \"\\\" cannot be spread here as objects of \") + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n\nfunction typeIncompatibleAnonSpreadMessage(parentType, fragType) {\n  return 'Fragment cannot be spread here as objects of ' + \"type \\\"\".concat(parentType, \"\\\" can never be of type \\\"\").concat(fragType, \"\\\".\");\n}\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\n\n\nfunction PossibleFragmentSpreads(context) {\n  return {\n    InlineFragment: function InlineFragment(node) {\n      var fragType = context.getType();\n      var parentType = context.getParentType();\n\n      if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        context.reportError(new _GraphQLError.GraphQLError(typeIncompatibleAnonSpreadMessage((0, _inspect.default)(parentType), (0, _inspect.default)(fragType)), [node]));\n      }\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var fragName = node.name.value;\n      var fragType = getFragmentType(context, fragName);\n      var parentType = context.getParentType();\n\n      if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(context.getSchema(), fragType, parentType)) {\n        context.reportError(new _GraphQLError.GraphQLError(typeIncompatibleSpreadMessage(fragName, (0, _inspect.default)(parentType), (0, _inspect.default)(fragType)), [node]));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  var frag = context.getFragment(name);\n\n  if (frag) {\n    var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), frag.typeCondition);\n\n    if ((0, _definition.isCompositeType)(type)) {\n      return type;\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/PossibleFragmentSpreads.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/ProvidedRequiredArguments.js":
/*!****************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/ProvidedRequiredArguments.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.missingFieldArgMessage = missingFieldArgMessage;\nexports.missingDirectiveArgMessage = missingDirectiveArgMessage;\nexports.ProvidedRequiredArguments = ProvidedRequiredArguments;\nexports.ProvidedRequiredArgumentsOnDirectives = ProvidedRequiredArgumentsOnDirectives;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _printer = __webpack_require__(/*! ../../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _directives = __webpack_require__(/*! ../../type/directives */ \"./node_modules/graphql/type/directives.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction missingFieldArgMessage(fieldName, argName, type) {\n  return \"Field \\\"\".concat(fieldName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \") + \"\\\"\".concat(type, \"\\\" is required but not provided.\");\n}\n\nfunction missingDirectiveArgMessage(directiveName, argName, type) {\n  return \"Directive \\\"@\".concat(directiveName, \"\\\" argument \\\"\").concat(argName, \"\\\" of type \") + \"\\\"\".concat(type, \"\\\" is required but not provided.\");\n}\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\n\n\nfunction ProvidedRequiredArguments(context) {\n  return _objectSpread({}, ProvidedRequiredArgumentsOnDirectives(context), {\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(fieldNode) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        var argNodes = fieldNode.arguments || [];\n        var argNodeMap = (0, _keyMap.default)(argNodes, function (arg) {\n          return arg.name.value;\n        });\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = fieldDef.args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var argDef = _step.value;\n            var argNode = argNodeMap[argDef.name];\n\n            if (!argNode && (0, _definition.isRequiredArgument)(argDef)) {\n              context.reportError(new _GraphQLError.GraphQLError(missingFieldArgMessage(fieldDef.name, argDef.name, (0, _inspect.default)(argDef.type)), [fieldNode]));\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  });\n} // @internal\n\n\nfunction ProvidedRequiredArgumentsOnDirectives(context) {\n  var requiredArgsMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = definedDirectives[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var directive = _step2.value;\n      requiredArgsMap[directive.name] = (0, _keyMap.default)(directive.args.filter(_definition.isRequiredArgument), function (arg) {\n        return arg.name;\n      });\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = astDefinitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var def = _step3.value;\n\n      if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {\n        requiredArgsMap[def.name.value] = (0, _keyMap.default)(def.arguments ? def.arguments.filter(isRequiredArgumentNode) : [], function (arg) {\n          return arg.name.value;\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave: function leave(directiveNode) {\n        var directiveName = directiveNode.name.value;\n        var requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var argNodes = directiveNode.arguments || [];\n          var argNodeMap = (0, _keyMap.default)(argNodes, function (arg) {\n            return arg.name.value;\n          });\n\n          var _arr = Object.keys(requiredArgs);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            var argName = _arr[_i];\n\n            if (!argNodeMap[argName]) {\n              var argType = requiredArgs[argName].type;\n              context.reportError(new _GraphQLError.GraphQLError(missingDirectiveArgMessage(directiveName, argName, (0, _definition.isType)(argType) ? (0, _inspect.default)(argType) : (0, _printer.print)(argType)), directiveNode));\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/ProvidedRequiredArguments.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/ScalarLeafs.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/ScalarLeafs.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.noSubselectionAllowedMessage = noSubselectionAllowedMessage;\nexports.requiredSubselectionMessage = requiredSubselectionMessage;\nexports.ScalarLeafs = ScalarLeafs;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction noSubselectionAllowedMessage(fieldName, type) {\n  return \"Field \\\"\".concat(fieldName, \"\\\" must not have a selection since \") + \"type \\\"\".concat(type, \"\\\" has no subfields.\");\n}\n\nfunction requiredSubselectionMessage(fieldName, type) {\n  return \"Field \\\"\".concat(fieldName, \"\\\" of type \\\"\").concat(type, \"\\\" must have a \") + \"selection of subfields. Did you mean \\\"\".concat(fieldName, \" { ... }\\\"?\");\n}\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\n\n\nfunction ScalarLeafs(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getType();\n      var selectionSet = node.selectionSet;\n\n      if (type) {\n        if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {\n          if (selectionSet) {\n            context.reportError(new _GraphQLError.GraphQLError(noSubselectionAllowedMessage(node.name.value, (0, _inspect.default)(type)), [selectionSet]));\n          }\n        } else if (!selectionSet) {\n          context.reportError(new _GraphQLError.GraphQLError(requiredSubselectionMessage(node.name.value, (0, _inspect.default)(type)), [node]));\n        }\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/ScalarLeafs.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/SingleFieldSubscriptions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/SingleFieldSubscriptions.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.singleFieldOnlyMessage = singleFieldOnlyMessage;\nexports.SingleFieldSubscriptions = SingleFieldSubscriptions;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction singleFieldOnlyMessage(name) {\n  return (name ? \"Subscription \\\"\".concat(name, \"\\\" \") : 'Anonymous Subscription ') + 'must select only one top level field.';\n}\n/**\n * Subscriptions must only include one field.\n *\n * A GraphQL subscription is valid only if it contains a single root field.\n */\n\n\nfunction SingleFieldSubscriptions(context) {\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        if (node.selectionSet.selections.length !== 1) {\n          context.reportError(new _GraphQLError.GraphQLError(singleFieldOnlyMessage(node.name && node.name.value), node.selectionSet.selections.slice(1)));\n        }\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/SingleFieldSubscriptions.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/UniqueArgumentNames.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/UniqueArgumentNames.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.duplicateArgMessage = duplicateArgMessage;\nexports.UniqueArgumentNames = UniqueArgumentNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction duplicateArgMessage(argName) {\n  return \"There can be only one argument named \\\"\".concat(argName, \"\\\".\");\n}\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n */\n\n\nfunction UniqueArgumentNames(context) {\n  var knownArgNames = Object.create(null);\n  return {\n    Field: function Field() {\n      knownArgNames = Object.create(null);\n    },\n    Directive: function Directive() {\n      knownArgNames = Object.create(null);\n    },\n    Argument: function Argument(node) {\n      var argName = node.name.value;\n\n      if (knownArgNames[argName]) {\n        context.reportError(new _GraphQLError.GraphQLError(duplicateArgMessage(argName), [knownArgNames[argName], node.name]));\n      } else {\n        knownArgNames[argName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/UniqueArgumentNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.js":
/*!******************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.duplicateDirectiveMessage = duplicateDirectiveMessage;\nexports.UniqueDirectivesPerLocation = UniqueDirectivesPerLocation;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction duplicateDirectiveMessage(directiveName) {\n  return \"The directive \\\"\".concat(directiveName, \"\\\" can only be used once at \") + 'this location.';\n}\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all directives at a given location\n * are uniquely named.\n */\n\n\nfunction UniqueDirectivesPerLocation(context) {\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      // Flow can't refine that node.directives will only contain directives,\n      var directives = node.directives;\n\n      if (directives) {\n        var knownDirectives = Object.create(null);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = directives[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var directive = _step.value;\n            var directiveName = directive.name.value;\n\n            if (knownDirectives[directiveName]) {\n              context.reportError(new _GraphQLError.GraphQLError(duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], directive]));\n            } else {\n              knownDirectives[directiveName] = directive;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/UniqueFragmentNames.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/UniqueFragmentNames.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.duplicateFragmentNameMessage = duplicateFragmentNameMessage;\nexports.UniqueFragmentNames = UniqueFragmentNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction duplicateFragmentNameMessage(fragName) {\n  return \"There can be only one fragment named \\\"\".concat(fragName, \"\\\".\");\n}\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n */\n\n\nfunction UniqueFragmentNames(context) {\n  var knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      var fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(new _GraphQLError.GraphQLError(duplicateFragmentNameMessage(fragmentName), [knownFragmentNames[fragmentName], node.name]));\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/UniqueFragmentNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/UniqueInputFieldNames.js":
/*!************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/UniqueInputFieldNames.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.duplicateInputFieldMessage = duplicateInputFieldMessage;\nexports.UniqueInputFieldNames = UniqueInputFieldNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction duplicateInputFieldMessage(fieldName) {\n  return \"There can be only one input field named \\\"\".concat(fieldName, \"\\\".\");\n}\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n */\n\n\nfunction UniqueInputFieldNames(context) {\n  var knownNameStack = [];\n  var knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter: function enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n      leave: function leave() {\n        knownNames = knownNameStack.pop();\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(new _GraphQLError.GraphQLError(duplicateInputFieldMessage(fieldName), [knownNames[fieldName], node.name]));\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n\n      return false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/UniqueInputFieldNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/UniqueOperationNames.js":
/*!***********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/UniqueOperationNames.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.duplicateOperationNameMessage = duplicateOperationNameMessage;\nexports.UniqueOperationNames = UniqueOperationNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction duplicateOperationNameMessage(operationName) {\n  return \"There can be only one operation named \\\"\".concat(operationName, \"\\\".\");\n}\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n */\n\n\nfunction UniqueOperationNames(context) {\n  var knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition(node) {\n      var operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(new _GraphQLError.GraphQLError(duplicateOperationNameMessage(operationName.value), [knownOperationNames[operationName.value], operationName]));\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n    FragmentDefinition: function FragmentDefinition() {\n      return false;\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/UniqueOperationNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/UniqueVariableNames.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/UniqueVariableNames.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.duplicateVariableMessage = duplicateVariableMessage;\nexports.UniqueVariableNames = UniqueVariableNames;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction duplicateVariableMessage(variableName) {\n  return \"There can be only one variable named \\\"\".concat(variableName, \"\\\".\");\n}\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\n\n\nfunction UniqueVariableNames(context) {\n  var knownVariableNames = Object.create(null);\n  return {\n    OperationDefinition: function OperationDefinition() {\n      knownVariableNames = Object.create(null);\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      var variableName = node.variable.name.value;\n\n      if (knownVariableNames[variableName]) {\n        context.reportError(new _GraphQLError.GraphQLError(duplicateVariableMessage(variableName), [knownVariableNames[variableName], node.variable.name]));\n      } else {\n        knownVariableNames[variableName] = node.variable.name;\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/UniqueVariableNames.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/ValuesOfCorrectType.js":
/*!**********************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/ValuesOfCorrectType.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.badValueMessage = badValueMessage;\nexports.requiredFieldMessage = requiredFieldMessage;\nexports.unknownFieldMessage = unknownFieldMessage;\nexports.ValuesOfCorrectType = ValuesOfCorrectType;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _printer = __webpack_require__(/*! ../../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _isInvalid = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/isInvalid */ \"./node_modules/graphql/jsutils/isInvalid.js\"));\n\nvar _keyMap = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/keyMap */ \"./node_modules/graphql/jsutils/keyMap.js\"));\n\nvar _orList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/orList */ \"./node_modules/graphql/jsutils/orList.js\"));\n\nvar _suggestionList = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/suggestionList */ \"./node_modules/graphql/jsutils/suggestionList.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction badValueMessage(typeName, valueName, message) {\n  return \"Expected type \".concat(typeName, \", found \").concat(valueName) + (message ? \"; \".concat(message) : '.');\n}\n\nfunction requiredFieldMessage(typeName, fieldName, fieldTypeName) {\n  return \"Field \".concat(typeName, \".\").concat(fieldName, \" of required type \") + \"\".concat(fieldTypeName, \" was not provided.\");\n}\n\nfunction unknownFieldMessage(typeName, fieldName, message) {\n  return \"Field \\\"\".concat(fieldName, \"\\\" is not defined by type \").concat(typeName) + (message ? \"; \".concat(message) : '.');\n}\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n */\n\n\nfunction ValuesOfCorrectType(context) {\n  return {\n    NullValue: function NullValue(node) {\n      var type = context.getInputType();\n\n      if ((0, _definition.isNonNullType)(type)) {\n        context.reportError(new _GraphQLError.GraphQLError(badValueMessage((0, _inspect.default)(type), (0, _printer.print)(node)), node));\n      }\n    },\n    ListValue: function ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      var type = (0, _definition.getNullableType)(context.getParentInputType());\n\n      if (!(0, _definition.isListType)(type)) {\n        isValidScalar(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n    ObjectValue: function ObjectValue(node) {\n      var type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isInputObjectType)(type)) {\n        isValidScalar(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n\n      var inputFields = type.getFields();\n      var fieldNodeMap = (0, _keyMap.default)(node.fields, function (field) {\n        return field.name.value;\n      });\n\n      var _arr = Object.keys(inputFields);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var fieldName = _arr[_i];\n        var fieldDef = inputFields[fieldName];\n        var fieldNode = fieldNodeMap[fieldName];\n\n        if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {\n          var typeStr = (0, _inspect.default)(fieldDef.type);\n          context.reportError(new _GraphQLError.GraphQLError(requiredFieldMessage(type.name, fieldName, typeStr), node));\n        }\n      }\n    },\n    ObjectField: function ObjectField(node) {\n      var parentType = (0, _definition.getNamedType)(context.getParentInputType());\n      var fieldType = context.getInputType();\n\n      if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {\n        var suggestions = (0, _suggestionList.default)(node.name.value, Object.keys(parentType.getFields()));\n        var didYouMean = suggestions.length !== 0 ? \"Did you mean \".concat((0, _orList.default)(suggestions), \"?\") : undefined;\n        context.reportError(new _GraphQLError.GraphQLError(unknownFieldMessage(parentType.name, node.name.value, didYouMean), node));\n      }\n    },\n    EnumValue: function EnumValue(node) {\n      var type = (0, _definition.getNamedType)(context.getInputType());\n\n      if (!(0, _definition.isEnumType)(type)) {\n        isValidScalar(context, node);\n      } else if (!type.getValue(node.value)) {\n        context.reportError(new _GraphQLError.GraphQLError(badValueMessage(type.name, (0, _printer.print)(node), enumTypeSuggestion(type, node)), node));\n      }\n    },\n    IntValue: function IntValue(node) {\n      return isValidScalar(context, node);\n    },\n    FloatValue: function FloatValue(node) {\n      return isValidScalar(context, node);\n    },\n    StringValue: function StringValue(node) {\n      return isValidScalar(context, node);\n    },\n    BooleanValue: function BooleanValue(node) {\n      return isValidScalar(context, node);\n    }\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\n\nfunction isValidScalar(context, node) {\n  // Report any error at the full type expected by the location.\n  var locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  var type = (0, _definition.getNamedType)(locationType);\n\n  if (!(0, _definition.isScalarType)(type)) {\n    context.reportError(new _GraphQLError.GraphQLError(badValueMessage((0, _inspect.default)(locationType), (0, _printer.print)(node), enumTypeSuggestion(type, node)), node));\n    return;\n  } // Scalars determine if a literal value is valid via parseLiteral() which\n  // may throw or return an invalid value to indicate failure.\n\n\n  try {\n    var parseResult = type.parseLiteral(node, undefined\n    /* variables */\n    );\n\n    if ((0, _isInvalid.default)(parseResult)) {\n      context.reportError(new _GraphQLError.GraphQLError(badValueMessage((0, _inspect.default)(locationType), (0, _printer.print)(node)), node));\n    }\n  } catch (error) {\n    // Ensure a reference to the original error is maintained.\n    context.reportError(new _GraphQLError.GraphQLError(badValueMessage((0, _inspect.default)(locationType), (0, _printer.print)(node), error.message), node, undefined, undefined, undefined, error));\n  }\n}\n\nfunction enumTypeSuggestion(type, node) {\n  if ((0, _definition.isEnumType)(type)) {\n    var suggestions = (0, _suggestionList.default)((0, _printer.print)(node), type.getValues().map(function (value) {\n      return value.name;\n    }));\n\n    if (suggestions.length !== 0) {\n      return \"Did you mean the enum value \".concat((0, _orList.default)(suggestions), \"?\");\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/ValuesOfCorrectType.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/VariablesAreInputTypes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/VariablesAreInputTypes.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage;\nexports.VariablesAreInputTypes = VariablesAreInputTypes;\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _printer = __webpack_require__(/*! ../../language/printer */ \"./node_modules/graphql/language/printer.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction nonInputTypeOnVarMessage(variableName, typeName) {\n  return \"Variable \\\"$\".concat(variableName, \"\\\" cannot be non-input type \\\"\").concat(typeName, \"\\\".\");\n}\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n */\n\n\nfunction VariablesAreInputTypes(context) {\n  return {\n    VariableDefinition: function VariableDefinition(node) {\n      var type = (0, _typeFromAST.typeFromAST)(context.getSchema(), node.type); // If the variable type is not an input type, return an error.\n\n      if (type && !(0, _definition.isInputType)(type)) {\n        var variableName = node.variable.name.value;\n        context.reportError(new _GraphQLError.GraphQLError(nonInputTypeOnVarMessage(variableName, (0, _printer.print)(node.type)), [node.type]));\n      }\n    }\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/VariablesAreInputTypes.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/rules/VariablesInAllowedPosition.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/graphql/validation/rules/VariablesInAllowedPosition.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.badVarPosMessage = badVarPosMessage;\nexports.VariablesInAllowedPosition = VariablesInAllowedPosition;\n\nvar _inspect = _interopRequireDefault(__webpack_require__(/*! ../../jsutils/inspect */ \"./node_modules/graphql/jsutils/inspect.js\"));\n\nvar _GraphQLError = __webpack_require__(/*! ../../error/GraphQLError */ \"./node_modules/graphql/error/GraphQLError.js\");\n\nvar _kinds = __webpack_require__(/*! ../../language/kinds */ \"./node_modules/graphql/language/kinds.js\");\n\nvar _definition = __webpack_require__(/*! ../../type/definition */ \"./node_modules/graphql/type/definition.js\");\n\nvar _typeComparators = __webpack_require__(/*! ../../utilities/typeComparators */ \"./node_modules/graphql/utilities/typeComparators.js\");\n\nvar _typeFromAST = __webpack_require__(/*! ../../utilities/typeFromAST */ \"./node_modules/graphql/utilities/typeFromAST.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\nfunction badVarPosMessage(varName, varType, expectedType) {\n  return \"Variable \\\"$\".concat(varName, \"\\\" of type \\\"\").concat(varType, \"\\\" used in \") + \"position expecting type \\\"\".concat(expectedType, \"\\\".\");\n}\n/**\n * Variables passed to field arguments conform to type\n */\n\n\nfunction VariablesInAllowedPosition(context) {\n  var varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter: function enter() {\n        varDefMap = Object.create(null);\n      },\n      leave: function leave(operation) {\n        var usages = context.getRecursiveVariableUsages(operation);\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = usages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n            var node = _ref2.node,\n                type = _ref2.type,\n                defaultValue = _ref2.defaultValue;\n            var varName = node.name.value;\n            var varDef = varDefMap[varName];\n\n            if (varDef && type) {\n              // A var type is allowed if it is the same or more strict (e.g. is\n              // a subtype of) than the expected type. It can be more strict if\n              // the variable type is non-null when the expected type is nullable.\n              // If both are list types, the variable item type can be more strict\n              // than the expected item type (contravariant).\n              var schema = context.getSchema();\n              var varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);\n\n              if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {\n                context.reportError(new _GraphQLError.GraphQLError(badVarPosMessage(varName, (0, _inspect.default)(varType), (0, _inspect.default)(type)), [varDef, node]));\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    },\n    VariableDefinition: function VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    }\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\n\nfunction allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {\n  if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {\n    var hasNonNullVariableDefaultValue = varDefaultValue && varDefaultValue.kind !== _kinds.Kind.NULL;\n    var hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    var nullableLocationType = locationType.ofType;\n    return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, nullableLocationType);\n  }\n\n  return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/rules/VariablesInAllowedPosition.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/specifiedRules.js":
/*!***********************************************************!*\
  !*** ./node_modules/graphql/validation/specifiedRules.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.specifiedSDLRules = exports.specifiedRules = void 0;\n\nvar _ExecutableDefinitions = __webpack_require__(/*! ./rules/ExecutableDefinitions */ \"./node_modules/graphql/validation/rules/ExecutableDefinitions.js\");\n\nvar _UniqueOperationNames = __webpack_require__(/*! ./rules/UniqueOperationNames */ \"./node_modules/graphql/validation/rules/UniqueOperationNames.js\");\n\nvar _LoneAnonymousOperation = __webpack_require__(/*! ./rules/LoneAnonymousOperation */ \"./node_modules/graphql/validation/rules/LoneAnonymousOperation.js\");\n\nvar _SingleFieldSubscriptions = __webpack_require__(/*! ./rules/SingleFieldSubscriptions */ \"./node_modules/graphql/validation/rules/SingleFieldSubscriptions.js\");\n\nvar _KnownTypeNames = __webpack_require__(/*! ./rules/KnownTypeNames */ \"./node_modules/graphql/validation/rules/KnownTypeNames.js\");\n\nvar _FragmentsOnCompositeTypes = __webpack_require__(/*! ./rules/FragmentsOnCompositeTypes */ \"./node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.js\");\n\nvar _VariablesAreInputTypes = __webpack_require__(/*! ./rules/VariablesAreInputTypes */ \"./node_modules/graphql/validation/rules/VariablesAreInputTypes.js\");\n\nvar _ScalarLeafs = __webpack_require__(/*! ./rules/ScalarLeafs */ \"./node_modules/graphql/validation/rules/ScalarLeafs.js\");\n\nvar _FieldsOnCorrectType = __webpack_require__(/*! ./rules/FieldsOnCorrectType */ \"./node_modules/graphql/validation/rules/FieldsOnCorrectType.js\");\n\nvar _UniqueFragmentNames = __webpack_require__(/*! ./rules/UniqueFragmentNames */ \"./node_modules/graphql/validation/rules/UniqueFragmentNames.js\");\n\nvar _KnownFragmentNames = __webpack_require__(/*! ./rules/KnownFragmentNames */ \"./node_modules/graphql/validation/rules/KnownFragmentNames.js\");\n\nvar _NoUnusedFragments = __webpack_require__(/*! ./rules/NoUnusedFragments */ \"./node_modules/graphql/validation/rules/NoUnusedFragments.js\");\n\nvar _PossibleFragmentSpreads = __webpack_require__(/*! ./rules/PossibleFragmentSpreads */ \"./node_modules/graphql/validation/rules/PossibleFragmentSpreads.js\");\n\nvar _NoFragmentCycles = __webpack_require__(/*! ./rules/NoFragmentCycles */ \"./node_modules/graphql/validation/rules/NoFragmentCycles.js\");\n\nvar _UniqueVariableNames = __webpack_require__(/*! ./rules/UniqueVariableNames */ \"./node_modules/graphql/validation/rules/UniqueVariableNames.js\");\n\nvar _NoUndefinedVariables = __webpack_require__(/*! ./rules/NoUndefinedVariables */ \"./node_modules/graphql/validation/rules/NoUndefinedVariables.js\");\n\nvar _NoUnusedVariables = __webpack_require__(/*! ./rules/NoUnusedVariables */ \"./node_modules/graphql/validation/rules/NoUnusedVariables.js\");\n\nvar _KnownDirectives = __webpack_require__(/*! ./rules/KnownDirectives */ \"./node_modules/graphql/validation/rules/KnownDirectives.js\");\n\nvar _UniqueDirectivesPerLocation = __webpack_require__(/*! ./rules/UniqueDirectivesPerLocation */ \"./node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.js\");\n\nvar _KnownArgumentNames = __webpack_require__(/*! ./rules/KnownArgumentNames */ \"./node_modules/graphql/validation/rules/KnownArgumentNames.js\");\n\nvar _UniqueArgumentNames = __webpack_require__(/*! ./rules/UniqueArgumentNames */ \"./node_modules/graphql/validation/rules/UniqueArgumentNames.js\");\n\nvar _ValuesOfCorrectType = __webpack_require__(/*! ./rules/ValuesOfCorrectType */ \"./node_modules/graphql/validation/rules/ValuesOfCorrectType.js\");\n\nvar _ProvidedRequiredArguments = __webpack_require__(/*! ./rules/ProvidedRequiredArguments */ \"./node_modules/graphql/validation/rules/ProvidedRequiredArguments.js\");\n\nvar _VariablesInAllowedPosition = __webpack_require__(/*! ./rules/VariablesInAllowedPosition */ \"./node_modules/graphql/validation/rules/VariablesInAllowedPosition.js\");\n\nvar _OverlappingFieldsCanBeMerged = __webpack_require__(/*! ./rules/OverlappingFieldsCanBeMerged */ \"./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.js\");\n\nvar _UniqueInputFieldNames = __webpack_require__(/*! ./rules/UniqueInputFieldNames */ \"./node_modules/graphql/validation/rules/UniqueInputFieldNames.js\");\n\nvar _LoneSchemaDefinition = __webpack_require__(/*! ./rules/LoneSchemaDefinition */ \"./node_modules/graphql/validation/rules/LoneSchemaDefinition.js\");\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n// Spec Section: \"Executable Definitions\"\n// Spec Section: \"Operation Name Uniqueness\"\n// Spec Section: \"Lone Anonymous Operation\"\n// Spec Section: \"Subscriptions with Single Root Field\"\n// Spec Section: \"Fragment Spread Type Existence\"\n// Spec Section: \"Fragments on Composite Types\"\n// Spec Section: \"Variables are Input Types\"\n// Spec Section: \"Leaf Field Selections\"\n// Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n// Spec Section: \"Fragment Name Uniqueness\"\n// Spec Section: \"Fragment spread target defined\"\n// Spec Section: \"Fragments must be used\"\n// Spec Section: \"Fragment spread is possible\"\n// Spec Section: \"Fragments must not form cycles\"\n// Spec Section: \"Variable Uniqueness\"\n// Spec Section: \"All Variable Used Defined\"\n// Spec Section: \"All Variables Used\"\n// Spec Section: \"Directives Are Defined\"\n// Spec Section: \"Directives Are Unique Per Location\"\n// Spec Section: \"Argument Names\"\n// Spec Section: \"Argument Uniqueness\"\n// Spec Section: \"Value Type Correctness\"\n// Spec Section: \"Argument Optionality\"\n// Spec Section: \"All Variable Usages Are Allowed\"\n// Spec Section: \"Field Selection Merging\"\n// Spec Section: \"Input Object Field Uniqueness\"\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nvar specifiedRules = [_ExecutableDefinitions.ExecutableDefinitions, _UniqueOperationNames.UniqueOperationNames, _LoneAnonymousOperation.LoneAnonymousOperation, _SingleFieldSubscriptions.SingleFieldSubscriptions, _KnownTypeNames.KnownTypeNames, _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes, _VariablesAreInputTypes.VariablesAreInputTypes, _ScalarLeafs.ScalarLeafs, _FieldsOnCorrectType.FieldsOnCorrectType, _UniqueFragmentNames.UniqueFragmentNames, _KnownFragmentNames.KnownFragmentNames, _NoUnusedFragments.NoUnusedFragments, _PossibleFragmentSpreads.PossibleFragmentSpreads, _NoFragmentCycles.NoFragmentCycles, _UniqueVariableNames.UniqueVariableNames, _NoUndefinedVariables.NoUndefinedVariables, _NoUnusedVariables.NoUnusedVariables, _KnownDirectives.KnownDirectives, _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation, _KnownArgumentNames.KnownArgumentNames, _UniqueArgumentNames.UniqueArgumentNames, _ValuesOfCorrectType.ValuesOfCorrectType, _ProvidedRequiredArguments.ProvidedRequiredArguments, _VariablesInAllowedPosition.VariablesInAllowedPosition, _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged, _UniqueInputFieldNames.UniqueInputFieldNames];\nexports.specifiedRules = specifiedRules;\n// @internal\nvar specifiedSDLRules = [_LoneSchemaDefinition.LoneSchemaDefinition, _KnownDirectives.KnownDirectives, _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation, _KnownArgumentNames.KnownArgumentNamesOnDirectives, _UniqueArgumentNames.UniqueArgumentNames, _UniqueInputFieldNames.UniqueInputFieldNames, _ProvidedRequiredArguments.ProvidedRequiredArgumentsOnDirectives];\nexports.specifiedSDLRules = specifiedSDLRules;\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/specifiedRules.js?");

/***/ }),

/***/ "./node_modules/graphql/validation/validate.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphql/validation/validate.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = validate;\nexports.validateSDL = validateSDL;\nexports.assertValidSDL = assertValidSDL;\nexports.assertValidSDLExtension = assertValidSDLExtension;\n\nvar _invariant = _interopRequireDefault(__webpack_require__(/*! ../jsutils/invariant */ \"./node_modules/graphql/jsutils/invariant.js\"));\n\nvar _visitor = __webpack_require__(/*! ../language/visitor */ \"./node_modules/graphql/language/visitor.js\");\n\nvar _validate = __webpack_require__(/*! ../type/validate */ \"./node_modules/graphql/type/validate.js\");\n\nvar _TypeInfo = __webpack_require__(/*! ../utilities/TypeInfo */ \"./node_modules/graphql/utilities/TypeInfo.js\");\n\nvar _specifiedRules = __webpack_require__(/*! ./specifiedRules */ \"./node_modules/graphql/validation/specifiedRules.js\");\n\nvar _ValidationContext = __webpack_require__(/*! ./ValidationContext */ \"./node_modules/graphql/validation/ValidationContext.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n *  strict\n */\n\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\nfunction validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _TypeInfo.TypeInfo(schema);\n  !documentAST ? (0, _invariant.default)(0, 'Must provide document') : void 0; // If the schema used for validation is invalid, throw an error.\n\n  (0, _validate.assertValidSchema)(schema);\n  var context = new _ValidationContext.ValidationContext(schema, documentAST, typeInfo); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = (0, _visitor.visitInParallel)(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  (0, _visitor.visit)(documentAST, (0, _visitor.visitWithTypeInfo)(typeInfo, visitor));\n  return context.getErrors();\n} // @internal\n\n\nfunction validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules.specifiedSDLRules;\n  var context = new _ValidationContext.SDLValidationContext(documentAST, schemaToExtend);\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));\n  return context.getErrors();\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\n\nfunction assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\n\nfunction assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/graphql/validation/validate.js?");

/***/ }),

/***/ "./node_modules/ignore/ignore.js":
/*!***************************************!*\
  !*** ./node_modules/ignore/ignore.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nmodule.exports = function () {\n  return new IgnoreBase();\n};\n\n// A simple implementation of make-array\nfunction make_array(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\n\nvar REGEX_BLANK_LINE = /^\\s+$/;\nvar REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\\\\!/;\nvar REGEX_LEADING_EXCAPED_HASH = /^\\\\#/;\nvar SLASH = '/';\nvar KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')\n/* istanbul ignore next */\n: 'node-ignore';\n\nvar IgnoreBase = function () {\n  function IgnoreBase() {\n    _classCallCheck(this, IgnoreBase);\n\n    this._rules = [];\n    this[KEY_IGNORE] = true;\n    this._initCache();\n  }\n\n  _createClass(IgnoreBase, [{\n    key: '_initCache',\n    value: function _initCache() {\n      this._cache = {};\n    }\n\n    // @param {Array.<string>|string|Ignore} pattern\n\n  }, {\n    key: 'add',\n    value: function add(pattern) {\n      this._added = false;\n\n      if (typeof pattern === 'string') {\n        pattern = pattern.split(/\\r?\\n/g);\n      }\n\n      make_array(pattern).forEach(this._addPattern, this);\n\n      // Some rules have just added to the ignore,\n      // making the behavior changed.\n      if (this._added) {\n        this._initCache();\n      }\n\n      return this;\n    }\n\n    // legacy\n\n  }, {\n    key: 'addPattern',\n    value: function addPattern(pattern) {\n      return this.add(pattern);\n    }\n  }, {\n    key: '_addPattern',\n    value: function _addPattern(pattern) {\n      // #32\n      if (pattern && pattern[KEY_IGNORE]) {\n        this._rules = this._rules.concat(pattern._rules);\n        this._added = true;\n        return;\n      }\n\n      if (this._checkPattern(pattern)) {\n        var rule = this._createRule(pattern);\n        this._added = true;\n        this._rules.push(rule);\n      }\n    }\n  }, {\n    key: '_checkPattern',\n    value: function _checkPattern(pattern) {\n      // > A blank line matches no files, so it can serve as a separator for readability.\n      return pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)\n\n      // > A line starting with # serves as a comment.\n      && pattern.indexOf('#') !== 0;\n    }\n  }, {\n    key: 'filter',\n    value: function filter(paths) {\n      var _this = this;\n\n      return make_array(paths).filter(function (path) {\n        return _this._filter(path);\n      });\n    }\n  }, {\n    key: 'createFilter',\n    value: function createFilter() {\n      var _this2 = this;\n\n      return function (path) {\n        return _this2._filter(path);\n      };\n    }\n  }, {\n    key: 'ignores',\n    value: function ignores(path) {\n      return !this._filter(path);\n    }\n  }, {\n    key: '_createRule',\n    value: function _createRule(pattern) {\n      var origin = pattern;\n      var negative = false;\n\n      // > An optional prefix \"!\" which negates the pattern;\n      if (pattern.indexOf('!') === 0) {\n        negative = true;\n        pattern = pattern.substr(1);\n      }\n\n      pattern = pattern\n      // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n      .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')\n      // > Put a backslash (\"\\\") in front of the first hash for patterns that begin with a hash.\n      .replace(REGEX_LEADING_EXCAPED_HASH, '#');\n\n      var regex = make_regex(pattern, negative);\n\n      return {\n        origin: origin,\n        pattern: pattern,\n        negative: negative,\n        regex: regex\n      };\n    }\n\n    // @returns `Boolean` true if the `path` is NOT ignored\n\n  }, {\n    key: '_filter',\n    value: function _filter(path, slices) {\n      if (!path) {\n        return false;\n      }\n\n      if (path in this._cache) {\n        return this._cache[path];\n      }\n\n      if (!slices) {\n        // path/to/a.js\n        // ['path', 'to', 'a.js']\n        slices = path.split(SLASH);\n      }\n\n      slices.pop();\n\n      return this._cache[path] = slices.length\n      // > It is not possible to re-include a file if a parent directory of that file is excluded.\n      // If the path contains a parent directory, check the parent first\n      ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)\n\n      // Or only test the path\n      : this._test(path);\n    }\n\n    // @returns {Boolean} true if a file is NOT ignored\n\n  }, {\n    key: '_test',\n    value: function _test(path) {\n      // Explicitly define variable type by setting matched to `0`\n      var matched = 0;\n\n      this._rules.forEach(function (rule) {\n        // if matched = true, then we only test negative rules\n        // if matched = false, then we test non-negative rules\n        if (!(matched ^ rule.negative)) {\n          matched = rule.negative ^ rule.regex.test(path);\n        }\n      });\n\n      return !matched;\n    }\n  }]);\n\n  return IgnoreBase;\n}();\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\n\n\nvar DEFAULT_REPLACER_PREFIX = [\n\n// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[\n// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, function (match) {\n  return match.indexOf('\\\\') === 0 ? ' ' : '';\n}],\n\n// replace (\\ ) with ' '\n[/\\\\\\s/g, function () {\n  return ' ';\n}],\n\n// Escape metacharacters\n// which is written down by users but means special for regular expressions.\n\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\\\^$.|?*+()\\[{]/g, function (match) {\n  return '\\\\' + match;\n}],\n\n// leading slash\n[\n\n// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, function () {\n  return '^';\n}],\n\n// replace special metacharacter slash after the leading slash\n[/\\//g, function () {\n  return '\\\\/';\n}], [\n// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n// '**/foo' <-> 'foo'\nfunction () {\n  return '^(?:.*\\\\/)?';\n}]];\n\nvar DEFAULT_REPLACER_SUFFIX = [\n// starting\n[\n// there will be no leading '/' (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^\\^])/, function () {\n  return !/\\/(?!$)/.test(this)\n  // > If the pattern does not contain a slash /, Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash, git also treats it as a shell glob pattern\n  ? '(?:^|\\\\/)'\n\n  // > Otherwise, Git treats the pattern as a shell glob suitable for consumption by fnmatch(3)\n  : '^';\n}],\n\n// two globstars\n[\n// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n// Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n\n// Check if it is not the last `'/**'`\nfunction (match, index, str) {\n  return index + 6 < str.length\n\n  // case: /**/\n  // > A slash followed by two consecutive asterisks then a slash matches zero or more directories.\n  // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n  // '/**/'\n  ? '(?:\\\\/[^\\\\/]+)*'\n\n  // case: /**\n  // > A trailing `\"/**\"` matches everything inside.\n\n  // #21: everything inside but it should not include the current folder\n  : '\\\\/.+';\n}],\n\n// intermediate wildcards\n[\n// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule\n/(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n\n// '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\nfunction (match, p1) {\n  return p1 + '[^\\\\/]*';\n}],\n\n// trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, function (match, p1) {\n  return (p1\n  // '\\^':\n  // '/*' does not match ''\n  // '/*' does not match everything\n\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? p1 + '[^/]+'\n\n  // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*') + '(?=$|\\\\/$)';\n}], [\n// unescape\n/\\\\\\\\\\\\/g, function () {\n  return '\\\\';\n}]];\n\nvar POSITIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [\n\n// 'f'\n// matches\n// - /f(end)\n// - /f/\n// - (start)f(end)\n// - (start)f/\n// doesn't match\n// - oof\n// - foo\n// pseudo:\n// -> (^|/)f(/|$)\n\n// ending\n[\n// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*\\/])$/,\n\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nfunction (match) {\n  return match + '(?=$|\\\\/)';\n}]], DEFAULT_REPLACER_SUFFIX);\n\nvar NEGATIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [\n\n// #24, #38\n// The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)\n// A negative pattern without a trailing wildcard should not\n// re-include the things inside that directory.\n\n// eg:\n// ['node_modules/*', '!node_modules']\n// should ignore `node_modules/a.js`\n[/(?:[^*])$/, function (match) {\n  return match + '(?=$|\\\\/$)';\n}]], DEFAULT_REPLACER_SUFFIX);\n\n// A simple cache, because an ignore rule only has only one certain meaning\nvar cache = {};\n\n// @param {pattern}\nfunction make_regex(pattern, negative) {\n  var r = cache[pattern];\n  if (r) {\n    return r;\n  }\n\n  var replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;\n\n  var source = replacers.reduce(function (prev, current) {\n    return prev.replace(current[0], current[1].bind(pattern));\n  }, pattern);\n\n  return cache[pattern] = new RegExp(source, 'i');\n}\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n// Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n\n  var filter = IgnoreBase.prototype._filter;\n  var make_posix = function make_posix(str) {\n    return (/^\\\\\\\\\\?\\\\/.test(str) || /[^\\x00-\\x80]+/.test(str) ? str : str.replace(/\\\\/g, '/')\n    );\n  };\n\n  IgnoreBase.prototype._filter = function (path, slices) {\n    path = make_posix(path);\n    return filter.call(this, path, slices);\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/ignore/ignore.js?");

/***/ }),

/***/ "./node_modules/is-absolute/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-absolute/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isRelative = __webpack_require__(/*! is-relative */ \"./node_modules/is-relative/index.js\");\nvar isWindows = __webpack_require__(/*! is-windows */ \"is-windows\");\n\n/**\n * Expose `isAbsolute`\n */\n\nmodule.exports = isAbsolute;\n\n/**\n * Returns true if a file path is absolute.\n *\n * @param  {String} `fp`\n * @return {Boolean}\n */\n\nfunction isAbsolute(fp) {\n  if (typeof fp !== 'string') {\n    throw new TypeError('isAbsolute expects a string.');\n  }\n  return isWindows() ? isAbsolute.win32(fp) : isAbsolute.posix(fp);\n}\n\n/**\n * Test posix paths.\n */\n\nisAbsolute.posix = function posixPath(fp) {\n  return fp.charAt(0) === '/';\n};\n\n/**\n * Test windows paths.\n */\n\nisAbsolute.win32 = function win32(fp) {\n  if (/[a-z]/i.test(fp.charAt(0)) && fp.charAt(1) === ':' && fp.charAt(2) === '\\\\') {\n    return true;\n  }\n  // Microsoft Azure absolute filepath\n  if (fp.slice(0, 2) === '\\\\\\\\') {\n    return true;\n  }\n  return !isRelative(fp);\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-absolute/index.js?");

/***/ }),

/***/ "./node_modules/is-negated-glob/index.js":
/*!***********************************************!*\
  !*** ./node_modules/is-negated-glob/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  var glob = { negated: false, pattern: pattern, original: pattern };\n  if (pattern.charAt(0) === '!' && pattern.charAt(1) !== '(') {\n    glob.negated = true;\n    glob.pattern = pattern.slice(1);\n  }\n\n  return glob;\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-negated-glob/index.js?");

/***/ }),

/***/ "./node_modules/is-relative/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-relative/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isUncPath = __webpack_require__(/*! is-unc-path */ \"./node_modules/is-unc-path/index.js\");\n\nmodule.exports = function isRelative(filepath) {\n  if (typeof filepath !== 'string') {\n    throw new TypeError('expected filepath to be a string');\n  }\n\n  // Windows UNC paths are always considered to be absolute.\n  return !isUncPath(filepath) && !/^([a-z]:)?[\\\\\\/]/i.test(filepath);\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-relative/index.js?");

/***/ }),

/***/ "./node_modules/is-unc-path/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-unc-path/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar regex = __webpack_require__(/*! unc-path-regex */ \"./node_modules/unc-path-regex/index.js\")();\n\nmodule.exports = function(filepath) {\n  if (typeof filepath !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  return regex.test(filepath);\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-unc-path/index.js?");

/***/ }),

/***/ "./node_modules/iterall/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/iterall/index.mjs ***!
  \****************************************/
/*! exports provided: $$iterator, isIterable, isArrayLike, isCollection, getIterator, getIteratorMethod, createIterator, forEach, $$asyncIterator, isAsyncIterable, getAsyncIterator, getAsyncIteratorMethod, createAsyncIterator, forAwaitEach */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$$iterator\", function() { return $$iterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIterable\", function() { return isIterable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArrayLike\", function() { return isArrayLike; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isCollection\", function() { return isCollection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIterator\", function() { return getIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIteratorMethod\", function() { return getIteratorMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createIterator\", function() { return createIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"$$asyncIterator\", function() { return $$asyncIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAsyncIterable\", function() { return isAsyncIterable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAsyncIterator\", function() { return getAsyncIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAsyncIteratorMethod\", function() { return getAsyncIteratorMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createAsyncIterator\", function() { return createAsyncIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forAwaitEach\", function() { return forAwaitEach; });\n/**\n * Copyright (c) 2016, Lee Byron\n * All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @ignore\n */\n\n/**\n * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)\n * is a *protocol* which describes a standard way to produce a sequence of\n * values, typically the values of the Iterable represented by this Iterator.\n *\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)\n * it can be utilized by any version of JavaScript.\n *\n * @external Iterator\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator|MDN Iteration protocols}\n */\n\n/**\n * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n * is a *protocol* which when implemented allows a JavaScript object to define\n * their iteration behavior, such as what values are looped over in a\n * [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)\n * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)\n * implement the Iterable protocol, including `Array` and `Map`.\n *\n * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)\n * it can be utilized by any version of JavaScript.\n *\n * @external Iterable\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable|MDN Iteration protocols}\n */\n\n// In ES2015 environments, Symbol exists\nvar SYMBOL /*: any */ = typeof Symbol === 'function' ? Symbol : void 0\n\n// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\nvar SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator\n\n/**\n * A property name to be used as the name of an Iterable's method responsible\n * for producing an Iterator, referred to as `@@iterator`. Typically represents\n * the value `Symbol.iterator` but falls back to the string `\"@@iterator\"` when\n * `Symbol.iterator` is not defined.\n *\n * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,\n * but do not use it for accessing existing Iterables, instead use\n * {@link getIterator} or {@link isIterable}.\n *\n * @example\n *\n * var $$iterator = require('iterall').$$iterator\n *\n * function Counter (to) {\n *   this.to = to\n * }\n *\n * Counter.prototype[$$iterator] = function () {\n *   return {\n *     to: this.to,\n *     num: 0,\n *     next () {\n *       if (this.num >= this.to) {\n *         return { value: undefined, done: true }\n *       }\n *       return { value: this.num++, done: false }\n *     }\n *   }\n * }\n *\n * var counter = new Counter(3)\n * for (var number of counter) {\n *   console.log(number) // 0 ... 1 ... 2\n * }\n *\n * @type {Symbol|string}\n */\n/*:: declare export var $$iterator: '@@iterator'; */\nvar $$iterator = SYMBOL_ITERATOR || '@@iterator'\n\n/**\n * Returns true if the provided object implements the Iterator protocol via\n * either implementing a `Symbol.iterator` or `\"@@iterator\"` method.\n *\n * @example\n *\n * var isIterable = require('iterall').isIterable\n * isIterable([ 1, 2, 3 ]) // true\n * isIterable('ABC') // true\n * isIterable({ length: 1, 0: 'Alpha' }) // false\n * isIterable({ key: 'value' }) // false\n * isIterable(new Map()) // true\n *\n * @param obj\n *   A value which might implement the Iterable protocol.\n * @return {boolean} true if Iterable.\n */\n/*:: declare export function isIterable(obj: any): boolean; */\nfunction isIterable(obj) {\n  return !!getIteratorMethod(obj)\n}\n\n/**\n * Returns true if the provided object implements the Array-like protocol via\n * defining a positive-integer `length` property.\n *\n * @example\n *\n * var isArrayLike = require('iterall').isArrayLike\n * isArrayLike([ 1, 2, 3 ]) // true\n * isArrayLike('ABC') // true\n * isArrayLike({ length: 1, 0: 'Alpha' }) // true\n * isArrayLike({ key: 'value' }) // false\n * isArrayLike(new Map()) // false\n *\n * @param obj\n *   A value which might implement the Array-like protocol.\n * @return {boolean} true if Array-like.\n */\n/*:: declare export function isArrayLike(obj: any): boolean; */\nfunction isArrayLike(obj) {\n  var length = obj != null && obj.length\n  return typeof length === 'number' && length >= 0 && length % 1 === 0\n}\n\n/**\n * Returns true if the provided object is an Object (i.e. not a string literal)\n * and is either Iterable or Array-like.\n *\n * This may be used in place of [Array.isArray()][isArray] to determine if an\n * object should be iterated-over. It always excludes string literals and\n * includes Arrays (regardless of if it is Iterable). It also includes other\n * Array-like objects such as NodeList, TypedArray, and Buffer.\n *\n * @example\n *\n * var isCollection = require('iterall').isCollection\n * isCollection([ 1, 2, 3 ]) // true\n * isCollection('ABC') // false\n * isCollection({ length: 1, 0: 'Alpha' }) // true\n * isCollection({ key: 'value' }) // false\n * isCollection(new Map()) // true\n *\n * @example\n *\n * var forEach = require('iterall').forEach\n * if (isCollection(obj)) {\n *   forEach(obj, function (value) {\n *     console.log(value)\n *   })\n * }\n *\n * @param obj\n *   An Object value which might implement the Iterable or Array-like protocols.\n * @return {boolean} true if Iterable or Array-like Object.\n */\n/*:: declare export function isCollection(obj: any): boolean; */\nfunction isCollection(obj) {\n  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))\n}\n\n/**\n * If the provided object implements the Iterator protocol, its Iterator object\n * is returned. Otherwise returns undefined.\n *\n * @example\n *\n * var getIterator = require('iterall').getIterator\n * var iterator = getIterator([ 1, 2, 3 ])\n * iterator.next() // { value: 1, done: false }\n * iterator.next() // { value: 2, done: false }\n * iterator.next() // { value: 3, done: false }\n * iterator.next() // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>} iterable\n *   An Iterable object which is the source of an Iterator.\n * @return {Iterator<T>} new Iterator instance.\n */\n/*:: declare export var getIterator:\n  & (<+TValue>(iterable: Iterable<TValue>) => Iterator<TValue>)\n  & ((iterable: mixed) => void | Iterator<mixed>); */\nfunction getIterator(iterable) {\n  var method = getIteratorMethod(iterable)\n  if (method) {\n    return method.call(iterable)\n  }\n}\n\n/**\n * If the provided object implements the Iterator protocol, the method\n * responsible for producing its Iterator object is returned.\n *\n * This is used in rare cases for performance tuning. This method must be called\n * with obj as the contextual this-argument.\n *\n * @example\n *\n * var getIteratorMethod = require('iterall').getIteratorMethod\n * var myArray = [ 1, 2, 3 ]\n * var method = getIteratorMethod(myArray)\n * if (method) {\n *   var iterator = method.call(myArray)\n * }\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>} iterable\n *   An Iterable object which defines an `@@iterator` method.\n * @return {function(): Iterator<T>} `@@iterator` method.\n */\n/*:: declare export var getIteratorMethod:\n  & (<+TValue>(iterable: Iterable<TValue>) => (() => Iterator<TValue>))\n  & ((iterable: mixed) => (void | (() => Iterator<mixed>))); */\nfunction getIteratorMethod(iterable) {\n  if (iterable != null) {\n    var method =\n      (SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR]) || iterable['@@iterator']\n    if (typeof method === 'function') {\n      return method\n    }\n  }\n}\n\n/**\n * Similar to {@link getIterator}, this method returns a new Iterator given an\n * Iterable. However it will also create an Iterator for a non-Iterable\n * Array-like collection, such as Array in a non-ES2015 environment.\n *\n * `createIterator` is complimentary to `forEach`, but allows a \"pull\"-based\n * iteration as opposed to `forEach`'s \"push\"-based iteration.\n *\n * `createIterator` produces an Iterator for Array-likes with the same behavior\n * as ArrayIteratorPrototype described in the ECMAScript specification, and\n * does *not* skip over \"holes\".\n *\n * @example\n *\n * var createIterator = require('iterall').createIterator\n *\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\n * var iterator = createIterator(myArraylike)\n * iterator.next() // { value: 'Alpha', done: false }\n * iterator.next() // { value: 'Bravo', done: false }\n * iterator.next() // { value: 'Charlie', done: false }\n * iterator.next() // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>|{ length: number }} collection\n *   An Iterable or Array-like object to produce an Iterator.\n * @return {Iterator<T>} new Iterator instance.\n */\n/*:: declare export var createIterator:\n  & (<+TValue>(collection: Iterable<TValue>) => Iterator<TValue>)\n  & ((collection: {length: number}) => Iterator<mixed>)\n  & ((collection: mixed) => (void | Iterator<mixed>)); */\nfunction createIterator(collection) {\n  if (collection != null) {\n    var iterator = getIterator(collection)\n    if (iterator) {\n      return iterator\n    }\n    if (isArrayLike(collection)) {\n      return new ArrayLikeIterator(collection)\n    }\n  }\n}\n\n// When the object provided to `createIterator` is not Iterable but is\n// Array-like, this simple Iterator is created.\nfunction ArrayLikeIterator(obj) {\n  this._o = obj\n  this._i = 0\n}\n\n// Note: all Iterators are themselves Iterable.\nArrayLikeIterator.prototype[$$iterator] = function() {\n  return this\n}\n\n// A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\nArrayLikeIterator.prototype.next = function() {\n  if (this._o === void 0 || this._i >= this._o.length) {\n    this._o = void 0\n    return { value: void 0, done: true }\n  }\n  return { value: this._o[this._i++], done: false }\n}\n\n/**\n * Given an object which either implements the Iterable protocol or is\n * Array-like, iterate over it, calling the `callback` at each iteration.\n *\n * Use `forEach` where you would expect to use a `for ... of` loop in ES6.\n * However `forEach` adheres to the behavior of [Array#forEach][] described in\n * the ECMAScript specification, skipping over \"holes\" in Array-likes. It will\n * also delegate to a `forEach` method on `collection` if one is defined,\n * ensuring native performance for `Arrays`.\n *\n * Similar to [Array#forEach][], the `callback` function accepts three\n * arguments, and is provided with `thisArg` as the calling context.\n *\n * Note: providing an infinite Iterator to forEach will produce an error.\n *\n * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n *\n * @example\n *\n * var forEach = require('iterall').forEach\n *\n * forEach(myIterable, function (value, index, iterable) {\n *   console.log(value, index, iterable === myIterable)\n * })\n *\n * @example\n *\n * // ES6:\n * for (let value of myIterable) {\n *   console.log(value)\n * }\n *\n * // Any JavaScript environment:\n * forEach(myIterable, function (value) {\n *   console.log(value)\n * })\n *\n * @template T the type of each iterated value\n * @param {Iterable<T>|{ length: number }} collection\n *   The Iterable or array to iterate over.\n * @param {function(T, number, object)} callback\n *   Function to execute for each iteration, taking up to three arguments\n * @param [thisArg]\n *   Optional. Value to use as `this` when executing `callback`.\n */\n/*:: declare export var forEach:\n  & (<+TValue, TCollection: Iterable<TValue>>(\n      collection: TCollection,\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => void)\n  & (<TCollection: {length: number}>(\n      collection: TCollection,\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => void); */\nfunction forEach(collection, callback, thisArg) {\n  if (collection != null) {\n    if (typeof collection.forEach === 'function') {\n      return collection.forEach(callback, thisArg)\n    }\n    var i = 0\n    var iterator = getIterator(collection)\n    if (iterator) {\n      var step\n      while (!(step = iterator.next()).done) {\n        callback.call(thisArg, step.value, i++, collection)\n        // Infinite Iterators could cause forEach to run forever.\n        // After a very large number of iterations, produce an error.\n        /* istanbul ignore if */\n        if (i > 9999999) {\n          throw new TypeError('Near-infinite iteration.')\n        }\n      }\n    } else if (isArrayLike(collection)) {\n      for (; i < collection.length; i++) {\n        if (collection.hasOwnProperty(i)) {\n          callback.call(thisArg, collection[i], i, collection)\n        }\n      }\n    }\n  }\n}\n\n/////////////////////////////////////////////////////\n//                                                 //\n//                 ASYNC ITERATORS                 //\n//                                                 //\n/////////////////////////////////////////////////////\n\n/**\n * [AsyncIterable](https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface)\n * is a *protocol* which when implemented allows a JavaScript object to define\n * an asynchronous iteration behavior, such as what values are looped over in\n * a [`for-await-of`](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements)\n * loop or `iterall`'s {@link forAwaitEach} function.\n *\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\n * it can be utilized by any version of JavaScript.\n *\n * @external AsyncIterable\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface|Async Iteration Proposal}\n * @template T The type of each iterated value\n * @property {function (): AsyncIterator<T>} Symbol.asyncIterator\n *   A method which produces an AsyncIterator for this AsyncIterable.\n */\n\n/**\n * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface)\n * is a *protocol* which describes a standard way to produce and consume an\n * asynchronous sequence of values, typically the values of the\n * {@link AsyncIterable} represented by this {@link AsyncIterator}.\n *\n * AsyncIterator is similar to Observable or Stream. Like an {@link Iterator} it\n * also as a `next()` method, however instead of an IteratorResult,\n * calling this method returns a {@link Promise} for a IteratorResult.\n *\n * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)\n * it can be utilized by any version of JavaScript.\n *\n * @external AsyncIterator\n * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface|Async Iteration Proposal}\n */\n\n// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator\nvar SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator\n\n/**\n * A property name to be used as the name of an AsyncIterable's method\n * responsible for producing an Iterator, referred to as `@@asyncIterator`.\n * Typically represents the value `Symbol.asyncIterator` but falls back to the\n * string `\"@@asyncIterator\"` when `Symbol.asyncIterator` is not defined.\n *\n * Use `$$asyncIterator` for defining new AsyncIterables instead of\n * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,\n * instead use {@link getAsyncIterator} or {@link isAsyncIterable}.\n *\n * @example\n *\n * var $$asyncIterator = require('iterall').$$asyncIterator\n *\n * function Chirper (to) {\n *   this.to = to\n * }\n *\n * Chirper.prototype[$$asyncIterator] = function () {\n *   return {\n *     to: this.to,\n *     num: 0,\n *     next () {\n *       return new Promise(resolve => {\n *         if (this.num >= this.to) {\n *           resolve({ value: undefined, done: true })\n *         } else {\n *           setTimeout(() => {\n *             resolve({ value: this.num++, done: false })\n *           }, 1000)\n *         }\n *       })\n *     }\n *   }\n * }\n *\n * var chirper = new Chirper(3)\n * for await (var number of chirper) {\n *   console.log(number) // 0 ...wait... 1 ...wait... 2\n * }\n *\n * @type {Symbol|string}\n */\n/*:: declare export var $$asyncIterator: '@@asyncIterator'; */\nvar $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator'\n\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\n *\n * @example\n *\n * var isAsyncIterable = require('iterall').isAsyncIterable\n * isAsyncIterable(myStream) // true\n * isAsyncIterable('ABC') // false\n *\n * @param obj\n *   A value which might implement the AsyncIterable protocol.\n * @return {boolean} true if AsyncIterable.\n */\n/*:: declare export function isAsyncIterable(obj: any): boolean; */\nfunction isAsyncIterable(obj) {\n  return !!getAsyncIteratorMethod(obj)\n}\n\n/**\n * If the provided object implements the AsyncIterator protocol, its\n * AsyncIterator object is returned. Otherwise returns undefined.\n *\n * @example\n *\n * var getAsyncIterator = require('iterall').getAsyncIterator\n * var asyncIterator = getAsyncIterator(myStream)\n * asyncIterator.next().then(console.log) // { value: 1, done: false }\n * asyncIterator.next().then(console.log) // { value: 2, done: false }\n * asyncIterator.next().then(console.log) // { value: 3, done: false }\n * asyncIterator.next().then(console.log) // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>} asyncIterable\n *   An AsyncIterable object which is the source of an AsyncIterator.\n * @return {AsyncIterator<T>} new AsyncIterator instance.\n */\n/*:: declare export var getAsyncIterator:\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => AsyncIterator<TValue>)\n  & ((asyncIterable: mixed) => (void | AsyncIterator<mixed>)); */\nfunction getAsyncIterator(asyncIterable) {\n  var method = getAsyncIteratorMethod(asyncIterable)\n  if (method) {\n    return method.call(asyncIterable)\n  }\n}\n\n/**\n * If the provided object implements the AsyncIterator protocol, the method\n * responsible for producing its AsyncIterator object is returned.\n *\n * This is used in rare cases for performance tuning. This method must be called\n * with obj as the contextual this-argument.\n *\n * @example\n *\n * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod\n * var method = getAsyncIteratorMethod(myStream)\n * if (method) {\n *   var asyncIterator = method.call(myStream)\n * }\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>} asyncIterable\n *   An AsyncIterable object which defines an `@@asyncIterator` method.\n * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.\n */\n/*:: declare export var getAsyncIteratorMethod:\n  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => (() => AsyncIterator<TValue>))\n  & ((asyncIterable: mixed) => (void | (() => AsyncIterator<mixed>))); */\nfunction getAsyncIteratorMethod(asyncIterable) {\n  if (asyncIterable != null) {\n    var method =\n      (SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR]) ||\n      asyncIterable['@@asyncIterator']\n    if (typeof method === 'function') {\n      return method\n    }\n  }\n}\n\n/**\n * Similar to {@link getAsyncIterator}, this method returns a new AsyncIterator\n * given an AsyncIterable. However it will also create an AsyncIterator for a\n * non-async Iterable as well as non-Iterable Array-like collection, such as\n * Array in a pre-ES2015 environment.\n *\n * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a\n * buffering \"pull\"-based iteration as opposed to `forAwaitEach`'s\n * \"push\"-based iteration.\n *\n * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as\n * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).\n *\n * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.\n * > While `Promise` has been available in modern browsers for a number of\n * > years, legacy browsers (like IE 11) may require a polyfill.\n *\n * @example\n *\n * var createAsyncIterator = require('iterall').createAsyncIterator\n *\n * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }\n * var iterator = createAsyncIterator(myArraylike)\n * iterator.next().then(console.log) // { value: 'Alpha', done: false }\n * iterator.next().then(console.log) // { value: 'Bravo', done: false }\n * iterator.next().then(console.log) // { value: 'Charlie', done: false }\n * iterator.next().then(console.log) // { value: undefined, done: true }\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source\n *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.\n * @return {AsyncIterator<T>} new AsyncIterator instance.\n */\n/*:: declare export var createAsyncIterator:\n  & (<+TValue>(\n      collection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>\n    ) => AsyncIterator<TValue>)\n  & ((collection: {length: number}) => AsyncIterator<mixed>)\n  & ((collection: mixed) => (void | AsyncIterator<mixed>)); */\nfunction createAsyncIterator(source) {\n  if (source != null) {\n    var asyncIterator = getAsyncIterator(source)\n    if (asyncIterator) {\n      return asyncIterator\n    }\n    var iterator = createIterator(source)\n    if (iterator) {\n      return new AsyncFromSyncIterator(iterator)\n    }\n  }\n}\n\n// When the object provided to `createAsyncIterator` is not AsyncIterable but is\n// sync Iterable, this simple wrapper is created.\nfunction AsyncFromSyncIterator(iterator) {\n  this._i = iterator\n}\n\n// Note: all AsyncIterators are themselves AsyncIterable.\nAsyncFromSyncIterator.prototype[$$asyncIterator] = function() {\n  return this\n}\n\n// A simple state-machine determines the IteratorResult returned, yielding\n// each value in the Array-like object in order of their indicies.\nAsyncFromSyncIterator.prototype.next = function() {\n  var step = this._i.next()\n  return Promise.resolve(step.value).then(function(value) {\n    return { value: value, done: step.done }\n  })\n}\n\n/**\n * Given an object which either implements the AsyncIterable protocol or is\n * Array-like, iterate over it, calling the `callback` at each iteration.\n *\n * Use `forAwaitEach` where you would expect to use a [for-await-of](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements) loop.\n *\n * Similar to [Array#forEach][], the `callback` function accepts three\n * arguments, and is provided with `thisArg` as the calling context.\n *\n * > Note: Using `forAwaitEach` requires the existence of `Promise`.\n * > While `Promise` has been available in modern browsers for a number of\n * > years, legacy browsers (like IE 11) may require a polyfill.\n *\n * @example\n *\n * var forAwaitEach = require('iterall').forAwaitEach\n *\n * forAwaitEach(myIterable, function (value, index, iterable) {\n *   console.log(value, index, iterable === myIterable)\n * })\n *\n * @example\n *\n * // ES2017:\n * for await (let value of myAsyncIterable) {\n *   console.log(await doSomethingAsync(value))\n * }\n * console.log('done')\n *\n * // Any JavaScript environment:\n * forAwaitEach(myAsyncIterable, function (value) {\n *   return doSomethingAsync(value).then(console.log)\n * }).then(function () {\n *   console.log('done')\n * })\n *\n * @template T the type of each iterated value\n * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source\n *   The AsyncIterable or array to iterate over.\n * @param {function(T, number, object)} callback\n *   Function to execute for each iteration, taking up to three arguments\n * @param [thisArg]\n *   Optional. Value to use as `this` when executing `callback`.\n */\n/*:: declare export var forAwaitEach:\n  & (<+TValue, TCollection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>>(\n      collection: TCollection,\n      callbackFn: (value: TValue, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => Promise<void>)\n  & (<TCollection: { length: number }>(\n      collection: TCollection,\n      callbackFn: (value: mixed, index: number, collection: TCollection) => any,\n      thisArg?: any\n    ) => Promise<void>); */\nfunction forAwaitEach(source, callback, thisArg) {\n  var asyncIterator = createAsyncIterator(source)\n  if (asyncIterator) {\n    var i = 0\n    return new Promise(function(resolve, reject) {\n      function next() {\n        asyncIterator\n          .next()\n          .then(function(step) {\n            if (!step.done) {\n              Promise.resolve(callback.call(thisArg, step.value, i++, source))\n                .then(next)\n                .catch(reject)\n            } else {\n              resolve()\n            }\n            // Explicitly return null, silencing bluebird-style warnings.\n            return null\n          })\n          .catch(reject)\n        // Explicitly return null, silencing bluebird-style warnings.\n        return null\n      }\n      next()\n    })\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/iterall/index.mjs?");

/***/ }),

/***/ "./node_modules/merge-graphql-schemas/dist sync recursive":
/*!******************************************************!*\
  !*** ./node_modules/merge-graphql-schemas/dist sync ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/merge-graphql-schemas/dist sync recursive\";\n\n//# sourceURL=webpack:///./node_modules/merge-graphql-schemas/dist_sync?");

/***/ }),

/***/ "./node_modules/merge-graphql-schemas/dist/index.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/merge-graphql-schemas/dist/index.esm.js ***!
  \**************************************************************/
/*! exports provided: mergeResolvers, mergeTypes, fileLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeResolvers\", function() { return mergeResolvers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeTypes\", function() { return mergeTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fileLoader\", function() { return fileLoader; });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! assert */ \"assert\");\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(assert__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! graphql/language/visitor */ \"./node_modules/graphql/language/visitor.js\");\n/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\n/* harmony import */ var graphql_utilities_buildASTSchema__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! graphql/utilities/buildASTSchema */ \"./node_modules/graphql/utilities/buildASTSchema.js\");\n/* harmony import */ var graphql_utilities_buildASTSchema__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(graphql_utilities_buildASTSchema__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar _global = createCommonjsModule(function (module) {\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n});\n\nvar _core = createCommonjsModule(function (module) {\nvar core = module.exports = { version: '2.5.3' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n});\nvar _core_1 = _core.version;\n\nvar _isObject = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\nvar _anObject = function (it) {\n  if (!_isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\nvar _fails = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n// Thank's IE8 for his funny defineProperty\nvar _descriptors = !_fails(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\nvar document = _global.document;\n// typeof document.createElement is 'object' in old IE\nvar is = _isObject(document) && _isObject(document.createElement);\nvar _domCreate = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\nvar _ie8DomDefine = !_descriptors && !_fails(function () {\n  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive = function (it, S) {\n  if (!_isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar dP = Object.defineProperty;\n\nvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  _anObject(O);\n  P = _toPrimitive(P, true);\n  _anObject(Attributes);\n  if (_ie8DomDefine) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar _objectDp = {\n\tf: f\n};\n\nvar _propertyDesc = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar _hide = _descriptors ? function (object, key, value) {\n  return _objectDp.f(object, key, _propertyDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar hasOwnProperty = {}.hasOwnProperty;\nvar _has = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\nvar id = 0;\nvar px = Math.random();\nvar _uid = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\nvar _redefine = createCommonjsModule(function (module) {\nvar SRC = _uid('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\n_core.inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) _has(val, 'name') || _hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === _global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    _hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    _hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n});\n\nvar _aFunction = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n// optional / simple context binding\n\nvar _ctx = function (fn, that, length) {\n  _aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n    // extend global\n    if (target) _redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) _hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\n_global.core = _core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nvar _export = $export;\n\nvar toString = {}.toString;\n\nvar _cof = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\n// eslint-disable-next-line no-prototype-builtins\nvar _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return _cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n// 7.2.1 RequireObjectCoercible(argument)\nvar _defined = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\n\n\nvar _toIobject = function (it) {\n  return _iobject(_defined(it));\n};\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nvar _toInteger = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n// 7.1.15 ToLength\n\nvar min = Math.min;\nvar _toLength = function (it) {\n  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\nvar max = Math.max;\nvar min$1 = Math.min;\nvar _toAbsoluteIndex = function (index, length) {\n  index = _toInteger(index);\n  return index < 0 ? max(index + length, 0) : min$1(index, length);\n};\n\n// false -> Array#indexOf\n// true  -> Array#includes\n\n\n\nvar _arrayIncludes = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = _toIobject($this);\n    var length = _toLength(O.length);\n    var index = _toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar SHARED = '__core-js_shared__';\nvar store = _global[SHARED] || (_global[SHARED] = {});\nvar _shared = function (key) {\n  return store[key] || (store[key] = {});\n};\n\nvar shared = _shared('keys');\n\nvar _sharedKey = function (key) {\n  return shared[key] || (shared[key] = _uid(key));\n};\n\nvar arrayIndexOf = _arrayIncludes(false);\nvar IE_PROTO = _sharedKey('IE_PROTO');\n\nvar _objectKeysInternal = function (object, names) {\n  var O = _toIobject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (_has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n// IE 8- don't enum bug keys\nvar _enumBugKeys = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\n\nvar _objectKeys = Object.keys || function keys(O) {\n  return _objectKeysInternal(O, _enumBugKeys);\n};\n\nvar f$1 = {}.propertyIsEnumerable;\n\nvar _objectPie = {\n\tf: f$1\n};\n\nvar isEnum = _objectPie.f;\nvar _objectToArray = function (isEntries) {\n  return function (it) {\n    var O = _toIobject(it);\n    var keys = _objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n\n// https://github.com/tc39/proposal-object-values-entries\n\nvar $values = _objectToArray(false);\n\n_export(_export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n\nvar _wks = createCommonjsModule(function (module) {\nvar store = _shared('wks');\n\nvar Symbol = _global.Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n});\n\n// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = _wks('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});\nvar _addToUnscopables = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n// https://github.com/tc39/Array.prototype.includes\n\nvar $includes = _arrayIncludes(true);\n\n_export(_export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n_addToUnscopables('includes');\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar chars = { '{': '}', '(': ')', '[': ']'};\n\nvar isGlob = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvar isWindows = process.platform === 'win32';\n\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = path__WEBPACK_IMPORTED_MODULE_0___default.a.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nvar realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs__WEBPACK_IMPORTED_MODULE_1___default.a.statSync(base);\n        linkTarget = fs__WEBPACK_IMPORTED_MODULE_1___default.a.readlinkSync(base);\n      }\n      resolvedLink = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nvar realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs__WEBPACK_IMPORTED_MODULE_1___default.a.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs__WEBPACK_IMPORTED_MODULE_1___default.a.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\nvar old = {\n\trealpathSync: realpathSync,\n\trealpath: realpath\n};\n\nvar fs_realpath = realpath$1;\nrealpath$1.realpath = realpath$1;\nrealpath$1.sync = realpathSync$1;\nrealpath$1.realpathSync = realpathSync$1;\nrealpath$1.monkeypatch = monkeypatch;\nrealpath$1.unmonkeypatch = unmonkeypatch;\n\n\nvar origRealpath = fs__WEBPACK_IMPORTED_MODULE_1___default.a.realpath;\nvar origRealpathSync = fs__WEBPACK_IMPORTED_MODULE_1___default.a.realpathSync;\n\nvar version = process.version;\nvar ok = /^v[0-5]\\./.test(version);\n\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath$1 (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache;\n    cache = null;\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb);\n    } else {\n      cb(er, result);\n    }\n  });\n}\n\nfunction realpathSync$1 (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs__WEBPACK_IMPORTED_MODULE_1___default.a.realpath = realpath$1;\n  fs__WEBPACK_IMPORTED_MODULE_1___default.a.realpathSync = realpathSync$1;\n}\n\nfunction unmonkeypatch () {\n  fs__WEBPACK_IMPORTED_MODULE_1___default.a.realpath = origRealpath;\n  fs__WEBPACK_IMPORTED_MODULE_1___default.a.realpathSync = origRealpathSync;\n}\n\nvar concatMap = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar balancedMatch = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\nvar braceExpansion = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balancedMatch('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balancedMatch('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length);\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\nvar minimatch_1 = minimatch;\nminimatch.Minimatch = Minimatch;\n\nvar path$1 = { sep: '/' };\ntry {\n  path$1 = path__WEBPACK_IMPORTED_MODULE_0___default.a;\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\n\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n};\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]';\n\n// * => any number of characters\nvar star = qmark + '*?';\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?';\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?';\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!');\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true;\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/;\n\nminimatch.filter = filter;\nfunction filter (pattern, options) {\n  options = options || {};\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {};\n  b = b || {};\n  var t = {};\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k];\n  });\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k];\n  });\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch;\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  };\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  };\n\n  return m\n};\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n};\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {};\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {};\n  pattern = pattern.trim();\n\n  // windows support: need to use /, not \\\n  if (path$1.sep !== '/') {\n    pattern = pattern.split(path$1.sep).join('/');\n  }\n\n  this.options = options;\n  this.set = [];\n  this.pattern = pattern;\n  this.regexp = null;\n  this.negate = false;\n  this.comment = false;\n  this.empty = false;\n\n  // make the set of regexps etc.\n  this.make();\n}\n\nMinimatch.prototype.debug = function () {};\n\nMinimatch.prototype.make = make;\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern;\n  var options = this.options;\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true;\n    return\n  }\n  if (!pattern) {\n    this.empty = true;\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate();\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand();\n\n  if (options.debug) this.debug = console.error;\n\n  this.debug(this.pattern, set);\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  });\n\n  this.debug(this.pattern, set);\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this);\n\n  this.debug(this.pattern, set);\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  });\n\n  this.debug(this.pattern, set);\n\n  this.set = set;\n}\n\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate () {\n  var pattern = this.pattern;\n  var negate = false;\n  var options = this.options;\n  var negateOffset = 0;\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate;\n    negateOffset++;\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset);\n  this.negate = negate;\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n};\n\nMinimatch.prototype.braceExpand = braceExpand;\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options;\n    } else {\n      options = {};\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern;\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return braceExpansion(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse$1;\nvar SUBPARSE = {};\nfunction parse$1 (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options;\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = '';\n  var hasMagic = !!options.nocase;\n  var escaping = false;\n  // ? => one single character\n  var patternListStack = [];\n  var negativeLists = [];\n  var stateChar;\n  var inClass = false;\n  var reClassStart = -1;\n  var classStart = -1;\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)';\n  var self = this;\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star;\n          hasMagic = true;\n        break\n        case '?':\n          re += qmark;\n          hasMagic = true;\n        break\n        default:\n          re += '\\\\' + stateChar;\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re);\n      stateChar = false;\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c);\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c;\n      escaping = false;\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar();\n        escaping = true;\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c);\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class');\n          if (c === '!' && i === classStart + 1) c = '^';\n          re += c;\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar);\n        clearStateChar();\n        stateChar = c;\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar();\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '(';\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\(';\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        });\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n        this.debug('plType %j %j', stateChar, re);\n        stateChar = false;\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)';\n          continue\n        }\n\n        clearStateChar();\n        hasMagic = true;\n        var pl = patternListStack.pop();\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close;\n        if (pl.type === '!') {\n          negativeLists.push(pl);\n        }\n        pl.reEnd = re.length;\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|';\n          escaping = false;\n          continue\n        }\n\n        clearStateChar();\n        re += '|';\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar();\n\n        if (inClass) {\n          re += '\\\\' + c;\n          continue\n        }\n\n        inClass = true;\n        classStart = i;\n        reClassStart = re.length;\n        re += c;\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c;\n          escaping = false;\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i);\n          try {\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE);\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n            hasMagic = hasMagic || sp[1];\n            inClass = false;\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true;\n        inClass = false;\n        re += c;\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar();\n\n        if (escaping) {\n          // no need\n          escaping = false;\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\';\n        }\n\n        re += c;\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1);\n    sp = this.parse(cs, SUBPARSE);\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n    hasMagic = hasMagic || sp[1];\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length);\n    this.debug('setting tail', re, pl);\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\';\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    });\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type;\n\n    hasMagic = true;\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar();\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\';\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false;\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true;\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n];\n\n    var nlBefore = re.slice(0, nl.reStart);\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n    var nlAfter = re.slice(nl.reEnd);\n\n    nlLast += nlAfter;\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1;\n    var cleanAfter = nlAfter;\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n    }\n    nlAfter = cleanAfter;\n\n    var dollar = '';\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$';\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    re = newRe;\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re;\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re;\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : '';\n  try {\n    var regExp = new RegExp('^' + re + '$', flags);\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern;\n  regExp._src = re;\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n};\n\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set;\n\n  if (!set.length) {\n    this.regexp = false;\n    return this.regexp\n  }\n  var options = this.options;\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot;\n  var flags = options.nocase ? 'i' : '';\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|');\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$';\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$';\n\n  try {\n    this.regexp = new RegExp(re, flags);\n  } catch (ex) {\n    this.regexp = false;\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {};\n  var mm = new Minimatch(pattern, options);\n  list = list.filter(function (f) {\n    return mm.match(f)\n  });\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list\n};\n\nMinimatch.prototype.match = match;\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern);\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options;\n\n  // windows: need to use /, not \\\n  if (path$1.sep !== '/') {\n    f = f.split(path$1.sep).join('/');\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit);\n  this.debug(this.pattern, 'split', f);\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set;\n  this.debug(this.pattern, 'set', set);\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename;\n  var i;\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i];\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i];\n    var file = f;\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename];\n    }\n    var hit = this.matchOne(file, pattern, partial);\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options;\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern });\n\n  this.debug('matchOne', file.length, pattern.length);\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop');\n    var p = pattern[pi];\n    var f = file[fi];\n\n    this.debug(pattern, p, f);\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f]);\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi;\n      var pr = pi + 1;\n      if (pr === pl) {\n        this.debug('** at the end');\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr];\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee);\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr);\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue');\n          fr++;\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit;\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase();\n      } else {\n        hit = f === p;\n      }\n      this.debug('string match', p, f, hit);\n    } else {\n      hit = f.match(p);\n      this.debug('pattern match', p, f, hit);\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n};\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\nvar inherits_browser = createCommonjsModule(function (module) {\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  };\n}\n});\n\nvar inherits = createCommonjsModule(function (module) {\ntry {\n  var util$$1 = util__WEBPACK_IMPORTED_MODULE_2___default.a;\n  if (typeof util$$1.inherits !== 'function') throw '';\n  module.exports = util$$1.inherits;\n} catch (e) {\n  module.exports = inherits_browser;\n}\n});\n\nfunction posix(path$$1) {\n\treturn path$$1.charAt(0) === '/';\n}\n\nfunction win32(path$$1) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path$$1);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nvar pathIsAbsolute = process.platform === 'win32' ? win32 : posix;\nvar posix_1 = posix;\nvar win32_1 = win32;\npathIsAbsolute.posix = posix_1;\npathIsAbsolute.win32 = win32_1;\n\nvar alphasort_1 = alphasort;\nvar alphasorti_1 = alphasorti;\nvar setopts_1 = setopts;\nvar ownProp_1 = ownProp;\nvar makeAbs_1 = makeAbs;\nvar finish_1 = finish;\nvar mark_1 = mark;\nvar isIgnored_1 = isIgnored;\nvar childrenIgnored_1 = childrenIgnored;\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\n\n\n\nvar Minimatch$1 = minimatch_1.Minimatch;\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || [];\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore];\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap);\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null;\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '');\n    gmatcher = new Minimatch$1(gpattern, { dot: true });\n  }\n\n  return {\n    matcher: new Minimatch$1(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {};\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern;\n  }\n\n  self.silent = !!options.silent;\n  self.pattern = pattern;\n  self.strict = options.strict !== false;\n  self.realpath = !!options.realpath;\n  self.realpathCache = options.realpathCache || Object.create(null);\n  self.follow = !!options.follow;\n  self.dot = !!options.dot;\n  self.mark = !!options.mark;\n  self.nodir = !!options.nodir;\n  if (self.nodir)\n    self.mark = true;\n  self.sync = !!options.sync;\n  self.nounique = !!options.nounique;\n  self.nonull = !!options.nonull;\n  self.nosort = !!options.nosort;\n  self.nocase = !!options.nocase;\n  self.stat = !!options.stat;\n  self.noprocess = !!options.noprocess;\n  self.absolute = !!options.absolute;\n\n  self.maxLength = options.maxLength || Infinity;\n  self.cache = options.cache || Object.create(null);\n  self.statCache = options.statCache || Object.create(null);\n  self.symlinks = options.symlinks || Object.create(null);\n\n  setupIgnores(self, options);\n\n  self.changedCwd = false;\n  var cwd = process.cwd();\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd;\n  else {\n    self.cwd = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(options.cwd);\n    self.changedCwd = self.cwd !== cwd;\n  }\n\n  self.root = options.root || path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(self.cwd, \"/\");\n  self.root = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(self.root);\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\");\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = pathIsAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n  self.nomount = !!options.nomount;\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true;\n  options.nocomment = true;\n\n  self.minimatch = new Minimatch$1(pattern, options);\n  self.options = self.minimatch.options;\n}\n\nfunction finish (self) {\n  var nou = self.nounique;\n  var all = nou ? [] : Object.create(null);\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i];\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i];\n        if (nou)\n          all.push(literal);\n        else\n          all[literal] = true;\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches);\n      if (nou)\n        all.push.apply(all, m);\n      else\n        m.forEach(function (m) {\n          all[m] = true;\n        });\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all);\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort);\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i]);\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e));\n        var c = self.cache[e] || self.cache[makeAbs(self, e)];\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c);\n        return notDir\n      });\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    });\n\n  self.found = all;\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p);\n  var c = self.cache[abs];\n  var m = p;\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c);\n    var slash = p.slice(-1) === '/';\n\n    if (isDir && !slash)\n      m += '/';\n    else if (!isDir && slash)\n      m = m.slice(0, -1);\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m);\n      self.statCache[mabs] = self.statCache[abs];\n      self.cache[mabs] = self.cache[abs];\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f;\n  if (f.charAt(0) === '/') {\n    abs = path__WEBPACK_IMPORTED_MODULE_0___default.a.join(self.root, f);\n  } else if (pathIsAbsolute(f) || f === '') {\n    abs = f;\n  } else if (self.changedCwd) {\n    abs = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(self.cwd, f);\n  } else {\n    abs = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(f);\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/');\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path$$1) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path$$1) || !!(item.gmatcher && item.gmatcher.match(path$$1))\n  })\n}\n\nfunction childrenIgnored (self, path$$1) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path$$1))\n  })\n}\n\nvar common = {\n\talphasort: alphasort_1,\n\talphasorti: alphasorti_1,\n\tsetopts: setopts_1,\n\townProp: ownProp_1,\n\tmakeAbs: makeAbs_1,\n\tfinish: finish_1,\n\tmark: mark_1,\n\tisIgnored: isIgnored_1,\n\tchildrenIgnored: childrenIgnored_1\n};\n\nvar sync = globSync;\nglobSync.GlobSync = GlobSync;\nvar setopts$1 = common.setopts;\nvar ownProp$1 = common.ownProp;\nvar childrenIgnored$1 = common.childrenIgnored;\nvar isIgnored$1 = common.isIgnored;\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts$1(this, pattern, options);\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length;\n  this.matches = new Array(n);\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false);\n  }\n  this._finish();\n}\n\nGlobSync.prototype._finish = function () {\n  assert__WEBPACK_IMPORTED_MODULE_3___default()(this instanceof GlobSync);\n  if (this.realpath) {\n    var self = this;\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null);\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p);\n          var real = fs_realpath.realpathSync(p, self.realpathCache);\n          set[real] = true;\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true;\n          else\n            throw er\n        }\n      }\n    });\n  }\n  common.finish(this);\n};\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert__WEBPACK_IMPORTED_MODULE_3___default()(this instanceof GlobSync);\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0;\n  while (typeof pattern[n] === 'string') {\n    n ++;\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix;\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index);\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/');\n      break\n  }\n\n  var remain = pattern.slice(n);\n\n  // get the list of entries.\n  var read;\n  if (prefix === null)\n    read = '.';\n  else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {\n    if (!prefix || !pathIsAbsolute(prefix))\n      prefix = '/' + prefix;\n    read = prefix;\n  } else\n    read = prefix;\n\n  var abs = this._makeAbs(read);\n\n  //if ignored, skip processing\n  if (childrenIgnored$1(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar);\n};\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar);\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0];\n  var negate = !!this.minimatch.negate;\n  var rawGlob = pn._glob;\n  var dotOk = this.dot || rawGlob.charAt(0) === '.';\n\n  var matchedEntries = [];\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m;\n      if (negate && !prefix) {\n        m = !e.match(pn);\n      } else {\n        m = e.match(pn);\n      }\n      if (m)\n        matchedEntries.push(e);\n    }\n  }\n\n  var len = matchedEntries.length;\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null);\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i];\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e;\n        else\n          e = prefix + e;\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path__WEBPACK_IMPORTED_MODULE_0___default.a.join(this.root, e);\n      }\n      this._emitMatch(index, e);\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift();\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i];\n    var newPattern;\n    if (prefix)\n      newPattern = [prefix, e];\n    else\n      newPattern = [e];\n    this._process(newPattern.concat(remain), index, inGlobStar);\n  }\n};\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored$1(this, e))\n    return\n\n  var abs = this._makeAbs(e);\n\n  if (this.mark)\n    e = this._mark(e);\n\n  if (this.absolute) {\n    e = abs;\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs];\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true;\n\n  if (this.stat)\n    this._stat(e);\n};\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries;\n  var lstat;\n  try {\n    lstat = fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstatSync(abs);\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink();\n  this.symlinks[abs] = isSym;\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE';\n  else\n    entries = this._readdir(abs, false);\n\n  return entries\n};\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n\n  if (inGlobStar && !ownProp$1(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp$1(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs__WEBPACK_IMPORTED_MODULE_1___default.a.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er);\n    return null\n  }\n};\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i];\n      if (abs === '/')\n        e = abs + e;\n      else\n        e = abs + '/' + e;\n      this.cache[e] = true;\n    }\n  }\n\n  this.cache[abs] = entries;\n\n  // mark and cache dir-ness\n  return entries\n};\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f);\n      this.cache[abs] = 'FILE';\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n        error.path = this.cwd;\n        error.code = er.code;\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false;\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false;\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er);\n      break\n  }\n};\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar);\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1);\n  var gspref = prefix ? [ prefix ] : [];\n  var noGlobStar = gspref.concat(remainWithoutGlobStar);\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false);\n\n  var len = entries.length;\n  var isSym = this.symlinks[abs];\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i];\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n    this._process(instead, index, true);\n\n    var below = gspref.concat(entries[i], remain);\n    this._process(below, index, true);\n  }\n};\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix);\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null);\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix);\n    if (prefix.charAt(0) === '/') {\n      prefix = path__WEBPACK_IMPORTED_MODULE_0___default.a.join(this.root, prefix);\n    } else {\n      prefix = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(this.root, prefix);\n      if (trail)\n        prefix += '/';\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/');\n\n  // Mark this as a match\n  this._emitMatch(index, prefix);\n};\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f);\n  var needDir = f.slice(-1) === '/';\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp$1(this.cache, abs)) {\n    var c = this.cache[abs];\n\n    if (Array.isArray(c))\n      c = 'DIR';\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n  var stat = this.statCache[abs];\n  if (!stat) {\n    var lstat;\n    try {\n      lstat = fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstatSync(abs);\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false;\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs__WEBPACK_IMPORTED_MODULE_1___default.a.statSync(abs);\n      } catch (er) {\n        stat = lstat;\n      }\n    } else {\n      stat = lstat;\n    }\n  }\n\n  this.statCache[abs] = stat;\n\n  var c = true;\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE';\n\n  this.cache[abs] = this.cache[abs] || c;\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n};\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n};\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n};\n\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nvar wrappy_1 = wrappy;\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k];\n  });\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    var ret = fn.apply(this, args);\n    var cb = args[args.length-1];\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k];\n      });\n    }\n    return ret\n  }\n}\n\nvar once_1 = wrappy_1(once);\nvar strict = wrappy_1(onceStrict);\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  });\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  });\n});\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true;\n    return f.value = fn.apply(this, arguments)\n  };\n  f.called = false;\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true;\n    return f.value = fn.apply(this, arguments)\n  };\n  var name = fn.name || 'Function wrapped with `once`';\n  f.onceError = name + \" shouldn't be called more than once\";\n  f.called = false;\n  return f\n}\nonce_1.strict = strict;\n\nvar reqs = Object.create(null);\n\n\nvar inflight_1 = wrappy_1(inflight);\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb);\n    return null\n  } else {\n    reqs[key] = [cb];\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once_1(function RES () {\n    var cbs = reqs[key];\n    var len = cbs.length;\n    var args = slice(arguments);\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args);\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len);\n        process.nextTick(function () {\n          RES.apply(null, args);\n        });\n      } else {\n        delete reqs[key];\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length;\n  var array = [];\n\n  for (var i = 0; i < length; i++) array[i] = args[i];\n  return array\n}\n\n// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nvar glob_1 = glob;\n\nvar EE = events__WEBPACK_IMPORTED_MODULE_4___default.a.EventEmitter;\nvar setopts$2 = common.setopts;\nvar ownProp$2 = common.ownProp;\n\n\nvar childrenIgnored$2 = common.childrenIgnored;\nvar isIgnored$2 = common.isIgnored;\n\n\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {};\n  if (!options) options = {};\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return sync(pattern, options)\n  }\n\n  return new Glob$1(pattern, options, cb)\n}\n\nglob.sync = sync;\nvar GlobSync$1 = glob.GlobSync = sync.GlobSync;\n\n// old api surface\nglob.glob = glob;\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_);\n  options.noprocess = true;\n\n  var g = new Glob$1(pattern, options);\n  var set = g.minimatch.set;\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n};\n\nglob.Glob = Glob$1;\ninherits(Glob$1, EE);\nfunction Glob$1 (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync$1(pattern, options)\n  }\n\n  if (!(this instanceof Glob$1))\n    return new Glob$1(pattern, options, cb)\n\n  setopts$2(this, pattern, options);\n  this._didRealPath = false;\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length;\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n);\n\n  if (typeof cb === 'function') {\n    cb = once_1(cb);\n    this.on('error', cb);\n    this.on('end', function (matches) {\n      cb(null, matches);\n    });\n  }\n\n  var self = this;\n  this._processing = 0;\n\n  this._emitQueue = [];\n  this._processQueue = [];\n  this.paused = false;\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync$$1 = true;\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done);\n  }\n  sync$$1 = false;\n\n  function done () {\n    --self._processing;\n    if (self._processing <= 0) {\n      if (sync$$1) {\n        process.nextTick(function () {\n          self._finish();\n        });\n      } else {\n        self._finish();\n      }\n    }\n  }\n}\n\nGlob$1.prototype._finish = function () {\n  assert__WEBPACK_IMPORTED_MODULE_3___default()(this instanceof Glob$1);\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this);\n  this.emit('end', this.found);\n};\n\nGlob$1.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true;\n\n  var n = this.matches.length;\n  if (n === 0)\n    return this._finish()\n\n  var self = this;\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next);\n\n  function next () {\n    if (--n === 0)\n      self._finish();\n  }\n};\n\nGlob$1.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index];\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset);\n  var self = this;\n  var n = found.length;\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null);\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p);\n    fs_realpath.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true;\n      else if (er.syscall === 'stat')\n        set[p] = true;\n      else\n        self.emit('error', er); // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set;\n        cb();\n      }\n    });\n  });\n};\n\nGlob$1.prototype._mark = function (p) {\n  return common.mark(this, p)\n};\n\nGlob$1.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n};\n\nGlob$1.prototype.abort = function () {\n  this.aborted = true;\n  this.emit('abort');\n};\n\nGlob$1.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true;\n    this.emit('pause');\n  }\n};\n\nGlob$1.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume');\n    this.paused = false;\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0);\n      this._emitQueue.length = 0;\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i];\n        this._emitMatch(e[0], e[1]);\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0);\n      this._processQueue.length = 0;\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i];\n        this._processing--;\n        this._process(p[0], p[1], p[2], p[3]);\n      }\n    }\n  }\n};\n\nGlob$1.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert__WEBPACK_IMPORTED_MODULE_3___default()(this instanceof Glob$1);\n  assert__WEBPACK_IMPORTED_MODULE_3___default()(typeof cb === 'function');\n\n  if (this.aborted)\n    return\n\n  this._processing++;\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb]);\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0;\n  while (typeof pattern[n] === 'string') {\n    n ++;\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix;\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb);\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/');\n      break\n  }\n\n  var remain = pattern.slice(n);\n\n  // get the list of entries.\n  var read;\n  if (prefix === null)\n    read = '.';\n  else if (pathIsAbsolute(prefix) || pathIsAbsolute(pattern.join('/'))) {\n    if (!prefix || !pathIsAbsolute(prefix))\n      prefix = '/' + prefix;\n    read = prefix;\n  } else\n    read = prefix;\n\n  var abs = this._makeAbs(read);\n\n  //if ignored, skip _processing\n  if (childrenIgnored$2(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch_1.GLOBSTAR;\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);\n};\n\nGlob$1.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this;\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  });\n};\n\nGlob$1.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0];\n  var negate = !!this.minimatch.negate;\n  var rawGlob = pn._glob;\n  var dotOk = this.dot || rawGlob.charAt(0) === '.';\n\n  var matchedEntries = [];\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m;\n      if (negate && !prefix) {\n        m = !e.match(pn);\n      } else {\n        m = e.match(pn);\n      }\n      if (m)\n        matchedEntries.push(e);\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length;\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null);\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i];\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e;\n        else\n          e = prefix + e;\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path__WEBPACK_IMPORTED_MODULE_0___default.a.join(this.root, e);\n      }\n      this._emitMatch(index, e);\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift();\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i];\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e;\n      else\n        e = prefix + e;\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb);\n  }\n  cb();\n};\n\nGlob$1.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored$2(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e]);\n    return\n  }\n\n  var abs = pathIsAbsolute(e) ? e : this._makeAbs(e);\n\n  if (this.mark)\n    e = this._mark(e);\n\n  if (this.absolute)\n    e = abs;\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs];\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true;\n\n  var st = this.statCache[abs];\n  if (st)\n    this.emit('stat', e, st);\n\n  this.emit('match', e);\n};\n\nGlob$1.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs;\n  var self = this;\n  var lstatcb = inflight_1(lstatkey, lstatcb_);\n\n  if (lstatcb)\n    fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstat(abs, lstatcb);\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink();\n    self.symlinks[abs] = isSym;\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE';\n      cb();\n    } else\n      self._readdir(abs, false, cb);\n  }\n};\n\nGlob$1.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight_1('readdir\\0'+abs+'\\0'+inGlobStar, cb);\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp$2(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp$2(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n  fs__WEBPACK_IMPORTED_MODULE_1___default.a.readdir(abs, readdirCb(this, abs, cb));\n};\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb);\n    else\n      self._readdirEntries(abs, entries, cb);\n  }\n}\n\nGlob$1.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i];\n      if (abs === '/')\n        e = abs + e;\n      else\n        e = abs + '/' + e;\n      this.cache[e] = true;\n    }\n  }\n\n  this.cache[abs] = entries;\n  return cb(null, entries)\n};\n\nGlob$1.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f);\n      this.cache[abs] = 'FILE';\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n        error.path = this.cwd;\n        error.code = er.code;\n        this.emit('error', error);\n        this.abort();\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false;\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false;\n      if (this.strict) {\n        this.emit('error', er);\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort();\n      }\n      if (!this.silent)\n        console.error('glob error', er);\n      break\n  }\n\n  return cb()\n};\n\nGlob$1.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this;\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n  });\n};\n\n\nGlob$1.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1);\n  var gspref = prefix ? [ prefix ] : [];\n  var noGlobStar = gspref.concat(remainWithoutGlobStar);\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb);\n\n  var isSym = this.symlinks[abs];\n  var len = entries.length;\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i];\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n    this._process(instead, index, true, cb);\n\n    var below = gspref.concat(entries[i], remain);\n    this._process(below, index, true, cb);\n  }\n\n  cb();\n};\n\nGlob$1.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this;\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb);\n  });\n};\nGlob$1.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null);\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && pathIsAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix);\n    if (prefix.charAt(0) === '/') {\n      prefix = path__WEBPACK_IMPORTED_MODULE_0___default.a.join(this.root, prefix);\n    } else {\n      prefix = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(this.root, prefix);\n      if (trail)\n        prefix += '/';\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/');\n\n  // Mark this as a match\n  this._emitMatch(index, prefix);\n  cb();\n};\n\n// Returns either 'DIR', 'FILE', or false\nGlob$1.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f);\n  var needDir = f.slice(-1) === '/';\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp$2(this.cache, abs)) {\n    var c = this.cache[abs];\n\n    if (Array.isArray(c))\n      c = 'DIR';\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n  var stat = this.statCache[abs];\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE';\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this;\n  var statcb = inflight_1('stat\\0' + abs, lstatcb_);\n  if (statcb)\n    fs__WEBPACK_IMPORTED_MODULE_1___default.a.lstat(abs, statcb);\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs__WEBPACK_IMPORTED_MODULE_1___default.a.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb);\n        else\n          self._stat2(f, abs, er, stat, cb);\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb);\n    }\n  }\n};\n\nGlob$1.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false;\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/';\n  this.statCache[abs] = stat;\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true;\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE';\n  this.cache[abs] = this.cache[abs] || c;\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n};\n\nvar recursiveReadDirSync = function recursiveReadDirSync(dir) {\n  return fs__WEBPACK_IMPORTED_MODULE_1___default.a.readdirSync(dir).reduce(function (files, file) {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default.a.statSync(path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, file)).isDirectory() ? files.concat(recursiveReadDirSync(path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, file))) : files.concat(path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, file));\n  }, []);\n};\n\nvar readDirSync = function readDirSync(dir) {\n  return fs__WEBPACK_IMPORTED_MODULE_1___default.a.readdirSync(dir).reduce(function (files, file) {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default.a.statSync(path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, file)).isDirectory() ? files : files.concat(path__WEBPACK_IMPORTED_MODULE_0___default.a.join(dir, file));\n  }, []);\n};\n\nvar readGlobSync = function readGlobSync(pattern, options) {\n  return glob_1.sync(pattern, options);\n};\n\nvar getSchemaFiles = function getSchemaFiles(dir, recursive, globOptions) {\n  if (isGlob(dir)) {\n    return readGlobSync(dir, globOptions);\n  }\n\n  if (recursive === true) {\n    return recursiveReadDirSync(dir);\n  }\n\n  return readDirSync(dir);\n};\n\nvar DEFAULT_EXTENSIONS = ['.ts', '.js', '.gql', '.graphql', '.graphqls'];\n\nvar fileLoader = function fileLoader(folderPath) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$recursive = _ref.recursive,\n      recursive = _ref$recursive === undefined ? false : _ref$recursive,\n      _ref$extensions = _ref.extensions,\n      extensions = _ref$extensions === undefined ? DEFAULT_EXTENSIONS : _ref$extensions,\n      _ref$globOptions = _ref.globOptions,\n      globOptions = _ref$globOptions === undefined ? {} : _ref$globOptions;\n\n  var dir = folderPath;\n  var schemafiles = getSchemaFiles(dir, recursive, globOptions);\n\n  var files = schemafiles.map(function (f) {\n    return { f, pathObj: path__WEBPACK_IMPORTED_MODULE_0___default.a.parse(f) };\n  }).filter(function (_ref2) {\n    var pathObj = _ref2.pathObj;\n    return pathObj.name.toLowerCase() !== 'index';\n  }).filter(function (_ref3) {\n    var pathObj = _ref3.pathObj;\n    return extensions.includes(pathObj.ext);\n  }).map(function (_ref4) {\n    var f = _ref4.f,\n        pathObj = _ref4.pathObj;\n\n    var returnVal = void 0;\n\n    switch (pathObj.ext) {\n      case '.ts':\n      case '.js':\n        {\n          var file = __webpack_require__(\"./node_modules/merge-graphql-schemas/dist sync recursive\")(f); // eslint-disable-line\n          returnVal = file.default || file;\n          break;\n        }\n\n      case '.graphqls':\n      case '.gql':\n      case '.graphql':\n        {\n          var _file = fs__WEBPACK_IMPORTED_MODULE_1___default.a.readFileSync(f, 'utf8');\n          returnVal = _file;\n          break;\n        }\n\n      default:\n      // we don't know how to handle other extensions\n    }\n\n    return returnVal;\n  }).filter(function (v) {\n    return !!v;\n  }); // filter files that we don't know how to handle\n\n  return files;\n};\n\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription) {\n  var escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return `$${node.name}`;\n  },\n\n  // Document\n\n  Document: function Document(node) {\n    return `${node.definitions.map(function (defNode) {\n      return `${defNode}\\n${defNode[0] === '#' ? '' : '\\n'}`;\n    }).join('').trim()}\\n`;\n  },\n\n  OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet;\n    // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue;\n    return `${variable}: ${type}${wrap(' = ', defaultValue)}`;\n  },\n\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], '  ');\n  },\n\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return `${name}: ${value}`;\n  },\n\n  // Fragments\n\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return `...${name}${wrap(' ', join(directives, ' '))}`;\n  },\n\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (\n      // Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      `${`fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}`}${selectionSet}`\n    );\n  },\n\n  // Value\n\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return `[${join(values, ', ')}]`;\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return `{${join(fields, ', ')}}`;\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return `${name}: ${value}`;\n  },\n\n  // Directive\n\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return `@${name}${wrap('(', join(args, ', '), ')')}`;\n  },\n\n  // Type\n\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return `[${type}]`;\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return `${type}!`;\n  },\n\n  // Type System Definitions\n\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return `${operation}: ${type}`;\n  },\n\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return `${name + wrap('(', join(args, ', '), ')')}: ${type}${wrap(' ', join(directives, ' '))}`;\n  }),\n\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([`${name}: ${type}`, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' ');\n  }),\n\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n\n  ScalarTypeExtension: function ScalarTypeExtension(_ref31) {\n    var name = _ref31.name,\n        directives = _ref31.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n\n  ObjectTypeExtension: function ObjectTypeExtension(_ref32) {\n    var name = _ref32.name,\n        interfaces = _ref32.interfaces,\n        directives = _ref32.directives,\n        fields = _ref32.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives,\n        fields = _ref33.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  UnionTypeExtension: function UnionTypeExtension(_ref34) {\n    var name = _ref34.name,\n        directives = _ref34.directives,\n        types = _ref34.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' ');\n  },\n\n  EnumTypeExtension: function EnumTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        values = _ref35.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        fields = _ref36.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  },\n\n  DirectiveDefinition: addDescription(function (_ref37) {\n    var name = _ref37.name,\n        args = _ref37.arguments,\n        locations = _ref37.locations;\n    return `directive @${name}${wrap('(', join(args, ', '), ')')} on ${join(locations, ' | ')}`;\n  }),\n\n  Comment: function Comment(_ref38) {\n    var value = _ref38.value;\n    return `# ${value.replace(/\\n/g, '\\n # ')}`;\n  }\n};\n\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction print(ast) {\n  return Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_5__[\"visit\"])(ast, { leave: printDocASTReducer });\n}\n\nvar hasDefinitionWithName = function hasDefinitionWithName(nodes, name) {\n  return nodes.findIndex(function (node) {\n    return node.name.value === name;\n  }) !== -1;\n};\n\nvar isObjectTypeDefinition = function isObjectTypeDefinition(def) {\n  return def.kind === graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].OBJECT_TYPE_DEFINITION || def.kind === graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].INPUT_OBJECT_TYPE_DEFINITION;\n};\n\nvar isEnumTypeDefinition = function isEnumTypeDefinition(def) {\n  return def.kind === graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].ENUM_TYPE_DEFINITION;\n};\n\nvar isObjectSchemaDefinition = function isObjectSchemaDefinition(def) {\n  return def.kind === graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].SCHEMA_DEFINITION;\n};\n\nvar typesMap = {\n  query: 'Query',\n  mutation: 'Mutation',\n  subscription: 'Subscription'\n};\n\nvar _mergeableOperationTypes = Object.keys(typesMap);\n\nvar _makeOperationType = function _makeOperationType(operation, value) {\n  return {\n    kind: graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].OPERATION_TYPE_DEFINITION,\n    operation,\n    type: {\n      kind: graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].NAMED_TYPE,\n      name: {\n        kind: graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].NAME,\n        value\n      }\n    }\n  };\n};\n\nvar mergeableTypes = Object.values(typesMap);\n\nvar makeSchema = function makeSchema(definitions, schemaDefs) {\n  var operationMap = {\n    query: _makeOperationType(_mergeableOperationTypes[0], mergeableTypes[0]),\n    mutation: null,\n    subscription: null\n  };\n\n  mergeableTypes.slice(1).forEach(function (type, key) {\n    if (hasDefinitionWithName(definitions, type)) {\n      var operation = _mergeableOperationTypes[key + 1];\n\n      operationMap[operation] = _makeOperationType(operation, type);\n    }\n  });\n\n  var operationTypes = Object.values(operationMap).map(function (operation, i) {\n    if (!operation) {\n      var type = Object.keys(operationMap)[i];\n\n      if (schemaDefs.some(function (def) {\n        return def.operationTypes.some(function (op) {\n          return op.operation === type;\n        });\n      })) {\n        return _makeOperationType(type, typesMap[type]);\n      }\n    }\n\n    return operation;\n  }).filter(function (op) {\n    return op;\n  });\n\n  return {\n    kind: graphql__WEBPACK_IMPORTED_MODULE_6__[\"Kind\"].SCHEMA_DEFINITION,\n    directives: [],\n    operationTypes\n  };\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n// NOTE: Currently using a slightly modified print instead of the exported graphql version.\n\nvar _isMergeableTypeDefinition = function _isMergeableTypeDefinition(def, all) {\n  return isObjectTypeDefinition(def) && (mergeableTypes.includes(def.name.value) || all);\n};\n\nvar _isNonMergeableTypeDefinition = function _isNonMergeableTypeDefinition(def, all) {\n  return !_isMergeableTypeDefinition(def, all);\n};\n\nvar _makeCommentNode = function _makeCommentNode(value) {\n  return { kind: 'Comment', value };\n};\n\nvar _addCommentsToAST = function _addCommentsToAST(nodes) {\n  var flatten = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  var astWithComments = nodes.map(function (node) {\n    var description = Object(graphql_utilities_buildASTSchema__WEBPACK_IMPORTED_MODULE_7__[\"getDescription\"])(node, { commentDescriptions: true });\n    if (description) {\n      return [_makeCommentNode(description), node];\n    }\n\n    return [node];\n  });\n\n  if (flatten) {\n    return astWithComments.reduce(function (a, b) {\n      return a.concat(b);\n    }, []);\n  }\n\n  return astWithComments;\n};\n\nvar _makeRestDefinitions = function _makeRestDefinitions(defs) {\n  var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return defs.filter(function (def) {\n    return _isNonMergeableTypeDefinition(def, all) && !isObjectSchemaDefinition(def);\n  }).map(function (def) {\n    if (isObjectTypeDefinition(def) || isEnumTypeDefinition(def)) {\n      return _extends({}, def, {\n        fields: def.fields ? _addCommentsToAST(def.fields) : undefined,\n        values: def.values ? _addCommentsToAST(def.values) : undefined\n      });\n    }\n\n    return def;\n  });\n};\n\nvar _makeMergedFieldDefinitions = function _makeMergedFieldDefinitions(merged, candidate) {\n  return _addCommentsToAST(candidate.fields).reduce(function (fields, field) {\n    var original = merged.fields.find(function (base) {\n      return base.name && typeof base.name.value !== 'undefined' && field.name && typeof field.name.value !== 'undefined' && base.name.value === field.name.value;\n    });\n    if (!original) {\n      fields.push(field);\n    } else if (field.type.kind === 'NamedType') {\n      if (field.type.name.value !== original.type.name.value) {\n        throw new Error(`Conflicting types for ${merged.name.value}.${field.name.value}: ` + `${field.type.name.value} != ${original.type.name.value}`);\n      }\n    } else if (field.type.kind === 'NonNullType') {\n      if (field.type.type.name.value !== original.type.type.name.value) {\n        throw new Error(`Conflicting types for ${merged.name.value}.${field.name.value}: ` + `${field.type.type.name.value} != ${original.type.type.name.value}`);\n      }\n    }\n\n    // retain directives of both fields.\n    if (original) {\n      original.directives = original.directives.concat(field.directives);\n    }\n    return fields;\n  }, merged.fields);\n};\n\nvar _makeMergedDefinitions = function _makeMergedDefinitions(defs) {\n  var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // TODO: This function can be cleaner!\n  var groupedMergableDefinitions = defs.filter(function (def) {\n    return _isMergeableTypeDefinition(def, all);\n  }).reduce(function (mergableDefs, def) {\n    var name = def.name.value;\n\n    if (!mergableDefs[name]) {\n      return _extends({}, mergableDefs, {\n        [name]: _extends({}, def, {\n          fields: def.fields ? _addCommentsToAST(def.fields) : undefined,\n          values: def.values ? _addCommentsToAST(def.values) : undefined\n        })\n      });\n    }\n\n    return _extends({}, mergableDefs, {\n      [name]: _extends({}, mergableDefs[name], {\n        fields: _makeMergedFieldDefinitions(mergableDefs[name], def)\n      })\n    });\n  }, {\n    Query: null,\n    Mutation: null,\n    Subscription: null\n  });\n\n  return Object.values(groupedMergableDefinitions).reduce(function (array, def) {\n    return def ? [].concat(toConsumableArray(array), [def]) : array;\n  }, []);\n};\n\nvar _makeDocumentWithDefinitions = function _makeDocumentWithDefinitions(definitions) {\n  return {\n    kind: 'Document',\n    definitions: definitions instanceof Array ? definitions : [definitions]\n  };\n};\n\nvar printDefinitions = function printDefinitions(defs) {\n  return print(_makeDocumentWithDefinitions(defs));\n};\n\nvar mergeTypes = function mergeTypes(types) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { all: false };\n\n  var allDefs = types.map(function (type) {\n    if (typeof type === 'string') {\n      return Object(graphql__WEBPACK_IMPORTED_MODULE_6__[\"parse\"])(type);\n    }\n    return type;\n  }).map(function (ast) {\n    return ast.definitions;\n  }).reduce(function (defs, newDef) {\n    return [].concat(toConsumableArray(defs), toConsumableArray(newDef));\n  }, []);\n\n  var mergedDefs = _makeMergedDefinitions(allDefs, options.all);\n  var rest = _addCommentsToAST(_makeRestDefinitions(allDefs, options.all), false).map(printDefinitions);\n  var schemaDefs = allDefs.filter(isObjectSchemaDefinition);\n  var schema = printDefinitions([makeSchema(mergedDefs, schemaDefs)].concat(toConsumableArray(mergedDefs)));\n\n  return [schema].concat(toConsumableArray(rest)).join('\\n');\n};\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tObject.keys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tObject.keys(source).forEach(function(key) {\n\t\tif (!options.isMergeableObject(source[key]) || !target[key]) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = deepmerge(target[key], source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nvar mergeResolvers = function mergeResolvers(resolvers) {\n  return resolvers.length === 1 ? resolvers[0] : deepmerge_1.all(resolvers);\n};\n\n// Import these two es7 features until we drop Node 4 support\n\n\n\n\n//# sourceURL=webpack:///./node_modules/merge-graphql-schemas/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/merge2/index.js":
/*!**************************************!*\
  !*** ./node_modules/merge2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n * merge2\n * https://github.com/teambition/merge2\n *\n * Copyright (c) 2014-2016 Teambition\n * Licensed under the MIT license.\n */\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nconst PassThrough = Stream.PassThrough\nconst slice = Array.prototype.slice\n\nmodule.exports = merge2\n\nfunction merge2 () {\n  const streamsQueue = []\n  let merging = false\n  let args = slice.call(arguments)\n  let options = args[args.length - 1]\n\n  if (options && !Array.isArray(options) && options.pipe == null) args.pop()\n  else options = {}\n\n  let doEnd = options.end !== false\n  if (options.objectMode == null) options.objectMode = true\n  if (options.highWaterMark == null) options.highWaterMark = 64 * 1024\n  const mergedStream = PassThrough(options)\n\n  function addStream () {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options))\n    }\n    mergeStream()\n    return this\n  }\n\n  function mergeStream () {\n    if (merging) return\n    merging = true\n\n    let streams = streamsQueue.shift()\n    if (!streams) {\n      process.nextTick(endStream)\n      return\n    }\n    if (!Array.isArray(streams)) streams = [streams]\n\n    let pipesCount = streams.length + 1\n\n    function next () {\n      if (--pipesCount > 0) return\n      merging = false\n      mergeStream()\n    }\n\n    function pipe (stream) {\n      function onend () {\n        stream.removeListener('merge2UnpipeEnd', onend)\n        stream.removeListener('end', onend)\n        next()\n      }\n      // skip ended stream\n      if (stream._readableState.endEmitted) return next()\n\n      stream.on('merge2UnpipeEnd', onend)\n      stream.on('end', onend)\n      stream.pipe(mergedStream, {end: false})\n      // compatible for old stream\n      stream.resume()\n    }\n\n    for (let i = 0; i < streams.length; i++) pipe(streams[i])\n\n    next()\n  }\n\n  function endStream () {\n    merging = false\n    // emit 'queueDrain' when all streams merged.\n    mergedStream.emit('queueDrain')\n    return doEnd && mergedStream.end()\n  }\n\n  mergedStream.setMaxListeners(0)\n  mergedStream.add = addStream\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd')\n  })\n\n  if (args.length) addStream.apply(null, args)\n  return mergedStream\n}\n\n// check and pause streams for pipe.\nfunction pauseStreams (streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.')\n    }\n    streams.pause()\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)\n  }\n  return streams\n}\n\n\n//# sourceURL=webpack:///./node_modules/merge2/index.js?");

/***/ }),

/***/ "./node_modules/multimatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/multimatch/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar minimatch = __webpack_require__(/*! minimatch */ \"minimatch\");\nvar arrayUnion = __webpack_require__(/*! array-union */ \"./node_modules/array-union/index.js\");\nvar arrayDiffer = __webpack_require__(/*! array-differ */ \"./node_modules/array-differ/index.js\");\nvar arrify = __webpack_require__(/*! arrify */ \"arrify\");\n\nmodule.exports = function (list, patterns, options) {\n\tlist = arrify(list);\n\tpatterns = arrify(patterns);\n\n\tif (list.length === 0 || patterns.length === 0) {\n\t\treturn [];\n\t}\n\n\toptions = options || {};\n\n\treturn patterns.reduce(function (ret, pattern) {\n\t\tvar process = arrayUnion;\n\n\t\tif (pattern[0] === '!') {\n\t\t\tpattern = pattern.slice(1);\n\t\t\tprocess = arrayDiffer;\n\t\t}\n\n\t\treturn process(ret, minimatch.match(list, pattern, options));\n\t}, []);\n};\n\n\n//# sourceURL=webpack:///./node_modules/multimatch/index.js?");

/***/ }),

/***/ "./node_modules/object-path/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-path/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function(){\n  'use strict';\n\n  var toStr = Object.prototype.toString;\n  function hasOwnProperty(obj, prop) {\n    if(obj == null) {\n      return false\n    }\n    //to handle objects with null prototypes (too edge case?)\n    return Object.prototype.hasOwnProperty.call(obj, prop)\n  }\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (typeof value !== 'string') {\n        for (var i in value) {\n            if (hasOwnProperty(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  var isArray = Array.isArray || function(obj){\n    /*istanbul ignore next:cant test*/\n    return toStr.call(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function factory(options) {\n    options = options || {}\n\n    var objectPath = function(obj) {\n      return Object.keys(objectPath).reduce(function(proxy, prop) {\n        if(prop === 'create') {\n          return proxy;\n        }\n\n        /*istanbul ignore else*/\n        if (typeof objectPath[prop] === 'function') {\n          proxy[prop] = objectPath[prop].bind(objectPath, obj);\n        }\n\n        return proxy;\n      }, {});\n    };\n\n    function hasShallowProperty(obj, prop) {\n      return (options.includeInheritedProps || (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop))\n    }\n\n    function getShallowProperty(obj, prop) {\n      if (hasShallowProperty(obj, prop)) {\n        return obj[prop];\n      }\n    }\n\n    function set(obj, path, value, doNotReplace){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (typeof path === 'string') {\n        return set(obj, path.split('.').map(getKey), value, doNotReplace);\n      }\n      var currentPath = path[0];\n      var currentValue = getShallowProperty(obj, currentPath);\n      if (path.length === 1) {\n        if (currentValue === void 0 || !doNotReplace) {\n          obj[currentPath] = value;\n        }\n        return currentValue;\n      }\n\n      if (currentValue === void 0) {\n        //check if we assume an array\n        if(typeof path[1] === 'number') {\n          obj[currentPath] = [];\n        } else {\n          obj[currentPath] = {};\n        }\n      }\n\n      return set(obj[currentPath], path.slice(1), value, doNotReplace);\n    }\n\n    objectPath.has = function (obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      } else if (typeof path === 'string') {\n        path = path.split('.');\n      }\n\n      if (!path || path.length === 0) {\n        return !!obj;\n      }\n\n      for (var i = 0; i < path.length; i++) {\n        var j = getKey(path[i]);\n\n        if((typeof j === 'number' && isArray(obj) && j < obj.length) ||\n          (options.includeInheritedProps ? (j in Object(obj)) : hasOwnProperty(obj, j))) {\n          obj = obj[j];\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    objectPath.ensureExists = function (obj, path, value){\n      return set(obj, path, value, true);\n    };\n\n    objectPath.set = function (obj, path, value, doNotReplace){\n      return set(obj, path, value, doNotReplace);\n    };\n\n    objectPath.insert = function (obj, path, value, at){\n      var arr = objectPath.get(obj, path);\n      at = ~~at;\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n      arr.splice(at, 0, value);\n    };\n\n    objectPath.empty = function(obj, path) {\n      if (isEmpty(path)) {\n        return void 0;\n      }\n      if (obj == null) {\n        return void 0;\n      }\n\n      var value, i;\n      if (!(value = objectPath.get(obj, path))) {\n        return void 0;\n      }\n\n      if (typeof value === 'string') {\n        return objectPath.set(obj, path, '');\n      } else if (isBoolean(value)) {\n        return objectPath.set(obj, path, false);\n      } else if (typeof value === 'number') {\n        return objectPath.set(obj, path, 0);\n      } else if (isArray(value)) {\n        value.length = 0;\n      } else if (isObject(value)) {\n        for (i in value) {\n          if (hasShallowProperty(value, i)) {\n            delete value[i];\n          }\n        }\n      } else {\n        return objectPath.set(obj, path, null);\n      }\n    };\n\n    objectPath.push = function (obj, path /*, values */){\n      var arr = objectPath.get(obj, path);\n      if (!isArray(arr)) {\n        arr = [];\n        objectPath.set(obj, path, arr);\n      }\n\n      arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n    };\n\n    objectPath.coalesce = function (obj, paths, defaultValue) {\n      var value;\n\n      for (var i = 0, len = paths.length; i < len; i++) {\n        if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n          return value;\n        }\n      }\n\n      return defaultValue;\n    };\n\n    objectPath.get = function (obj, path, defaultValue){\n      if (typeof path === 'number') {\n        path = [path];\n      }\n      if (!path || path.length === 0) {\n        return obj;\n      }\n      if (obj == null) {\n        return defaultValue;\n      }\n      if (typeof path === 'string') {\n        return objectPath.get(obj, path.split('.'), defaultValue);\n      }\n\n      var currentPath = getKey(path[0]);\n      var nextObj = getShallowProperty(obj, currentPath)\n      if (nextObj === void 0) {\n        return defaultValue;\n      }\n\n      if (path.length === 1) {\n        return nextObj;\n      }\n\n      return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n    };\n\n    objectPath.del = function del(obj, path) {\n      if (typeof path === 'number') {\n        path = [path];\n      }\n\n      if (obj == null) {\n        return obj;\n      }\n\n      if (isEmpty(path)) {\n        return obj;\n      }\n      if(typeof path === 'string') {\n        return objectPath.del(obj, path.split('.'));\n      }\n\n      var currentPath = getKey(path[0]);\n      if (!hasShallowProperty(obj, currentPath)) {\n        return obj;\n      }\n\n      if(path.length === 1) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      } else {\n        return objectPath.del(obj[currentPath], path.slice(1));\n      }\n\n      return obj;\n    }\n\n    return objectPath;\n  }\n\n  var mod = factory();\n  mod.create = factory;\n  mod.withInheritedProps = factory({includeInheritedProps: true})\n  return mod;\n});\n\n\n//# sourceURL=webpack:///./node_modules/object-path/index.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// minimal library entry point.\r\n\r\n\r\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar protobuf = exports;\r\n\r\n/**\r\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\r\n * @name build\r\n * @type {string}\r\n * @const\r\n */\r\nprotobuf.build = \"minimal\";\r\n\r\n// Serialization\r\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\r\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\r\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\r\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\r\n\r\n// Utility\r\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\r\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\r\nprotobuf.configure    = configure;\r\n\r\n/* istanbul ignore next */\r\n/**\r\n * Reconfigures the library according to the environment.\r\n * @returns {undefined}\r\n */\r\nfunction configure() {\r\n    protobuf.Reader._configure(protobuf.BufferReader);\r\n    protobuf.util._configure();\r\n}\r\n\r\n// Set up buffer utility according to the environment\r\nprotobuf.Writer._configure(protobuf.BufferWriter);\r\nconfigure();\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = Reader;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferReader; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    utf8      = util.utf8;\r\n\r\n/* istanbul ignore next */\r\nfunction indexOutOfRange(reader, writeLength) {\r\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\r\n}\r\n\r\n/**\r\n * Constructs a new reader instance using the specified buffer.\r\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n * @param {Uint8Array} buffer Buffer to read from\r\n */\r\nfunction Reader(buffer) {\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @type {Uint8Array}\r\n     */\r\n    this.buf = buffer;\r\n\r\n    /**\r\n     * Read buffer position.\r\n     * @type {number}\r\n     */\r\n    this.pos = 0;\r\n\r\n    /**\r\n     * Read buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = buffer.length;\r\n}\r\n\r\nvar create_array = typeof Uint8Array !== \"undefined\"\r\n    ? function create_typed_array(buffer) {\r\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array(buffer) {\r\n        if (Array.isArray(buffer))\r\n            return new Reader(buffer);\r\n        throw Error(\"illegal buffer\");\r\n    };\r\n\r\n/**\r\n * Creates a new reader using the specified buffer.\r\n * @function\r\n * @param {Uint8Array|Buffer} buffer Buffer to read from\r\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\r\n * @throws {Error} If `buffer` is not a valid buffer\r\n */\r\nReader.create = util.Buffer\r\n    ? function create_buffer_setup(buffer) {\r\n        return (Reader.create = function create_buffer(buffer) {\r\n            return util.Buffer.isBuffer(buffer)\r\n                ? new BufferReader(buffer)\r\n                /* istanbul ignore next */\r\n                : create_array(buffer);\r\n        })(buffer);\r\n    }\r\n    /* istanbul ignore next */\r\n    : create_array;\r\n\r\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\r\n\r\n/**\r\n * Reads a varint as an unsigned 32 bit value.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.uint32 = (function read_uint32_setup() {\r\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\r\n    return function read_uint32() {\r\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\r\n\r\n        /* istanbul ignore if */\r\n        if ((this.pos += 5) > this.len) {\r\n            this.pos = this.len;\r\n            throw indexOutOfRange(this, 10);\r\n        }\r\n        return value;\r\n    };\r\n})();\r\n\r\n/**\r\n * Reads a varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.int32 = function read_int32() {\r\n    return this.uint32() | 0;\r\n};\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 32 bit value.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sint32 = function read_sint32() {\r\n    var value = this.uint32();\r\n    return value >>> 1 ^ -(value & 1) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readLongVarint() {\r\n    // tends to deopt with local vars for octet etc.\r\n    var bits = new LongBits(0, 0);\r\n    var i = 0;\r\n    if (this.len - this.pos > 4) { // fast route (lo)\r\n        for (; i < 4; ++i) {\r\n            // 1st..4th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 5th\r\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\r\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\r\n        if (this.buf[this.pos++] < 128)\r\n            return bits;\r\n        i = 0;\r\n    } else {\r\n        for (; i < 3; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 1st..3th\r\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n        // 4th\r\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\r\n        return bits;\r\n    }\r\n    if (this.len - this.pos > 4) { // fast route (hi)\r\n        for (; i < 5; ++i) {\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    } else {\r\n        for (; i < 5; ++i) {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n            // 6th..10th\r\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\r\n            if (this.buf[this.pos++] < 128)\r\n                return bits;\r\n        }\r\n    }\r\n    /* istanbul ignore next */\r\n    throw Error(\"invalid varint encoding\");\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads a varint as a signed 64 bit value.\r\n * @name Reader#int64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as an unsigned 64 bit value.\r\n * @name Reader#uint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a zig-zag encoded varint as a signed 64 bit value.\r\n * @name Reader#sint64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a varint as a boolean.\r\n * @returns {boolean} Value read\r\n */\r\nReader.prototype.bool = function read_bool() {\r\n    return this.uint32() !== 0;\r\n};\r\n\r\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\r\n    return (buf[end - 4]\r\n          | buf[end - 3] << 8\r\n          | buf[end - 2] << 16\r\n          | buf[end - 1] << 24) >>> 0;\r\n}\r\n\r\n/**\r\n * Reads fixed 32 bits as an unsigned 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.fixed32 = function read_fixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4);\r\n};\r\n\r\n/**\r\n * Reads fixed 32 bits as a signed 32 bit integer.\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.sfixed32 = function read_sfixed32() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\r\n};\r\n\r\n/* eslint-disable no-invalid-this */\r\n\r\nfunction readFixed64(/* this: Reader */) {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 8);\r\n\r\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\r\n}\r\n\r\n/* eslint-enable no-invalid-this */\r\n\r\n/**\r\n * Reads fixed 64 bits.\r\n * @name Reader#fixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads zig-zag encoded fixed 64 bits.\r\n * @name Reader#sfixed64\r\n * @function\r\n * @returns {Long} Value read\r\n */\r\n\r\n/**\r\n * Reads a float (32 bit) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.float = function read_float() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 4 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readFloatLE(this.buf, this.pos);\r\n    this.pos += 4;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a double (64 bit float) as a number.\r\n * @function\r\n * @returns {number} Value read\r\n */\r\nReader.prototype.double = function read_double() {\r\n\r\n    /* istanbul ignore if */\r\n    if (this.pos + 8 > this.len)\r\n        throw indexOutOfRange(this, 4);\r\n\r\n    var value = util.float.readDoubleLE(this.buf, this.pos);\r\n    this.pos += 8;\r\n    return value;\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @returns {Uint8Array} Value read\r\n */\r\nReader.prototype.bytes = function read_bytes() {\r\n    var length = this.uint32(),\r\n        start  = this.pos,\r\n        end    = this.pos + length;\r\n\r\n    /* istanbul ignore if */\r\n    if (end > this.len)\r\n        throw indexOutOfRange(this, length);\r\n\r\n    this.pos += length;\r\n    if (Array.isArray(this.buf)) // plain array\r\n        return this.buf.slice(start, end);\r\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\r\n        ? new this.buf.constructor(0)\r\n        : this._slice.call(this.buf, start, end);\r\n};\r\n\r\n/**\r\n * Reads a string preceeded by its byte length as a varint.\r\n * @returns {string} Value read\r\n */\r\nReader.prototype.string = function read_string() {\r\n    var bytes = this.bytes();\r\n    return utf8.read(bytes, 0, bytes.length);\r\n};\r\n\r\n/**\r\n * Skips the specified number of bytes if specified, otherwise skips a varint.\r\n * @param {number} [length] Length if known, otherwise a varint is assumed\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skip = function skip(length) {\r\n    if (typeof length === \"number\") {\r\n        /* istanbul ignore if */\r\n        if (this.pos + length > this.len)\r\n            throw indexOutOfRange(this, length);\r\n        this.pos += length;\r\n    } else {\r\n        do {\r\n            /* istanbul ignore if */\r\n            if (this.pos >= this.len)\r\n                throw indexOutOfRange(this);\r\n        } while (this.buf[this.pos++] & 128);\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Skips the next element of the specified wire type.\r\n * @param {number} wireType Wire type received\r\n * @returns {Reader} `this`\r\n */\r\nReader.prototype.skipType = function(wireType) {\r\n    switch (wireType) {\r\n        case 0:\r\n            this.skip();\r\n            break;\r\n        case 1:\r\n            this.skip(8);\r\n            break;\r\n        case 2:\r\n            this.skip(this.uint32());\r\n            break;\r\n        case 3:\r\n            while ((wireType = this.uint32() & 7) !== 4) {\r\n                this.skipType(wireType);\r\n            }\r\n            break;\r\n        case 5:\r\n            this.skip(4);\r\n            break;\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\r\n    }\r\n    return this;\r\n};\r\n\r\nReader._configure = function(BufferReader_) {\r\n    BufferReader = BufferReader_;\r\n\r\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\r\n    util.merge(Reader.prototype, {\r\n\r\n        int64: function read_int64() {\r\n            return readLongVarint.call(this)[fn](false);\r\n        },\r\n\r\n        uint64: function read_uint64() {\r\n            return readLongVarint.call(this)[fn](true);\r\n        },\r\n\r\n        sint64: function read_sint64() {\r\n            return readLongVarint.call(this).zzDecode()[fn](false);\r\n        },\r\n\r\n        fixed64: function read_fixed64() {\r\n            return readFixed64.call(this)[fn](true);\r\n        },\r\n\r\n        sfixed64: function read_sfixed64() {\r\n            return readFixed64.call(this)[fn](false);\r\n        }\r\n\r\n    });\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = BufferReader;\r\n\r\n// extends Reader\r\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\r\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs a new buffer reader instance.\r\n * @classdesc Wire format reader using node buffers.\r\n * @extends Reader\r\n * @constructor\r\n * @param {Buffer} buffer Buffer to read from\r\n */\r\nfunction BufferReader(buffer) {\r\n    Reader.call(this, buffer);\r\n\r\n    /**\r\n     * Read buffer.\r\n     * @name BufferReader#buf\r\n     * @type {Buffer}\r\n     */\r\n}\r\n\r\n/* istanbul ignore else */\r\nif (util.Buffer)\r\n    BufferReader.prototype._slice = util.Buffer.prototype.slice;\r\n\r\n/**\r\n * @override\r\n */\r\nBufferReader.prototype.string = function read_string_buffer() {\r\n    var len = this.uint32(); // modifies pos\r\n    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\r\n};\r\n\r\n/**\r\n * Reads a sequence of bytes preceeded by its length as a varint.\r\n * @name BufferReader#bytes\r\n * @function\r\n * @returns {Buffer} Value read\r\n */\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = {};\r\n\r\n/**\r\n * Named roots.\r\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\r\n * Can also be used manually to make roots available accross modules.\r\n * @name roots\r\n * @type {Object.<string,Root>}\r\n * @example\r\n * // pbjs -r myroot -o compiled.js ...\r\n *\r\n * // in another module:\r\n * require(\"./compiled.js\");\r\n *\r\n * // in any subsequent module:\r\n * var root = protobuf.roots[\"myroot\"];\r\n */\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * Streaming RPC helpers.\r\n * @namespace\r\n */\r\nvar rpc = exports;\r\n\r\n/**\r\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\r\n * @typedef RPCImpl\r\n * @type {function}\r\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\r\n * @param {Uint8Array} requestData Request data\r\n * @param {RPCImplCallback} callback Callback function\r\n * @returns {undefined}\r\n * @example\r\n * function rpcImpl(method, requestData, callback) {\r\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\r\n *         throw Error(\"no such method\");\r\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\r\n *         callback(err, responseData);\r\n *     });\r\n * }\r\n */\r\n\r\n/**\r\n * Node-style callback as used by {@link RPCImpl}.\r\n * @typedef RPCImplCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = Service;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n// Extends EventEmitter\r\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\r\n\r\n/**\r\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\r\n *\r\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\r\n * @typedef rpc.ServiceMethodCallback\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {TRes} [response] Response message\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\r\n * @typedef rpc.ServiceMethod\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n * @type {function}\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\r\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\r\n */\r\n\r\n/**\r\n * Constructs a new RPC service instance.\r\n * @classdesc An RPC service as returned by {@link Service#create}.\r\n * @exports rpc.Service\r\n * @extends util.EventEmitter\r\n * @constructor\r\n * @param {RPCImpl} rpcImpl RPC implementation\r\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\r\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\r\n */\r\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\r\n\r\n    if (typeof rpcImpl !== \"function\")\r\n        throw TypeError(\"rpcImpl must be a function\");\r\n\r\n    util.EventEmitter.call(this);\r\n\r\n    /**\r\n     * RPC implementation. Becomes `null` once the service is ended.\r\n     * @type {RPCImpl|null}\r\n     */\r\n    this.rpcImpl = rpcImpl;\r\n\r\n    /**\r\n     * Whether requests are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.requestDelimited = Boolean(requestDelimited);\r\n\r\n    /**\r\n     * Whether responses are length-delimited.\r\n     * @type {boolean}\r\n     */\r\n    this.responseDelimited = Boolean(responseDelimited);\r\n}\r\n\r\n/**\r\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\r\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\r\n * @param {Constructor<TReq>} requestCtor Request constructor\r\n * @param {Constructor<TRes>} responseCtor Response constructor\r\n * @param {TReq|Properties<TReq>} request Request message or plain object\r\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\r\n * @returns {undefined}\r\n * @template TReq extends Message<TReq>\r\n * @template TRes extends Message<TRes>\r\n */\r\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\r\n\r\n    if (!request)\r\n        throw TypeError(\"request must be specified\");\r\n\r\n    var self = this;\r\n    if (!callback)\r\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\r\n\r\n    if (!self.rpcImpl) {\r\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\r\n        return undefined;\r\n    }\r\n\r\n    try {\r\n        return self.rpcImpl(\r\n            method,\r\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\r\n            function rpcCallback(err, response) {\r\n\r\n                if (err) {\r\n                    self.emit(\"error\", err, method);\r\n                    return callback(err);\r\n                }\r\n\r\n                if (response === null) {\r\n                    self.end(/* endedByRPC */ true);\r\n                    return undefined;\r\n                }\r\n\r\n                if (!(response instanceof responseCtor)) {\r\n                    try {\r\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\r\n                    } catch (err) {\r\n                        self.emit(\"error\", err, method);\r\n                        return callback(err);\r\n                    }\r\n                }\r\n\r\n                self.emit(\"data\", response, method);\r\n                return callback(null, response);\r\n            }\r\n        );\r\n    } catch (err) {\r\n        self.emit(\"error\", err, method);\r\n        setTimeout(function() { callback(err); }, 0);\r\n        return undefined;\r\n    }\r\n};\r\n\r\n/**\r\n * Ends this service and emits the `end` event.\r\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\r\n * @returns {rpc.Service} `this`\r\n */\r\nService.prototype.end = function end(endedByRPC) {\r\n    if (this.rpcImpl) {\r\n        if (!endedByRPC) // signal end to rpcImpl\r\n            this.rpcImpl(null, null, null);\r\n        this.rpcImpl = null;\r\n        this.emit(\"end\").off();\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = LongBits;\r\n\r\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\n/**\r\n * Constructs new long bits.\r\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\r\n * @memberof util\r\n * @constructor\r\n * @param {number} lo Low 32 bits, unsigned\r\n * @param {number} hi High 32 bits, unsigned\r\n */\r\nfunction LongBits(lo, hi) {\r\n\r\n    // note that the casts below are theoretically unnecessary as of today, but older statically\r\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\r\n\r\n    /**\r\n     * Low bits.\r\n     * @type {number}\r\n     */\r\n    this.lo = lo >>> 0;\r\n\r\n    /**\r\n     * High bits.\r\n     * @type {number}\r\n     */\r\n    this.hi = hi >>> 0;\r\n}\r\n\r\n/**\r\n * Zero bits.\r\n * @memberof util.LongBits\r\n * @type {util.LongBits}\r\n */\r\nvar zero = LongBits.zero = new LongBits(0, 0);\r\n\r\nzero.toNumber = function() { return 0; };\r\nzero.zzEncode = zero.zzDecode = function() { return this; };\r\nzero.length = function() { return 1; };\r\n\r\n/**\r\n * Zero hash.\r\n * @memberof util.LongBits\r\n * @type {string}\r\n */\r\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\r\n\r\n/**\r\n * Constructs new long bits from the specified number.\r\n * @param {number} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.fromNumber = function fromNumber(value) {\r\n    if (value === 0)\r\n        return zero;\r\n    var sign = value < 0;\r\n    if (sign)\r\n        value = -value;\r\n    var lo = value >>> 0,\r\n        hi = (value - lo) / 4294967296 >>> 0;\r\n    if (sign) {\r\n        hi = ~hi >>> 0;\r\n        lo = ~lo >>> 0;\r\n        if (++lo > 4294967295) {\r\n            lo = 0;\r\n            if (++hi > 4294967295)\r\n                hi = 0;\r\n        }\r\n    }\r\n    return new LongBits(lo, hi);\r\n};\r\n\r\n/**\r\n * Constructs new long bits from a number, long or string.\r\n * @param {Long|number|string} value Value\r\n * @returns {util.LongBits} Instance\r\n */\r\nLongBits.from = function from(value) {\r\n    if (typeof value === \"number\")\r\n        return LongBits.fromNumber(value);\r\n    if (util.isString(value)) {\r\n        /* istanbul ignore else */\r\n        if (util.Long)\r\n            value = util.Long.fromString(value);\r\n        else\r\n            return LongBits.fromNumber(parseInt(value, 10));\r\n    }\r\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a possibly unsafe JavaScript number.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {number} Possibly unsafe number\r\n */\r\nLongBits.prototype.toNumber = function toNumber(unsigned) {\r\n    if (!unsigned && this.hi >>> 31) {\r\n        var lo = ~this.lo + 1 >>> 0,\r\n            hi = ~this.hi     >>> 0;\r\n        if (!lo)\r\n            hi = hi + 1 >>> 0;\r\n        return -(lo + hi * 4294967296);\r\n    }\r\n    return this.lo + this.hi * 4294967296;\r\n};\r\n\r\n/**\r\n * Converts this long bits to a long.\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long} Long\r\n */\r\nLongBits.prototype.toLong = function toLong(unsigned) {\r\n    return util.Long\r\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\r\n        /* istanbul ignore next */\r\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\r\n};\r\n\r\nvar charCodeAt = String.prototype.charCodeAt;\r\n\r\n/**\r\n * Constructs new long bits from the specified 8 characters long hash.\r\n * @param {string} hash Hash\r\n * @returns {util.LongBits} Bits\r\n */\r\nLongBits.fromHash = function fromHash(hash) {\r\n    if (hash === zeroHash)\r\n        return zero;\r\n    return new LongBits(\r\n        ( charCodeAt.call(hash, 0)\r\n        | charCodeAt.call(hash, 1) << 8\r\n        | charCodeAt.call(hash, 2) << 16\r\n        | charCodeAt.call(hash, 3) << 24) >>> 0\r\n    ,\r\n        ( charCodeAt.call(hash, 4)\r\n        | charCodeAt.call(hash, 5) << 8\r\n        | charCodeAt.call(hash, 6) << 16\r\n        | charCodeAt.call(hash, 7) << 24) >>> 0\r\n    );\r\n};\r\n\r\n/**\r\n * Converts this long bits to a 8 characters long hash.\r\n * @returns {string} Hash\r\n */\r\nLongBits.prototype.toHash = function toHash() {\r\n    return String.fromCharCode(\r\n        this.lo        & 255,\r\n        this.lo >>> 8  & 255,\r\n        this.lo >>> 16 & 255,\r\n        this.lo >>> 24      ,\r\n        this.hi        & 255,\r\n        this.hi >>> 8  & 255,\r\n        this.hi >>> 16 & 255,\r\n        this.hi >>> 24\r\n    );\r\n};\r\n\r\n/**\r\n * Zig-zag encodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzEncode = function zzEncode() {\r\n    var mask =   this.hi >> 31;\r\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\r\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Zig-zag decodes this long bits.\r\n * @returns {util.LongBits} `this`\r\n */\r\nLongBits.prototype.zzDecode = function zzDecode() {\r\n    var mask = -(this.lo & 1);\r\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\r\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Calculates the length of this longbits when encoded as a varint.\r\n * @returns {number} Length\r\n */\r\nLongBits.prototype.length = function length() {\r\n    var part0 =  this.lo,\r\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\r\n        part2 =  this.hi >>> 24;\r\n    return part2 === 0\r\n         ? part1 === 0\r\n           ? part0 < 16384\r\n             ? part0 < 128 ? 1 : 2\r\n             : part0 < 2097152 ? 3 : 4\r\n           : part1 < 16384\r\n             ? part1 < 128 ? 5 : 6\r\n             : part1 < 2097152 ? 7 : 8\r\n         : part2 < 128 ? 9 : 10;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar util = exports;\r\n\r\n// used to return a Promise where callback is omitted\r\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\r\n\r\n// converts to / from base64 encoded strings\r\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\r\n\r\n// base class of rpc.Service\r\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\r\n\r\n// float handling accross browsers\r\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\r\n\r\n// requires modules optionally and hides the call from bundlers\r\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\r\n\r\n// converts to / from utf8 encoded strings\r\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\r\n\r\n// provides a node-like buffer pool in the browser\r\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\r\n\r\n// utility to work with the low and high bits of a 64 bit value\r\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\r\n\r\n// global object reference\r\nutil.global = typeof window !== \"undefined\" && window\r\n           || typeof global !== \"undefined\" && global\r\n           || typeof self   !== \"undefined\" && self\r\n           || this; // eslint-disable-line no-invalid-this\r\n\r\n/**\r\n * An immuable empty array.\r\n * @memberof util\r\n * @type {Array.<*>}\r\n * @const\r\n */\r\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\r\n\r\n/**\r\n * An immutable empty object.\r\n * @type {Object}\r\n * @const\r\n */\r\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\r\n\r\n/**\r\n * Whether running within node or not.\r\n * @memberof util\r\n * @type {boolean}\r\n * @const\r\n */\r\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\r\n\r\n/**\r\n * Tests if the specified value is an integer.\r\n * @function\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is an integer\r\n */\r\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\r\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a string.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a string\r\n */\r\nutil.isString = function isString(value) {\r\n    return typeof value === \"string\" || value instanceof String;\r\n};\r\n\r\n/**\r\n * Tests if the specified value is a non-null object.\r\n * @param {*} value Value to test\r\n * @returns {boolean} `true` if the value is a non-null object\r\n */\r\nutil.isObject = function isObject(value) {\r\n    return value && typeof value === \"object\";\r\n};\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * This is an alias of {@link util.isSet}.\r\n * @function\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isset =\r\n\r\n/**\r\n * Checks if a property on a message is considered to be present.\r\n * @param {Object} obj Plain object or message instance\r\n * @param {string} prop Property name\r\n * @returns {boolean} `true` if considered to be present, otherwise `false`\r\n */\r\nutil.isSet = function isSet(obj, prop) {\r\n    var value = obj[prop];\r\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\r\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\r\n    return false;\r\n};\r\n\r\n/**\r\n * Any compatible Buffer instance.\r\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\r\n * @interface Buffer\r\n * @extends Uint8Array\r\n */\r\n\r\n/**\r\n * Node's Buffer class if available.\r\n * @type {Constructor<Buffer>}\r\n */\r\nutil.Buffer = (function() {\r\n    try {\r\n        var Buffer = util.inquire(\"buffer\").Buffer;\r\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\r\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\r\n    } catch (e) {\r\n        /* istanbul ignore next */\r\n        return null;\r\n    }\r\n})();\r\n\r\n// Internal alias of or polyfull for Buffer.from.\r\nutil._Buffer_from = null;\r\n\r\n// Internal alias of or polyfill for Buffer.allocUnsafe.\r\nutil._Buffer_allocUnsafe = null;\r\n\r\n/**\r\n * Creates a new buffer of whatever type supported by the environment.\r\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\r\n * @returns {Uint8Array|Buffer} Buffer\r\n */\r\nutil.newBuffer = function newBuffer(sizeOrArray) {\r\n    /* istanbul ignore next */\r\n    return typeof sizeOrArray === \"number\"\r\n        ? util.Buffer\r\n            ? util._Buffer_allocUnsafe(sizeOrArray)\r\n            : new util.Array(sizeOrArray)\r\n        : util.Buffer\r\n            ? util._Buffer_from(sizeOrArray)\r\n            : typeof Uint8Array === \"undefined\"\r\n                ? sizeOrArray\r\n                : new Uint8Array(sizeOrArray);\r\n};\r\n\r\n/**\r\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\r\n * @type {Constructor<Uint8Array>}\r\n */\r\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\r\n\r\n/**\r\n * Any compatible Long instance.\r\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\r\n * @interface Long\r\n * @property {number} low Low bits\r\n * @property {number} high High bits\r\n * @property {boolean} unsigned Whether unsigned or not\r\n */\r\n\r\n/**\r\n * Long.js's Long class if available.\r\n * @type {Constructor<Long>}\r\n */\r\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\r\n         || /* istanbul ignore next */ util.global.Long\r\n         || util.inquire(\"long\");\r\n\r\n/**\r\n * Regular expression used to verify 2 bit (`bool`) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key2Re = /^true|false|0|1$/;\r\n\r\n/**\r\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\r\n\r\n/**\r\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\r\n * @type {RegExp}\r\n * @const\r\n */\r\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\r\n\r\n/**\r\n * Converts a number or long to an 8 characters long hash string.\r\n * @param {Long|number} value Value to convert\r\n * @returns {string} Hash\r\n */\r\nutil.longToHash = function longToHash(value) {\r\n    return value\r\n        ? util.LongBits.from(value).toHash()\r\n        : util.LongBits.zeroHash;\r\n};\r\n\r\n/**\r\n * Converts an 8 characters long hash string to a long or number.\r\n * @param {string} hash Hash\r\n * @param {boolean} [unsigned=false] Whether unsigned or not\r\n * @returns {Long|number} Original value\r\n */\r\nutil.longFromHash = function longFromHash(hash, unsigned) {\r\n    var bits = util.LongBits.fromHash(hash);\r\n    if (util.Long)\r\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\r\n    return bits.toNumber(Boolean(unsigned));\r\n};\r\n\r\n/**\r\n * Merges the properties of the source object into the destination object.\r\n * @memberof util\r\n * @param {Object.<string,*>} dst Destination object\r\n * @param {Object.<string,*>} src Source object\r\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\r\n * @returns {Object.<string,*>} Destination object\r\n */\r\nfunction merge(dst, src, ifNotSet) { // used by converters\r\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\r\n        if (dst[keys[i]] === undefined || !ifNotSet)\r\n            dst[keys[i]] = src[keys[i]];\r\n    return dst;\r\n}\r\n\r\nutil.merge = merge;\r\n\r\n/**\r\n * Converts the first character of a string to lower case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\r\nutil.lcFirst = function lcFirst(str) {\r\n    return str.charAt(0).toLowerCase() + str.substring(1);\r\n};\r\n\r\n/**\r\n * Creates a custom error constructor.\r\n * @memberof util\r\n * @param {string} name Error name\r\n * @returns {Constructor<Error>} Custom error constructor\r\n */\r\nfunction newError(name) {\r\n\r\n    function CustomError(message, properties) {\r\n\r\n        if (!(this instanceof CustomError))\r\n            return new CustomError(message, properties);\r\n\r\n        // Error.call(this, message);\r\n        // ^ just returns a new error instance because the ctor can be called as a function\r\n\r\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\r\n\r\n        /* istanbul ignore next */\r\n        if (Error.captureStackTrace) // node\r\n            Error.captureStackTrace(this, CustomError);\r\n        else\r\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\r\n\r\n        if (properties)\r\n            merge(this, properties);\r\n    }\r\n\r\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\r\n\r\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\r\n\r\n    CustomError.prototype.toString = function toString() {\r\n        return this.name + \": \" + this.message;\r\n    };\r\n\r\n    return CustomError;\r\n}\r\n\r\nutil.newError = newError;\r\n\r\n/**\r\n * Constructs a new protocol error.\r\n * @classdesc Error subclass indicating a protocol specifc error.\r\n * @memberof util\r\n * @extends Error\r\n * @template T extends Message<T>\r\n * @constructor\r\n * @param {string} message Error message\r\n * @param {Object.<string,*>} [properties] Additional properties\r\n * @example\r\n * try {\r\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\r\n * } catch (e) {\r\n *     if (e instanceof ProtocolError && e.instance)\r\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\r\n * }\r\n */\r\nutil.ProtocolError = newError(\"ProtocolError\");\r\n\r\n/**\r\n * So far decoded message instance.\r\n * @name util.ProtocolError#instance\r\n * @type {Message<T>}\r\n */\r\n\r\n/**\r\n * A OneOf getter as returned by {@link util.oneOfGetter}.\r\n * @typedef OneOfGetter\r\n * @type {function}\r\n * @returns {string|undefined} Set field name, if any\r\n */\r\n\r\n/**\r\n * Builds a getter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfGetter} Unbound getter\r\n */\r\nutil.oneOfGetter = function getOneOf(fieldNames) {\r\n    var fieldMap = {};\r\n    for (var i = 0; i < fieldNames.length; ++i)\r\n        fieldMap[fieldNames[i]] = 1;\r\n\r\n    /**\r\n     * @returns {string|undefined} Set field name, if any\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function() { // eslint-disable-line consistent-return\r\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\r\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\r\n                return keys[i];\r\n    };\r\n};\r\n\r\n/**\r\n * A OneOf setter as returned by {@link util.oneOfSetter}.\r\n * @typedef OneOfSetter\r\n * @type {function}\r\n * @param {string|undefined} value Field name\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Builds a setter for a oneof's present field name.\r\n * @param {string[]} fieldNames Field names\r\n * @returns {OneOfSetter} Unbound setter\r\n */\r\nutil.oneOfSetter = function setOneOf(fieldNames) {\r\n\r\n    /**\r\n     * @param {string} name Field name\r\n     * @returns {undefined}\r\n     * @this Object\r\n     * @ignore\r\n     */\r\n    return function(name) {\r\n        for (var i = 0; i < fieldNames.length; ++i)\r\n            if (fieldNames[i] !== name)\r\n                delete this[fieldNames[i]];\r\n    };\r\n};\r\n\r\n/**\r\n * Default conversion options used for {@link Message#toJSON} implementations.\r\n *\r\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\r\n *\r\n * - Longs become strings\r\n * - Enums become string keys\r\n * - Bytes become base64 encoded strings\r\n * - (Sub-)Messages become plain objects\r\n * - Maps become plain objects with all string keys\r\n * - Repeated fields become arrays\r\n * - NaN and Infinity for float and double fields become strings\r\n *\r\n * @type {IConversionOptions}\r\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\r\n */\r\nutil.toJSONOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    bytes: String,\r\n    json: true\r\n};\r\n\r\n// Sets up buffer utility according to the environment (called in index-minimal)\r\nutil._configure = function() {\r\n    var Buffer = util.Buffer;\r\n    /* istanbul ignore if */\r\n    if (!Buffer) {\r\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\r\n        return;\r\n    }\r\n    // because node 4.x buffers are incompatible & immutable\r\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\r\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\r\n        /* istanbul ignore next */\r\n        function Buffer_from(value, encoding) {\r\n            return new Buffer(value, encoding);\r\n        };\r\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\r\n        /* istanbul ignore next */\r\n        function Buffer_allocUnsafe(size) {\r\n            return new Buffer(size);\r\n        };\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = Writer;\r\n\r\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar BufferWriter; // cyclic\r\n\r\nvar LongBits  = util.LongBits,\r\n    base64    = util.base64,\r\n    utf8      = util.utf8;\r\n\r\n/**\r\n * Constructs a new writer operation instance.\r\n * @classdesc Scheduled writer operation.\r\n * @constructor\r\n * @param {function(*, Uint8Array, number)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {*} val Value to write\r\n * @ignore\r\n */\r\nfunction Op(fn, len, val) {\r\n\r\n    /**\r\n     * Function to call.\r\n     * @type {function(Uint8Array, number, *)}\r\n     */\r\n    this.fn = fn;\r\n\r\n    /**\r\n     * Value byte length.\r\n     * @type {number}\r\n     */\r\n    this.len = len;\r\n\r\n    /**\r\n     * Next operation.\r\n     * @type {Writer.Op|undefined}\r\n     */\r\n    this.next = undefined;\r\n\r\n    /**\r\n     * Value to write.\r\n     * @type {*}\r\n     */\r\n    this.val = val; // type varies\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction noop() {} // eslint-disable-line no-empty-function\r\n\r\n/**\r\n * Constructs a new writer state instance.\r\n * @classdesc Copied writer state.\r\n * @memberof Writer\r\n * @constructor\r\n * @param {Writer} writer Writer to copy state from\r\n * @ignore\r\n */\r\nfunction State(writer) {\r\n\r\n    /**\r\n     * Current head.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.head = writer.head;\r\n\r\n    /**\r\n     * Current tail.\r\n     * @type {Writer.Op}\r\n     */\r\n    this.tail = writer.tail;\r\n\r\n    /**\r\n     * Current buffer length.\r\n     * @type {number}\r\n     */\r\n    this.len = writer.len;\r\n\r\n    /**\r\n     * Next state.\r\n     * @type {State|null}\r\n     */\r\n    this.next = writer.states;\r\n}\r\n\r\n/**\r\n * Constructs a new writer instance.\r\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\r\n * @constructor\r\n */\r\nfunction Writer() {\r\n\r\n    /**\r\n     * Current length.\r\n     * @type {number}\r\n     */\r\n    this.len = 0;\r\n\r\n    /**\r\n     * Operations head.\r\n     * @type {Object}\r\n     */\r\n    this.head = new Op(noop, 0, 0);\r\n\r\n    /**\r\n     * Operations tail\r\n     * @type {Object}\r\n     */\r\n    this.tail = this.head;\r\n\r\n    /**\r\n     * Linked forked states.\r\n     * @type {Object|null}\r\n     */\r\n    this.states = null;\r\n\r\n    // When a value is written, the writer calculates its byte length and puts it into a linked\r\n    // list of operations to perform when finish() is called. This both allows us to allocate\r\n    // buffers of the exact required size and reduces the amount of work we have to do compared\r\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\r\n    // part is just a linked list walk calling operations with already prepared values.\r\n}\r\n\r\n/**\r\n * Creates a new writer.\r\n * @function\r\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\r\n */\r\nWriter.create = util.Buffer\r\n    ? function create_buffer_setup() {\r\n        return (Writer.create = function create_buffer() {\r\n            return new BufferWriter();\r\n        })();\r\n    }\r\n    /* istanbul ignore next */\r\n    : function create_array() {\r\n        return new Writer();\r\n    };\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\nWriter.alloc = function alloc(size) {\r\n    return new util.Array(size);\r\n};\r\n\r\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\r\n/* istanbul ignore else */\r\nif (util.Array !== Array)\r\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\r\n\r\n/**\r\n * Pushes a new operation to the queue.\r\n * @param {function(Uint8Array, number, *)} fn Function to call\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @returns {Writer} `this`\r\n * @private\r\n */\r\nWriter.prototype._push = function push(fn, len, val) {\r\n    this.tail = this.tail.next = new Op(fn, len, val);\r\n    this.len += len;\r\n    return this;\r\n};\r\n\r\nfunction writeByte(val, buf, pos) {\r\n    buf[pos] = val & 255;\r\n}\r\n\r\nfunction writeVarint32(val, buf, pos) {\r\n    while (val > 127) {\r\n        buf[pos++] = val & 127 | 128;\r\n        val >>>= 7;\r\n    }\r\n    buf[pos] = val;\r\n}\r\n\r\n/**\r\n * Constructs a new varint writer operation instance.\r\n * @classdesc Scheduled varint writer operation.\r\n * @extends Op\r\n * @constructor\r\n * @param {number} len Value byte length\r\n * @param {number} val Value to write\r\n * @ignore\r\n */\r\nfunction VarintOp(len, val) {\r\n    this.len = len;\r\n    this.next = undefined;\r\n    this.val = val;\r\n}\r\n\r\nVarintOp.prototype = Object.create(Op.prototype);\r\nVarintOp.prototype.fn = writeVarint32;\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as a varint.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.uint32 = function write_uint32(value) {\r\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\r\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\r\n    this.len += (this.tail = this.tail.next = new VarintOp(\r\n        (value = value >>> 0)\r\n                < 128       ? 1\r\n        : value < 16384     ? 2\r\n        : value < 2097152   ? 3\r\n        : value < 268435456 ? 4\r\n        :                     5,\r\n    value)).len;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as a varint.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.int32 = function write_int32(value) {\r\n    return value < 0\r\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\r\n        : this.uint32(value);\r\n};\r\n\r\n/**\r\n * Writes a 32 bit value as a varint, zig-zag encoded.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sint32 = function write_sint32(value) {\r\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\r\n};\r\n\r\nfunction writeVarint64(val, buf, pos) {\r\n    while (val.hi) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\r\n        val.hi >>>= 7;\r\n    }\r\n    while (val.lo > 127) {\r\n        buf[pos++] = val.lo & 127 | 128;\r\n        val.lo = val.lo >>> 7;\r\n    }\r\n    buf[pos++] = val.lo;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as a varint.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.uint64 = function write_uint64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.int64 = Writer.prototype.uint64;\r\n\r\n/**\r\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sint64 = function write_sint64(value) {\r\n    var bits = LongBits.from(value).zzEncode();\r\n    return this._push(writeVarint64, bits.length(), bits);\r\n};\r\n\r\n/**\r\n * Writes a boolish value as a varint.\r\n * @param {boolean} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bool = function write_bool(value) {\r\n    return this._push(writeByte, 1, value ? 1 : 0);\r\n};\r\n\r\nfunction writeFixed32(val, buf, pos) {\r\n    buf[pos    ] =  val         & 255;\r\n    buf[pos + 1] =  val >>> 8   & 255;\r\n    buf[pos + 2] =  val >>> 16  & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\n/**\r\n * Writes an unsigned 32 bit value as fixed 32 bits.\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fixed32 = function write_fixed32(value) {\r\n    return this._push(writeFixed32, 4, value >>> 0);\r\n};\r\n\r\n/**\r\n * Writes a signed 32 bit value as fixed 32 bits.\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\r\n\r\n/**\r\n * Writes an unsigned 64 bit value as fixed 64 bits.\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.fixed64 = function write_fixed64(value) {\r\n    var bits = LongBits.from(value);\r\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\r\n};\r\n\r\n/**\r\n * Writes a signed 64 bit value as fixed 64 bits.\r\n * @function\r\n * @param {Long|number|string} value Value to write\r\n * @returns {Writer} `this`\r\n * @throws {TypeError} If `value` is a string and no long library is present.\r\n */\r\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\r\n\r\n/**\r\n * Writes a float (32 bit).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.float = function write_float(value) {\r\n    return this._push(util.float.writeFloatLE, 4, value);\r\n};\r\n\r\n/**\r\n * Writes a double (64 bit float).\r\n * @function\r\n * @param {number} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.double = function write_double(value) {\r\n    return this._push(util.float.writeDoubleLE, 8, value);\r\n};\r\n\r\nvar writeBytes = util.Array.prototype.set\r\n    ? function writeBytes_set(val, buf, pos) {\r\n        buf.set(val, pos); // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytes_for(val, buf, pos) {\r\n        for (var i = 0; i < val.length; ++i)\r\n            buf[pos + i] = val[i];\r\n    };\r\n\r\n/**\r\n * Writes a sequence of bytes.\r\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.bytes = function write_bytes(value) {\r\n    var len = value.length >>> 0;\r\n    if (!len)\r\n        return this._push(writeByte, 1, 0);\r\n    if (util.isString(value)) {\r\n        var buf = Writer.alloc(len = base64.length(value));\r\n        base64.decode(value, buf, 0);\r\n        value = buf;\r\n    }\r\n    return this.uint32(len)._push(writeBytes, len, value);\r\n};\r\n\r\n/**\r\n * Writes a string.\r\n * @param {string} value Value to write\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.string = function write_string(value) {\r\n    var len = utf8.length(value);\r\n    return len\r\n        ? this.uint32(len)._push(utf8.write, len, value)\r\n        : this._push(writeByte, 1, 0);\r\n};\r\n\r\n/**\r\n * Forks this writer's state by pushing it to a stack.\r\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.fork = function fork() {\r\n    this.states = new State(this);\r\n    this.head = this.tail = new Op(noop, 0, 0);\r\n    this.len = 0;\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets this instance to the last state.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.reset = function reset() {\r\n    if (this.states) {\r\n        this.head   = this.states.head;\r\n        this.tail   = this.states.tail;\r\n        this.len    = this.states.len;\r\n        this.states = this.states.next;\r\n    } else {\r\n        this.head = this.tail = new Op(noop, 0, 0);\r\n        this.len  = 0;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\r\n * @returns {Writer} `this`\r\n */\r\nWriter.prototype.ldelim = function ldelim() {\r\n    var head = this.head,\r\n        tail = this.tail,\r\n        len  = this.len;\r\n    this.reset().uint32(len);\r\n    if (len) {\r\n        this.tail.next = head.next; // skip noop\r\n        this.tail = tail;\r\n        this.len += len;\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @returns {Uint8Array} Finished buffer\r\n */\r\nWriter.prototype.finish = function finish() {\r\n    var head = this.head.next, // skip noop\r\n        buf  = this.constructor.alloc(this.len),\r\n        pos  = 0;\r\n    while (head) {\r\n        head.fn(head.val, buf, pos);\r\n        pos += head.len;\r\n        head = head.next;\r\n    }\r\n    // this.head = this.tail = null;\r\n    return buf;\r\n};\r\n\r\nWriter._configure = function(BufferWriter_) {\r\n    BufferWriter = BufferWriter_;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = BufferWriter;\r\n\r\n// extends Writer\r\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\r\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\r\n\r\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\r\n\r\nvar Buffer = util.Buffer;\r\n\r\n/**\r\n * Constructs a new buffer writer instance.\r\n * @classdesc Wire format writer using node buffers.\r\n * @extends Writer\r\n * @constructor\r\n */\r\nfunction BufferWriter() {\r\n    Writer.call(this);\r\n}\r\n\r\n/**\r\n * Allocates a buffer of the specified size.\r\n * @param {number} size Buffer size\r\n * @returns {Buffer} Buffer\r\n */\r\nBufferWriter.alloc = function alloc_buffer(size) {\r\n    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\r\n};\r\n\r\nvar writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === \"set\"\r\n    ? function writeBytesBuffer_set(val, buf, pos) {\r\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\r\n                           // also works for plain array values\r\n    }\r\n    /* istanbul ignore next */\r\n    : function writeBytesBuffer_copy(val, buf, pos) {\r\n        if (val.copy) // Buffer values\r\n            val.copy(buf, pos, 0, val.length);\r\n        else for (var i = 0; i < val.length;) // plain array values\r\n            buf[pos++] = val[i++];\r\n    };\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\r\n    if (util.isString(value))\r\n        value = util._Buffer_from(value, \"base64\");\r\n    var len = value.length >>> 0;\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeBytesBuffer, len, value);\r\n    return this;\r\n};\r\n\r\nfunction writeStringBuffer(val, buf, pos) {\r\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\r\n        util.utf8.write(val, buf, pos);\r\n    else\r\n        buf.utf8Write(val, pos);\r\n}\r\n\r\n/**\r\n * @override\r\n */\r\nBufferWriter.prototype.string = function write_string_buffer(value) {\r\n    var len = Buffer.byteLength(value);\r\n    this.uint32(len);\r\n    if (len)\r\n        this._push(writeStringBuffer, len, value);\r\n    return this;\r\n};\r\n\r\n\r\n/**\r\n * Finishes the write operation.\r\n * @name BufferWriter#finish\r\n * @function\r\n * @returns {Buffer} Finished buffer\r\n */\r\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/retry */ \"./node_modules/retry/lib/retry.js\");\n\n//# sourceURL=webpack:///./node_modules/retry/index.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var RetryOperation = __webpack_require__(/*! ./retry_operation */ \"./node_modules/retry/lib/retry_operation.js\");\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && options.forever,\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts;\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(this._errors.length - 1, this._errors.length);\n      this._timeouts = this._cachedTimeouts.slice(0);\n      timeout = this._timeouts.shift();\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  var timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry_operation.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/client.js":
/*!****************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/client.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _global = typeof global !== 'undefined' ? global : (typeof window !== 'undefined' ? window : {});\nvar NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\nvar Backoff = __webpack_require__(/*! backo2 */ \"./node_modules/backo2/index.js\");\nvar eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nvar is_string_1 = __webpack_require__(/*! ./utils/is-string */ \"./node_modules/subscriptions-transport-ws/dist/utils/is-string.js\");\nvar is_object_1 = __webpack_require__(/*! ./utils/is-object */ \"./node_modules/subscriptions-transport-ws/dist/utils/is-object.js\");\nvar printer_1 = __webpack_require__(/*! graphql/language/printer */ \"./node_modules/graphql/language/printer.js\");\nvar getOperationAST_1 = __webpack_require__(/*! graphql/utilities/getOperationAST */ \"./node_modules/graphql/utilities/getOperationAST.js\");\nvar symbol_observable_1 = __webpack_require__(/*! symbol-observable */ \"symbol-observable\");\nvar protocol_1 = __webpack_require__(/*! ./protocol */ \"./node_modules/subscriptions-transport-ws/dist/protocol.js\");\nvar defaults_1 = __webpack_require__(/*! ./defaults */ \"./node_modules/subscriptions-transport-ws/dist/defaults.js\");\nvar message_types_1 = __webpack_require__(/*! ./message-types */ \"./node_modules/subscriptions-transport-ws/dist/message-types.js\");\nvar SubscriptionClient = (function () {\n    function SubscriptionClient(url, options, webSocketImpl) {\n        var _a = (options || {}), _b = _a.connectionCallback, connectionCallback = _b === void 0 ? undefined : _b, _c = _a.connectionParams, connectionParams = _c === void 0 ? {} : _c, _d = _a.timeout, timeout = _d === void 0 ? defaults_1.WS_TIMEOUT : _d, _e = _a.reconnect, reconnect = _e === void 0 ? false : _e, _f = _a.reconnectionAttempts, reconnectionAttempts = _f === void 0 ? Infinity : _f, _g = _a.lazy, lazy = _g === void 0 ? false : _g, _h = _a.inactivityTimeout, inactivityTimeout = _h === void 0 ? 0 : _h;\n        this.wsImpl = webSocketImpl || NativeWebSocket;\n        if (!this.wsImpl) {\n            throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n        }\n        this.connectionCallback = connectionCallback;\n        this.url = url;\n        this.operations = {};\n        this.nextOperationId = 0;\n        this.wsTimeout = timeout;\n        this.unsentMessagesQueue = [];\n        this.reconnect = reconnect;\n        this.reconnecting = false;\n        this.reconnectionAttempts = reconnectionAttempts;\n        this.lazy = !!lazy;\n        this.inactivityTimeout = inactivityTimeout;\n        this.closedByUser = false;\n        this.backoff = new Backoff({ jitter: 0.5 });\n        this.eventEmitter = new eventemitter3_1.EventEmitter();\n        this.middlewares = [];\n        this.client = null;\n        this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n        this.connectionParams = this.getConnectionParams(connectionParams);\n        if (!this.lazy) {\n            this.connect();\n        }\n    }\n    Object.defineProperty(SubscriptionClient.prototype, \"status\", {\n        get: function () {\n            if (this.client === null) {\n                return this.wsImpl.CLOSED;\n            }\n            return this.client.readyState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SubscriptionClient.prototype.close = function (isForced, closedByUser) {\n        if (isForced === void 0) { isForced = true; }\n        if (closedByUser === void 0) { closedByUser = true; }\n        this.clearInactivityTimeout();\n        if (this.client !== null) {\n            this.closedByUser = closedByUser;\n            if (isForced) {\n                this.clearCheckConnectionInterval();\n                this.clearMaxConnectTimeout();\n                this.clearTryReconnectTimeout();\n                this.unsubscribeAll();\n                this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_TERMINATE, null);\n            }\n            this.client.close();\n            this.client = null;\n            this.eventEmitter.emit('disconnected');\n            if (!isForced) {\n                this.tryReconnect();\n            }\n        }\n    };\n    SubscriptionClient.prototype.request = function (request) {\n        var _a;\n        var getObserver = this.getObserver.bind(this);\n        var executeOperation = this.executeOperation.bind(this);\n        var unsubscribe = this.unsubscribe.bind(this);\n        var opId;\n        this.clearInactivityTimeout();\n        return _a = {},\n            _a[symbol_observable_1.default] = function () {\n                return this;\n            },\n            _a.subscribe = function (observerOrNext, onError, onComplete) {\n                var observer = getObserver(observerOrNext, onError, onComplete);\n                opId = executeOperation(request, function (error, result) {\n                    if (error === null && result === null) {\n                        if (observer.complete) {\n                            observer.complete();\n                        }\n                    }\n                    else if (error) {\n                        if (observer.error) {\n                            observer.error(error[0]);\n                        }\n                    }\n                    else {\n                        if (observer.next) {\n                            observer.next(result);\n                        }\n                    }\n                });\n                return {\n                    unsubscribe: function () {\n                        if (opId) {\n                            unsubscribe(opId);\n                            opId = null;\n                        }\n                    },\n                };\n            },\n            _a;\n    };\n    SubscriptionClient.prototype.on = function (eventName, callback, context) {\n        var handler = this.eventEmitter.on(eventName, callback, context);\n        return function () {\n            handler.off(eventName, callback, context);\n        };\n    };\n    SubscriptionClient.prototype.onConnected = function (callback, context) {\n        return this.on('connected', callback, context);\n    };\n    SubscriptionClient.prototype.onConnecting = function (callback, context) {\n        return this.on('connecting', callback, context);\n    };\n    SubscriptionClient.prototype.onDisconnected = function (callback, context) {\n        return this.on('disconnected', callback, context);\n    };\n    SubscriptionClient.prototype.onReconnected = function (callback, context) {\n        return this.on('reconnected', callback, context);\n    };\n    SubscriptionClient.prototype.onReconnecting = function (callback, context) {\n        return this.on('reconnecting', callback, context);\n    };\n    SubscriptionClient.prototype.onError = function (callback, context) {\n        return this.on('error', callback, context);\n    };\n    SubscriptionClient.prototype.unsubscribeAll = function () {\n        var _this = this;\n        Object.keys(this.operations).forEach(function (subId) {\n            _this.unsubscribe(subId);\n        });\n    };\n    SubscriptionClient.prototype.applyMiddlewares = function (options) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var queue = function (funcs, scope) {\n                var next = function (error) {\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        if (funcs.length > 0) {\n                            var f = funcs.shift();\n                            if (f) {\n                                f.applyMiddleware.apply(scope, [options, next]);\n                            }\n                        }\n                        else {\n                            resolve(options);\n                        }\n                    }\n                };\n                next();\n            };\n            queue(_this.middlewares.slice(), _this);\n        });\n    };\n    SubscriptionClient.prototype.use = function (middlewares) {\n        var _this = this;\n        middlewares.map(function (middleware) {\n            if (typeof middleware.applyMiddleware === 'function') {\n                _this.middlewares.push(middleware);\n            }\n            else {\n                throw new Error('Middleware must implement the applyMiddleware function.');\n            }\n        });\n        return this;\n    };\n    SubscriptionClient.prototype.getConnectionParams = function (connectionParams) {\n        return function () { return new Promise(function (resolve, reject) {\n            if (typeof connectionParams === 'function') {\n                try {\n                    return resolve(connectionParams.call(null));\n                }\n                catch (error) {\n                    return reject(error);\n                }\n            }\n            resolve(connectionParams);\n        }); };\n    };\n    SubscriptionClient.prototype.executeOperation = function (options, handler) {\n        var _this = this;\n        if (this.client === null) {\n            this.connect();\n        }\n        var opId = this.generateOperationId();\n        this.operations[opId] = { options: options, handler: handler };\n        this.applyMiddlewares(options)\n            .then(function (processedOptions) {\n            _this.checkOperationOptions(processedOptions, handler);\n            if (_this.operations[opId]) {\n                _this.operations[opId] = { options: processedOptions, handler: handler };\n                _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);\n            }\n        })\n            .catch(function (error) {\n            _this.unsubscribe(opId);\n            handler(_this.formatErrors(error));\n        });\n        return opId;\n    };\n    SubscriptionClient.prototype.getObserver = function (observerOrNext, error, complete) {\n        if (typeof observerOrNext === 'function') {\n            return {\n                next: function (v) { return observerOrNext(v); },\n                error: function (e) { return error && error(e); },\n                complete: function () { return complete && complete(); },\n            };\n        }\n        return observerOrNext;\n    };\n    SubscriptionClient.prototype.createMaxConnectTimeGenerator = function () {\n        var minValue = 1000;\n        var maxValue = this.wsTimeout;\n        return new Backoff({\n            min: minValue,\n            max: maxValue,\n            factor: 1.2,\n        });\n    };\n    SubscriptionClient.prototype.clearCheckConnectionInterval = function () {\n        if (this.checkConnectionIntervalId) {\n            clearInterval(this.checkConnectionIntervalId);\n            this.checkConnectionIntervalId = null;\n        }\n    };\n    SubscriptionClient.prototype.clearMaxConnectTimeout = function () {\n        if (this.maxConnectTimeoutId) {\n            clearTimeout(this.maxConnectTimeoutId);\n            this.maxConnectTimeoutId = null;\n        }\n    };\n    SubscriptionClient.prototype.clearTryReconnectTimeout = function () {\n        if (this.tryReconnectTimeoutId) {\n            clearTimeout(this.tryReconnectTimeoutId);\n            this.tryReconnectTimeoutId = null;\n        }\n    };\n    SubscriptionClient.prototype.clearInactivityTimeout = function () {\n        if (this.inactivityTimeoutId) {\n            clearTimeout(this.inactivityTimeoutId);\n            this.inactivityTimeoutId = null;\n        }\n    };\n    SubscriptionClient.prototype.setInactivityTimeout = function () {\n        var _this = this;\n        if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n            this.inactivityTimeoutId = setTimeout(function () {\n                if (Object.keys(_this.operations).length === 0) {\n                    _this.close();\n                }\n            }, this.inactivityTimeout);\n        }\n    };\n    SubscriptionClient.prototype.checkOperationOptions = function (options, handler) {\n        var query = options.query, variables = options.variables, operationName = options.operationName;\n        if (!query) {\n            throw new Error('Must provide a query.');\n        }\n        if (!handler) {\n            throw new Error('Must provide an handler.');\n        }\n        if ((!is_string_1.default(query) && !getOperationAST_1.getOperationAST(query, operationName)) ||\n            (operationName && !is_string_1.default(operationName)) ||\n            (variables && !is_object_1.default(variables))) {\n            throw new Error('Incorrect option types. query must be a string or a document,' +\n                '`operationName` must be a string, and `variables` must be an object.');\n        }\n    };\n    SubscriptionClient.prototype.buildMessage = function (id, type, payload) {\n        var payloadToReturn = payload && payload.query ? __assign({}, payload, { query: typeof payload.query === 'string' ? payload.query : printer_1.print(payload.query) }) :\n            payload;\n        return {\n            id: id,\n            type: type,\n            payload: payloadToReturn,\n        };\n    };\n    SubscriptionClient.prototype.formatErrors = function (errors) {\n        if (Array.isArray(errors)) {\n            return errors;\n        }\n        if (errors && errors.errors) {\n            return this.formatErrors(errors.errors);\n        }\n        if (errors && errors.message) {\n            return [errors];\n        }\n        return [{\n                name: 'FormatedError',\n                message: 'Unknown error',\n                originalError: errors,\n            }];\n    };\n    SubscriptionClient.prototype.sendMessage = function (id, type, payload) {\n        this.sendMessageRaw(this.buildMessage(id, type, payload));\n    };\n    SubscriptionClient.prototype.sendMessageRaw = function (message) {\n        switch (this.status) {\n            case this.wsImpl.OPEN:\n                var serializedMessage = JSON.stringify(message);\n                try {\n                    JSON.parse(serializedMessage);\n                }\n                catch (e) {\n                    this.eventEmitter.emit('error', new Error(\"Message must be JSON-serializable. Got: \" + message));\n                }\n                this.client.send(serializedMessage);\n                break;\n            case this.wsImpl.CONNECTING:\n                this.unsentMessagesQueue.push(message);\n                break;\n            default:\n                if (!this.reconnecting) {\n                    this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' +\n                        'is already closed. Message was: ' + JSON.stringify(message)));\n                }\n        }\n    };\n    SubscriptionClient.prototype.generateOperationId = function () {\n        return String(++this.nextOperationId);\n    };\n    SubscriptionClient.prototype.tryReconnect = function () {\n        var _this = this;\n        if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n            return;\n        }\n        if (!this.reconnecting) {\n            Object.keys(this.operations).forEach(function (key) {\n                _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));\n            });\n            this.reconnecting = true;\n        }\n        this.clearTryReconnectTimeout();\n        var delay = this.backoff.duration();\n        this.tryReconnectTimeoutId = setTimeout(function () {\n            _this.connect();\n        }, delay);\n    };\n    SubscriptionClient.prototype.flushUnsentMessagesQueue = function () {\n        var _this = this;\n        this.unsentMessagesQueue.forEach(function (message) {\n            _this.sendMessageRaw(message);\n        });\n        this.unsentMessagesQueue = [];\n    };\n    SubscriptionClient.prototype.checkConnection = function () {\n        if (this.wasKeepAliveReceived) {\n            this.wasKeepAliveReceived = false;\n            return;\n        }\n        if (!this.reconnecting) {\n            this.close(false, true);\n        }\n    };\n    SubscriptionClient.prototype.checkMaxConnectTimeout = function () {\n        var _this = this;\n        this.clearMaxConnectTimeout();\n        this.maxConnectTimeoutId = setTimeout(function () {\n            if (_this.status !== _this.wsImpl.OPEN) {\n                _this.reconnecting = true;\n                _this.close(false, true);\n            }\n        }, this.maxConnectTimeGenerator.duration());\n    };\n    SubscriptionClient.prototype.connect = function () {\n        var _this = this;\n        this.client = new this.wsImpl(this.url, protocol_1.GRAPHQL_WS);\n        this.checkMaxConnectTimeout();\n        this.client.onopen = function () { return __awaiter(_this, void 0, void 0, function () {\n            var connectionParams, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.status === this.wsImpl.OPEN)) return [3, 4];\n                        this.clearMaxConnectTimeout();\n                        this.closedByUser = false;\n                        this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4, this.connectionParams()];\n                    case 2:\n                        connectionParams = _a.sent();\n                        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);\n                        this.flushUnsentMessagesQueue();\n                        return [3, 4];\n                    case 3:\n                        error_1 = _a.sent();\n                        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_ERROR, error_1);\n                        this.flushUnsentMessagesQueue();\n                        return [3, 4];\n                    case 4: return [2];\n                }\n            });\n        }); };\n        this.client.onclose = function () {\n            if (!_this.closedByUser) {\n                _this.close(false, false);\n            }\n        };\n        this.client.onerror = function (err) {\n            _this.eventEmitter.emit('error', err);\n        };\n        this.client.onmessage = function (_a) {\n            var data = _a.data;\n            _this.processReceivedData(data);\n        };\n    };\n    SubscriptionClient.prototype.processReceivedData = function (receivedData) {\n        var parsedMessage;\n        var opId;\n        try {\n            parsedMessage = JSON.parse(receivedData);\n            opId = parsedMessage.id;\n        }\n        catch (e) {\n            throw new Error(\"Message must be JSON-parseable. Got: \" + receivedData);\n        }\n        if ([message_types_1.default.GQL_DATA,\n            message_types_1.default.GQL_COMPLETE,\n            message_types_1.default.GQL_ERROR,\n        ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {\n            this.unsubscribe(opId);\n            return;\n        }\n        switch (parsedMessage.type) {\n            case message_types_1.default.GQL_CONNECTION_ERROR:\n                if (this.connectionCallback) {\n                    this.connectionCallback(parsedMessage.payload);\n                }\n                break;\n            case message_types_1.default.GQL_CONNECTION_ACK:\n                this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected');\n                this.reconnecting = false;\n                this.backoff.reset();\n                this.maxConnectTimeGenerator.reset();\n                if (this.connectionCallback) {\n                    this.connectionCallback();\n                }\n                break;\n            case message_types_1.default.GQL_COMPLETE:\n                this.operations[opId].handler(null, null);\n                delete this.operations[opId];\n                break;\n            case message_types_1.default.GQL_ERROR:\n                this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n                delete this.operations[opId];\n                break;\n            case message_types_1.default.GQL_DATA:\n                var parsedPayload = !parsedMessage.payload.errors ?\n                    parsedMessage.payload : __assign({}, parsedMessage.payload, { errors: this.formatErrors(parsedMessage.payload.errors) });\n                this.operations[opId].handler(null, parsedPayload);\n                break;\n            case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:\n                var firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n                this.wasKeepAliveReceived = true;\n                if (firstKA) {\n                    this.checkConnection();\n                }\n                if (this.checkConnectionIntervalId) {\n                    clearInterval(this.checkConnectionIntervalId);\n                    this.checkConnection();\n                }\n                this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n                break;\n            default:\n                throw new Error('Invalid message type!');\n        }\n    };\n    SubscriptionClient.prototype.unsubscribe = function (opId) {\n        if (this.operations[opId]) {\n            delete this.operations[opId];\n            this.setInactivityTimeout();\n            this.sendMessage(opId, message_types_1.default.GQL_STOP, undefined);\n        }\n    };\n    return SubscriptionClient;\n}());\nexports.SubscriptionClient = SubscriptionClient;\n//# sourceMappingURL=client.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/client.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/defaults.js":
/*!******************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/defaults.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar WS_TIMEOUT = 30000;\nexports.WS_TIMEOUT = WS_TIMEOUT;\n//# sourceMappingURL=defaults.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/defaults.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./client */ \"./node_modules/subscriptions-transport-ws/dist/client.js\"));\n__export(__webpack_require__(/*! ./server */ \"./node_modules/subscriptions-transport-ws/dist/server.js\"));\n__export(__webpack_require__(/*! ./message-types */ \"./node_modules/subscriptions-transport-ws/dist/message-types.js\"));\n__export(__webpack_require__(/*! ./protocol */ \"./node_modules/subscriptions-transport-ws/dist/protocol.js\"));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/index.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/legacy/parse-legacy-protocol.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/legacy/parse-legacy-protocol.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar message_types_1 = __webpack_require__(/*! ../message-types */ \"./node_modules/subscriptions-transport-ws/dist/message-types.js\");\nexports.parseLegacyProtocolMessage = function (connectionContext, message) {\n    var messageToReturn = message;\n    switch (message.type) {\n        case message_types_1.default.INIT:\n            connectionContext.isLegacy = true;\n            messageToReturn = __assign({}, message, { type: message_types_1.default.GQL_CONNECTION_INIT });\n            break;\n        case message_types_1.default.SUBSCRIPTION_START:\n            messageToReturn = {\n                id: message.id,\n                type: message_types_1.default.GQL_START,\n                payload: {\n                    query: message.query,\n                    operationName: message.operationName,\n                    variables: message.variables,\n                },\n            };\n            break;\n        case message_types_1.default.SUBSCRIPTION_END:\n            messageToReturn = __assign({}, message, { type: message_types_1.default.GQL_STOP });\n            break;\n        case message_types_1.default.GQL_CONNECTION_ACK:\n            if (connectionContext.isLegacy) {\n                messageToReturn = __assign({}, message, { type: message_types_1.default.INIT_SUCCESS });\n            }\n            break;\n        case message_types_1.default.GQL_CONNECTION_ERROR:\n            if (connectionContext.isLegacy) {\n                messageToReturn = __assign({}, message, { type: message_types_1.default.INIT_FAIL, payload: message.payload.message ? { error: message.payload.message } : message.payload });\n            }\n            break;\n        case message_types_1.default.GQL_ERROR:\n            if (connectionContext.isLegacy) {\n                messageToReturn = __assign({}, message, { type: message_types_1.default.SUBSCRIPTION_FAIL });\n            }\n            break;\n        case message_types_1.default.GQL_DATA:\n            if (connectionContext.isLegacy) {\n                messageToReturn = __assign({}, message, { type: message_types_1.default.SUBSCRIPTION_DATA });\n            }\n            break;\n        case message_types_1.default.GQL_COMPLETE:\n            if (connectionContext.isLegacy) {\n                messageToReturn = null;\n            }\n            break;\n        case message_types_1.default.SUBSCRIPTION_SUCCESS:\n            if (!connectionContext.isLegacy) {\n                messageToReturn = null;\n            }\n            break;\n        default:\n            break;\n    }\n    return messageToReturn;\n};\n//# sourceMappingURL=parse-legacy-protocol.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/legacy/parse-legacy-protocol.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/message-types.js":
/*!***********************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/message-types.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MessageTypes = (function () {\n    function MessageTypes() {\n        throw new Error('Static Class');\n    }\n    MessageTypes.GQL_CONNECTION_INIT = 'connection_init';\n    MessageTypes.GQL_CONNECTION_ACK = 'connection_ack';\n    MessageTypes.GQL_CONNECTION_ERROR = 'connection_error';\n    MessageTypes.GQL_CONNECTION_KEEP_ALIVE = 'ka';\n    MessageTypes.GQL_CONNECTION_TERMINATE = 'connection_terminate';\n    MessageTypes.GQL_START = 'start';\n    MessageTypes.GQL_DATA = 'data';\n    MessageTypes.GQL_ERROR = 'error';\n    MessageTypes.GQL_COMPLETE = 'complete';\n    MessageTypes.GQL_STOP = 'stop';\n    MessageTypes.SUBSCRIPTION_START = 'subscription_start';\n    MessageTypes.SUBSCRIPTION_DATA = 'subscription_data';\n    MessageTypes.SUBSCRIPTION_SUCCESS = 'subscription_success';\n    MessageTypes.SUBSCRIPTION_FAIL = 'subscription_fail';\n    MessageTypes.SUBSCRIPTION_END = 'subscription_end';\n    MessageTypes.INIT = 'init';\n    MessageTypes.INIT_SUCCESS = 'init_success';\n    MessageTypes.INIT_FAIL = 'init_fail';\n    MessageTypes.KEEP_ALIVE = 'keepalive';\n    return MessageTypes;\n}());\nexports.default = MessageTypes;\n//# sourceMappingURL=message-types.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/message-types.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/protocol.js":
/*!******************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/protocol.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GRAPHQL_WS = 'graphql-ws';\nexports.GRAPHQL_WS = GRAPHQL_WS;\nvar GRAPHQL_SUBSCRIPTIONS = 'graphql-subscriptions';\nexports.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;\n//# sourceMappingURL=protocol.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/protocol.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/server.js":
/*!****************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/server.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar WebSocket = __webpack_require__(/*! ws */ \"ws\");\nvar message_types_1 = __webpack_require__(/*! ./message-types */ \"./node_modules/subscriptions-transport-ws/dist/message-types.js\");\nvar protocol_1 = __webpack_require__(/*! ./protocol */ \"./node_modules/subscriptions-transport-ws/dist/protocol.js\");\nvar is_object_1 = __webpack_require__(/*! ./utils/is-object */ \"./node_modules/subscriptions-transport-ws/dist/utils/is-object.js\");\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nvar empty_iterable_1 = __webpack_require__(/*! ./utils/empty-iterable */ \"./node_modules/subscriptions-transport-ws/dist/utils/empty-iterable.js\");\nvar iterall_1 = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\nvar is_subscriptions_1 = __webpack_require__(/*! ./utils/is-subscriptions */ \"./node_modules/subscriptions-transport-ws/dist/utils/is-subscriptions.js\");\nvar parse_legacy_protocol_1 = __webpack_require__(/*! ./legacy/parse-legacy-protocol */ \"./node_modules/subscriptions-transport-ws/dist/legacy/parse-legacy-protocol.js\");\nvar isWebSocketServer = function (socket) { return socket.on; };\nvar SubscriptionServer = (function () {\n    function SubscriptionServer(options, socketOptionsOrServer) {\n        var _this = this;\n        var onOperation = options.onOperation, onOperationComplete = options.onOperationComplete, onConnect = options.onConnect, onDisconnect = options.onDisconnect, keepAlive = options.keepAlive;\n        this.specifiedRules = options.validationRules || graphql_1.specifiedRules;\n        this.loadExecutor(options);\n        this.onOperation = onOperation;\n        this.onOperationComplete = onOperationComplete;\n        this.onConnect = onConnect;\n        this.onDisconnect = onDisconnect;\n        this.keepAlive = keepAlive;\n        if (isWebSocketServer(socketOptionsOrServer)) {\n            this.wsServer = socketOptionsOrServer;\n        }\n        else {\n            this.wsServer = new WebSocket.Server(socketOptionsOrServer || {});\n        }\n        var connectionHandler = (function (socket, request) {\n            socket.upgradeReq = request;\n            if (socket.protocol === undefined ||\n                (socket.protocol.indexOf(protocol_1.GRAPHQL_WS) === -1 && socket.protocol.indexOf(protocol_1.GRAPHQL_SUBSCRIPTIONS) === -1)) {\n                socket.close(1002);\n                return;\n            }\n            var connectionContext = Object.create(null);\n            connectionContext.initPromise = Promise.resolve(true);\n            connectionContext.isLegacy = false;\n            connectionContext.socket = socket;\n            connectionContext.request = request;\n            connectionContext.operations = {};\n            var connectionClosedHandler = function (error) {\n                if (error) {\n                    _this.sendError(connectionContext, '', { message: error.message ? error.message : error }, message_types_1.default.GQL_CONNECTION_ERROR);\n                    setTimeout(function () {\n                        connectionContext.socket.close(1011);\n                    }, 10);\n                }\n                _this.onClose(connectionContext);\n                if (_this.onDisconnect) {\n                    _this.onDisconnect(socket, connectionContext);\n                }\n            };\n            socket.on('error', connectionClosedHandler);\n            socket.on('close', connectionClosedHandler);\n            socket.on('message', _this.onMessage(connectionContext));\n        });\n        this.wsServer.on('connection', connectionHandler);\n        this.closeHandler = function () {\n            _this.wsServer.removeListener('connection', connectionHandler);\n            _this.wsServer.close();\n        };\n    }\n    SubscriptionServer.create = function (options, socketOptionsOrServer) {\n        return new SubscriptionServer(options, socketOptionsOrServer);\n    };\n    Object.defineProperty(SubscriptionServer.prototype, \"server\", {\n        get: function () {\n            return this.wsServer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SubscriptionServer.prototype.close = function () {\n        this.closeHandler();\n    };\n    SubscriptionServer.prototype.loadExecutor = function (options) {\n        var execute = options.execute, subscribe = options.subscribe, schema = options.schema, rootValue = options.rootValue;\n        if (!execute) {\n            throw new Error('Must provide `execute` for websocket server constructor.');\n        }\n        this.schema = schema;\n        this.rootValue = rootValue;\n        this.execute = execute;\n        this.subscribe = subscribe;\n    };\n    SubscriptionServer.prototype.unsubscribe = function (connectionContext, opId) {\n        if (connectionContext.operations && connectionContext.operations[opId]) {\n            if (connectionContext.operations[opId].return) {\n                connectionContext.operations[opId].return();\n            }\n            delete connectionContext.operations[opId];\n            if (this.onOperationComplete) {\n                this.onOperationComplete(connectionContext.socket, opId);\n            }\n        }\n    };\n    SubscriptionServer.prototype.onClose = function (connectionContext) {\n        var _this = this;\n        Object.keys(connectionContext.operations).forEach(function (opId) {\n            _this.unsubscribe(connectionContext, opId);\n        });\n    };\n    SubscriptionServer.prototype.onMessage = function (connectionContext) {\n        var _this = this;\n        return function (message) {\n            var parsedMessage;\n            try {\n                parsedMessage = parse_legacy_protocol_1.parseLegacyProtocolMessage(connectionContext, JSON.parse(message));\n            }\n            catch (e) {\n                _this.sendError(connectionContext, null, { message: e.message }, message_types_1.default.GQL_CONNECTION_ERROR);\n                return;\n            }\n            var opId = parsedMessage.id;\n            switch (parsedMessage.type) {\n                case message_types_1.default.GQL_CONNECTION_INIT:\n                    if (_this.onConnect) {\n                        connectionContext.initPromise = new Promise(function (resolve, reject) {\n                            try {\n                                resolve(_this.onConnect(parsedMessage.payload, connectionContext.socket, connectionContext));\n                            }\n                            catch (e) {\n                                reject(e);\n                            }\n                        });\n                    }\n                    connectionContext.initPromise.then(function (result) {\n                        if (result === false) {\n                            throw new Error('Prohibited connection!');\n                        }\n                        _this.sendMessage(connectionContext, undefined, message_types_1.default.GQL_CONNECTION_ACK, undefined);\n                        if (_this.keepAlive) {\n                            _this.sendKeepAlive(connectionContext);\n                            var keepAliveTimer_1 = setInterval(function () {\n                                if (connectionContext.socket.readyState === WebSocket.OPEN) {\n                                    _this.sendKeepAlive(connectionContext);\n                                }\n                                else {\n                                    clearInterval(keepAliveTimer_1);\n                                }\n                            }, _this.keepAlive);\n                        }\n                    }).catch(function (error) {\n                        _this.sendError(connectionContext, opId, { message: error.message }, message_types_1.default.GQL_CONNECTION_ERROR);\n                        setTimeout(function () {\n                            connectionContext.socket.close(1011);\n                        }, 10);\n                    });\n                    break;\n                case message_types_1.default.GQL_CONNECTION_TERMINATE:\n                    connectionContext.socket.close();\n                    break;\n                case message_types_1.default.GQL_START:\n                    connectionContext.initPromise.then(function (initResult) {\n                        if (connectionContext.operations && connectionContext.operations[opId]) {\n                            _this.unsubscribe(connectionContext, opId);\n                        }\n                        var baseParams = {\n                            query: parsedMessage.payload.query,\n                            variables: parsedMessage.payload.variables,\n                            operationName: parsedMessage.payload.operationName,\n                            context: is_object_1.default(initResult) ? Object.assign(Object.create(Object.getPrototypeOf(initResult)), initResult) : {},\n                            formatResponse: undefined,\n                            formatError: undefined,\n                            callback: undefined,\n                            schema: _this.schema,\n                        };\n                        var promisedParams = Promise.resolve(baseParams);\n                        connectionContext.operations[opId] = empty_iterable_1.createEmptyIterable();\n                        if (_this.onOperation) {\n                            var messageForCallback = parsedMessage;\n                            promisedParams = Promise.resolve(_this.onOperation(messageForCallback, baseParams, connectionContext.socket));\n                        }\n                        promisedParams.then(function (params) {\n                            if (typeof params !== 'object') {\n                                var error = \"Invalid params returned from onOperation! return values must be an object!\";\n                                _this.sendError(connectionContext, opId, { message: error });\n                                throw new Error(error);\n                            }\n                            if (!params.schema) {\n                                var error = 'Missing schema information. The GraphQL schema should be provided either statically in' +\n                                    ' the `SubscriptionServer` constructor or as a property on the object returned from onOperation!';\n                                _this.sendError(connectionContext, opId, { message: error });\n                                throw new Error(error);\n                            }\n                            var document = typeof baseParams.query !== 'string' ? baseParams.query : graphql_1.parse(baseParams.query);\n                            var executionPromise;\n                            var validationErrors = graphql_1.validate(params.schema, document, _this.specifiedRules);\n                            if (validationErrors.length > 0) {\n                                executionPromise = Promise.resolve({ errors: validationErrors });\n                            }\n                            else {\n                                var executor = _this.execute;\n                                if (_this.subscribe && is_subscriptions_1.isASubscriptionOperation(document, params.operationName)) {\n                                    executor = _this.subscribe;\n                                }\n                                executionPromise = Promise.resolve(executor(params.schema, document, _this.rootValue, params.context, params.variables, params.operationName));\n                            }\n                            return executionPromise.then(function (executionResult) { return ({\n                                executionIterable: iterall_1.isAsyncIterable(executionResult) ?\n                                    executionResult : iterall_1.createAsyncIterator([executionResult]),\n                                params: params,\n                            }); });\n                        }).then(function (_a) {\n                            var executionIterable = _a.executionIterable, params = _a.params;\n                            iterall_1.forAwaitEach(executionIterable, function (value) {\n                                var result = value;\n                                if (params.formatResponse) {\n                                    try {\n                                        result = params.formatResponse(value, params);\n                                    }\n                                    catch (err) {\n                                        console.error('Error in formatError function:', err);\n                                    }\n                                }\n                                _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_DATA, result);\n                            })\n                                .then(function () {\n                                _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_COMPLETE, null);\n                            })\n                                .catch(function (e) {\n                                var error = e;\n                                if (params.formatError) {\n                                    try {\n                                        error = params.formatError(e, params);\n                                    }\n                                    catch (err) {\n                                        console.error('Error in formatError function: ', err);\n                                    }\n                                }\n                                if (Object.keys(e).length === 0) {\n                                    error = { name: e.name, message: e.message };\n                                }\n                                _this.sendError(connectionContext, opId, error);\n                            });\n                            return executionIterable;\n                        }).then(function (subscription) {\n                            connectionContext.operations[opId] = subscription;\n                        }).then(function () {\n                            _this.sendMessage(connectionContext, opId, message_types_1.default.SUBSCRIPTION_SUCCESS, undefined);\n                        }).catch(function (e) {\n                            if (e.errors) {\n                                _this.sendMessage(connectionContext, opId, message_types_1.default.GQL_DATA, { errors: e.errors });\n                            }\n                            else {\n                                _this.sendError(connectionContext, opId, { message: e.message });\n                            }\n                            _this.unsubscribe(connectionContext, opId);\n                            return;\n                        });\n                        return promisedParams;\n                    }).catch(function (error) {\n                        _this.sendError(connectionContext, opId, { message: error.message });\n                        _this.unsubscribe(connectionContext, opId);\n                    });\n                    break;\n                case message_types_1.default.GQL_STOP:\n                    _this.unsubscribe(connectionContext, opId);\n                    break;\n                default:\n                    _this.sendError(connectionContext, opId, { message: 'Invalid message type!' });\n            }\n        };\n    };\n    SubscriptionServer.prototype.sendKeepAlive = function (connectionContext) {\n        if (connectionContext.isLegacy) {\n            this.sendMessage(connectionContext, undefined, message_types_1.default.KEEP_ALIVE, undefined);\n        }\n        else {\n            this.sendMessage(connectionContext, undefined, message_types_1.default.GQL_CONNECTION_KEEP_ALIVE, undefined);\n        }\n    };\n    SubscriptionServer.prototype.sendMessage = function (connectionContext, opId, type, payload) {\n        var parsedMessage = parse_legacy_protocol_1.parseLegacyProtocolMessage(connectionContext, {\n            type: type,\n            id: opId,\n            payload: payload,\n        });\n        if (parsedMessage && connectionContext.socket.readyState === WebSocket.OPEN) {\n            connectionContext.socket.send(JSON.stringify(parsedMessage));\n        }\n    };\n    SubscriptionServer.prototype.sendError = function (connectionContext, opId, errorPayload, overrideDefaultErrorType) {\n        var sanitizedOverrideDefaultErrorType = overrideDefaultErrorType || message_types_1.default.GQL_ERROR;\n        if ([\n            message_types_1.default.GQL_CONNECTION_ERROR,\n            message_types_1.default.GQL_ERROR,\n        ].indexOf(sanitizedOverrideDefaultErrorType) === -1) {\n            throw new Error('overrideDefaultErrorType should be one of the allowed error messages' +\n                ' GQL_CONNECTION_ERROR or GQL_ERROR');\n        }\n        this.sendMessage(connectionContext, opId, sanitizedOverrideDefaultErrorType, errorPayload);\n    };\n    return SubscriptionServer;\n}());\nexports.SubscriptionServer = SubscriptionServer;\n//# sourceMappingURL=server.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/server.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/utils/empty-iterable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/utils/empty-iterable.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"./node_modules/iterall/index.mjs\");\nexports.createEmptyIterable = function () {\n    var _a;\n    return _a = {\n            next: function () {\n                return Promise.resolve({ value: undefined, done: true });\n            },\n            return: function () {\n                return Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (e) {\n                return Promise.reject(e);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n};\n//# sourceMappingURL=empty-iterable.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/utils/empty-iterable.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/utils/is-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/utils/is-object.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isObject(value) {\n    return ((value !== null) && (typeof value === 'object'));\n}\nexports.default = isObject;\n//# sourceMappingURL=is-object.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/utils/is-object.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/utils/is-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/utils/is-string.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.default = isString;\n//# sourceMappingURL=is-string.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/utils/is-string.js?");

/***/ }),

/***/ "./node_modules/subscriptions-transport-ws/dist/utils/is-subscriptions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/subscriptions-transport-ws/dist/utils/is-subscriptions.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\nexports.isASubscriptionOperation = function (document, operationName) {\n    var operationAST = graphql_1.getOperationAST(document, operationName);\n    return !!operationAST && operationAST.operation === 'subscription';\n};\n//# sourceMappingURL=is-subscriptions.js.map\n\n//# sourceURL=webpack:///./node_modules/subscriptions-transport-ws/dist/utils/is-subscriptions.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/Project.js":
/*!****************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/Project.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar fileSystem_1 = __webpack_require__(/*! ./fileSystem */ \"./node_modules/ts-simple-ast/dist/fileSystem/index.js\");\r\nvar ProjectContext_1 = __webpack_require__(/*! ./ProjectContext */ \"./node_modules/ts-simple-ast/dist/ProjectContext.js\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Project that holds source files.\r\n */\r\nvar Project = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance.\r\n     * @param options - Optional options.\r\n     * @param fileSystem - Optional file system host. Useful for mocking access to the file system.\r\n     */\r\n    function Project(options, fileSystem) {\r\n        if (options === void 0) { options = {}; }\r\n        // setup file system\r\n        if (fileSystem != null && options.useVirtualFileSystem)\r\n            throw new errors.InvalidOperationError(\"Cannot provide a file system when specifying to use a virtual file system.\");\r\n        else if (options.useVirtualFileSystem)\r\n            fileSystem = new fileSystem_1.VirtualFileSystemHost();\r\n        else if (fileSystem == null)\r\n            fileSystem = new fileSystem_1.DefaultFileSystemHost();\r\n        var fileSystemWrapper = new fileSystem_1.FileSystemWrapper(fileSystem);\r\n        // get tsconfig info\r\n        var tsConfigResolver = options.tsConfigFilePath == null ? undefined : new utils_1.TsConfigResolver(fileSystemWrapper, options.tsConfigFilePath, getEncoding());\r\n        var compilerOptions = getCompilerOptions();\r\n        // setup context\r\n        this.context = new ProjectContext_1.ProjectContext(fileSystemWrapper, compilerOptions, { createLanguageService: true });\r\n        // initialize manipulation settings\r\n        if (options.manipulationSettings != null)\r\n            this.context.manipulationSettings.set(options.manipulationSettings);\r\n        // add any file paths from the tsconfig if necessary\r\n        if (tsConfigResolver != null && options.addFilesFromTsConfig !== false)\r\n            this._addSourceFilesForTsConfigResolver(tsConfigResolver, compilerOptions);\r\n        function getCompilerOptions() {\r\n            return tslib_1.__assign({}, getTsConfigCompilerOptions(), (options.compilerOptions || {}));\r\n        }\r\n        function getTsConfigCompilerOptions() {\r\n            if (tsConfigResolver == null)\r\n                return {};\r\n            return tsConfigResolver.getCompilerOptions();\r\n        }\r\n        function getEncoding() {\r\n            var defaultEncoding = \"utf-8\";\r\n            if (options.compilerOptions != null)\r\n                return options.compilerOptions.charset || defaultEncoding;\r\n            return defaultEncoding;\r\n        }\r\n    }\r\n    Object.defineProperty(Project.prototype, \"manipulationSettings\", {\r\n        /** Gets the manipulation settings. */\r\n        get: function () {\r\n            return this.context.manipulationSettings;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Project.prototype, \"compilerOptions\", {\r\n        /** Gets the compiler options for modification. */\r\n        get: function () {\r\n            return this.context.compilerOptions;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Adds an existing directory from the path or returns undefined if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Path to add the directory at.\r\n     * @param options - Options.\r\n     * @skipOrThrowCheck\r\n     */\r\n    Project.prototype.addExistingDirectoryIfExists = function (dirPath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);\r\n        return this.context.directoryCoordinator.addExistingDirectoryIfExists(dirPath, options);\r\n    };\r\n    /**\r\n     * Adds an existing directory from the path or throws if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Path to add the directory at.\r\n     * @param options - Options.\r\n     * @throws DirectoryNotFoundError when the directory does not exist.\r\n     */\r\n    Project.prototype.addExistingDirectory = function (dirPath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);\r\n        return this.context.directoryCoordinator.addExistingDirectory(dirPath, options);\r\n    };\r\n    /**\r\n     * Creates a directory at the specified path.\r\n     * @param dirPath - Path to create the directory at.\r\n     */\r\n    Project.prototype.createDirectory = function (dirPath) {\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);\r\n        return this.context.directoryCoordinator.createDirectoryOrAddIfExists(dirPath);\r\n    };\r\n    /**\r\n     * Gets a directory by the specified path or throws if it doesn't exist.\r\n     * @param dirPath - Path to create the directory at.\r\n     */\r\n    Project.prototype.getDirectoryOrThrow = function (dirPath) {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getDirectory(dirPath), function () { return \"Could not find a directory at the specified path: \" + _this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath); });\r\n    };\r\n    /**\r\n     * Gets a directory by the specified path or returns undefined if it doesn't exist.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    Project.prototype.getDirectory = function (dirPath) {\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);\r\n        return this.context.compilerFactory.getDirectoryFromCache(dirPath);\r\n    };\r\n    /**\r\n     * Gets all the directories.\r\n     */\r\n    Project.prototype.getDirectories = function () {\r\n        return utils_1.ArrayUtils.from(this.context.compilerFactory.getDirectoriesByDepth());\r\n    };\r\n    /**\r\n     * Gets the directories without a parent.\r\n     */\r\n    Project.prototype.getRootDirectories = function () {\r\n        return this.context.compilerFactory.getOrphanDirectories();\r\n    };\r\n    /**\r\n     * Add source files based on file globs.\r\n     * @param fileGlobs - File glob or globs to add files based on.\r\n     * @returns The matched source files.\r\n     */\r\n    Project.prototype.addExistingSourceFiles = function (fileGlobs) {\r\n        var e_1, _a, e_2, _b;\r\n        if (typeof fileGlobs === \"string\")\r\n            fileGlobs = [fileGlobs];\r\n        var sourceFiles = [];\r\n        var globbedDirectories = utils_1.FileUtils.getParentMostPaths(fileGlobs.filter(function (g) { return !utils_1.FileUtils.isNegatedGlob(g); }).map(function (g) { return utils_1.FileUtils.getGlobDir(g); }));\r\n        try {\r\n            for (var _c = tslib_1.__values(this.context.fileSystemWrapper.glob(fileGlobs)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var filePath = _d.value;\r\n                var sourceFile = this.addExistingSourceFileIfExists(filePath);\r\n                if (sourceFile != null)\r\n                    sourceFiles.push(sourceFile);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        try {\r\n            for (var globbedDirectories_1 = tslib_1.__values(globbedDirectories), globbedDirectories_1_1 = globbedDirectories_1.next(); !globbedDirectories_1_1.done; globbedDirectories_1_1 = globbedDirectories_1.next()) {\r\n                var dirPath = globbedDirectories_1_1.value;\r\n                this.addExistingDirectoryIfExists(dirPath, { recursive: true });\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (globbedDirectories_1_1 && !globbedDirectories_1_1.done && (_b = globbedDirectories_1.return)) _b.call(globbedDirectories_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return sourceFiles;\r\n    };\r\n    /**\r\n     * Adds a source file from a file path if it exists or returns undefined.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param filePath - File path to get the file from.\r\n     * @skipOrThrowCheck\r\n     */\r\n    Project.prototype.addExistingSourceFileIfExists = function (filePath) {\r\n        return this.context.directoryCoordinator.addExistingSourceFileIfExists(filePath);\r\n    };\r\n    /**\r\n     * Adds an existing source file from a file path or throws if it doesn't exist.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param filePath - File path to get the file from.\r\n     * @throws FileNotFoundError when the file is not found.\r\n     */\r\n    Project.prototype.addExistingSourceFile = function (filePath) {\r\n        return this.context.directoryCoordinator.addExistingSourceFile(filePath);\r\n    };\r\n    /**\r\n     * Adds all the source files from the specified tsconfig.json.\r\n     *\r\n     * Note that this is done by default when specifying a tsconfig file in the constructor and not explicitly setting the\r\n     * addFilesFromTsConfig option to false.\r\n     * @param tsConfigFilePath - File path to the tsconfig.json file.\r\n     */\r\n    Project.prototype.addSourceFilesFromTsConfig = function (tsConfigFilePath) {\r\n        tsConfigFilePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(tsConfigFilePath);\r\n        var resolver = new utils_1.TsConfigResolver(this.context.fileSystemWrapper, tsConfigFilePath, this.context.getEncoding());\r\n        return this._addSourceFilesForTsConfigResolver(resolver, resolver.getCompilerOptions());\r\n    };\r\n    /** @internal */\r\n    Project.prototype._addSourceFilesForTsConfigResolver = function (tsConfigResolver, compilerOptions) {\r\n        var _this = this;\r\n        var e_3, _a;\r\n        var paths = tsConfigResolver.getPaths(compilerOptions);\r\n        var addedSourceFiles = paths.filePaths.map(function (p) { return _this.addExistingSourceFile(p); });\r\n        try {\r\n            for (var _b = tslib_1.__values(paths.directoryPaths), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var dirPath = _c.value;\r\n                this.addExistingDirectoryIfExists(dirPath);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return addedSourceFiles;\r\n    };\r\n    Project.prototype.createSourceFile = function (filePath, structureOrText, options) {\r\n        return this.context.compilerFactory.createSourceFile(filePath, structureOrText || \"\", options || {});\r\n    };\r\n    /**\r\n     * Removes a source file from the AST.\r\n     * @param sourceFile - Source file to remove.\r\n     * @returns True if removed.\r\n     */\r\n    Project.prototype.removeSourceFile = function (sourceFile) {\r\n        var previouslyForgotten = sourceFile.wasForgotten();\r\n        sourceFile.forget();\r\n        return !previouslyForgotten;\r\n    };\r\n    Project.prototype.getSourceFileOrThrow = function (fileNameOrSearchFunction) {\r\n        var sourceFile = this.getSourceFile(fileNameOrSearchFunction);\r\n        if (sourceFile == null) {\r\n            var filePathOrSearchFunction = getFilePathOrSearchFunction(this.context.fileSystemWrapper, fileNameOrSearchFunction);\r\n            if (typeof filePathOrSearchFunction === \"string\")\r\n                throw new errors.InvalidOperationError(\"Could not find source file based on the provided name or path: \" + filePathOrSearchFunction + \".\");\r\n            else\r\n                throw new errors.InvalidOperationError(\"Could not find source file based on the provided condition.\");\r\n        }\r\n        return sourceFile;\r\n    };\r\n    Project.prototype.getSourceFile = function (fileNameOrSearchFunction) {\r\n        var filePathOrSearchFunction = getFilePathOrSearchFunction(this.context.fileSystemWrapper, fileNameOrSearchFunction);\r\n        if (typeof filePathOrSearchFunction === \"string\")\r\n            return this.context.compilerFactory.getSourceFileFromCacheFromFilePath(filePathOrSearchFunction);\r\n        return utils_1.ArrayUtils.find(this.context.compilerFactory.getSourceFilesByDirectoryDepth(), filePathOrSearchFunction);\r\n    };\r\n    Project.prototype.getSourceFiles = function (globPatterns) {\r\n        var _a = this.context, compilerFactory = _a.compilerFactory, fileSystemWrapper = _a.fileSystemWrapper;\r\n        var sourceFiles = this.context.compilerFactory.getSourceFilesByDirectoryDepth();\r\n        if (typeof globPatterns === \"string\" || globPatterns instanceof Array)\r\n            return utils_1.ArrayUtils.from(getFilteredSourceFiles());\r\n        else\r\n            return utils_1.ArrayUtils.from(sourceFiles);\r\n        function getFilteredSourceFiles() {\r\n            function getSourceFilePaths() {\r\n                var e_5, _a, sourceFiles_1, sourceFiles_1_1, sourceFile, e_5_1;\r\n                return tslib_1.__generator(this, function (_b) {\r\n                    switch (_b.label) {\r\n                        case 0:\r\n                            _b.trys.push([0, 5, 6, 7]);\r\n                            sourceFiles_1 = tslib_1.__values(sourceFiles), sourceFiles_1_1 = sourceFiles_1.next();\r\n                            _b.label = 1;\r\n                        case 1:\r\n                            if (!!sourceFiles_1_1.done) return [3 /*break*/, 4];\r\n                            sourceFile = sourceFiles_1_1.value;\r\n                            return [4 /*yield*/, sourceFile.getFilePath()];\r\n                        case 2:\r\n                            _b.sent();\r\n                            _b.label = 3;\r\n                        case 3:\r\n                            sourceFiles_1_1 = sourceFiles_1.next();\r\n                            return [3 /*break*/, 1];\r\n                        case 4: return [3 /*break*/, 7];\r\n                        case 5:\r\n                            e_5_1 = _b.sent();\r\n                            e_5 = { error: e_5_1 };\r\n                            return [3 /*break*/, 7];\r\n                        case 6:\r\n                            try {\r\n                                if (sourceFiles_1_1 && !sourceFiles_1_1.done && (_a = sourceFiles_1.return)) _a.call(sourceFiles_1);\r\n                            }\r\n                            finally { if (e_5) throw e_5.error; }\r\n                            return [7 /*endfinally*/];\r\n                        case 7: return [2 /*return*/];\r\n                    }\r\n                });\r\n            }\r\n            var e_4, _a, sourceFilePaths, matchedPaths, matchedPaths_1, matchedPaths_1_1, matchedPath, e_4_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        sourceFilePaths = Array.from(getSourceFilePaths());\r\n                        matchedPaths = utils_1.matchGlobs(sourceFilePaths, globPatterns, fileSystemWrapper.getCurrentDirectory());\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 6, 7, 8]);\r\n                        matchedPaths_1 = tslib_1.__values(matchedPaths), matchedPaths_1_1 = matchedPaths_1.next();\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        if (!!matchedPaths_1_1.done) return [3 /*break*/, 5];\r\n                        matchedPath = matchedPaths_1_1.value;\r\n                        return [4 /*yield*/, compilerFactory.getSourceFileFromCacheFromFilePath(matchedPath)];\r\n                    case 3:\r\n                        _b.sent();\r\n                        _b.label = 4;\r\n                    case 4:\r\n                        matchedPaths_1_1 = matchedPaths_1.next();\r\n                        return [3 /*break*/, 2];\r\n                    case 5: return [3 /*break*/, 8];\r\n                    case 6:\r\n                        e_4_1 = _b.sent();\r\n                        e_4 = { error: e_4_1 };\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        try {\r\n                            if (matchedPaths_1_1 && !matchedPaths_1_1.done && (_a = matchedPaths_1.return)) _a.call(matchedPaths_1);\r\n                        }\r\n                        finally { if (e_4) throw e_4.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Saves all the unsaved source files to the file system and deletes all deleted files.\r\n     */\r\n    Project.prototype.save = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.context.fileSystemWrapper.flush()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, Promise.all(this.getUnsavedSourceFiles().map(function (f) { return f.save(); }))];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronously saves all the unsaved source files to the file system and deletes all deleted files.\r\n     *\r\n     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.\r\n     */\r\n    Project.prototype.saveSync = function () {\r\n        var e_6, _a;\r\n        this.context.fileSystemWrapper.flushSync();\r\n        try {\r\n            // sidenote: I wish I could do something like in c# where I do this all asynchronously then\r\n            // wait synchronously on the task. It would not be as bad as this is performance wise. Maybe there\r\n            // is a way, but people just shouldn't be using this method unless they're really lazy.\r\n            for (var _b = tslib_1.__values(this.getUnsavedSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var file = _c.value;\r\n                file.saveSync();\r\n            }\r\n        }\r\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_6) throw e_6.error; }\r\n        }\r\n    };\r\n    /**\r\n     * Enables logging to the console.\r\n     * @param enabled - Enabled.\r\n     */\r\n    Project.prototype.enableLogging = function (enabled) {\r\n        if (enabled === void 0) { enabled = true; }\r\n        this.context.logger.setEnabled(enabled);\r\n    };\r\n    Project.prototype.getUnsavedSourceFiles = function () {\r\n        return utils_1.ArrayUtils.from(getUnsavedIterator(this.context.compilerFactory.getSourceFilesByDirectoryDepth()));\r\n        function getUnsavedIterator(sourceFiles) {\r\n            var e_7, _a, sourceFiles_2, sourceFiles_2_1, sourceFile, e_7_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _b.trys.push([0, 5, 6, 7]);\r\n                        sourceFiles_2 = tslib_1.__values(sourceFiles), sourceFiles_2_1 = sourceFiles_2.next();\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!!sourceFiles_2_1.done) return [3 /*break*/, 4];\r\n                        sourceFile = sourceFiles_2_1.value;\r\n                        if (!!sourceFile.isSaved()) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, sourceFile];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        sourceFiles_2_1 = sourceFiles_2.next();\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [3 /*break*/, 7];\r\n                    case 5:\r\n                        e_7_1 = _b.sent();\r\n                        e_7 = { error: e_7_1 };\r\n                        return [3 /*break*/, 7];\r\n                    case 6:\r\n                        try {\r\n                            if (sourceFiles_2_1 && !sourceFiles_2_1.done && (_a = sourceFiles_2.return)) _a.call(sourceFiles_2);\r\n                        }\r\n                        finally { if (e_7) throw e_7.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Gets the pre-emit diagnostics.\r\n     */\r\n    Project.prototype.getPreEmitDiagnostics = function () {\r\n        return this.context.getPreEmitDiagnostics();\r\n    };\r\n    /**\r\n     * Gets the language service.\r\n     */\r\n    Project.prototype.getLanguageService = function () {\r\n        return this.context.languageService;\r\n    };\r\n    /**\r\n     * Gets the program.\r\n     */\r\n    Project.prototype.getProgram = function () {\r\n        return this.context.program;\r\n    };\r\n    /**\r\n     * Gets the type checker.\r\n     */\r\n    Project.prototype.getTypeChecker = function () {\r\n        return this.context.typeChecker;\r\n    };\r\n    /**\r\n     * Gets the file system.\r\n     */\r\n    Project.prototype.getFileSystem = function () {\r\n        return this.context.fileSystemWrapper.getFileSystem();\r\n    };\r\n    /**\r\n     * Emits all the source files.\r\n     * @param emitOptions - Optional emit options.\r\n     */\r\n    Project.prototype.emit = function (emitOptions) {\r\n        if (emitOptions === void 0) { emitOptions = {}; }\r\n        return this.context.program.emit(emitOptions);\r\n    };\r\n    /**\r\n     * Emits all the source files to memory.\r\n     * @param emitOptions - Optional emit options.\r\n     */\r\n    Project.prototype.emitToMemory = function (emitOptions) {\r\n        if (emitOptions === void 0) { emitOptions = {}; }\r\n        return this.context.program.emitToMemory(emitOptions);\r\n    };\r\n    /**\r\n     * Gets the compiler options.\r\n     */\r\n    Project.prototype.getCompilerOptions = function () {\r\n        return this.context.compilerOptions.get();\r\n    };\r\n    /**\r\n     * Creates a writer with the current manipulation settings.\r\n     * @remarks Generally it's best to use a provided writer, but this may be useful in some scenarios.\r\n     */\r\n    Project.prototype.createWriter = function () {\r\n        return this.context.createWriter();\r\n    };\r\n    Project.prototype.forgetNodesCreatedInBlock = function (block) {\r\n        return this.context.compilerFactory.forgetNodesCreatedInBlock(block);\r\n    };\r\n    return Project;\r\n}());\r\nexports.Project = Project;\r\nfunction getFilePathOrSearchFunction(fileSystemWrapper, fileNameOrSearchFunction) {\r\n    if (fileNameOrSearchFunction instanceof Function)\r\n        return fileNameOrSearchFunction;\r\n    var fileNameOrPath = utils_1.FileUtils.standardizeSlashes(fileNameOrSearchFunction);\r\n    if (utils_1.FileUtils.pathIsAbsolute(fileNameOrPath) || fileNameOrPath.indexOf(\"/\") >= 0)\r\n        return fileSystemWrapper.getStandardizedAbsolutePath(fileNameOrPath);\r\n    else\r\n        return function (def) { return utils_1.FileUtils.pathEndsWith(def.getFilePath(), fileNameOrPath); };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/Project.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/ProjectContext.js":
/*!***********************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/ProjectContext.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar codeBlockWriter_1 = __webpack_require__(/*! ./codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\");\r\nvar compiler_1 = __webpack_require__(/*! ./compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\");\r\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar factories_1 = __webpack_require__(/*! ./factories */ \"./node_modules/ts-simple-ast/dist/factories/index.js\");\r\nvar fileSystem_1 = __webpack_require__(/*! ./fileSystem */ \"./node_modules/ts-simple-ast/dist/fileSystem/index.js\");\r\nvar options_1 = __webpack_require__(/*! ./options */ \"./node_modules/ts-simple-ast/dist/options/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ./typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar createWrappedNode_1 = __webpack_require__(/*! ./utils/compiler/createWrappedNode */ \"./node_modules/ts-simple-ast/dist/utils/compiler/createWrappedNode.js\");\r\n/**\r\n * Context for a project instance.\r\n * @internal\r\n */\r\nvar ProjectContext = /** @class */ (function () {\r\n    function ProjectContext(fileSystemWrapper, compilerOptions, opts) {\r\n        var _this = this;\r\n        this._manipulationSettings = new options_1.ManipulationSettingsContainer();\r\n        this._compilerOptions = new options_1.CompilerOptionsContainer();\r\n        this._logger = new utils_1.ConsoleLogger();\r\n        this._fileSystemWrapper = fileSystemWrapper;\r\n        this._compilerOptions.set(compilerOptions);\r\n        this._compilerFactory = new factories_1.CompilerFactory(this);\r\n        this._structurePrinterFactory = new factories_1.StructurePrinterFactory(function () { return _this.manipulationSettings.getFormatCodeSettings(); });\r\n        this._lazyReferenceCoordinator = new utils_1.LazyReferenceCoordinator(this._compilerFactory);\r\n        this._directoryCoordinator = new fileSystem_1.DirectoryCoordinator(this._compilerFactory, fileSystemWrapper);\r\n        this._languageService = opts.createLanguageService ? new compiler_1.LanguageService(this) : undefined;\r\n        if (opts.typeChecker != null) {\r\n            errors.throwIfTrue(opts.createLanguageService, \"Cannot specify a type checker and create a language service.\");\r\n            this._customTypeChecker = new compiler_1.TypeChecker(this);\r\n            this._customTypeChecker.reset(function () { return opts.typeChecker; });\r\n        }\r\n    }\r\n    Object.defineProperty(ProjectContext.prototype, \"fileSystemWrapper\", {\r\n        /** Gets the file system wrapper. */\r\n        get: function () {\r\n            return this._fileSystemWrapper;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"compilerOptions\", {\r\n        /** Gets the compiler options. */\r\n        get: function () {\r\n            return this._compilerOptions;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"manipulationSettings\", {\r\n        /** Gets the manipulation settings. */\r\n        get: function () {\r\n            return this._manipulationSettings;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"compilerFactory\", {\r\n        /** Gets the compiler factory. */\r\n        get: function () {\r\n            return this._compilerFactory;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"structurePrinterFactory\", {\r\n        /** Gets the structure printer factory. */\r\n        get: function () {\r\n            return this._structurePrinterFactory;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"languageService\", {\r\n        /** Gets the language service. Throws an exception if it doesn't exist. */\r\n        get: function () {\r\n            if (this._languageService == null)\r\n                throw this.getToolRequiredError(\"language service\");\r\n            return this._languageService;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"program\", {\r\n        /**\r\n         * Gets the program.\r\n         */\r\n        get: function () {\r\n            if (this._languageService == null)\r\n                throw this.getToolRequiredError(\"program\");\r\n            return this.languageService.getProgram();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"typeChecker\", {\r\n        /**\r\n         * Gets the type checker.\r\n         */\r\n        get: function () {\r\n            if (this._customTypeChecker != null)\r\n                return this._customTypeChecker;\r\n            if (this._languageService == null)\r\n                throw this.getToolRequiredError(\"type checker\");\r\n            return this.program.getTypeChecker();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"logger\", {\r\n        /**\r\n         * Gets the logger.\r\n         */\r\n        get: function () {\r\n            return this._logger;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"lazyReferenceCoordinator\", {\r\n        /** Gets the lazy reference coordinator. */\r\n        get: function () {\r\n            return this._lazyReferenceCoordinator;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ProjectContext.prototype, \"directoryCoordinator\", {\r\n        /** Gets the directory coordinator. */\r\n        get: function () {\r\n            return this._directoryCoordinator;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets if this object has a language service.\r\n     */\r\n    ProjectContext.prototype.hasLanguageService = function () {\r\n        return this._languageService != null;\r\n    };\r\n    /**\r\n     * Gets the encoding.\r\n     */\r\n    ProjectContext.prototype.getEncoding = function () {\r\n        return this.compilerOptions.get().charset || \"utf-8\";\r\n    };\r\n    /**\r\n     * Helper for getting the format code settings.\r\n     */\r\n    ProjectContext.prototype.getFormatCodeSettings = function () {\r\n        return this.manipulationSettings.getFormatCodeSettings();\r\n    };\r\n    /**\r\n     * Helper for getting the user preferences.\r\n     */\r\n    ProjectContext.prototype.getUserPreferences = function () {\r\n        return this.manipulationSettings.getUserPreferences();\r\n    };\r\n    /**\r\n     * Resets the program.\r\n     */\r\n    ProjectContext.prototype.resetProgram = function () {\r\n        this.languageService.resetProgram();\r\n    };\r\n    /**\r\n     * Creates a code block writer.\r\n     */\r\n    ProjectContext.prototype.createWriter = function () {\r\n        var indentationText = this.manipulationSettings.getIndentationText();\r\n        return new codeBlockWriter_1.CodeBlockWriter({\r\n            newLine: this.manipulationSettings.getNewLineKindAsString(),\r\n            indentNumberOfSpaces: indentationText === options_1.IndentationText.Tab ? undefined : indentationText.length,\r\n            useTabs: indentationText === options_1.IndentationText.Tab,\r\n            useSingleQuote: this.manipulationSettings.getQuoteKind() === compiler_1.QuoteKind.Single\r\n        });\r\n    };\r\n    /**\r\n     * Gets the pre-emit diagnostics.\r\n     * @param sourceFile - Optional source file to filter the results by.\r\n     */\r\n    ProjectContext.prototype.getPreEmitDiagnostics = function (sourceFile) {\r\n        var _this = this;\r\n        var compilerDiagnostics = typescript_1.ts.getPreEmitDiagnostics(this.program.compilerObject, sourceFile == null ? undefined : sourceFile.compilerNode);\r\n        return compilerDiagnostics.map(function (d) { return _this.compilerFactory.getDiagnostic(d); });\r\n    };\r\n    ProjectContext.prototype.getToolRequiredError = function (name) {\r\n        return new errors.InvalidOperationError(\"A \" + name + \" is required for this operation. \" +\r\n            \"This might occur when manipulating or getting type information from a node that was not added \" +\r\n            (\"to a Project object and created via \" + \"createWrappedNode\" + \". \") +\r\n            (\"Please submit a bug report if you don't believe a \" + name + \" should be required for this operation.\"));\r\n    };\r\n    return ProjectContext;\r\n}());\r\nexports.ProjectContext = ProjectContext;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/ProjectContext.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/codeBlockWriter/code-block-writer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/codeBlockWriter/code-block-writer.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar code_block_writer_1 = __webpack_require__(/*! code-block-writer */ \"./node_modules/code-block-writer/dist/code-block-writer.js\");\r\n// this is a trick to get the import module defined in the local scope by its name, but have the compiler\r\n// understand this as exporting the ambient declaration above (so it works at compile time and run time)\r\n// @ts-ignore: Implicit use of this.\r\nvar tempThis = this;\r\ntempThis[\"CodeBlockWriter\"] = code_block_writer_1.default;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/codeBlockWriter/code-block-writer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./code-block-writer */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/code-block-writer.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/AmbientableNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/AmbientableNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction AmbientableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.hasDeclareKeyword = function () {\r\n            return this.getDeclareKeyword() != null;\r\n        };\r\n        class_1.prototype.getDeclareKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getDeclareKeyword(), \"Expected to find a declare keyword.\");\r\n        };\r\n        class_1.prototype.getDeclareKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.DeclareKeyword);\r\n        };\r\n        class_1.prototype.isAmbient = function () {\r\n            return utils_1.isNodeAmbientOrInAmbientContext(this);\r\n        };\r\n        class_1.prototype.setHasDeclareKeyword = function (value) {\r\n            // do nothing for these kind of nodes\r\n            if (utils_1.TypeGuards.isInterfaceDeclaration(this) || utils_1.TypeGuards.isTypeAliasDeclaration(this))\r\n                return this;\r\n            this.toggleModifier(\"declare\", value);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.hasDeclareKeyword != null)\r\n                this.setHasDeclareKeyword(structure.hasDeclareKeyword);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.AmbientableNode = AmbientableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/AmbientableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ArgumentedNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ArgumentedNode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction ArgumentedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getArguments = function () {\r\n            var _this = this;\r\n            return this.compilerNode.arguments.map(function (a) { return _this.getNodeFromCompilerNode(a); });\r\n        };\r\n        class_1.prototype.addArgument = function (argumentText) {\r\n            return this.addArguments([argumentText])[0];\r\n        };\r\n        class_1.prototype.addArguments = function (argumentTexts) {\r\n            return this.insertArguments(this.getArguments().length, argumentTexts);\r\n        };\r\n        class_1.prototype.insertArgument = function (index, argumentText) {\r\n            return this.insertArguments(index, [argumentText])[0];\r\n        };\r\n        class_1.prototype.insertArguments = function (index, argumentTexts) {\r\n            if (utils_1.ArrayUtils.isNullOrEmpty(argumentTexts))\r\n                return [];\r\n            var args = this.getArguments();\r\n            index = manipulation_1.verifyAndGetIndex(index, args.length);\r\n            var writer = this.getWriterWithQueuedChildIndentation();\r\n            for (var i = 0; i < argumentTexts.length; i++) {\r\n                writer.conditionalWrite(i > 0, \", \");\r\n                utils_1.printTextFromStringOrWriter(writer, argumentTexts[i]);\r\n            }\r\n            manipulation_1.insertIntoCommaSeparatedNodes({\r\n                parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenParenToken).getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                currentNodes: args,\r\n                insertIndex: index,\r\n                newText: writer.toString()\r\n            });\r\n            return manipulation_1.getNodesToReturn(this.getArguments(), index, argumentTexts.length);\r\n        };\r\n        class_1.prototype.removeArgument = function (argOrIndex) {\r\n            var args = this.getArguments();\r\n            if (args.length === 0)\r\n                throw new errors.InvalidOperationError(\"Cannot remove an argument when none exist.\");\r\n            var argToRemove = typeof argOrIndex === \"number\" ? getArgFromIndex(argOrIndex) : argOrIndex;\r\n            manipulation_1.removeCommaSeparatedChild(argToRemove);\r\n            return this;\r\n            function getArgFromIndex(index) {\r\n                return args[manipulation_1.verifyAndGetIndex(index, args.length - 1)];\r\n            }\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ArgumentedNode = ArgumentedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ArgumentedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/AsyncableNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/AsyncableNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction AsyncableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.isAsync = function () {\r\n            return this.hasModifier(typescript_1.SyntaxKind.AsyncKeyword);\r\n        };\r\n        class_1.prototype.getAsyncKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.AsyncKeyword);\r\n        };\r\n        class_1.prototype.getAsyncKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getAsyncKeyword(), \"Expected to find an async keyword.\");\r\n        };\r\n        class_1.prototype.setIsAsync = function (value) {\r\n            this.toggleModifier(\"async\", value);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isAsync != null)\r\n                this.setIsAsync(structure.isAsync);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.AsyncableNode = AsyncableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/AsyncableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/AwaitableNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/AwaitableNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction AwaitableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.isAwaited = function () {\r\n            return this.compilerNode.awaitModifier != null;\r\n        };\r\n        class_1.prototype.getAwaitKeyword = function () {\r\n            var awaitModifier = this.compilerNode.awaitModifier;\r\n            return this.getNodeFromCompilerNodeIfExists(awaitModifier);\r\n        };\r\n        class_1.prototype.getAwaitKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getAwaitKeyword(), \"Expected to find an await token.\");\r\n        };\r\n        class_1.prototype.setIsAwaited = function (value) {\r\n            var awaitModifier = this.getAwaitKeyword();\r\n            var isSet = awaitModifier != null;\r\n            if (isSet === value)\r\n                return this;\r\n            if (awaitModifier == null) {\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: getAwaitInsertPos(this),\r\n                    parent: this,\r\n                    newText: \" await\"\r\n                });\r\n            }\r\n            else {\r\n                manipulation_1.removeChildren({\r\n                    children: [awaitModifier],\r\n                    removePrecedingSpaces: true\r\n                });\r\n            }\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isAwaited != null)\r\n                this.setIsAwaited(structure.isAwaited);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.AwaitableNode = AwaitableNode;\r\nfunction getAwaitInsertPos(node) {\r\n    if (node.getKind() === typescript_1.SyntaxKind.ForOfStatement)\r\n        return node.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.ForKeyword).getEnd();\r\n    throw new errors.NotImplementedError(\"Expected a for of statement node.\");\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/AwaitableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/BodiedNode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/BodiedNode.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar setBodyTextForNode_1 = __webpack_require__(/*! ./helpers/setBodyTextForNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/setBodyTextForNode.js\");\r\nfunction BodiedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getBody = function () {\r\n            var body = this.compilerNode.body;\r\n            if (body == null)\r\n                throw new errors.InvalidOperationError(\"Bodied node should have a body.\");\r\n            return this.getNodeFromCompilerNode(body);\r\n        };\r\n        class_1.prototype.setBodyText = function (textOrWriterFunction) {\r\n            var body = this.getBody();\r\n            setBodyTextForNode_1.setBodyTextForNode(body, textOrWriterFunction);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.bodyText != null)\r\n                this.setBodyText(structure.bodyText);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.BodiedNode = BodiedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/BodiedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/BodyableNode.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/BodyableNode.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar setBodyTextForNode_1 = __webpack_require__(/*! ./helpers/setBodyTextForNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/setBodyTextForNode.js\");\r\nfunction BodyableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getBodyOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getBody(), \"Expected to find the node's body.\");\r\n        };\r\n        class_1.prototype.getBody = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.body);\r\n        };\r\n        class_1.prototype.setBodyText = function (textOrWriterFunction) {\r\n            this.addBody();\r\n            setBodyTextForNode_1.setBodyTextForNode(this.getBodyOrThrow(), textOrWriterFunction);\r\n            return this;\r\n        };\r\n        class_1.prototype.hasBody = function () {\r\n            return this.compilerNode.body != null;\r\n        };\r\n        class_1.prototype.addBody = function () {\r\n            if (this.hasBody())\r\n                return this;\r\n            var semiColon = this.getLastChildByKind(typescript_1.SyntaxKind.SemicolonToken);\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: semiColon == null ? this.getEnd() : semiColon.getStart(),\r\n                newText: this.getWriterWithQueuedIndentation().block().toString(),\r\n                replacing: {\r\n                    textLength: semiColon == null ? 0 : semiColon.getFullWidth()\r\n                }\r\n            });\r\n            return this;\r\n        };\r\n        class_1.prototype.removeBody = function () {\r\n            var body = this.getBody();\r\n            if (body == null)\r\n                return this;\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: body.getPos(),\r\n                newText: \";\",\r\n                replacing: {\r\n                    textLength: body.getFullWidth()\r\n                }\r\n            });\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.bodyText != null)\r\n                this.setBodyText(structure.bodyText);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.BodyableNode = BodyableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/BodyableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ChildOrderableNode.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ChildOrderableNode.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nfunction ChildOrderableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.setOrder = function (order) {\r\n            var childIndex = this.getChildIndex();\r\n            var parent = this.getParentSyntaxList() || this.getParentSyntaxListOrThrow();\r\n            errors.throwIfOutOfRange(order, [0, parent.getChildCount() - 1], \"order\");\r\n            if (childIndex === order)\r\n                return this;\r\n            manipulation_1.changeChildOrder({\r\n                parent: parent,\r\n                getSiblingFormatting: manipulation_1.getGeneralFormatting,\r\n                oldIndex: childIndex,\r\n                newIndex: order\r\n            });\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ChildOrderableNode = ChildOrderableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ChildOrderableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/DecoratableNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/DecoratableNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction DecoratableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getDecorator = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getDecorators(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getDecoratorOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getDecorator(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"decorator\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.getDecorators = function () {\r\n            var _this = this;\r\n            if (this.compilerNode.decorators == null)\r\n                return [];\r\n            return this.compilerNode.decorators.map(function (d) { return _this.getNodeFromCompilerNode(d); });\r\n        };\r\n        class_1.prototype.addDecorator = function (structure) {\r\n            return this.insertDecorator(manipulation_1.getEndIndexFromArray(this.compilerNode.decorators), structure);\r\n        };\r\n        class_1.prototype.addDecorators = function (structures) {\r\n            return this.insertDecorators(manipulation_1.getEndIndexFromArray(this.compilerNode.decorators), structures);\r\n        };\r\n        class_1.prototype.insertDecorator = function (index, structure) {\r\n            return this.insertDecorators(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertDecorators = function (index, structures) {\r\n            if (utils_1.ArrayUtils.isNullOrEmpty(structures))\r\n                return [];\r\n            var decoratorLines = getDecoratorLines(this, structures);\r\n            var decorators = this.getDecorators();\r\n            index = manipulation_1.verifyAndGetIndex(index, decorators.length);\r\n            var formattingKind = getDecoratorFormattingKind(this, decorators);\r\n            var previousDecorator = decorators[index - 1];\r\n            var decoratorCode = manipulation_1.getNewInsertCode({\r\n                structures: structures,\r\n                newCodes: decoratorLines,\r\n                parent: this,\r\n                indentationText: this.getIndentationText(),\r\n                getSeparator: function () { return formattingKind; },\r\n                previousFormattingKind: previousDecorator == null ? manipulation_1.FormattingKind.None : formattingKind,\r\n                nextFormattingKind: previousDecorator == null ? formattingKind : manipulation_1.FormattingKind.None\r\n            });\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: decorators.length === 0 ? this : decorators[0].getParentSyntaxListOrThrow(),\r\n                insertPos: decorators[index - 1] == null ? this.getStart() : decorators[index - 1].getEnd(),\r\n                newText: decoratorCode\r\n            });\r\n            return manipulation_1.getNodesToReturn(this.getDecorators(), index, structures.length);\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.decorators != null && structure.decorators.length > 0)\r\n                this.addDecorators(structure.decorators);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.DecoratableNode = DecoratableNode;\r\nfunction getDecoratorLines(node, structures) {\r\n    var e_1, _a;\r\n    var lines = [];\r\n    try {\r\n        for (var structures_1 = tslib_1.__values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {\r\n            var structure = structures_1_1.value;\r\n            // todo: temporary code... refactor this later\r\n            var writer = node.getWriter();\r\n            var structurePrinter = node.context.structurePrinterFactory.forDecorator();\r\n            structurePrinter.printText(writer, structure);\r\n            lines.push(writer.toString());\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return lines;\r\n}\r\nfunction getDecoratorFormattingKind(parent, currentDecorators) {\r\n    var sameLine = areDecoratorsOnSameLine(parent, currentDecorators);\r\n    return sameLine ? manipulation_1.FormattingKind.Space : manipulation_1.FormattingKind.Newline;\r\n}\r\nfunction areDecoratorsOnSameLine(parent, currentDecorators) {\r\n    if (currentDecorators.length <= 1)\r\n        return parent.getKind() === typescript_1.SyntaxKind.Parameter;\r\n    var startLinePos = currentDecorators[0].getStartLinePos();\r\n    for (var i = 1; i < currentDecorators.length; i++) {\r\n        if (currentDecorators[i].getStartLinePos() !== startLinePos)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/DecoratableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ExclamationTokenableNode.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ExclamationTokenableNode.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ExclamationTokenableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.hasExclamationToken = function () {\r\n            return this.compilerNode.exclamationToken != null;\r\n        };\r\n        class_1.prototype.getExclamationTokenNode = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.exclamationToken);\r\n        };\r\n        class_1.prototype.getExclamationTokenNodeOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getExclamationTokenNode(), \"Expected to find an exclamation token.\");\r\n        };\r\n        class_1.prototype.setHasExclamationToken = function (value) {\r\n            var exclamationTokenNode = this.getExclamationTokenNode();\r\n            var hasExclamationToken = exclamationTokenNode != null;\r\n            if (value === hasExclamationToken)\r\n                return this;\r\n            if (value) {\r\n                if (utils_1.TypeGuards.isQuestionTokenableNode(this))\r\n                    this.setHasQuestionToken(false);\r\n                var colonNode = this.getFirstChildByKind(typescript_1.SyntaxKind.ColonToken);\r\n                if (colonNode == null)\r\n                    throw new errors.InvalidOperationError(\"Cannot add an exclamation token to a node that does not have a type.\");\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: colonNode.getStart(),\r\n                    parent: this,\r\n                    newText: \"!\"\r\n                });\r\n            }\r\n            else\r\n                manipulation_1.removeChildren({ children: [exclamationTokenNode] });\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.hasExclamationToken != null)\r\n                this.setHasExclamationToken(structure.hasExclamationToken);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ExclamationTokenableNode = ExclamationTokenableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ExclamationTokenableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ExportableNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ExportableNode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ExportableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.hasExportKeyword = function () {\r\n            return this.getExportKeyword() != null;\r\n        };\r\n        class_1.prototype.getExportKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.ExportKeyword);\r\n        };\r\n        class_1.prototype.getExportKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getExportKeyword(), \"Expected to find an export keyword.\");\r\n        };\r\n        class_1.prototype.hasDefaultKeyword = function () {\r\n            return this.getDefaultKeyword() != null;\r\n        };\r\n        class_1.prototype.getDefaultKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.DefaultKeyword);\r\n        };\r\n        class_1.prototype.getDefaultKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getDefaultKeyword(), \"Expected to find a default keyword.\");\r\n        };\r\n        class_1.prototype.isExported = function () {\r\n            if (this.hasExportKeyword())\r\n                return true;\r\n            var thisSymbol = this.getSymbol();\r\n            var sourceFileSymbol = this.getSourceFile().getSymbol();\r\n            if (thisSymbol == null || sourceFileSymbol == null)\r\n                return false;\r\n            return sourceFileSymbol.getExports().some(function (e) { return e === thisSymbol || e.getAliasedSymbol() === thisSymbol; });\r\n        };\r\n        class_1.prototype.isDefaultExport = function () {\r\n            if (this.hasDefaultKeyword())\r\n                return true;\r\n            if (!utils_1.TypeGuards.isSourceFile(this.getParentOrThrow()))\r\n                return false;\r\n            var thisSymbol = this.getSymbol();\r\n            var defaultExportSymbol = this.getSourceFile().getDefaultExportSymbol();\r\n            if (defaultExportSymbol == null || thisSymbol == null)\r\n                return false;\r\n            if (thisSymbol === defaultExportSymbol)\r\n                return true;\r\n            var aliasedSymbol = defaultExportSymbol.getAliasedSymbol();\r\n            return thisSymbol === aliasedSymbol;\r\n        };\r\n        class_1.prototype.isNamedExport = function () {\r\n            var parentNode = this.getParentOrThrow();\r\n            return utils_1.TypeGuards.isSourceFile(parentNode) && this.hasExportKeyword() && !this.hasDefaultKeyword();\r\n        };\r\n        class_1.prototype.setIsDefaultExport = function (value) {\r\n            if (value === this.isDefaultExport())\r\n                return this;\r\n            if (value && !utils_1.TypeGuards.isSourceFile(this.getParentOrThrow()))\r\n                throw new errors.InvalidOperationError(\"The parent must be a source file in order to set this node as a default export.\");\r\n            // remove any existing default export\r\n            var sourceFile = this.getSourceFile();\r\n            var fileDefaultExportSymbol = sourceFile.getDefaultExportSymbol();\r\n            if (fileDefaultExportSymbol != null)\r\n                sourceFile.removeDefaultExport(fileDefaultExportSymbol);\r\n            if (!value)\r\n                return this;\r\n            // set this node as the one to default export\r\n            if (utils_1.TypeGuards.isAmbientableNode(this) && utils_1.TypeGuards.hasName(this) && this.isAmbient()) {\r\n                var parentSyntaxList = this.getFirstAncestorByKindOrThrow(typescript_1.SyntaxKind.SyntaxList);\r\n                parentSyntaxList.insertChildText(this.getChildIndex() + 1, \"export default \" + this.getName() + \";\");\r\n            }\r\n            else {\r\n                this.addModifier(\"export\");\r\n                this.addModifier(\"default\");\r\n            }\r\n            return this;\r\n        };\r\n        class_1.prototype.setIsExported = function (value) {\r\n            // remove the default keyword if it exists\r\n            if (utils_1.TypeGuards.isSourceFile(this.getParentOrThrow()))\r\n                this.toggleModifier(\"default\", false);\r\n            this.toggleModifier(\"export\", value);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isExported != null)\r\n                this.setIsExported(structure.isExported);\r\n            if (structure.isDefaultExport != null)\r\n                this.setIsDefaultExport(structure.isDefaultExport);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ExportableNode = ExportableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ExportableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ExtendsClauseableNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ExtendsClauseableNode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar structurePrinters_1 = __webpack_require__(/*! ../../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ExtendsClauseableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getExtends = function () {\r\n            var extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);\r\n            return extendsClause == null ? [] : extendsClause.getTypeNodes();\r\n        };\r\n        class_1.prototype.addExtends = function (text) {\r\n            return this.insertExtends(this.getExtends().length, text);\r\n        };\r\n        class_1.prototype.insertExtends = function (index, texts) {\r\n            var length = texts instanceof Array ? texts.length : 0;\r\n            if (typeof texts === \"string\") {\r\n                errors.throwIfNotStringOrWhitespace(texts, \"texts\");\r\n                texts = [texts];\r\n            }\r\n            else if (texts.length === 0) {\r\n                return [];\r\n            }\r\n            var writer = this.getWriterWithQueuedChildIndentation();\r\n            var structurePrinter = new structurePrinters_1.CommaSeparatedStructuresPrinter(new structurePrinters_1.StringStructurePrinter());\r\n            structurePrinter.printText(writer, texts);\r\n            var extendsTypes = this.getExtends();\r\n            index = manipulation_1.verifyAndGetIndex(index, extendsTypes.length);\r\n            if (extendsTypes.length > 0) {\r\n                var extendsClause = this.getHeritageClauseByKindOrThrow(typescript_1.SyntaxKind.ExtendsKeyword);\r\n                manipulation_1.insertIntoCommaSeparatedNodes({\r\n                    parent: extendsClause.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                    currentNodes: extendsTypes,\r\n                    insertIndex: index,\r\n                    newText: writer.toString()\r\n                });\r\n                return manipulation_1.getNodeOrNodesToReturn(this.getExtends(), index, length);\r\n            }\r\n            var openBraceToken = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenBraceToken);\r\n            var openBraceStart = openBraceToken.getStart();\r\n            var isLastSpace = /\\s/.test(this.getSourceFile().getFullText()[openBraceStart - 1]);\r\n            var insertText = \"extends \" + writer.toString() + \" \";\r\n            if (!isLastSpace)\r\n                insertText = \" \" + insertText;\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: openBraceStart,\r\n                newText: insertText\r\n            });\r\n            return manipulation_1.getNodeOrNodesToReturn(this.getExtends(), index, length);\r\n        };\r\n        class_1.prototype.removeExtends = function (implementsNodeOrIndex) {\r\n            var extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);\r\n            if (extendsClause == null)\r\n                throw new errors.InvalidOperationError(\"Cannot remove an extends when none exist.\");\r\n            extendsClause.removeExpression(implementsNodeOrIndex);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.extends != null && structure.extends.length > 0)\r\n                this.addExtends(structure.extends);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ExtendsClauseableNode = ExtendsClauseableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ExtendsClauseableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/GeneratorableNode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/GeneratorableNode.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction GeneratorableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.isGenerator = function () {\r\n            return this.compilerNode.asteriskToken != null;\r\n        };\r\n        class_1.prototype.getAsteriskToken = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.asteriskToken);\r\n        };\r\n        class_1.prototype.getAsteriskTokenOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getAsteriskToken(), \"Expected to find an asterisk token.\");\r\n        };\r\n        class_1.prototype.setIsGenerator = function (value) {\r\n            var asteriskToken = this.getAsteriskToken();\r\n            var isSet = asteriskToken != null;\r\n            if (isSet === value)\r\n                return this;\r\n            if (asteriskToken == null) {\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: getAsteriskInsertPos(this),\r\n                    parent: this,\r\n                    newText: \"*\"\r\n                });\r\n            }\r\n            else {\r\n                manipulation_1.removeChildrenWithFormatting({\r\n                    children: [asteriskToken],\r\n                    getSiblingFormatting: function () { return manipulation_1.FormattingKind.Space; }\r\n                });\r\n            }\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isGenerator != null)\r\n                this.setIsGenerator(structure.isGenerator);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.GeneratorableNode = GeneratorableNode;\r\nfunction getAsteriskInsertPos(node) {\r\n    if (node.getKind() === typescript_1.SyntaxKind.FunctionDeclaration)\r\n        return node.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.FunctionKeyword).getEnd();\r\n    var namedNode = node;\r\n    /* istanbul ignore if */\r\n    if (namedNode.getName == null)\r\n        throw new errors.NotImplementedError(\"Expected a name node for a non-function declaration.\");\r\n    return namedNode.getNameNode().getStart();\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/GeneratorableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/HeritageClauseableNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/HeritageClauseableNode.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction HeritageClauseableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getHeritageClauses = function () {\r\n            var _this = this;\r\n            var heritageClauses = this.compilerNode.heritageClauses;\r\n            if (heritageClauses == null)\r\n                return [];\r\n            return heritageClauses.map(function (c) { return _this.getNodeFromCompilerNode(c); });\r\n        };\r\n        class_1.prototype.getHeritageClauseByKindOrThrow = function (kind) {\r\n            return errors.throwIfNullOrUndefined(this.getHeritageClauseByKind(kind), \"Expected to have heritage clause of kind \" + utils_1.getSyntaxKindName(kind) + \".\");\r\n        };\r\n        class_1.prototype.getHeritageClauseByKind = function (kind) {\r\n            return utils_1.ArrayUtils.find(this.getHeritageClauses(), function (c) { return c.compilerNode.token === kind; });\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.HeritageClauseableNode = HeritageClauseableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/HeritageClauseableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ImplementsClauseableNode.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ImplementsClauseableNode.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar structurePrinters_1 = __webpack_require__(/*! ../../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ImplementsClauseableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getImplements = function () {\r\n            var implementsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ImplementsKeyword);\r\n            return implementsClause == null ? [] : implementsClause.getTypeNodes();\r\n        };\r\n        class_1.prototype.addImplements = function (text) {\r\n            return this.insertImplements(this.getImplements().length, text);\r\n        };\r\n        class_1.prototype.insertImplements = function (index, texts) {\r\n            var length = texts instanceof Array ? texts.length : 0;\r\n            if (typeof texts === \"string\") {\r\n                errors.throwIfNotStringOrWhitespace(texts, \"texts\");\r\n                texts = [texts];\r\n            }\r\n            else if (texts.length === 0) {\r\n                return [];\r\n            }\r\n            var writer = this.getWriterWithQueuedChildIndentation();\r\n            var structurePrinter = new structurePrinters_1.CommaSeparatedStructuresPrinter(new structurePrinters_1.StringStructurePrinter());\r\n            structurePrinter.printText(writer, texts);\r\n            var heritageClauses = this.getHeritageClauses();\r\n            var implementsTypes = this.getImplements();\r\n            index = manipulation_1.verifyAndGetIndex(index, implementsTypes.length);\r\n            if (implementsTypes.length > 0) {\r\n                var implementsClause = this.getHeritageClauseByKindOrThrow(typescript_1.SyntaxKind.ImplementsKeyword);\r\n                manipulation_1.insertIntoCommaSeparatedNodes({\r\n                    parent: implementsClause.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                    currentNodes: implementsTypes,\r\n                    insertIndex: index,\r\n                    newText: writer.toString()\r\n                });\r\n                return manipulation_1.getNodeOrNodesToReturn(this.getImplements(), index, length);\r\n            }\r\n            var openBraceToken = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenBraceToken);\r\n            var openBraceStart = openBraceToken.getStart();\r\n            var isLastSpace = /\\s/.test(this.getSourceFile().getFullText()[openBraceStart - 1]);\r\n            var insertText = \"implements \" + writer.toString() + \" \";\r\n            if (!isLastSpace)\r\n                insertText = \" \" + insertText;\r\n            // assumes there can only be another extends heritage clause\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: heritageClauses.length === 0 ? this : heritageClauses[0].getParentSyntaxListOrThrow(),\r\n                insertPos: openBraceStart,\r\n                newText: insertText\r\n            });\r\n            return manipulation_1.getNodeOrNodesToReturn(this.getImplements(), index, length);\r\n        };\r\n        class_1.prototype.removeImplements = function (implementsNodeOrIndex) {\r\n            var implementsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ImplementsKeyword);\r\n            if (implementsClause == null)\r\n                throw new errors.InvalidOperationError(\"Cannot remove an implements when none exist.\");\r\n            implementsClause.removeExpression(implementsNodeOrIndex);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.implements != null && structure.implements.length > 0)\r\n                this.addImplements(structure.implements);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ImplementsClauseableNode = ImplementsClauseableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ImplementsClauseableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/JSDocableNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/JSDocableNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction JSDocableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getJsDocs = function () {\r\n            var _this = this;\r\n            var nodes = this.compilerNode.jsDoc;\r\n            if (nodes == null)\r\n                return [];\r\n            return nodes.map(function (n) { return _this.getNodeFromCompilerNode(n); });\r\n        };\r\n        class_1.prototype.addJsDoc = function (structure) {\r\n            return this.addJsDocs([structure])[0];\r\n        };\r\n        class_1.prototype.addJsDocs = function (structures) {\r\n            return this.insertJsDocs(manipulation_1.getEndIndexFromArray(this.compilerNode.jsDoc), structures);\r\n        };\r\n        class_1.prototype.insertJsDoc = function (index, structure) {\r\n            return this.insertJsDocs(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertJsDocs = function (index, structures) {\r\n            if (utils_1.ArrayUtils.isNullOrEmpty(structures))\r\n                return [];\r\n            var writer = this.getWriterWithQueuedIndentation();\r\n            var structurePrinter = this.context.structurePrinterFactory.forJSDoc();\r\n            structurePrinter.printDocs(writer, structures);\r\n            writer.write(\"\"); // final indentation\r\n            var code = writer.toString();\r\n            var nodes = this.getJsDocs();\r\n            index = manipulation_1.verifyAndGetIndex(index, nodes.length);\r\n            var insertPos = index === nodes.length ? this.getStart() : nodes[index].getStart();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: insertPos,\r\n                parent: this,\r\n                newText: code\r\n            });\r\n            return manipulation_1.getNodesToReturn(this.getJsDocs(), index, structures.length);\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.docs != null && structure.docs.length > 0)\r\n                this.addJsDocs(structure.docs);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.JSDocableNode = JSDocableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/JSDocableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/LiteralLikeNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/LiteralLikeNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction LiteralLikeNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getLiteralText = function () {\r\n            return this.compilerNode.text;\r\n        };\r\n        class_1.prototype.isTerminated = function () {\r\n            // I'm sorry, but this should not be a negative\r\n            return !(this.compilerNode.isUnterminated || false);\r\n        };\r\n        class_1.prototype.hasExtendedUnicodeEscape = function () {\r\n            return this.compilerNode.hasExtendedUnicodeEscape || false;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.LiteralLikeNode = LiteralLikeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/LiteralLikeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ModifierableNode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ModifierableNode.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction ModifierableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getModifiers = function () {\r\n            var _this = this;\r\n            return this.getCompilerModifiers().map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.getFirstModifierByKindOrThrow = function (kind) {\r\n            return errors.throwIfNullOrUndefined(this.getFirstModifierByKind(kind), \"Expected a modifier of syntax kind: \" + utils_1.getSyntaxKindName(kind));\r\n        };\r\n        class_1.prototype.getFirstModifierByKind = function (kind) {\r\n            var e_1, _a;\r\n            try {\r\n                for (var _b = tslib_1.__values(this.getCompilerModifiers()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var modifier = _c.value;\r\n                    if (modifier.kind === kind)\r\n                        return this.getNodeFromCompilerNode(modifier);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return undefined;\r\n        };\r\n        class_1.prototype.hasModifier = function (textOrKind) {\r\n            if (typeof textOrKind === \"string\")\r\n                return this.getModifiers().some(function (m) { return m.getText() === textOrKind; });\r\n            else\r\n                return this.getCompilerModifiers().some(function (m) { return m.kind === textOrKind; });\r\n        };\r\n        class_1.prototype.toggleModifier = function (text, value) {\r\n            if (value == null)\r\n                value = !this.hasModifier(text);\r\n            if (value)\r\n                this.addModifier(text);\r\n            else\r\n                this.removeModifier(text);\r\n            return this;\r\n        };\r\n        class_1.prototype.addModifier = function (text) {\r\n            var modifiers = this.getModifiers();\r\n            var existingModifier = utils_1.ArrayUtils.find(modifiers, function (m) { return m.getText() === text; });\r\n            if (existingModifier != null)\r\n                return existingModifier;\r\n            // get insert position & index\r\n            var _a = getInsertInfo(this), insertPos = _a.insertPos, insertIndex = _a.insertIndex;\r\n            // insert setup\r\n            var startPos;\r\n            var newText;\r\n            var isFirstModifier = modifiers.length === 0 || insertPos === modifiers[0].getStart();\r\n            if (isFirstModifier) {\r\n                newText = text + \" \";\r\n                startPos = insertPos;\r\n            }\r\n            else {\r\n                newText = \" \" + text;\r\n                startPos = insertPos + 1;\r\n            }\r\n            // insert\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: modifiers.length === 0 ? this : modifiers[0].getParentSyntaxListOrThrow(),\r\n                insertPos: insertPos,\r\n                newText: newText\r\n            });\r\n            return utils_1.ArrayUtils.find(this.getModifiers(), function (m) { return m.getStart() === startPos; });\r\n            function getInsertInfo(node) {\r\n                var e_2, _a;\r\n                var pos = getInitialInsertPos();\r\n                var index = 0;\r\n                try {\r\n                    for (var _b = tslib_1.__values(getAddAfterModifierTexts(text)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                        var addAfterText = _c.value;\r\n                        for (var i = 0; i < modifiers.length; i++) {\r\n                            var modifier = modifiers[i];\r\n                            if (modifier.getText() === addAfterText) {\r\n                                if (pos < modifier.getEnd()) {\r\n                                    pos = modifier.getEnd();\r\n                                    index = i + 1;\r\n                                }\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                }\r\n                return { insertPos: pos, insertIndex: index };\r\n                function getInitialInsertPos() {\r\n                    var e_3, _a;\r\n                    if (modifiers.length > 0)\r\n                        return modifiers[0].getStart();\r\n                    try {\r\n                        for (var _b = tslib_1.__values(node.getChildrenIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                            var child = _c.value;\r\n                            // skip over any initial syntax lists (ex. decorators) or js docs\r\n                            if (child.getKind() === typescript_1.SyntaxKind.SyntaxList || typescript_1.ts.isJSDocCommentContainingNode(child.compilerNode))\r\n                                continue;\r\n                            return child.getStart();\r\n                        }\r\n                    }\r\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                        }\r\n                        finally { if (e_3) throw e_3.error; }\r\n                    }\r\n                    return node.getStart();\r\n                }\r\n            }\r\n        };\r\n        class_1.prototype.removeModifier = function (text) {\r\n            var modifiers = this.getModifiers();\r\n            var modifier = utils_1.ArrayUtils.find(modifiers, function (m) { return m.getText() === text; });\r\n            if (modifier == null)\r\n                return false;\r\n            manipulation_1.removeChildren({\r\n                children: [modifiers.length === 1 ? modifier.getParentSyntaxListOrThrow() : modifier],\r\n                removeFollowingSpaces: true\r\n            });\r\n            return true;\r\n        };\r\n        class_1.prototype.getCompilerModifiers = function () {\r\n            return this.compilerNode.modifiers || [];\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ModifierableNode = ModifierableNode;\r\n/**\r\n * @returns The texts the specified text should appear after.\r\n */\r\nfunction getAddAfterModifierTexts(text) {\r\n    switch (text) {\r\n        case \"export\":\r\n            return [];\r\n        case \"default\":\r\n            return [\"export\"];\r\n        case \"declare\":\r\n            return [\"export\", \"default\"];\r\n        case \"abstract\":\r\n            return [\"export\", \"default\", \"declare\", \"public\", \"private\", \"protected\"];\r\n        case \"readonly\":\r\n            return [\"export\", \"default\", \"declare\", \"public\", \"private\", \"protected\", \"abstract\", \"static\"];\r\n        case \"public\":\r\n        case \"protected\":\r\n        case \"private\":\r\n            return [];\r\n        case \"static\":\r\n            return [\"public\", \"protected\", \"private\"];\r\n        case \"async\":\r\n            return [\"export\", \"public\", \"protected\", \"private\", \"static\", \"abstract\"];\r\n        case \"const\":\r\n            return [];\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw new errors.NotImplementedError(\"Not implemented modifier: \" + text);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ModifierableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ParameteredNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ParameteredNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ParameteredNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getParameter = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getParameters(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getParameterOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getParameter(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"parameter\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.getParameters = function () {\r\n            var _this = this;\r\n            return this.compilerNode.parameters.map(function (p) { return _this.getNodeFromCompilerNode(p); });\r\n        };\r\n        class_1.prototype.addParameter = function (structure) {\r\n            return this.addParameters([structure])[0];\r\n        };\r\n        class_1.prototype.addParameters = function (structures) {\r\n            return this.insertParameters(manipulation_1.getEndIndexFromArray(this.compilerNode.parameters), structures);\r\n        };\r\n        class_1.prototype.insertParameter = function (index, structure) {\r\n            return this.insertParameters(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertParameters = function (index, structures) {\r\n            if (utils_1.ArrayUtils.isNullOrEmpty(structures))\r\n                return [];\r\n            var parameters = this.getParameters();\r\n            var syntaxList = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenParenToken).getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.SyntaxList);\r\n            index = manipulation_1.verifyAndGetIndex(index, parameters.length);\r\n            var writer = this.getWriterWithQueuedChildIndentation();\r\n            var structurePrinter = this.context.structurePrinterFactory.forParameterDeclaration();\r\n            structurePrinter.printTexts(writer, structures);\r\n            manipulation_1.insertIntoCommaSeparatedNodes({\r\n                parent: syntaxList,\r\n                currentNodes: parameters,\r\n                insertIndex: index,\r\n                newText: writer.toString()\r\n            });\r\n            return manipulation_1.getNodesToReturn(this.getParameters(), index, structures.length);\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.parameters != null && structure.parameters.length > 0)\r\n                this.addParameters(structure.parameters);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ParameteredNode = ParameteredNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ParameteredNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/QuestionTokenableNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/QuestionTokenableNode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction QuestionTokenableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.hasQuestionToken = function () {\r\n            return this.compilerNode.questionToken != null;\r\n        };\r\n        class_1.prototype.getQuestionTokenNode = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.questionToken);\r\n        };\r\n        class_1.prototype.getQuestionTokenNodeOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getQuestionTokenNode(), \"Expected to find a question token.\");\r\n        };\r\n        class_1.prototype.setHasQuestionToken = function (value) {\r\n            var questionTokenNode = this.getQuestionTokenNode();\r\n            var hasQuestionToken = questionTokenNode != null;\r\n            if (value === hasQuestionToken)\r\n                return this;\r\n            if (value) {\r\n                if (utils_1.TypeGuards.isExclamationTokenableNode(this))\r\n                    this.setHasExclamationToken(false);\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: getInsertPos.call(this),\r\n                    parent: this,\r\n                    newText: \"?\"\r\n                });\r\n            }\r\n            else\r\n                manipulation_1.removeChildren({ children: [questionTokenNode] });\r\n            return this;\r\n            function getInsertPos() {\r\n                var colonNode = this.getFirstChildByKind(typescript_1.SyntaxKind.ColonToken);\r\n                if (colonNode != null)\r\n                    return colonNode.getStart();\r\n                var semicolonToken = this.getLastChildByKind(typescript_1.SyntaxKind.SemicolonToken);\r\n                if (semicolonToken != null)\r\n                    return semicolonToken.getStart();\r\n                return this.getEnd();\r\n            }\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.hasQuestionToken != null)\r\n                this.setHasQuestionToken(structure.hasQuestionToken);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.QuestionTokenableNode = QuestionTokenableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/QuestionTokenableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ReadonlyableNode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ReadonlyableNode.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ReadonlyableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.isReadonly = function () {\r\n            return this.getReadonlyKeyword() != null;\r\n        };\r\n        class_1.prototype.getReadonlyKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.ReadonlyKeyword);\r\n        };\r\n        class_1.prototype.getReadonlyKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getReadonlyKeyword(), \"Expected to find a readonly keyword.\");\r\n        };\r\n        class_1.prototype.setIsReadonly = function (value) {\r\n            this.toggleModifier(\"readonly\", value);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isReadonly != null)\r\n                this.setIsReadonly(structure.isReadonly);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ReadonlyableNode = ReadonlyableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ReadonlyableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ReturnTypedNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ReturnTypedNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction ReturnTypedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getReturnType = function () {\r\n            var typeChecker = this.context.typeChecker;\r\n            var signature = typeChecker.getSignatureFromNode(this); // should always return a signature\r\n            return signature.getReturnType();\r\n        };\r\n        class_1.prototype.getReturnTypeNode = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.type);\r\n        };\r\n        class_1.prototype.getReturnTypeNodeOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getReturnTypeNode(), \"Expected to find a return type node.\");\r\n        };\r\n        class_1.prototype.setReturnType = function (textOrWriterFunction) {\r\n            var text = utils_1.getTextFromStringOrWriter(this.getWriterWithQueuedChildIndentation(), textOrWriterFunction);\r\n            if (utils_1.StringUtils.isNullOrWhitespace(text))\r\n                return this.removeReturnType();\r\n            var returnTypeNode = this.getReturnTypeNode();\r\n            if (returnTypeNode != null && returnTypeNode.getText() === text)\r\n                return this;\r\n            // insert new type\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: returnTypeNode != null ? returnTypeNode.getStart() : this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.CloseParenToken).getEnd(),\r\n                newText: returnTypeNode != null ? text : \": \" + text,\r\n                replacing: {\r\n                    textLength: returnTypeNode == null ? 0 : returnTypeNode.getWidth()\r\n                }\r\n            });\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.returnType != null)\r\n                this.setReturnType(structure.returnType);\r\n            return this;\r\n        };\r\n        class_1.prototype.removeReturnType = function () {\r\n            var returnTypeNode = this.getReturnTypeNode();\r\n            if (returnTypeNode == null)\r\n                return this;\r\n            var colonToken = returnTypeNode.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.ColonToken);\r\n            manipulation_1.removeChildren({ children: [colonToken, returnTypeNode], removePrecedingSpaces: true });\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ReturnTypedNode = ReturnTypedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ReturnTypedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ScopeableNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ScopeableNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar Scope_1 = __webpack_require__(/*! ../common/Scope */ \"./node_modules/ts-simple-ast/dist/compiler/common/Scope.js\");\r\nfunction ScopeableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getScope = function () {\r\n            return getScopeForNode(this);\r\n        };\r\n        class_1.prototype.setScope = function (scope) {\r\n            setScopeForNode(this, scope);\r\n            return this;\r\n        };\r\n        class_1.prototype.hasScopeKeyword = function () {\r\n            return this.getScope() != null;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.scope != null)\r\n                this.setScope(structure.scope);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ScopeableNode = ScopeableNode;\r\n/**\r\n * Gets the scope for a node.\r\n * @internal\r\n * @param node - Node to check for.\r\n */\r\nfunction getScopeForNode(node) {\r\n    var modifierFlags = node.getCombinedModifierFlags();\r\n    if ((modifierFlags & typescript_1.ts.ModifierFlags.Private) !== 0)\r\n        return Scope_1.Scope.Private;\r\n    else if ((modifierFlags & typescript_1.ts.ModifierFlags.Protected) !== 0)\r\n        return Scope_1.Scope.Protected;\r\n    else if ((modifierFlags & typescript_1.ts.ModifierFlags.Public) !== 0)\r\n        return Scope_1.Scope.Public;\r\n    else\r\n        return undefined;\r\n}\r\nexports.getScopeForNode = getScopeForNode;\r\n/**\r\n * Sets the scope for a node.\r\n * @internal\r\n * @param node - Node to set the scope for.\r\n * @param scope - Scope to be set to.\r\n */\r\nfunction setScopeForNode(node, scope) {\r\n    node.toggleModifier(\"public\", scope === Scope_1.Scope.Public); // always be explicit with scope\r\n    node.toggleModifier(\"protected\", scope === Scope_1.Scope.Protected);\r\n    node.toggleModifier(\"private\", scope === Scope_1.Scope.Private);\r\n}\r\nexports.setScopeForNode = setScopeForNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ScopeableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/ScopedNode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/ScopedNode.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar Scope_1 = __webpack_require__(/*! ../common/Scope */ \"./node_modules/ts-simple-ast/dist/compiler/common/Scope.js\");\r\nvar scopeableNode = __webpack_require__(/*! ./ScopeableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ScopeableNode.js\");\r\nfunction ScopedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getScope = function () {\r\n            return scopeableNode.getScopeForNode(this) || Scope_1.Scope.Public;\r\n        };\r\n        class_1.prototype.setScope = function (scope) {\r\n            scopeableNode.setScopeForNode(this, scope);\r\n            return this;\r\n        };\r\n        class_1.prototype.hasScopeKeyword = function () {\r\n            return scopeableNode.getScopeForNode(this) != null;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.scope != null)\r\n                this.setScope(structure.scope);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ScopedNode = ScopedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/ScopedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/SignaturedDeclaration.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/SignaturedDeclaration.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ParameteredNode_1 = __webpack_require__(/*! ./ParameteredNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ParameteredNode.js\");\r\nvar ReturnTypedNode_1 = __webpack_require__(/*! ./ReturnTypedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ReturnTypedNode.js\");\r\nfunction SignaturedDeclaration(Base) {\r\n    return ReturnTypedNode_1.ReturnTypedNode(ParameteredNode_1.ParameteredNode(Base));\r\n}\r\nexports.SignaturedDeclaration = SignaturedDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/SignaturedDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/StaticableNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/StaticableNode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction StaticableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.isStatic = function () {\r\n            return this.hasModifier(typescript_1.SyntaxKind.StaticKeyword);\r\n        };\r\n        class_1.prototype.getStaticKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.StaticKeyword);\r\n        };\r\n        class_1.prototype.getStaticKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getStaticKeyword(), \"Expected to find a static keyword.\");\r\n        };\r\n        class_1.prototype.setIsStatic = function (value) {\r\n            this.toggleModifier(\"static\", value);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isStatic != null)\r\n                this.setIsStatic(structure.isStatic);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.StaticableNode = StaticableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/StaticableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/TextInsertableNode.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/TextInsertableNode.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction TextInsertableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.insertText = function (pos, textOrWriterFunction) {\r\n            this.replaceText([pos, pos], textOrWriterFunction);\r\n            return this;\r\n        };\r\n        class_1.prototype.removeText = function (pos, end) {\r\n            if (pos == null)\r\n                this.replaceText(getValidRange(this), \"\");\r\n            else\r\n                this.replaceText([pos, end], \"\");\r\n            return this;\r\n        };\r\n        class_1.prototype.replaceText = function (range, textOrWriterFunction) {\r\n            var childSyntaxList = this.getChildSyntaxListOrThrow();\r\n            var validRange = getValidRange(this);\r\n            var pos = range[0];\r\n            var end = range[1];\r\n            verifyArguments();\r\n            // ideally this wouldn't replace the existing syntax list\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: pos,\r\n                newText: utils_1.getTextFromStringOrWriter(this.getWriter(), textOrWriterFunction),\r\n                parent: childSyntaxList.getParentOrThrow(),\r\n                replacing: {\r\n                    textLength: end - pos,\r\n                    nodes: [childSyntaxList]\r\n                }\r\n            });\r\n            return this;\r\n            function verifyArguments() {\r\n                verifyInRange(pos);\r\n                verifyInRange(end);\r\n                if (pos > end)\r\n                    throw new errors.ArgumentError(\"range\", \"Cannot specify a start position greater than the end position.\");\r\n            }\r\n            function verifyInRange(i) {\r\n                if (i >= validRange[0] && i <= validRange[1])\r\n                    return;\r\n                throw new errors.InvalidOperationError(\"Cannot insert or replace text outside the bounds of the node. \" +\r\n                    (\"Expected a position between [\" + validRange[0] + \", \" + validRange[1] + \"], but received \" + i + \".\"));\r\n            }\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.TextInsertableNode = TextInsertableNode;\r\nfunction getValidRange(thisNode) {\r\n    var rangeNode = getRangeNode();\r\n    var openBrace = utils_1.TypeGuards.isSourceFile(rangeNode) ? undefined : rangeNode.getPreviousSiblingIfKind(typescript_1.SyntaxKind.OpenBraceToken);\r\n    var closeBrace = openBrace == null ? undefined : rangeNode.getNextSiblingIfKind(typescript_1.SyntaxKind.CloseBraceToken);\r\n    if (openBrace != null && closeBrace != null)\r\n        return [openBrace.getEnd(), closeBrace.getStart()];\r\n    else\r\n        return [rangeNode.getPos(), rangeNode.getEnd()];\r\n    function getRangeNode() {\r\n        if (utils_1.TypeGuards.isSourceFile(thisNode))\r\n            return thisNode;\r\n        return thisNode.getChildSyntaxListOrThrow();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/TextInsertableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/TypeArgumentedNode.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/TypeArgumentedNode.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction TypeArgumentedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getTypeArguments = function () {\r\n            var _this = this;\r\n            if (this.compilerNode.typeArguments == null)\r\n                return [];\r\n            return this.compilerNode.typeArguments.map(function (a) { return _this.getNodeFromCompilerNode(a); });\r\n        };\r\n        class_1.prototype.addTypeArgument = function (argumentText) {\r\n            return this.addTypeArguments([argumentText])[0];\r\n        };\r\n        class_1.prototype.addTypeArguments = function (argumentTexts) {\r\n            return this.insertTypeArguments(this.getTypeArguments().length, argumentTexts);\r\n        };\r\n        class_1.prototype.insertTypeArgument = function (index, argumentText) {\r\n            return this.insertTypeArguments(index, [argumentText])[0];\r\n        };\r\n        class_1.prototype.insertTypeArguments = function (index, argumentTexts) {\r\n            if (utils_1.ArrayUtils.isNullOrEmpty(argumentTexts))\r\n                return [];\r\n            var typeArguments = this.getTypeArguments();\r\n            index = manipulation_1.verifyAndGetIndex(index, typeArguments.length);\r\n            if (typeArguments.length === 0) {\r\n                var identifier = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.Identifier);\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: identifier.getEnd(),\r\n                    parent: this,\r\n                    newText: \"<\" + argumentTexts.join(\", \") + \">\"\r\n                });\r\n            }\r\n            else {\r\n                manipulation_1.insertIntoCommaSeparatedNodes({\r\n                    parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.LessThanToken).getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                    currentNodes: typeArguments,\r\n                    insertIndex: index,\r\n                    newText: argumentTexts.join(\", \")\r\n                });\r\n            }\r\n            return manipulation_1.getNodesToReturn(this.getTypeArguments(), index, argumentTexts.length);\r\n        };\r\n        class_1.prototype.removeTypeArgument = function (typeArgOrIndex) {\r\n            var typeArguments = this.getTypeArguments();\r\n            if (typeArguments.length === 0)\r\n                throw new errors.InvalidOperationError(\"Cannot remove a type argument when none exist.\");\r\n            var typeArgToRemove = typeof typeArgOrIndex === \"number\" ? getTypeArgFromIndex(typeArgOrIndex) : typeArgOrIndex;\r\n            if (typeArguments.length === 1) {\r\n                var childSyntaxList = typeArguments[0].getParentSyntaxListOrThrow();\r\n                manipulation_1.removeChildren({\r\n                    children: [\r\n                        childSyntaxList.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.LessThanToken),\r\n                        childSyntaxList,\r\n                        childSyntaxList.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.GreaterThanToken)\r\n                    ]\r\n                });\r\n            }\r\n            else\r\n                manipulation_1.removeCommaSeparatedChild(typeArgToRemove);\r\n            return this;\r\n            function getTypeArgFromIndex(index) {\r\n                return typeArguments[manipulation_1.verifyAndGetIndex(index, typeArguments.length - 1)];\r\n            }\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.TypeArgumentedNode = TypeArgumentedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/TypeArgumentedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/TypeElementMemberedNode.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/TypeElementMemberedNode.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction TypeElementMemberedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.addConstructSignature = function (structure) {\r\n            return this.addConstructSignatures([structure])[0];\r\n        };\r\n        class_1.prototype.addConstructSignatures = function (structures) {\r\n            return this.insertConstructSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);\r\n        };\r\n        class_1.prototype.insertConstructSignature = function (index, structure) {\r\n            return this.insertConstructSignatures(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertConstructSignatures = function (index, structures) {\r\n            var _this = this;\r\n            return insertChildren({\r\n                thisNode: this,\r\n                index: index,\r\n                structures: structures,\r\n                expectedKind: typescript_1.SyntaxKind.ConstructSignature,\r\n                createStructurePrinter: function () { return _this.context.structurePrinterFactory.forConstructSignatureDeclaration(); }\r\n            });\r\n        };\r\n        class_1.prototype.getConstructSignature = function (findFunction) {\r\n            return utils_1.ArrayUtils.find(this.getConstructSignatures(), findFunction);\r\n        };\r\n        class_1.prototype.getConstructSignatureOrThrow = function (findFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getConstructSignature(findFunction), \"Expected to find a construct signature with the provided condition.\");\r\n        };\r\n        class_1.prototype.getConstructSignatures = function () {\r\n            var _this = this;\r\n            return this.compilerNode.members.filter(function (m) { return m.kind === typescript_1.SyntaxKind.ConstructSignature; })\r\n                .map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.addCallSignature = function (structure) {\r\n            return this.addCallSignatures([structure])[0];\r\n        };\r\n        class_1.prototype.addCallSignatures = function (structures) {\r\n            return this.insertCallSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);\r\n        };\r\n        class_1.prototype.insertCallSignature = function (index, structure) {\r\n            return this.insertCallSignatures(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertCallSignatures = function (index, structures) {\r\n            var _this = this;\r\n            return insertChildren({\r\n                thisNode: this,\r\n                index: index,\r\n                structures: structures,\r\n                expectedKind: typescript_1.SyntaxKind.CallSignature,\r\n                createStructurePrinter: function () { return _this.context.structurePrinterFactory.forCallSignatureDeclaration(); }\r\n            });\r\n        };\r\n        class_1.prototype.getCallSignature = function (findFunction) {\r\n            return utils_1.ArrayUtils.find(this.getCallSignatures(), findFunction);\r\n        };\r\n        class_1.prototype.getCallSignatureOrThrow = function (findFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getCallSignature(findFunction), \"Expected to find a call signature with the provided condition.\");\r\n        };\r\n        class_1.prototype.getCallSignatures = function () {\r\n            var _this = this;\r\n            return this.compilerNode.members.filter(function (m) { return m.kind === typescript_1.SyntaxKind.CallSignature; })\r\n                .map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.addIndexSignature = function (structure) {\r\n            return this.addIndexSignatures([structure])[0];\r\n        };\r\n        class_1.prototype.addIndexSignatures = function (structures) {\r\n            return this.insertIndexSignatures(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);\r\n        };\r\n        class_1.prototype.insertIndexSignature = function (index, structure) {\r\n            return this.insertIndexSignatures(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertIndexSignatures = function (index, structures) {\r\n            var _this = this;\r\n            return insertChildren({\r\n                thisNode: this,\r\n                index: index,\r\n                structures: structures,\r\n                expectedKind: typescript_1.SyntaxKind.IndexSignature,\r\n                createStructurePrinter: function () { return _this.context.structurePrinterFactory.forIndexSignatureDeclaration(); }\r\n            });\r\n        };\r\n        class_1.prototype.getIndexSignature = function (findFunction) {\r\n            return utils_1.ArrayUtils.find(this.getIndexSignatures(), findFunction);\r\n        };\r\n        class_1.prototype.getIndexSignatureOrThrow = function (findFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getIndexSignature(findFunction), \"Expected to find a index signature with the provided condition.\");\r\n        };\r\n        class_1.prototype.getIndexSignatures = function () {\r\n            var _this = this;\r\n            return this.compilerNode.members.filter(function (m) { return m.kind === typescript_1.SyntaxKind.IndexSignature; })\r\n                .map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.addMethod = function (structure) {\r\n            return this.addMethods([structure])[0];\r\n        };\r\n        class_1.prototype.addMethods = function (structures) {\r\n            return this.insertMethods(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);\r\n        };\r\n        class_1.prototype.insertMethod = function (index, structure) {\r\n            return this.insertMethods(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertMethods = function (index, structures) {\r\n            var _this = this;\r\n            return insertChildren({\r\n                thisNode: this,\r\n                index: index,\r\n                structures: structures,\r\n                expectedKind: typescript_1.SyntaxKind.MethodSignature,\r\n                createStructurePrinter: function () { return _this.context.structurePrinterFactory.forMethodSignature(); }\r\n            });\r\n        };\r\n        class_1.prototype.getMethod = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getMethodOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"interface method signature\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.getMethods = function () {\r\n            var _this = this;\r\n            return this.compilerNode.members.filter(function (m) { return m.kind === typescript_1.SyntaxKind.MethodSignature; })\r\n                .map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.addProperty = function (structure) {\r\n            return this.addProperties([structure])[0];\r\n        };\r\n        class_1.prototype.addProperties = function (structures) {\r\n            return this.insertProperties(manipulation_1.getEndIndexFromArray(this.compilerNode.members), structures);\r\n        };\r\n        class_1.prototype.insertProperty = function (index, structure) {\r\n            return this.insertProperties(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertProperties = function (index, structures) {\r\n            var _this = this;\r\n            return insertChildren({\r\n                thisNode: this,\r\n                index: index,\r\n                structures: structures,\r\n                expectedKind: typescript_1.SyntaxKind.PropertySignature,\r\n                createStructurePrinter: function () { return _this.context.structurePrinterFactory.forPropertySignature(); }\r\n            });\r\n        };\r\n        class_1.prototype.getProperty = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getPropertyOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"interface property signature\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.getProperties = function () {\r\n            var _this = this;\r\n            return this.compilerNode.members.filter(function (m) { return m.kind === typescript_1.SyntaxKind.PropertySignature; })\r\n                .map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.getMembers = function () {\r\n            var _this = this;\r\n            return this.compilerNode.members.map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.callSignatures != null)\r\n                this.addCallSignatures(structure.callSignatures);\r\n            if (structure.constructSignatures != null)\r\n                this.addConstructSignatures(structure.constructSignatures);\r\n            if (structure.indexSignatures != null)\r\n                this.addIndexSignatures(structure.indexSignatures);\r\n            if (structure.properties != null)\r\n                this.addProperties(structure.properties);\r\n            if (structure.methods != null)\r\n                this.addMethods(structure.methods);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.TypeElementMemberedNode = TypeElementMemberedNode;\r\nfunction insertChildren(opts) {\r\n    return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n        getIndexedChildren: function () { return opts.thisNode.getMembers(); },\r\n        parent: opts.thisNode,\r\n        index: opts.index,\r\n        structures: opts.structures,\r\n        expectedKind: opts.expectedKind,\r\n        write: function (writer, info) {\r\n            writer.newLineIfLastNot();\r\n            opts.createStructurePrinter().printTexts(writer, opts.structures);\r\n            writer.newLineIfLastNot();\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/TypeElementMemberedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/TypeParameteredNode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/TypeParameteredNode.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction TypeParameteredNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getTypeParameter = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getTypeParameters(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getTypeParameterOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getTypeParameter(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"type parameter\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.getTypeParameters = function () {\r\n            var _this = this;\r\n            var typeParameters = this.compilerNode.typeParameters;\r\n            if (typeParameters == null)\r\n                return [];\r\n            return typeParameters.map(function (t) { return _this.getNodeFromCompilerNode(t); });\r\n        };\r\n        class_1.prototype.addTypeParameter = function (structure) {\r\n            return this.addTypeParameters([structure])[0];\r\n        };\r\n        class_1.prototype.addTypeParameters = function (structures) {\r\n            return this.insertTypeParameters(manipulation_1.getEndIndexFromArray(this.compilerNode.typeParameters), structures);\r\n        };\r\n        class_1.prototype.insertTypeParameter = function (index, structure) {\r\n            return this.insertTypeParameters(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertTypeParameters = function (index, structures) {\r\n            if (utils_1.ArrayUtils.isNullOrEmpty(structures))\r\n                return [];\r\n            var typeParameters = this.getTypeParameters();\r\n            var writer = this.getWriterWithQueuedChildIndentation();\r\n            var structurePrinter = this.context.structurePrinterFactory.forTypeParameterDeclaration();\r\n            index = manipulation_1.verifyAndGetIndex(index, typeParameters.length);\r\n            structurePrinter.printTexts(writer, structures);\r\n            if (typeParameters.length === 0) {\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: getInsertPos(this),\r\n                    parent: this,\r\n                    newText: \"<\" + writer.toString() + \">\"\r\n                });\r\n            }\r\n            else {\r\n                manipulation_1.insertIntoCommaSeparatedNodes({\r\n                    parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.LessThanToken).getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                    currentNodes: typeParameters,\r\n                    insertIndex: index,\r\n                    newText: writer.toString()\r\n                });\r\n            }\r\n            return manipulation_1.getNodesToReturn(this.getTypeParameters(), index, structures.length);\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.typeParameters != null && structure.typeParameters.length > 0)\r\n                this.addTypeParameters(structure.typeParameters);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.TypeParameteredNode = TypeParameteredNode;\r\nfunction getInsertPos(node) {\r\n    var namedNode = node;\r\n    if (namedNode.getNameNode != null)\r\n        return namedNode.getNameNode().getEnd();\r\n    else if (utils_1.TypeGuards.isCallSignatureDeclaration(node) || utils_1.TypeGuards.isFunctionTypeNode(node))\r\n        return node.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenParenToken).getStart();\r\n    else\r\n        throw new errors.NotImplementedError(\"Not implemented scenario inserting type parameters for node with kind \" + node.getKindName() + \".\");\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/TypeParameteredNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/TypedNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/TypedNode.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction TypedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getTypeNode = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.type);\r\n        };\r\n        class_1.prototype.getTypeNodeOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getTypeNode(), \"Expected to find a type node.\");\r\n        };\r\n        class_1.prototype.setType = function (textOrWriterFunction) {\r\n            var text = utils_1.getTextFromStringOrWriter(this.getWriterWithQueuedChildIndentation(), textOrWriterFunction);\r\n            if (utils_1.StringUtils.isNullOrWhitespace(text))\r\n                return this.removeType();\r\n            var typeNode = this.getTypeNode();\r\n            if (typeNode != null && typeNode.getText() === text)\r\n                return this;\r\n            // remove previous type\r\n            var separatorSyntaxKind = getSeparatorSyntaxKindForNode(this);\r\n            var separatorNode = this.getFirstChildByKind(separatorSyntaxKind);\r\n            var insertPos;\r\n            var newText;\r\n            if (separatorNode == null) {\r\n                insertPos = getInsertPosWhenNoType(this);\r\n                newText = (separatorSyntaxKind === typescript_1.SyntaxKind.EqualsToken ? \" = \" : \": \") + text;\r\n            }\r\n            else {\r\n                insertPos = typeNode.getStart();\r\n                newText = text;\r\n            }\r\n            // insert new type\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: insertPos,\r\n                newText: newText,\r\n                replacing: {\r\n                    textLength: typeNode == null ? 0 : typeNode.getWidth()\r\n                }\r\n            });\r\n            return this;\r\n            function getInsertPosWhenNoType(node) {\r\n                var identifier = node.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.Identifier);\r\n                var nextSibling = identifier.getNextSibling();\r\n                var insertAfterNode = isQuestionOrExclamation(nextSibling) ? nextSibling : identifier;\r\n                return insertAfterNode.getEnd();\r\n            }\r\n            function isQuestionOrExclamation(node) {\r\n                if (node == null)\r\n                    return false;\r\n                var kind = node.getKind();\r\n                return kind === typescript_1.SyntaxKind.QuestionToken || kind === typescript_1.SyntaxKind.ExclamationToken;\r\n            }\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.type != null)\r\n                this.setType(structure.type);\r\n            return this;\r\n        };\r\n        class_1.prototype.removeType = function () {\r\n            if (this.getKind() === typescript_1.SyntaxKind.TypeAliasDeclaration)\r\n                throw new errors.NotSupportedError(\"Cannot remove the type of a type alias. Use \" + \"setType\" + \" instead.\");\r\n            var typeNode = this.getTypeNode();\r\n            if (typeNode == null)\r\n                return this;\r\n            var separatorToken = typeNode.getPreviousSiblingIfKindOrThrow(getSeparatorSyntaxKindForNode(this));\r\n            manipulation_1.removeChildren({ children: [separatorToken, typeNode], removePrecedingSpaces: true });\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.TypedNode = TypedNode;\r\nfunction getSeparatorSyntaxKindForNode(node) {\r\n    switch (node.getKind()) {\r\n        case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n            return typescript_1.SyntaxKind.EqualsToken;\r\n        default:\r\n            return typescript_1.SyntaxKind.ColonToken;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/TypedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/UnwrappableNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/UnwrappableNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nfunction UnwrappableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.unwrap = function () {\r\n            manipulation_1.unwrapNode(this);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.UnwrappableNode = UnwrappableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/UnwrappableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/helpers/getBodyText.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/helpers/getBodyText.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * @internal\r\n */\r\nfunction getBodyText(writer, textOrWriterFunction) {\r\n    writer.newLineIfLastNot();\r\n    if (typeof textOrWriterFunction !== \"string\" || textOrWriterFunction.length > 0)\r\n        writer.indentBlock(function () {\r\n            utils_1.printTextFromStringOrWriter(writer, textOrWriterFunction);\r\n        });\r\n    writer.newLineIfLastNot();\r\n    writer.write(\"\"); // write last line's indentation\r\n    return writer.toString();\r\n}\r\nexports.getBodyText = getBodyText;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/helpers/getBodyText.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/helpers/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/helpers/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getBodyText */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/getBodyText.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./setBodyTextForNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/setBodyTextForNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/helpers/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/helpers/setBodyTextForNode.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/helpers/setBodyTextForNode.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar getBodyText_1 = __webpack_require__(/*! ./getBodyText */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/getBodyText.js\");\r\n/**\r\n * @internal\r\n */\r\nfunction setBodyTextForNode(body, textOrWriterFunction) {\r\n    var newText = getBodyText_1.getBodyText(body.getWriterWithIndentation(), textOrWriterFunction);\r\n    var openBrace = body.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenBraceToken);\r\n    var closeBrace = body.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.CloseBraceToken);\r\n    manipulation_1.insertIntoParentTextRange({\r\n        insertPos: openBrace.getEnd(),\r\n        newText: newText,\r\n        parent: body,\r\n        replacing: {\r\n            textLength: closeBrace.getStart() - openBrace.getEnd()\r\n        }\r\n    });\r\n}\r\nexports.setBodyTextForNode = setBodyTextForNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/helpers/setBodyTextForNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AmbientableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/AmbientableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArgumentedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ArgumentedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AsyncableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/AsyncableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AwaitableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/AwaitableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BodiedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/BodiedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BodyableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/BodyableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ChildOrderableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ChildOrderableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DecoratableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/DecoratableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExclamationTokenableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ExclamationTokenableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExportableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ExportableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExtendsClauseableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ExtendsClauseableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./GeneratorableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/GeneratorableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./helpers */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./HeritageClauseableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/HeritageClauseableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImplementsClauseableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ImplementsClauseableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./initializer */ \"./node_modules/ts-simple-ast/dist/compiler/base/initializer/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/JSDocableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LiteralLikeNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/LiteralLikeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ModifierableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ModifierableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./name */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ParameteredNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ParameteredNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./QuestionTokenableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/QuestionTokenableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReadonlyableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ReadonlyableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReturnTypedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ReturnTypedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ScopeableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ScopeableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ScopedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/ScopedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SignaturedDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/base/SignaturedDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StaticableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/StaticableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TextInsertableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/TextInsertableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeArgumentedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/TypeArgumentedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/TypedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeElementMemberedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/TypeElementMemberedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeParameteredNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/TypeParameteredNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UnwrappableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/UnwrappableNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerExpressionableNode.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerExpressionableNode.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar InitializerGetExpressionableNode_1 = __webpack_require__(/*! ./InitializerGetExpressionableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerGetExpressionableNode.js\");\r\nvar InitializerSetExpressionableNode_1 = __webpack_require__(/*! ./InitializerSetExpressionableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerSetExpressionableNode.js\");\r\nfunction InitializerExpressionableNode(Base) {\r\n    return InitializerSetExpressionableNode_1.InitializerSetExpressionableNode(InitializerGetExpressionableNode_1.InitializerGetExpressionableNode(Base));\r\n}\r\nexports.InitializerExpressionableNode = InitializerExpressionableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerExpressionableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerGetExpressionableNode.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerGetExpressionableNode.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction InitializerGetExpressionableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.hasInitializer = function () {\r\n            return this.compilerNode.initializer != null;\r\n        };\r\n        class_1.prototype.getInitializerIfKindOrThrow = function (kind) {\r\n            return errors.throwIfNullOrUndefined(this.getInitializerIfKind(kind), \"Expected to find an initiailizer of kind '\" + utils_1.getSyntaxKindName(kind) + \"'.\");\r\n        };\r\n        class_1.prototype.getInitializerIfKind = function (kind) {\r\n            var initiailizer = this.getInitializer();\r\n            if (initiailizer != null && initiailizer.getKind() !== kind)\r\n                return undefined;\r\n            return initiailizer;\r\n        };\r\n        class_1.prototype.getInitializerOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getInitializer(), \"Expected to find an initializer.\");\r\n        };\r\n        class_1.prototype.getInitializer = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.initializer);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.InitializerGetExpressionableNode = InitializerGetExpressionableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerGetExpressionableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerSetExpressionableNode.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerSetExpressionableNode.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction InitializerSetExpressionableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.removeInitializer = function () {\r\n            var initializer = this.getInitializer();\r\n            if (initializer == null)\r\n                return this;\r\n            var previousSibling = initializer.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.EqualsToken);\r\n            manipulation_1.removeChildren({\r\n                children: [previousSibling, initializer],\r\n                removePrecedingSpaces: true\r\n            });\r\n            return this;\r\n        };\r\n        class_1.prototype.setInitializer = function (textOrWriterFunction) {\r\n            var text = utils_1.getTextFromStringOrWriter(this.getWriterWithQueuedChildIndentation(), textOrWriterFunction);\r\n            errors.throwIfNotStringOrWhitespace(text, \"textOrWriterFunction\");\r\n            if (this.hasInitializer())\r\n                this.removeInitializer();\r\n            var semiColonToken = this.getLastChildIfKind(typescript_1.SyntaxKind.SemicolonToken);\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: semiColonToken != null ? semiColonToken.getPos() : this.getEnd(),\r\n                parent: this,\r\n                newText: \" = \" + text\r\n            });\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.initializer != null)\r\n                this.setInitializer(structure.initializer);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.InitializerSetExpressionableNode = InitializerSetExpressionableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerSetExpressionableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/initializer/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/initializer/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InitializerExpressionableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerExpressionableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InitializerGetExpressionableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerGetExpressionableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InitializerSetExpressionableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/initializer/InitializerSetExpressionableNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/initializer/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/BindingNamedNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/BindingNamedNode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ReferenceFindableNode_1 = __webpack_require__(/*! ./ReferenceFindableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js\");\r\nvar RenameableNode_1 = __webpack_require__(/*! ./RenameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js\");\r\nvar NamedNodeBase_1 = __webpack_require__(/*! ./NamedNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js\");\r\nfunction BindingNamedNode(Base) {\r\n    var base = ReferenceFindableNode_1.ReferenceFindableNode(RenameableNode_1.RenameableNode(Base));\r\n    return NamedNodeBase_1.NamedNodeBase(base);\r\n}\r\nexports.BindingNamedNode = BindingNamedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/BindingNamedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/DeclarationNamedNode.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/DeclarationNamedNode.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar ReferenceFindableNode_1 = __webpack_require__(/*! ./ReferenceFindableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js\");\r\nvar RenameableNode_1 = __webpack_require__(/*! ./RenameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js\");\r\nfunction DeclarationNamedNode(Base) {\r\n    return DeclarationNamedNodeInternal(ReferenceFindableNode_1.ReferenceFindableNode(RenameableNode_1.RenameableNode(Base)));\r\n}\r\nexports.DeclarationNamedNode = DeclarationNamedNode;\r\nfunction DeclarationNamedNodeInternal(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getNameNodeOrThrow = function () {\r\n            var nameNode = this.getNameNode();\r\n            if (nameNode == null)\r\n                throw new errors.InvalidOperationError(\"Expected a name node.\");\r\n            return nameNode;\r\n        };\r\n        class_1.prototype.getNameNode = function () {\r\n            var compilerNameNode = this.compilerNode.name;\r\n            if (compilerNameNode == null)\r\n                return undefined;\r\n            switch (compilerNameNode.kind) {\r\n                case typescript_1.SyntaxKind.Identifier:\r\n                    return this.getNodeFromCompilerNode(compilerNameNode);\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw errors.getNotImplementedForSyntaxKindError(compilerNameNode.kind);\r\n            }\r\n        };\r\n        class_1.prototype.getNameOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getName(), \"Expected to find a name.\");\r\n        };\r\n        class_1.prototype.getName = function () {\r\n            var nameNode = this.getNameNode();\r\n            return nameNode == null ? undefined : nameNode.getText();\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/DeclarationNamedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/NameableNode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/NameableNode.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar ReferenceFindableNode_1 = __webpack_require__(/*! ./ReferenceFindableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js\");\r\nvar RenameableNode_1 = __webpack_require__(/*! ./RenameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js\");\r\nfunction NameableNode(Base) {\r\n    return NameableNodeInternal(ReferenceFindableNode_1.ReferenceFindableNode(RenameableNode_1.RenameableNode(Base)));\r\n}\r\nexports.NameableNode = NameableNode;\r\nfunction NameableNodeInternal(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getNameNode = function () {\r\n            return this.getNodeFromCompilerNodeIfExists(this.compilerNode.name);\r\n        };\r\n        class_1.prototype.getNameNodeOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getNameNode(), \"Expected to have a name node.\");\r\n        };\r\n        class_1.prototype.getName = function () {\r\n            var identifier = this.getNameNode();\r\n            return identifier == null ? undefined : identifier.getText();\r\n        };\r\n        class_1.prototype.getNameOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getName(), \"Expected to have a name.\");\r\n        };\r\n        class_1.prototype.rename = function (newName) {\r\n            if (newName === this.getName())\r\n                return this;\r\n            var nameNode = this.getNameNode();\r\n            if (utils_1.StringUtils.isNullOrWhitespace(newName)) {\r\n                if (nameNode == null)\r\n                    return this;\r\n                manipulation_1.removeChildren({ children: [nameNode], removePrecedingSpaces: true });\r\n                return this;\r\n            }\r\n            if (nameNode == null) {\r\n                var openParenToken = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenParenToken);\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: openParenToken.getStart(),\r\n                    newText: \" \" + newName,\r\n                    parent: this\r\n                });\r\n            }\r\n            else {\r\n                Base.prototype.rename.call(this, newName);\r\n            }\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.name != null)\r\n                this.rename(structure.name);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/NameableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ReferenceFindableNode_1 = __webpack_require__(/*! ./ReferenceFindableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js\");\r\nvar RenameableNode_1 = __webpack_require__(/*! ./RenameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js\");\r\nvar NamedNodeBase_1 = __webpack_require__(/*! ./NamedNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js\");\r\nfunction NamedNode(Base) {\r\n    var base = RenameableNode_1.RenameableNode(ReferenceFindableNode_1.ReferenceFindableNode(Base));\r\n    return NamedNodeBase_1.NamedNodeBase(base);\r\n}\r\nexports.NamedNode = NamedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction NamedNodeBase(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getNameNode = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.name);\r\n        };\r\n        class_1.prototype.getName = function () {\r\n            return this.getNameNode().getText();\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.name != null)\r\n                this.rename(structure.name);\r\n            return this;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.NamedNodeBase = NamedNodeBase;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/PropertyNamedNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/PropertyNamedNode.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ReferenceFindableNode_1 = __webpack_require__(/*! ./ReferenceFindableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js\");\r\nvar RenameableNode_1 = __webpack_require__(/*! ./RenameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js\");\r\nvar NamedNodeBase_1 = __webpack_require__(/*! ./NamedNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js\");\r\nfunction PropertyNamedNode(Base) {\r\n    var base = ReferenceFindableNode_1.ReferenceFindableNode(RenameableNode_1.RenameableNode(Base));\r\n    return NamedNodeBase_1.NamedNodeBase(base);\r\n}\r\nexports.PropertyNamedNode = PropertyNamedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/PropertyNamedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction ReferenceFindableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.findReferences = function () {\r\n            return this.context.languageService.findReferences(getNodeForReferences(this));\r\n        };\r\n        class_1.prototype.findReferencesAsNodes = function () {\r\n            return this.context.languageService.findReferencesAsNodes(getNodeForReferences(this));\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ReferenceFindableNode = ReferenceFindableNode;\r\nfunction getNodeForReferences(node) {\r\n    if (utils_1.TypeGuards.isIdentifier(node))\r\n        return node;\r\n    var nameNode = node.getNodeProperty(\"name\");\r\n    if (nameNode != null)\r\n        return nameNode;\r\n    if (utils_1.TypeGuards.isExportableNode(node))\r\n        return node.getDefaultKeyword() || node;\r\n    return node;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction RenameableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.rename = function (newName, options) {\r\n            this.context.languageService.renameNode(getNodeToRename(this), newName, options);\r\n            return this;\r\n            function getNodeToRename(thisNode) {\r\n                if (utils_1.TypeGuards.isIdentifier(thisNode))\r\n                    return thisNode;\r\n                else if (thisNode.getNameNode != null) {\r\n                    var node = thisNode.getNameNode();\r\n                    errors.throwIfNullOrUndefined(node, \"Expected to find a name node when renaming.\");\r\n                    if (utils_1.TypeGuards.isArrayBindingPattern(node) || utils_1.TypeGuards.isObjectBindingPattern(node))\r\n                        throw new errors.NotImplementedError(\"Not implemented renameable scenario for \" + node.getKindName() + \".\");\r\n                    return node;\r\n                }\r\n                else\r\n                    throw new errors.NotImplementedError(\"Not implemented renameable scenario for \" + thisNode.getKindName());\r\n            }\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.RenameableNode = RenameableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/base/name/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/base/name/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BindingNamedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/BindingNamedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DeclarationNamedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/DeclarationNamedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/NameableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NamedNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNodeBase.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NamedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/NamedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyNamedNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/PropertyNamedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReferenceFindableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/ReferenceFindableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RenameableNode */ \"./node_modules/ts-simple-ast/dist/compiler/base/name/RenameableNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/base/name/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/binding/ArrayBindingPattern.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/binding/ArrayBindingPattern.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar ArrayBindingPattern = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrayBindingPattern, _super);\r\n    function ArrayBindingPattern() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the array binding pattern's elements.\r\n     */\r\n    ArrayBindingPattern.prototype.getElements = function () {\r\n        var _this = this;\r\n        return this.compilerNode.elements.map(function (e) { return _this.getNodeFromCompilerNode(e); });\r\n    };\r\n    return ArrayBindingPattern;\r\n}(common_1.Node));\r\nexports.ArrayBindingPattern = ArrayBindingPattern;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/binding/ArrayBindingPattern.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/binding/BindingElement.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/binding/BindingElement.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.BindingElementBase = base_1.InitializerExpressionableNode(base_1.BindingNamedNode(common_1.Node));\r\nvar BindingElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BindingElement, _super);\r\n    function BindingElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the binding element's dot dot dot token (...) if it exists or throws if not.\r\n     */\r\n    BindingElement.prototype.getDotDotDotTokenOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDotDotDotToken(), \"Expected to find a dot dot dot token (...).\");\r\n    };\r\n    /**\r\n     * Gets the binding element's dot dot dot token (...) if it exists or returns undefined.\r\n     */\r\n    BindingElement.prototype.getDotDotDotToken = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);\r\n    };\r\n    /**\r\n     * Gets binding element's property name node or throws if not found.\r\n     *\r\n     * For example in `const { a: b } = { a: 5 }`, `a` would be the property name.\r\n     */\r\n    BindingElement.prototype.getPropertyNameNodeOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getPropertyNameNode(), \"Expected to find a property name node.\");\r\n    };\r\n    /**\r\n     * Gets binding element's property name node or returns undefined if not found.\r\n     *\r\n     * For example in `const { a: b } = { a: 5 }`, `a` would be the property name.\r\n     */\r\n    BindingElement.prototype.getPropertyNameNode = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.propertyName);\r\n    };\r\n    return BindingElement;\r\n}(exports.BindingElementBase));\r\nexports.BindingElement = BindingElement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/binding/BindingElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/binding/ObjectBindingPattern.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/binding/ObjectBindingPattern.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar ObjectBindingPattern = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ObjectBindingPattern, _super);\r\n    function ObjectBindingPattern() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the object binding pattern's elements.\r\n     */\r\n    ObjectBindingPattern.prototype.getElements = function () {\r\n        var _this = this;\r\n        return this.compilerNode.elements.map(function (e) { return _this.getNodeFromCompilerNode(e); });\r\n    };\r\n    return ObjectBindingPattern;\r\n}(common_1.Node));\r\nexports.ObjectBindingPattern = ObjectBindingPattern;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/binding/ObjectBindingPattern.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/binding/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/binding/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArrayBindingPattern */ \"./node_modules/ts-simple-ast/dist/compiler/binding/ArrayBindingPattern.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BindingElement */ \"./node_modules/ts-simple-ast/dist/compiler/binding/BindingElement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ObjectBindingPattern */ \"./node_modules/ts-simple-ast/dist/compiler/binding/ObjectBindingPattern.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/binding/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// todo: add code verification to ensure all fill functions call this\r\n/** @internal */\r\nfunction callBaseFill(basePrototype, node, structure) {\r\n    if (basePrototype.fill != null)\r\n        basePrototype.fill.call(node, structure);\r\n}\r\nexports.callBaseFill = callBaseFill;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/callBaseGetStructure.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/callBaseGetStructure.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* barrel:ignore */\r\nvar objectAssign = __webpack_require__(/*! object-assign */ \"object-assign\");\r\n// todo: add code verification to ensure all fill functions call this\r\n/** @internal */\r\nfunction callBaseGetStructure(basePrototype, node, structure) {\r\n    var newStructure;\r\n    if (basePrototype.getStructure != null)\r\n        newStructure = basePrototype.getStructure.call(node);\r\n    else\r\n        newStructure = {};\r\n    objectAssign(newStructure, structure);\r\n    return newStructure;\r\n}\r\nexports.callBaseGetStructure = callBaseGetStructure;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/callBaseGetStructure.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/ClassDeclaration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/ClassDeclaration.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar function_1 = __webpack_require__(/*! ../function */ \"./node_modules/ts-simple-ast/dist/compiler/function/index.js\");\r\nvar namespace_1 = __webpack_require__(/*! ../namespace */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar base_2 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/index.js\");\r\nvar MethodDeclaration_1 = __webpack_require__(/*! ./MethodDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/MethodDeclaration.js\");\r\nexports.ClassDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.ImplementsClauseableNode(base_1.HeritageClauseableNode(base_1.DecoratableNode(base_1.TypeParameteredNode(namespace_1.NamespaceChildableNode(base_1.JSDocableNode(base_1.AmbientableNode(base_2.AbstractableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NameableNode(statement_1.Statement)))))))))))));\r\nvar ClassDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ClassDeclaration, _super);\r\n    function ClassDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    ClassDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.ClassDeclarationBase.prototype, this, structure);\r\n        if (structure.extends != null)\r\n            this.setExtends(structure.extends);\r\n        if (structure.ctors != null)\r\n            this.addConstructors(structure.ctors);\r\n        if (structure.properties != null)\r\n            this.addProperties(structure.properties);\r\n        if (structure.getAccessors != null)\r\n            this.addGetAccessors(structure.getAccessors);\r\n        if (structure.setAccessors != null)\r\n            this.addSetAccessors(structure.setAccessors);\r\n        if (structure.methods != null)\r\n            this.addMethods(structure.methods);\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the extends expression.\r\n     * @param text - Text to set as the extends expression.\r\n     */\r\n    ClassDeclaration.prototype.setExtends = function (text) {\r\n        if (utils_1.StringUtils.isNullOrWhitespace(text))\r\n            return this.removeExtends();\r\n        var heritageClauses = this.getHeritageClauses();\r\n        var extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);\r\n        if (extendsClause != null) {\r\n            var childSyntaxList = extendsClause.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList);\r\n            var childSyntaxListStart = childSyntaxList.getStart();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: extendsClause,\r\n                newText: text,\r\n                insertPos: childSyntaxListStart,\r\n                replacing: {\r\n                    textLength: childSyntaxList.getEnd() - childSyntaxListStart\r\n                }\r\n            });\r\n            return this;\r\n        }\r\n        var implementsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ImplementsKeyword);\r\n        var insertPos;\r\n        if (implementsClause != null)\r\n            insertPos = implementsClause.getStart();\r\n        else\r\n            insertPos = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenBraceToken).getStart();\r\n        var isLastSpace = /\\s/.test(this.getSourceFile().getFullText()[insertPos - 1]);\r\n        var newText = \"extends \" + text + \" \";\r\n        if (!isLastSpace)\r\n            newText = \" \" + newText;\r\n        manipulation_1.insertIntoParentTextRange({\r\n            parent: implementsClause == null ? this : implementsClause.getParentSyntaxListOrThrow(),\r\n            insertPos: insertPos,\r\n            newText: newText\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the extends expression, if it exists.\r\n     */\r\n    ClassDeclaration.prototype.removeExtends = function () {\r\n        var extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);\r\n        if (extendsClause == null)\r\n            return this;\r\n        extendsClause.removeExpression(0);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the extends expression or throws if it doesn't exist.\r\n     */\r\n    ClassDeclaration.prototype.getExtendsOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExtends(), \"Expected to find the extends expression for the class \" + this.getName() + \".\");\r\n    };\r\n    /**\r\n     * Gets the extends expression or returns undefined if it doesn't exist.\r\n     */\r\n    ClassDeclaration.prototype.getExtends = function () {\r\n        var extendsClause = this.getHeritageClauseByKind(typescript_1.SyntaxKind.ExtendsKeyword);\r\n        if (extendsClause == null)\r\n            return undefined;\r\n        var types = extendsClause.getTypeNodes();\r\n        return types.length === 0 ? undefined : types[0];\r\n    };\r\n    /**\r\n     * Adds a constructor.\r\n     * @param structure - Structure of the constructor.\r\n     */\r\n    ClassDeclaration.prototype.addConstructor = function (structure) {\r\n        if (structure === void 0) { structure = {}; }\r\n        return this.insertConstructor(manipulation_1.getEndIndexFromArray(this.getMembers()), structure);\r\n    };\r\n    /**\r\n     * Adds constructors.\r\n     * @param structures - Structures of the constructor.\r\n     */\r\n    ClassDeclaration.prototype.addConstructors = function (structures) {\r\n        return this.insertConstructors(manipulation_1.getEndIndexFromArray(this.getMembers()), structures);\r\n    };\r\n    /**\r\n     * Inserts a constructor.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the constructor.\r\n     */\r\n    ClassDeclaration.prototype.insertConstructor = function (index, structure) {\r\n        if (structure === void 0) { structure = {}; }\r\n        return this.insertConstructors(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts constructors.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the constructor.\r\n     */\r\n    ClassDeclaration.prototype.insertConstructors = function (index, structures) {\r\n        var _this = this;\r\n        var isAmbient = this.isAmbient();\r\n        return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n            getIndexedChildren: function () { return _this.getMembers(); },\r\n            parent: this,\r\n            index: index,\r\n            structures: structures,\r\n            expectedKind: typescript_1.SyntaxKind.Constructor,\r\n            write: function (writer, info) {\r\n                if (!isAmbient && info.previousMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n                _this.context.structurePrinterFactory.forConstructorDeclaration({ isAmbient: isAmbient }).printTexts(writer, structures);\r\n                if (!isAmbient && info.nextMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the constructor declarations.\r\n     */\r\n    ClassDeclaration.prototype.getConstructors = function () {\r\n        return this.getMembers().filter(function (m) { return utils_1.TypeGuards.isConstructorDeclaration(m); });\r\n    };\r\n    /**\r\n     * Add get accessor.\r\n     * @param structure - Structure representing the get accessor.\r\n     */\r\n    ClassDeclaration.prototype.addGetAccessor = function (structure) {\r\n        return this.addGetAccessors([structure])[0];\r\n    };\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    ClassDeclaration.prototype.addGetAccessors = function (structures) {\r\n        return this.insertGetAccessors(manipulation_1.getEndIndexFromArray(this.getMembers()), structures);\r\n    };\r\n    /**\r\n     * Insert get accessor.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the get accessor.\r\n     */\r\n    ClassDeclaration.prototype.insertGetAccessor = function (index, structure) {\r\n        return this.insertGetAccessors(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    ClassDeclaration.prototype.insertGetAccessors = function (index, structures) {\r\n        var _this = this;\r\n        return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n            getIndexedChildren: function () { return _this.getMembers(); },\r\n            parent: this,\r\n            index: index,\r\n            structures: structures,\r\n            expectedKind: typescript_1.SyntaxKind.GetAccessor,\r\n            write: function (writer, info) {\r\n                if (info.previousMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n                _this.context.structurePrinterFactory.forGetAccessorDeclaration({ isAmbient: _this.isAmbient() }).printTexts(writer, structures);\r\n                if (info.nextMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Add set accessor.\r\n     * @param structure - Structure representing the set accessor.\r\n     */\r\n    ClassDeclaration.prototype.addSetAccessor = function (structure) {\r\n        return this.addSetAccessors([structure])[0];\r\n    };\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    ClassDeclaration.prototype.addSetAccessors = function (structures) {\r\n        return this.insertSetAccessors(manipulation_1.getEndIndexFromArray(this.getMembers()), structures);\r\n    };\r\n    /**\r\n     * Insert set accessor.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the set accessor.\r\n     */\r\n    ClassDeclaration.prototype.insertSetAccessor = function (index, structure) {\r\n        return this.insertSetAccessors(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    ClassDeclaration.prototype.insertSetAccessors = function (index, structures) {\r\n        var _this = this;\r\n        return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n            getIndexedChildren: function () { return _this.getMembers(); },\r\n            parent: this,\r\n            index: index,\r\n            structures: structures,\r\n            expectedKind: typescript_1.SyntaxKind.SetAccessor,\r\n            write: function (writer, info) {\r\n                if (info.previousMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n                _this.context.structurePrinterFactory.forSetAccessorDeclaration({ isAmbient: _this.isAmbient() }).printTexts(writer, structures);\r\n                if (info.nextMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Add property.\r\n     * @param structure - Structure representing the property.\r\n     */\r\n    ClassDeclaration.prototype.addProperty = function (structure) {\r\n        return this.addProperties([structure])[0];\r\n    };\r\n    /**\r\n     * Add properties.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    ClassDeclaration.prototype.addProperties = function (structures) {\r\n        return this.insertProperties(manipulation_1.getEndIndexFromArray(this.getMembers()), structures);\r\n    };\r\n    /**\r\n     * Insert property.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the property.\r\n     */\r\n    ClassDeclaration.prototype.insertProperty = function (index, structure) {\r\n        return this.insertProperties(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert properties.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the properties.\r\n     */\r\n    ClassDeclaration.prototype.insertProperties = function (index, structures) {\r\n        var _this = this;\r\n        return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n            getIndexedChildren: function () { return _this.getMembers(); },\r\n            parent: this,\r\n            index: index,\r\n            structures: structures,\r\n            expectedKind: typescript_1.SyntaxKind.PropertyDeclaration,\r\n            write: function (writer, info) {\r\n                if (info.previousMember != null && utils_1.TypeGuards.hasBody(info.previousMember))\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n                _this.context.structurePrinterFactory.forPropertyDeclaration().printTexts(writer, structures);\r\n                if (info.nextMember != null && utils_1.TypeGuards.hasBody(info.nextMember))\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n            }\r\n        });\r\n    };\r\n    ClassDeclaration.prototype.getInstanceProperty = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getInstanceProperties(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getInstancePropertyOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getInstanceProperty(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class instance property\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class instance property declarations.\r\n     */\r\n    ClassDeclaration.prototype.getInstanceProperties = function () {\r\n        return this.getInstanceMembers()\r\n            .filter(function (m) { return isClassPropertyType(m); });\r\n    };\r\n    ClassDeclaration.prototype.getStaticProperty = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getStaticProperties(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getStaticPropertyOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getStaticProperty(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class static property\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class instance property declarations.\r\n     */\r\n    ClassDeclaration.prototype.getStaticProperties = function () {\r\n        return this.getStaticMembers()\r\n            .filter(function (m) { return isClassPropertyType(m); });\r\n    };\r\n    ClassDeclaration.prototype.getProperty = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getPropertyOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class property declaration\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class property declarations regardless of whether it's an instance of static property.\r\n     */\r\n    ClassDeclaration.prototype.getProperties = function () {\r\n        return this.getMembers()\r\n            .filter(function (m) { return utils_1.TypeGuards.isPropertyDeclaration(m); });\r\n    };\r\n    ClassDeclaration.prototype.getGetAccessor = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getGetAccessors(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getGetAccessorOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getGetAccessor(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class getAccessor declaration\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class get accessor declarations regardless of whether it's an instance of static getAccessor.\r\n     */\r\n    ClassDeclaration.prototype.getGetAccessors = function () {\r\n        return this.getMembers()\r\n            .filter(function (m) { return utils_1.TypeGuards.isGetAccessorDeclaration(m); });\r\n    };\r\n    ClassDeclaration.prototype.getSetAccessor = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getSetAccessors(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getSetAccessorOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getSetAccessor(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class setAccessor declaration\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Sets the class set accessor declarations regardless of whether it's an instance of static setAccessor.\r\n     */\r\n    ClassDeclaration.prototype.getSetAccessors = function () {\r\n        return this.getMembers()\r\n            .filter(function (m) { return utils_1.TypeGuards.isSetAccessorDeclaration(m); });\r\n    };\r\n    /**\r\n     * Add method.\r\n     * @param structure - Structure representing the method.\r\n     */\r\n    ClassDeclaration.prototype.addMethod = function (structure) {\r\n        return this.addMethods([structure])[0];\r\n    };\r\n    /**\r\n     * Add methods.\r\n     * @param structures - Structures representing the methods.\r\n     */\r\n    ClassDeclaration.prototype.addMethods = function (structures) {\r\n        return this.insertMethods(manipulation_1.getEndIndexFromArray(this.getMembers()), structures);\r\n    };\r\n    /**\r\n     * Insert method.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the method.\r\n     */\r\n    ClassDeclaration.prototype.insertMethod = function (index, structure) {\r\n        return this.insertMethods(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert methods.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the methods.\r\n     */\r\n    ClassDeclaration.prototype.insertMethods = function (index, structures) {\r\n        var _this = this;\r\n        var isAmbient = this.isAmbient();\r\n        structures = structures.map(function (s) { return (tslib_1.__assign({}, s)); });\r\n        // insert, fill, and get created nodes\r\n        return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n            parent: this,\r\n            index: index,\r\n            getIndexedChildren: function () { return _this.getMembers(); },\r\n            write: function (writer, info) {\r\n                if (!isAmbient && info.previousMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n                _this.context.structurePrinterFactory.forMethodDeclaration({ isAmbient: isAmbient }).printTexts(writer, structures);\r\n                if (!isAmbient && info.nextMember != null)\r\n                    writer.blankLineIfLastNot();\r\n                else\r\n                    writer.newLineIfLastNot();\r\n            },\r\n            structures: structures,\r\n            expectedKind: typescript_1.SyntaxKind.MethodDeclaration\r\n        });\r\n    };\r\n    ClassDeclaration.prototype.getMethod = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getMethodOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class method declaration\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class method declarations regardless of whether it's an instance of static method.\r\n     */\r\n    ClassDeclaration.prototype.getMethods = function () {\r\n        return this.getMembers()\r\n            .filter(function (m) { return utils_1.TypeGuards.isMethodDeclaration(m); });\r\n    };\r\n    ClassDeclaration.prototype.getInstanceMethod = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getInstanceMethods(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getInstanceMethodOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getInstanceMethod(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class instance method\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class instance method declarations.\r\n     */\r\n    ClassDeclaration.prototype.getInstanceMethods = function () {\r\n        return this.getInstanceMembers().filter(function (m) { return m instanceof MethodDeclaration_1.MethodDeclaration; });\r\n    };\r\n    ClassDeclaration.prototype.getStaticMethod = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getStaticMethods(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getStaticMethodOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getStaticMethod(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class static method\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the class instance method declarations.\r\n     */\r\n    ClassDeclaration.prototype.getStaticMethods = function () {\r\n        return this.getStaticMembers().filter(function (m) { return m instanceof MethodDeclaration_1.MethodDeclaration; });\r\n    };\r\n    ClassDeclaration.prototype.getInstanceMember = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getInstanceMembers(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getInstanceMemberOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getInstanceMember(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class instance member\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the instance members.\r\n     */\r\n    ClassDeclaration.prototype.getInstanceMembers = function () {\r\n        return this.getMembersWithParameterProperties()\r\n            .filter(function (m) { return !utils_1.TypeGuards.isConstructorDeclaration(m) && (utils_1.TypeGuards.isParameterDeclaration(m) || !m.isStatic()); });\r\n    };\r\n    ClassDeclaration.prototype.getStaticMember = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getStaticMembers(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getStaticMemberOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getStaticMember(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class static member\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the static members.\r\n     */\r\n    ClassDeclaration.prototype.getStaticMembers = function () {\r\n        return this.getMembers().filter(function (m) { return !utils_1.TypeGuards.isConstructorDeclaration(m) && !(m instanceof function_1.ParameterDeclaration) && m.isStatic(); });\r\n    };\r\n    /**\r\n     * Gets the class members regardless of whether an instance of static member with parameter properties.\r\n     * @internal\r\n     */\r\n    ClassDeclaration.prototype.getMembersWithParameterProperties = function () {\r\n        var e_1, _a, e_2, _b;\r\n        var members = this.getMembers();\r\n        var implementationCtors = members.filter(function (c) { return utils_1.TypeGuards.isConstructorDeclaration(c) && c.isImplementation(); });\r\n        try {\r\n            for (var implementationCtors_1 = tslib_1.__values(implementationCtors), implementationCtors_1_1 = implementationCtors_1.next(); !implementationCtors_1_1.done; implementationCtors_1_1 = implementationCtors_1.next()) {\r\n                var ctor = implementationCtors_1_1.value;\r\n                // insert after the constructor\r\n                var insertIndex = members.indexOf(ctor) + 1;\r\n                try {\r\n                    for (var _c = tslib_1.__values(ctor.getParameters()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                        var param = _d.value;\r\n                        if (param.isParameterProperty()) {\r\n                            members.splice(insertIndex, 0, param);\r\n                            insertIndex++;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (implementationCtors_1_1 && !implementationCtors_1_1.done && (_a = implementationCtors_1.return)) _a.call(implementationCtors_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return members;\r\n    };\r\n    /**\r\n     * Gets the class' members regardless of whether it's an instance of static member.\r\n     */\r\n    ClassDeclaration.prototype.getMembers = function () {\r\n        return getAllMembers(this).filter(function (m) { return isSupportedClassMember(m); });\r\n        function getAllMembers(classDec) {\r\n            var members = classDec.compilerNode.members.map(function (m) { return classDec.getNodeFromCompilerNode(m); });\r\n            // filter out the method declarations or constructor declarations without a body if not ambient\r\n            return classDec.isAmbient() ? members : members.filter(function (m) {\r\n                if (!(utils_1.TypeGuards.isConstructorDeclaration(m) || utils_1.TypeGuards.isMethodDeclaration(m)))\r\n                    return true;\r\n                if (utils_1.TypeGuards.isMethodDeclaration(m) && m.isAbstract())\r\n                    return true;\r\n                return m.isImplementation();\r\n            });\r\n        }\r\n    };\r\n    ClassDeclaration.prototype.getMember = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);\r\n    };\r\n    ClassDeclaration.prototype.getMemberOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class member\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the base types.\r\n     *\r\n     * This is useful to use if the base could possibly be a mixin.\r\n     */\r\n    ClassDeclaration.prototype.getBaseTypes = function () {\r\n        return this.getType().getBaseTypes();\r\n    };\r\n    /**\r\n     * Gets the base class or throws.\r\n     *\r\n     * Note: Use getBaseTypes if you need to get the mixins.\r\n     */\r\n    ClassDeclaration.prototype.getBaseClassOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getBaseClass(), \"Expected to find the base class of \" + this.getName() + \".\");\r\n    };\r\n    /**\r\n     * Gets the base class.\r\n     *\r\n     * Note: Use getBaseTypes if you need to get the mixins.\r\n     */\r\n    ClassDeclaration.prototype.getBaseClass = function () {\r\n        var baseTypes = utils_1.ArrayUtils.flatten(this.getBaseTypes().map(function (t) { return t.isIntersection() ? t.getIntersectionTypes() : [t]; }));\r\n        var declarations = baseTypes\r\n            .map(function (t) { return t.getSymbol(); })\r\n            .filter(function (s) { return s != null; })\r\n            .map(function (s) { return s.getDeclarations(); })\r\n            .reduce(function (a, b) { return a.concat(b); }, [])\r\n            .filter(function (d) { return d.getKind() === typescript_1.SyntaxKind.ClassDeclaration; });\r\n        if (declarations.length !== 1)\r\n            return undefined;\r\n        return declarations[0];\r\n    };\r\n    /**\r\n     * Gets all the derived classes.\r\n     */\r\n    ClassDeclaration.prototype.getDerivedClasses = function () {\r\n        var e_3, _a;\r\n        var classes = this.getImmediateDerivedClasses();\r\n        for (var i = 0; i < classes.length; i++) {\r\n            var derivedClasses = classes[i].getImmediateDerivedClasses();\r\n            try {\r\n                for (var derivedClasses_1 = tslib_1.__values(derivedClasses), derivedClasses_1_1 = derivedClasses_1.next(); !derivedClasses_1_1.done; derivedClasses_1_1 = derivedClasses_1.next()) {\r\n                    var derivedClass = derivedClasses_1_1.value;\r\n                    // don't allow circular references\r\n                    if (derivedClass !== this && classes.indexOf(derivedClass) === -1)\r\n                        classes.push(derivedClass);\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (derivedClasses_1_1 && !derivedClasses_1_1.done && (_a = derivedClasses_1.return)) _a.call(derivedClasses_1);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        }\r\n        return classes;\r\n    };\r\n    ClassDeclaration.prototype.getImmediateDerivedClasses = function () {\r\n        var e_4, _a;\r\n        var classes = [];\r\n        var nameNode = this.getNameNode();\r\n        if (nameNode == null)\r\n            return classes;\r\n        try {\r\n            for (var _b = tslib_1.__values(nameNode.findReferencesAsNodes()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var node = _c.value;\r\n                var nodeParent = node.getParentIfKind(typescript_1.SyntaxKind.ExpressionWithTypeArguments);\r\n                if (nodeParent == null)\r\n                    continue;\r\n                var heritageClause = nodeParent.getParentIfKind(typescript_1.SyntaxKind.HeritageClause);\r\n                if (heritageClause == null || heritageClause.getToken() !== typescript_1.SyntaxKind.ExtendsKeyword)\r\n                    continue;\r\n                classes.push(heritageClause.getFirstAncestorByKindOrThrow(typescript_1.SyntaxKind.ClassDeclaration));\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        return classes;\r\n    };\r\n    return ClassDeclaration;\r\n}(exports.ClassDeclarationBase));\r\nexports.ClassDeclaration = ClassDeclaration;\r\nfunction isClassPropertyType(m) {\r\n    return utils_1.TypeGuards.isPropertyDeclaration(m)\r\n        || utils_1.TypeGuards.isSetAccessorDeclaration(m)\r\n        || utils_1.TypeGuards.isGetAccessorDeclaration(m)\r\n        || utils_1.TypeGuards.isParameterDeclaration(m);\r\n}\r\nfunction isSupportedClassMember(m) {\r\n    return utils_1.TypeGuards.isMethodDeclaration(m)\r\n        || utils_1.TypeGuards.isPropertyDeclaration(m)\r\n        || utils_1.TypeGuards.isGetAccessorDeclaration(m)\r\n        || utils_1.TypeGuards.isSetAccessorDeclaration(m)\r\n        || utils_1.TypeGuards.isConstructorDeclaration(m);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/ClassDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/ConstructorDeclaration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/ConstructorDeclaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar getStructureFuncs = __webpack_require__(/*! ../../manipulation/helpers/getStructureFunctions */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar function_1 = __webpack_require__(/*! ../function */ \"./node_modules/ts-simple-ast/dist/compiler/function/index.js\");\r\nexports.ConstructorDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(function_1.OverloadableNode(base_1.ScopedNode(function_1.FunctionLikeDeclaration(base_1.BodyableNode(common_1.Node))))));\r\nvar ConstructorDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConstructorDeclaration, _super);\r\n    function ConstructorDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    ConstructorDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.ConstructorDeclarationBase.prototype, this, structure);\r\n        if (structure.overloads != null && structure.overloads.length > 0)\r\n            this.addOverloads(structure.overloads);\r\n        return this;\r\n    };\r\n    /**\r\n     * Add a constructor overload.\r\n     * @param structure - Structure to add.\r\n     */\r\n    ConstructorDeclaration.prototype.addOverload = function (structure) {\r\n        return this.addOverloads([structure])[0];\r\n    };\r\n    /**\r\n     * Add constructor overloads.\r\n     * @param structures - Structures to add.\r\n     */\r\n    ConstructorDeclaration.prototype.addOverloads = function (structures) {\r\n        return this.insertOverloads(this.getOverloads().length, structures);\r\n    };\r\n    /**\r\n     * Inserts a constructor overload.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structures to insert.\r\n     */\r\n    ConstructorDeclaration.prototype.insertOverload = function (index, structure) {\r\n        return this.insertOverloads(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts constructor overloads.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures to insert.\r\n     */\r\n    ConstructorDeclaration.prototype.insertOverloads = function (index, structures) {\r\n        var childCodes = structures.map(function (structure) { return \"constructor();\"; });\r\n        return function_1.insertOverloads({\r\n            node: this,\r\n            index: index,\r\n            structures: structures,\r\n            childCodes: childCodes,\r\n            getThisStructure: getStructureFuncs.fromConstructorDeclarationOverload,\r\n            fillNodeFromStructure: function (node, structure) { return node.fill(structure); },\r\n            expectedSyntaxKind: typescript_1.SyntaxKind.Constructor\r\n        });\r\n    };\r\n    /**\r\n     * Remove the constructor.\r\n     */\r\n    ConstructorDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeOverloadableClassMember(this);\r\n    };\r\n    return ConstructorDeclaration;\r\n}(exports.ConstructorDeclarationBase));\r\nexports.ConstructorDeclaration = ConstructorDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/ConstructorDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/GetAccessorDeclaration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/GetAccessorDeclaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar function_1 = __webpack_require__(/*! ../function */ \"./node_modules/ts-simple-ast/dist/compiler/function/index.js\");\r\nvar base_2 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/index.js\");\r\nexports.GetAccessorDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.DecoratableNode(base_2.AbstractableNode(base_1.ScopedNode(base_1.StaticableNode(base_1.BodiedNode(function_1.FunctionLikeDeclaration(base_1.PropertyNamedNode(common_1.Node)))))))));\r\nvar GetAccessorDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(GetAccessorDeclaration, _super);\r\n    function GetAccessorDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    GetAccessorDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.GetAccessorDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the corresponding set accessor if one exists.\r\n     */\r\n    GetAccessorDeclaration.prototype.getSetAccessor = function () {\r\n        var e_1, _a;\r\n        var parent = this.getParentIfKindOrThrow(typescript_1.SyntaxKind.ClassDeclaration);\r\n        var thisName = this.getName();\r\n        try {\r\n            for (var _b = tslib_1.__values(parent.getInstanceProperties()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var prop = _c.value;\r\n                if (prop.getName() === thisName && prop.getKind() === typescript_1.SyntaxKind.SetAccessor)\r\n                    return prop;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the corresponding set accessor or throws if not exists.\r\n     */\r\n    GetAccessorDeclaration.prototype.getSetAccessorOrThrow = function () {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getSetAccessor(), function () { return \"Expected to find a corresponding set accessor for \" + _this.getName() + \".\"; });\r\n    };\r\n    /**\r\n     * Removes the get accessor.\r\n     */\r\n    GetAccessorDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeClassMember(this);\r\n    };\r\n    return GetAccessorDeclaration;\r\n}(exports.GetAccessorDeclarationBase));\r\nexports.GetAccessorDeclaration = GetAccessorDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/GetAccessorDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/MethodDeclaration.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/MethodDeclaration.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar getStructureFuncs = __webpack_require__(/*! ../../manipulation/helpers/getStructureFunctions */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar function_1 = __webpack_require__(/*! ../function */ \"./node_modules/ts-simple-ast/dist/compiler/function/index.js\");\r\nvar base_2 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/index.js\");\r\nexports.MethodDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(function_1.OverloadableNode(base_1.BodyableNode(base_1.DecoratableNode(base_2.AbstractableNode(base_1.ScopedNode(base_1.StaticableNode(base_1.AsyncableNode(base_1.GeneratorableNode(function_1.FunctionLikeDeclaration(base_1.PropertyNamedNode(common_1.Node))))))))))));\r\nvar MethodDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MethodDeclaration, _super);\r\n    function MethodDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    MethodDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.MethodDeclarationBase.prototype, this, structure);\r\n        if (structure.overloads != null && structure.overloads.length > 0)\r\n            this.addOverloads(structure.overloads);\r\n        return this;\r\n    };\r\n    /**\r\n     * Add a method overload.\r\n     * @param structure - Structure to add.\r\n     */\r\n    MethodDeclaration.prototype.addOverload = function (structure) {\r\n        return this.addOverloads([structure])[0];\r\n    };\r\n    /**\r\n     * Add method overloads.\r\n     * @param structures - Structures to add.\r\n     */\r\n    MethodDeclaration.prototype.addOverloads = function (structures) {\r\n        return this.insertOverloads(this.getOverloads().length, structures);\r\n    };\r\n    /**\r\n     * Inserts a method overload.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structures to insert.\r\n     */\r\n    MethodDeclaration.prototype.insertOverload = function (index, structure) {\r\n        return this.insertOverloads(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts method overloads.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures to insert.\r\n     */\r\n    MethodDeclaration.prototype.insertOverloads = function (index, structures) {\r\n        var thisName = this.getName();\r\n        var childCodes = structures.map(function (structure) { return thisName + \"();\"; });\r\n        return function_1.insertOverloads({\r\n            node: this,\r\n            index: index,\r\n            structures: structures,\r\n            childCodes: childCodes,\r\n            getThisStructure: getStructureFuncs.fromMethodDeclarationOverload,\r\n            fillNodeFromStructure: function (node, structure) { return node.fill(structure); },\r\n            expectedSyntaxKind: typescript_1.SyntaxKind.MethodDeclaration\r\n        });\r\n    };\r\n    /**\r\n     * Removes the method.\r\n     */\r\n    MethodDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeOverloadableClassMember(this);\r\n    };\r\n    return MethodDeclaration;\r\n}(exports.MethodDeclarationBase));\r\nexports.MethodDeclaration = MethodDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/MethodDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/PropertyDeclaration.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/PropertyDeclaration.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar base_2 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/index.js\");\r\nexports.PropertyDeclarationBase = base_1.ChildOrderableNode(base_1.DecoratableNode(base_2.AbstractableNode(base_1.ScopedNode(base_1.StaticableNode(base_1.JSDocableNode(base_1.ReadonlyableNode(base_1.ExclamationTokenableNode(base_1.QuestionTokenableNode(base_1.InitializerExpressionableNode(base_1.TypedNode(base_1.PropertyNamedNode(base_1.ModifierableNode(common_1.Node)))))))))))));\r\nvar PropertyDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertyDeclaration, _super);\r\n    function PropertyDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    PropertyDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.PropertyDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the property.\r\n     */\r\n    PropertyDeclaration.prototype.remove = function () {\r\n        var parent = this.getParentOrThrow();\r\n        switch (parent.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n                manipulation_1.removeClassMember(this);\r\n                break;\r\n            default:\r\n                throw new errors.NotImplementedError(\"Not implemented parent syntax kind: \" + parent.getKindName());\r\n        }\r\n    };\r\n    return PropertyDeclaration;\r\n}(exports.PropertyDeclarationBase));\r\nexports.PropertyDeclaration = PropertyDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/PropertyDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/SetAccessorDeclaration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/SetAccessorDeclaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar function_1 = __webpack_require__(/*! ../function */ \"./node_modules/ts-simple-ast/dist/compiler/function/index.js\");\r\nvar base_2 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/index.js\");\r\nexports.SetAccessorDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.DecoratableNode(base_2.AbstractableNode(base_1.ScopedNode(base_1.StaticableNode(base_1.BodiedNode(function_1.FunctionLikeDeclaration(base_1.PropertyNamedNode(common_1.Node)))))))));\r\nvar SetAccessorDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SetAccessorDeclaration, _super);\r\n    function SetAccessorDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    SetAccessorDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.SetAccessorDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the corresponding get accessor if one exists.\r\n     */\r\n    SetAccessorDeclaration.prototype.getGetAccessor = function () {\r\n        var e_1, _a;\r\n        var parent = this.getParentIfKindOrThrow(typescript_1.SyntaxKind.ClassDeclaration);\r\n        var thisName = this.getName();\r\n        try {\r\n            for (var _b = tslib_1.__values(parent.getInstanceProperties()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var prop = _c.value;\r\n                if (prop.getKind() === typescript_1.SyntaxKind.GetAccessor && prop.getName() === thisName)\r\n                    return prop;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the corresponding get accessor or throws if not exists.\r\n     */\r\n    SetAccessorDeclaration.prototype.getGetAccessorOrThrow = function () {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getGetAccessor(), function () { return \"Expected to find a corresponding get accessor for \" + _this.getName() + \".\"; });\r\n    };\r\n    /**\r\n     * Removes the set accessor.\r\n     */\r\n    SetAccessorDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeClassMember(this);\r\n    };\r\n    return SetAccessorDeclaration;\r\n}(exports.SetAccessorDeclarationBase));\r\nexports.SetAccessorDeclaration = SetAccessorDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/SetAccessorDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/base/AbstractableNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/base/AbstractableNode.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar callBaseGetStructure_1 = __webpack_require__(/*! ../../callBaseGetStructure */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseGetStructure.js\");\r\nfunction AbstractableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.isAbstract = function () {\r\n            return this.getAbstractKeyword() != null;\r\n        };\r\n        class_1.prototype.getAbstractKeyword = function () {\r\n            return this.getFirstModifierByKind(typescript_1.SyntaxKind.AbstractKeyword);\r\n        };\r\n        class_1.prototype.getAbstractKeywordOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getAbstractKeyword(), \"Expected to find an abstract keyword.\");\r\n        };\r\n        class_1.prototype.setIsAbstract = function (isAbstract) {\r\n            this.toggleModifier(\"abstract\", isAbstract);\r\n            return this;\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.isAbstract != null)\r\n                this.setIsAbstract(structure.isAbstract);\r\n            return this;\r\n        };\r\n        class_1.prototype.getStructure = function () {\r\n            return callBaseGetStructure_1.callBaseGetStructure(Base.prototype, this, {\r\n                isAbstract: this.isAbstract()\r\n            });\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.AbstractableNode = AbstractableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/base/AbstractableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/base/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/base/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AbstractableNode */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/AbstractableNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/base/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/class/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/class/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/class/base/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ClassDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/ClassDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConstructorDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/ConstructorDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./GetAccessorDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/GetAccessorDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./MethodDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/MethodDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/PropertyDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SetAccessorDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/class/SetAccessorDeclaration.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/class/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/CommentRange.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/CommentRange.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar CommentRange = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function CommentRange(compilerObject, sourceFile) {\r\n        this._compilerObject = compilerObject;\r\n        this._sourceFile = sourceFile;\r\n    }\r\n    Object.defineProperty(CommentRange.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the underlying compiler object.\r\n         */\r\n        get: function () {\r\n            this._throwIfForgotten();\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the source file of the comment range.\r\n     */\r\n    CommentRange.prototype.getSourceFile = function () {\r\n        this._throwIfForgotten();\r\n        return this._sourceFile;\r\n    };\r\n    /**\r\n     * Gets the comment syntax kind.\r\n     */\r\n    CommentRange.prototype.getKind = function () {\r\n        return this.compilerObject.kind;\r\n    };\r\n    /**\r\n     * Gets the position.\r\n     */\r\n    CommentRange.prototype.getPos = function () {\r\n        return this.compilerObject.pos;\r\n    };\r\n    /**\r\n     * Gets the end.\r\n     */\r\n    CommentRange.prototype.getEnd = function () {\r\n        return this.compilerObject.end;\r\n    };\r\n    /**\r\n     * Gets the width of the comment range.\r\n     */\r\n    CommentRange.prototype.getWidth = function () {\r\n        return this.getEnd() - this.getPos();\r\n    };\r\n    /**\r\n     * Gets the text of the comment range.\r\n     */\r\n    CommentRange.prototype.getText = function () {\r\n        var fullText = this.getSourceFile().getFullText();\r\n        return fullText.substring(this.compilerObject.pos, this.compilerObject.end);\r\n    };\r\n    /**\r\n     * Forgets the comment range.\r\n     * @internal\r\n     */\r\n    CommentRange.prototype.forget = function () {\r\n        this._compilerObject = undefined;\r\n        this._sourceFile = undefined;\r\n    };\r\n    /**\r\n     * Gets if the comment range was forgotten.\r\n     *\r\n     * This will be true after any manipulations have occured to the source file this comment range was generated from.\r\n     */\r\n    CommentRange.prototype.wasForgotten = function () {\r\n        return this._compilerObject == null;\r\n    };\r\n    CommentRange.prototype._throwIfForgotten = function () {\r\n        if (this._compilerObject != null)\r\n            return;\r\n        var message = \"Attempted to get a comment range that was forgotten. \" +\r\n            \"Comment ranges are forgotten after a manipulation has occurred. \" +\r\n            \"Please re-request the comment range from the node.\";\r\n        throw new errors.InvalidOperationError(message);\r\n    };\r\n    return CommentRange;\r\n}());\r\nexports.CommentRange = CommentRange;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/CommentRange.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/ComputedPropertyName.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/ComputedPropertyName.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Node_1 = __webpack_require__(/*! ./Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\");\r\nvar ComputedPropertyName = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ComputedPropertyName, _super);\r\n    function ComputedPropertyName() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    ComputedPropertyName.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return ComputedPropertyName;\r\n}(Node_1.Node));\r\nexports.ComputedPropertyName = ComputedPropertyName;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/ComputedPropertyName.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/Identifier.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/Identifier.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ../expression/PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.IdentifierBase = base_1.ReferenceFindableNode(base_1.RenameableNode(PrimaryExpression_1.PrimaryExpression));\r\nvar Identifier = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Identifier, _super);\r\n    function Identifier() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the text for the identifier.\r\n     */\r\n    Identifier.prototype.getText = function () {\r\n        return this.compilerNode.text;\r\n    };\r\n    /**\r\n     * Gets the definition nodes of the identifier.\r\n     * @remarks This is similar to \"go to definition\" and `.getDefinitions()`, but only returns the nodes.\r\n     */\r\n    Identifier.prototype.getDefinitionNodes = function () {\r\n        return this.getDefinitions().map(function (d) { return d.getDeclarationNode(); }).filter(function (d) { return d != null; });\r\n    };\r\n    /**\r\n     * Gets the definitions of the identifier.\r\n     * @remarks This is similar to \"go to definition.\" Use `.getDefinitionNodes()` if you only care about the nodes.\r\n     */\r\n    Identifier.prototype.getDefinitions = function () {\r\n        return this.context.languageService.getDefinitions(this);\r\n    };\r\n    /**\r\n     * Gets the implementations of the identifier.\r\n     *\r\n     * This is similar to \"go to implementation.\"\r\n     */\r\n    Identifier.prototype.getImplementations = function () {\r\n        return this.context.languageService.getImplementations(this);\r\n    };\r\n    return Identifier;\r\n}(exports.IdentifierBase));\r\nexports.Identifier = Identifier;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/Identifier.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/Node.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/Node.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar CommentRange_1 = __webpack_require__(/*! ./CommentRange */ \"./node_modules/ts-simple-ast/dist/compiler/common/CommentRange.js\");\r\nvar Node = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance.\r\n     * @internal\r\n     * @param context - Project context.\r\n     * @param node - Underlying node.\r\n     * @param sourceFile - Source file for the node.\r\n     */\r\n    function Node(context, node, sourceFile) {\r\n        if (context == null || context.compilerFactory == null)\r\n            throw new errors.InvalidOperationError(\"Constructing a node is not supported. Please create a source file from the default export \" +\r\n                \"of the package and manipulate the source file from there.\");\r\n        this.context = context;\r\n        this._compilerNode = node;\r\n        this.sourceFile = sourceFile;\r\n    }\r\n    Object.defineProperty(Node.prototype, \"compilerNode\", {\r\n        /**\r\n         * Gets the underlying compiler node.\r\n         */\r\n        get: function () {\r\n            if (this._compilerNode == null)\r\n                throw new errors.InvalidOperationError(\"Attempted to get information from a node that was removed or forgotten.\");\r\n            return this._compilerNode;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Releases the node and all its descendants from the underlying node cache and ast.\r\n     *\r\n     * This is useful if you want to improve the performance of manipulation by not tracking this node anymore.\r\n     */\r\n    Node.prototype.forget = function () {\r\n        var e_1, _a;\r\n        if (this.wasForgotten())\r\n            return;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getChildrenInCacheIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                child.forget();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        this.forgetOnlyThis();\r\n    };\r\n    /**\r\n     * Only forgets this node.\r\n     * @internal\r\n     */\r\n    Node.prototype.forgetOnlyThis = function () {\r\n        if (this.wasForgotten())\r\n            return;\r\n        this.context.compilerFactory.removeNodeFromCache(this);\r\n        this._clearInternals();\r\n    };\r\n    /**\r\n     * Gets if the node was forgotten.\r\n     *\r\n     * This will be true when the node was forgotten or removed.\r\n     */\r\n    Node.prototype.wasForgotten = function () {\r\n        return this._compilerNode == null;\r\n    };\r\n    /**\r\n     * @internal\r\n     *\r\n     * WARNING: This should only be called by the compiler factory!\r\n     */\r\n    Node.prototype.replaceCompilerNodeFromFactory = function (compilerNode) {\r\n        this._clearInternals();\r\n        this._compilerNode = compilerNode;\r\n    };\r\n    /** @internal */\r\n    Node.prototype._clearInternals = function () {\r\n        this._compilerNode = undefined;\r\n        this._childStringRanges = undefined;\r\n        clearCommentRanges(this._leadingCommentRanges);\r\n        clearCommentRanges(this._trailingCommentRanges);\r\n        this._leadingCommentRanges = undefined;\r\n        this._trailingCommentRanges = undefined;\r\n        function clearCommentRanges(commentRanges) {\r\n            if (commentRanges == null)\r\n                return;\r\n            commentRanges.forEach(function (r) { return r.forget(); });\r\n        }\r\n    };\r\n    /**\r\n     * Gets the syntax kind.\r\n     */\r\n    Node.prototype.getKind = function () {\r\n        return this.compilerNode.kind;\r\n    };\r\n    /**\r\n     * Gets the syntax kind name.\r\n     */\r\n    Node.prototype.getKindName = function () {\r\n        return utils_1.getSyntaxKindName(this.compilerNode.kind);\r\n    };\r\n    /**\r\n     * Prints the node using the compiler's printer.\r\n     * @param options - Options.\r\n     */\r\n    Node.prototype.print = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        if (options.newLineKind == null)\r\n            options.newLineKind = this.context.manipulationSettings.getNewLineKind();\r\n        if (this.getKind() === typescript_1.SyntaxKind.SourceFile)\r\n            return utils_1.printNode(this.compilerNode, options);\r\n        else\r\n            return utils_1.printNode(this.compilerNode, this.sourceFile.compilerNode, options);\r\n    };\r\n    /**\r\n     * Gets the symbol or throws an error if it doesn't exist.\r\n     */\r\n    Node.prototype.getSymbolOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getSymbol(), \"Could not find the node's symbol.\");\r\n    };\r\n    /**\r\n     * Gets the compiler symbol or undefined if it doesn't exist.\r\n     */\r\n    Node.prototype.getSymbol = function () {\r\n        var boundSymbol = this.compilerNode.symbol;\r\n        if (boundSymbol != null)\r\n            return this.context.compilerFactory.getSymbol(boundSymbol);\r\n        var typeChecker = this.context.typeChecker;\r\n        var typeCheckerSymbol = typeChecker.getSymbolAtLocation(this);\r\n        if (typeCheckerSymbol != null)\r\n            return typeCheckerSymbol;\r\n        var nameNode = this.compilerNode.name;\r\n        if (nameNode != null)\r\n            return this.getNodeFromCompilerNode(nameNode).getSymbol();\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the type of the node.\r\n     */\r\n    Node.prototype.getType = function () {\r\n        return this.context.typeChecker.getTypeAtLocation(this);\r\n    };\r\n    /**\r\n     * If the node contains the provided range (inclusive).\r\n     * @param pos - Start position.\r\n     * @param end - End position.\r\n     */\r\n    Node.prototype.containsRange = function (pos, end) {\r\n        return this.getPos() <= pos && end <= this.getEnd();\r\n    };\r\n    /**\r\n     * Gets if the specified position is within a string.\r\n     * @param pos - Position.\r\n     */\r\n    Node.prototype.isInStringAtPos = function (pos) {\r\n        var e_2, _a;\r\n        errors.throwIfOutOfRange(pos, [this.getPos(), this.getEnd()], \"pos\");\r\n        if (this._childStringRanges == null) {\r\n            this._childStringRanges = [];\r\n            try {\r\n                for (var _b = tslib_1.__values(this.getCompilerDescendantsIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var descendant = _c.value;\r\n                    if (utils_1.isStringKind(descendant.kind))\r\n                        this._childStringRanges.push([descendant.getStart(this.sourceFile.compilerNode), descendant.getEnd()]);\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        }\r\n        var InStringRangeComparer = /** @class */ (function () {\r\n            function InStringRangeComparer() {\r\n            }\r\n            InStringRangeComparer.prototype.compareTo = function (value) {\r\n                if (pos <= value[0])\r\n                    return -1;\r\n                if (pos >= value[1] - 1)\r\n                    return 1;\r\n                return 0;\r\n            };\r\n            return InStringRangeComparer;\r\n        }());\r\n        return utils_1.ArrayUtils.binarySearch(this._childStringRanges, new InStringRangeComparer()) !== -1;\r\n    };\r\n    Node.prototype.getFirstChildOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstChild(condition), \"Could not find a child that matched the specified condition.\");\r\n    };\r\n    Node.prototype.getFirstChild = function (condition) {\r\n        var firstChild = this.getCompilerFirstChild(getWrappedCondition(this, condition));\r\n        return this.getNodeFromCompilerNodeIfExists(firstChild);\r\n    };\r\n    Node.prototype.getLastChildOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getLastChild(condition), \"Could not find a child that matched the specified condition.\");\r\n    };\r\n    Node.prototype.getLastChild = function (condition) {\r\n        var lastChild = this.getCompilerLastChild(getWrappedCondition(this, condition));\r\n        return this.getNodeFromCompilerNodeIfExists(lastChild);\r\n    };\r\n    Node.prototype.getFirstDescendantOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstDescendant(condition), \"Could not find a descendant that matched the specified condition.\");\r\n    };\r\n    Node.prototype.getFirstDescendant = function (condition) {\r\n        var e_3, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getDescendantsIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var descendant = _c.value;\r\n                if (condition == null || condition(descendant))\r\n                    return descendant;\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Offset this node's positions (pos and end) and all of its children by the given offset.\r\n     * @internal\r\n     * @param offset - Offset.\r\n     */\r\n    Node.prototype.offsetPositions = function (offset) {\r\n        var e_4, _a;\r\n        this.compilerNode.pos += offset;\r\n        this.compilerNode.end += offset;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                child.offsetPositions(offset);\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n    };\r\n    Node.prototype.getPreviousSiblingOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getPreviousSibling(condition), \"Could not find the previous sibling.\");\r\n    };\r\n    Node.prototype.getPreviousSibling = function (condition) {\r\n        var previousSibling = this.getCompilerPreviousSibling(getWrappedCondition(this, condition));\r\n        return this.getNodeFromCompilerNodeIfExists(previousSibling);\r\n    };\r\n    Node.prototype.getNextSiblingOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getNextSibling(condition), \"Could not find the next sibling.\");\r\n    };\r\n    Node.prototype.getNextSibling = function (condition) {\r\n        var nextSibling = this.getCompilerNextSibling(getWrappedCondition(this, condition));\r\n        return this.getNodeFromCompilerNodeIfExists(nextSibling);\r\n    };\r\n    /**\r\n     * Gets the previous siblings.\r\n     *\r\n     * Note: Closest sibling is the zero index.\r\n     */\r\n    Node.prototype.getPreviousSiblings = function () {\r\n        var _this = this;\r\n        return this.getCompilerPreviousSiblings().map(function (n) { return _this.getNodeFromCompilerNode(n); });\r\n    };\r\n    /**\r\n     * Gets the next siblings.\r\n     *\r\n     * Note: Closest sibling is the zero index.\r\n     */\r\n    Node.prototype.getNextSiblings = function () {\r\n        var _this = this;\r\n        return this.getCompilerNextSiblings().map(function (n) { return _this.getNodeFromCompilerNode(n); });\r\n    };\r\n    /**\r\n     * Gets all the children of the node.\r\n     */\r\n    Node.prototype.getChildren = function () {\r\n        var _this = this;\r\n        return this.getCompilerChildren().map(function (n) { return _this.getNodeFromCompilerNode(n); });\r\n    };\r\n    /**\r\n     * Gets the child at the specified index.\r\n     * @param index - Index of the child.\r\n     */\r\n    Node.prototype.getChildAtIndex = function (index) {\r\n        return this.getNodeFromCompilerNode(this.getCompilerChildAtIndex(index));\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Node.prototype.getChildrenIterator = function () {\r\n        var e_5, _a, _b, _c, compilerChild, e_5_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(this.getCompilerChildren()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    compilerChild = _c.value;\r\n                    return [4 /*yield*/, this.getNodeFromCompilerNode(compilerChild)];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_5_1 = _d.sent();\r\n                    e_5 = { error: e_5_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_5) throw e_5.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Node.prototype.getChildrenInCacheIterator = function () {\r\n        var e_6, _a, _b, _c, child, e_6_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 7, 8, 9]);\r\n                    _b = tslib_1.__values(this.getCompilerChildren()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 6];\r\n                    child = _c.value;\r\n                    if (!this.context.compilerFactory.hasCompilerNode(child)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, this.context.compilerFactory.getExistingCompilerNode(child)];\r\n                case 2:\r\n                    _d.sent();\r\n                    return [3 /*break*/, 5];\r\n                case 3:\r\n                    if (!(child.kind === typescript_1.SyntaxKind.SyntaxList)) return [3 /*break*/, 5];\r\n                    // always return syntax lists because their children could be in the cache\r\n                    return [4 /*yield*/, this.getNodeFromCompilerNode(child)];\r\n                case 4:\r\n                    // always return syntax lists because their children could be in the cache\r\n                    _d.sent();\r\n                    _d.label = 5;\r\n                case 5:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_6_1 = _d.sent();\r\n                    e_6 = { error: e_6_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_6) throw e_6.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the child syntax list or throws if it doesn't exist.\r\n     */\r\n    Node.prototype.getChildSyntaxListOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getChildSyntaxList(), \"A child syntax list was expected.\");\r\n    };\r\n    /**\r\n     * Gets the child syntax list if it exists.\r\n     */\r\n    Node.prototype.getChildSyntaxList = function () {\r\n        var e_7, _a;\r\n        var node = this;\r\n        if (utils_1.TypeGuards.isBodyableNode(node) || utils_1.TypeGuards.isBodiedNode(node)) {\r\n            do {\r\n                node = utils_1.TypeGuards.isBodyableNode(node) ? node.getBodyOrThrow() : node.getBody();\r\n            } while ((utils_1.TypeGuards.isBodyableNode(node) || utils_1.TypeGuards.isBodiedNode(node)) && node.compilerNode.statements == null);\r\n        }\r\n        if (utils_1.TypeGuards.isSourceFile(node) ||\r\n            utils_1.TypeGuards.isBodyableNode(this) ||\r\n            utils_1.TypeGuards.isBodiedNode(this) ||\r\n            utils_1.TypeGuards.isCaseBlock(this) ||\r\n            utils_1.TypeGuards.isCaseClause(this) ||\r\n            utils_1.TypeGuards.isDefaultClause(this) ||\r\n            utils_1.TypeGuards.isJsxElement(this))\r\n            return node.getFirstChildByKind(typescript_1.SyntaxKind.SyntaxList);\r\n        var passedBrace = false;\r\n        try {\r\n            for (var _b = tslib_1.__values(node.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                if (!passedBrace)\r\n                    passedBrace = child.kind === typescript_1.SyntaxKind.OpenBraceToken;\r\n                else if (child.kind === typescript_1.SyntaxKind.SyntaxList)\r\n                    return this.getNodeFromCompilerNode(child);\r\n            }\r\n        }\r\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_7) throw e_7.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Invokes the `cbNode` callback for each child and the `cbNodeArray` for every array of nodes stored in properties of the node.\r\n     * If `cbNodeArray` is not defined, then it will pass every element of the array to `cbNode`.\r\n     *\r\n     * @remarks There exists a `traversal.stop()` function on the second parameter that allows stopping iteration.\r\n     * @param cbNode - Callback invoked for each child.\r\n     * @param cbNodeArray - Callback invoked for each array of nodes.\r\n     */\r\n    Node.prototype.forEachChild = function (cbNode, cbNodeArray) {\r\n        var _this = this;\r\n        var e_8, _a;\r\n        var stop = false;\r\n        var traversal = {\r\n            stop: function () { return stop = true; }\r\n        };\r\n        var snapshots = [];\r\n        // Get all the nodes from the compiler's forEachChild. Taking this snapshot prevents the results of\r\n        // .forEachChild from returning out of date nodes due to a manipulation or deletion\r\n        this.compilerNode.forEachChild(function (node) {\r\n            // use function block to ensure a truthy value is not returned\r\n            snapshots.push(_this.getNodeFromCompilerNode(node));\r\n        }, cbNodeArray == null ? undefined : function (nodes) {\r\n            snapshots.push(nodes.map(function (n) { return _this.getNodeFromCompilerNode(n); }));\r\n        });\r\n        try {\r\n            // now send them to the user\r\n            for (var snapshots_1 = tslib_1.__values(snapshots), snapshots_1_1 = snapshots_1.next(); !snapshots_1_1.done; snapshots_1_1 = snapshots_1.next()) {\r\n                var snapshot = snapshots_1_1.value;\r\n                if (snapshot instanceof Array) {\r\n                    var filteredNodes = snapshot.filter(function (n) { return !n.wasForgotten(); });\r\n                    if (filteredNodes.length > 0)\r\n                        cbNodeArray(filteredNodes, traversal);\r\n                }\r\n                else if (!snapshot.wasForgotten())\r\n                    cbNode(snapshot, traversal);\r\n                if (stop)\r\n                    break;\r\n            }\r\n        }\r\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\r\n        finally {\r\n            try {\r\n                if (snapshots_1_1 && !snapshots_1_1.done && (_a = snapshots_1.return)) _a.call(snapshots_1);\r\n            }\r\n            finally { if (e_8) throw e_8.error; }\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the `cbNode` callback for each descendant and the `cbNodeArray` for every array of nodes stored in properties of the node and descendant nodes.\r\n     * If `cbNodeArray` is not defined, then it will pass every element of the array to `cbNode`.\r\n     *\r\n     * @remarks There exists a `traversal` object on the second parameter that allows various control of iteration.\r\n     * @param cbNode - Callback invoked for each descendant.\r\n     * @param cbNodeArray - Callback invoked for each array of nodes.\r\n     */\r\n    Node.prototype.forEachDescendant = function (cbNode, cbNodeArray) {\r\n        var stop = false;\r\n        var up = false;\r\n        var traversal = {\r\n            stop: function () { return stop = true; },\r\n            up: function () { return up = true; }\r\n        };\r\n        var nodeCallback = function (node) {\r\n            if (stop)\r\n                return;\r\n            var skip = false;\r\n            cbNode(node, tslib_1.__assign({}, traversal, { skip: function () { return skip = true; } }));\r\n            if (stop || skip || up)\r\n                return;\r\n            forEachChildForNode(node);\r\n        };\r\n        var arrayCallback = cbNodeArray == null ? undefined : function (nodes) {\r\n            var e_9, _a;\r\n            if (stop)\r\n                return;\r\n            var skip = false;\r\n            cbNodeArray(nodes, tslib_1.__assign({}, traversal, { skip: function () { return skip = true; } }));\r\n            if (skip)\r\n                return;\r\n            try {\r\n                for (var nodes_1 = tslib_1.__values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\r\n                    var node = nodes_1_1.value;\r\n                    if (stop || up)\r\n                        return;\r\n                    forEachChildForNode(node);\r\n                }\r\n            }\r\n            catch (e_9_1) { e_9 = { error: e_9_1 }; }\r\n            finally {\r\n                try {\r\n                    if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\r\n                }\r\n                finally { if (e_9) throw e_9.error; }\r\n            }\r\n        };\r\n        forEachChildForNode(this);\r\n        function forEachChildForNode(node) {\r\n            node.forEachChild(function (innerNode, innerTraversal) {\r\n                nodeCallback(innerNode);\r\n                if (up) {\r\n                    innerTraversal.stop();\r\n                    up = false;\r\n                }\r\n            }, arrayCallback == null ? undefined : function (nodes, innerTraversal) {\r\n                arrayCallback(nodes);\r\n                if (up) {\r\n                    innerTraversal.stop();\r\n                    up = false;\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Gets the node's descendants.\r\n     */\r\n    Node.prototype.getDescendants = function () {\r\n        return utils_1.ArrayUtils.from(this.getDescendantsIterator());\r\n    };\r\n    /**\r\n     * Gets the node's descendants as an iterator.\r\n     * @internal\r\n     */\r\n    Node.prototype.getDescendantsIterator = function () {\r\n        var e_10, _a, _b, _c, descendant, e_10_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(this.getCompilerDescendantsIterator()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    descendant = _c.value;\r\n                    return [4 /*yield*/, this.getNodeFromCompilerNode(descendant)];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_10_1 = _d.sent();\r\n                    e_10 = { error: e_10_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_10) throw e_10.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the node's descendant statements.\r\n     */\r\n    Node.prototype.getDescendantStatements = function () {\r\n        var statements = [];\r\n        handleNode(this, this.compilerNode);\r\n        return statements;\r\n        function handleNode(thisNode, node) {\r\n            if (handleStatements(thisNode, node))\r\n                return;\r\n            else if (node.kind === typescript_1.SyntaxKind.ArrowFunction) {\r\n                var arrowFunction = node;\r\n                if (arrowFunction.body.kind !== typescript_1.SyntaxKind.Block)\r\n                    statements.push(thisNode.getNodeFromCompilerNode(arrowFunction.body)); // todo: bug... it's not a statement\r\n                else\r\n                    handleNode(thisNode, arrowFunction.body);\r\n            }\r\n            else\r\n                handleChildren(thisNode, node);\r\n        }\r\n        function handleStatements(thisNode, node) {\r\n            var e_11, _a;\r\n            if (node.statements == null)\r\n                return false;\r\n            try {\r\n                for (var _b = tslib_1.__values(node.statements), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var statement = _c.value;\r\n                    statements.push(thisNode.getNodeFromCompilerNode(statement));\r\n                    handleChildren(thisNode, statement);\r\n                }\r\n            }\r\n            catch (e_11_1) { e_11 = { error: e_11_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_11) throw e_11.error; }\r\n            }\r\n            return true;\r\n        }\r\n        function handleChildren(thisNode, node) {\r\n            typescript_1.ts.forEachChild(node, function (childNode) { return handleNode(thisNode, childNode); });\r\n        }\r\n    };\r\n    /**\r\n     * Gets the number of children the node has.\r\n     */\r\n    Node.prototype.getChildCount = function () {\r\n        return this.compilerNode.getChildCount(this.sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the child at the provided text position, or undefined if not found.\r\n     * @param pos - Text position to search for.\r\n     */\r\n    Node.prototype.getChildAtPos = function (pos) {\r\n        var e_12, _a;\r\n        if (pos < this.getPos() || pos >= this.getEnd())\r\n            return undefined;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                if (pos >= child.pos && pos < child.end)\r\n                    return this.getNodeFromCompilerNode(child);\r\n            }\r\n        }\r\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_12) throw e_12.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the most specific descendant at the provided text position, or undefined if not found.\r\n     * @param pos - Text position to search for.\r\n     */\r\n    Node.prototype.getDescendantAtPos = function (pos) {\r\n        var node;\r\n        while (true) {\r\n            var nextNode = (node || this).getChildAtPos(pos);\r\n            if (nextNode == null)\r\n                return node;\r\n            else\r\n                node = nextNode;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the most specific descendant at the provided start text position with the specified width, or undefined if not found.\r\n     * @param start - Start text position to search for.\r\n     * @param width - Text length of the node to search for.\r\n     */\r\n    Node.prototype.getDescendantAtStartWithWidth = function (start, width) {\r\n        var _this = this;\r\n        var foundNode;\r\n        this.context.compilerFactory.forgetNodesCreatedInBlock(function (remember) {\r\n            var nextNode = _this.getSourceFile();\r\n            do {\r\n                nextNode = nextNode.getChildAtPos(start);\r\n                if (nextNode != null) {\r\n                    if (nextNode.getStart() === start && nextNode.getWidth() === width)\r\n                        foundNode = nextNode;\r\n                    else if (foundNode != null)\r\n                        break; // no need to keep looking\r\n                }\r\n            } while (nextNode != null);\r\n            if (foundNode != null)\r\n                remember(foundNode);\r\n        });\r\n        return foundNode;\r\n    };\r\n    /**\r\n     * Gets the source file text position where the node starts that includes the leading trivia (comments and whitespace).\r\n     */\r\n    Node.prototype.getPos = function () {\r\n        return this.compilerNode.pos;\r\n    };\r\n    /**\r\n     * Gets the source file text position where the node ends.\r\n     *\r\n     * @remarks This does not include the following trivia (comments and whitespace).\r\n     */\r\n    Node.prototype.getEnd = function () {\r\n        return this.compilerNode.end;\r\n    };\r\n    /**\r\n     * Gets the source file text position where the node starts that does not include the leading trivia (comments and whitespace).\r\n     * @param includeJsDocComment - Whether to include the JS doc comment.\r\n     */\r\n    Node.prototype.getStart = function (includeJsDocComment) {\r\n        // rare time a bool parameter will be used... it's because it's done in the ts compiler\r\n        return this.compilerNode.getStart(this.sourceFile.compilerNode, includeJsDocComment);\r\n    };\r\n    /**\r\n     * Gets the source file text position of the end of the last significant token or the start of the source file.\r\n     */\r\n    Node.prototype.getFullStart = function () {\r\n        return this.compilerNode.getFullStart();\r\n    };\r\n    /**\r\n     * Gets the first source file text position from the result of .getPos() that is not whitespace.\r\n     */\r\n    Node.prototype.getNonWhitespaceStart = function () {\r\n        return manipulation_1.getNextNonWhitespacePos(this.sourceFile.getFullText(), this.getPos());\r\n    };\r\n    /**\r\n     * Gets the text length of the node without trivia.\r\n     */\r\n    Node.prototype.getWidth = function () {\r\n        return this.compilerNode.getWidth(this.sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the text length of the node with trivia.\r\n     */\r\n    Node.prototype.getFullWidth = function () {\r\n        return this.compilerNode.getFullWidth();\r\n    };\r\n    /**\r\n     * Gets the node's leading trivia's text length.\r\n     */\r\n    Node.prototype.getLeadingTriviaWidth = function () {\r\n        return this.compilerNode.getLeadingTriviaWidth(this.sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the text length from the end of the current node to the next significant token or new line.\r\n     */\r\n    Node.prototype.getTrailingTriviaWidth = function () {\r\n        return this.getTrailingTriviaEnd() - this.getEnd();\r\n    };\r\n    /**\r\n     * Gets the text position of the next significant token or new line.\r\n     */\r\n    Node.prototype.getTrailingTriviaEnd = function () {\r\n        var parent = this.getParent();\r\n        var end = this.getEnd();\r\n        if (parent == null)\r\n            return end;\r\n        var parentEnd = parent.getEnd();\r\n        if (parentEnd === end)\r\n            return end;\r\n        var trailingComments = this.getTrailingCommentRanges();\r\n        var searchStart = getSearchStart();\r\n        return manipulation_1.getNextMatchingPos(this.sourceFile.getFullText(), searchStart, function (char) { return char !== \" \" && char !== \"\\t\"; });\r\n        function getSearchStart() {\r\n            return trailingComments.length > 0 ? trailingComments[trailingComments.length - 1].getEnd() : end;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the text without leading trivia (comments and whitespace).\r\n     */\r\n    Node.prototype.getText = function () {\r\n        return this.compilerNode.getText(this.sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the full text with leading trivia (comments and whitespace).\r\n     */\r\n    Node.prototype.getFullText = function () {\r\n        return this.compilerNode.getFullText(this.sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the combined modifier flags.\r\n     */\r\n    Node.prototype.getCombinedModifierFlags = function () {\r\n        // todo: make this method only available on declarations in the future.\r\n        return typescript_1.ts.getCombinedModifierFlags(this.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the source file.\r\n     */\r\n    Node.prototype.getSourceFile = function () {\r\n        return this.sourceFile;\r\n    };\r\n    /**\r\n     * Gets a compiler node property wrapped in a Node.\r\n     * @param propertyName - Property name.\r\n     */\r\n    Node.prototype.getNodeProperty = function (propertyName) {\r\n        var _this = this;\r\n        var property = this.compilerNode[propertyName];\r\n        if (property == null)\r\n            return undefined;\r\n        else if (property instanceof Array)\r\n            return property.map(function (p) { return isNode(p) ? _this.getNodeFromCompilerNode(p) : p; });\r\n        else if (isNode(property))\r\n            return this.getNodeFromCompilerNode(property);\r\n        else\r\n            return property;\r\n        function isNode(value) {\r\n            return typeof value.kind === \"number\" && typeof value.pos === \"number\" && typeof value.end === \"number\";\r\n        }\r\n    };\r\n    Node.prototype.getAncestors = function (includeSyntaxLists) {\r\n        if (includeSyntaxLists === void 0) { includeSyntaxLists = false; }\r\n        return utils_1.ArrayUtils.from(this.getAncestorsIterator(includeSyntaxLists));\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Node.prototype.getAncestorsIterator = function (includeSyntaxLists) {\r\n        function getParent(node) {\r\n            return includeSyntaxLists ? node.getParentSyntaxList() || node.getParent() : node.getParent();\r\n        }\r\n        var parent;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    parent = getParent(this);\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(parent != null)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, parent];\r\n                case 2:\r\n                    _a.sent();\r\n                    parent = getParent(parent);\r\n                    return [3 /*break*/, 1];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Get the node's parent.\r\n     */\r\n    Node.prototype.getParent = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.parent);\r\n    };\r\n    /**\r\n     * Gets the parent or throws an error if it doesn't exist.\r\n     */\r\n    Node.prototype.getParentOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getParent(), \"Expected to find a parent.\");\r\n    };\r\n    Node.prototype.getParentWhileOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getParentWhile(condition), \"The initial parent did not match the provided condition.\");\r\n    };\r\n    Node.prototype.getParentWhile = function (condition) {\r\n        var node = undefined;\r\n        var nextParent = this.getParent();\r\n        while (nextParent != null && condition(nextParent)) {\r\n            node = nextParent;\r\n            nextParent = nextParent.getParent();\r\n        }\r\n        return node;\r\n    };\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while the parent is the specified syntax kind.\r\n     * Throws if the initial parent is not the specified syntax kind.\r\n     * @param kind - Syntax kind to check for.\r\n     */\r\n    Node.prototype.getParentWhileKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getParentWhileKind(kind), \"The initial parent was not a syntax kind of \" + utils_1.getSyntaxKindName(kind) + \".\");\r\n    };\r\n    /**\r\n     * Goes up the parents (ancestors) of the node while the parent is the specified syntax kind.\r\n     * Returns undefined if the initial parent is not the specified syntax kind.\r\n     * @param kind - Syntax kind to check for.\r\n     */\r\n    Node.prototype.getParentWhileKind = function (kind) {\r\n        return this.getParentWhile(function (n) { return n.getKind() === kind; });\r\n    };\r\n    /**\r\n     * Gets the last token of this node. Usually this is a close brace.\r\n     */\r\n    Node.prototype.getLastToken = function () {\r\n        var lastToken = this.compilerNode.getLastToken(this.sourceFile.compilerNode);\r\n        if (lastToken == null)\r\n            throw new errors.NotImplementedError(\"Not implemented scenario where the last token does not exist.\");\r\n        return this.getNodeFromCompilerNode(lastToken);\r\n    };\r\n    /**\r\n     * Gets if this node is in a syntax list.\r\n     */\r\n    Node.prototype.isInSyntaxList = function () {\r\n        return this.getParentSyntaxList() != null;\r\n    };\r\n    /**\r\n     * Gets the parent if it's a syntax list or throws an error otherwise.\r\n     */\r\n    Node.prototype.getParentSyntaxListOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getParentSyntaxList(), \"Expected the parent to be a syntax list.\");\r\n    };\r\n    /**\r\n     * Gets the parent if it's a syntax list.\r\n     */\r\n    Node.prototype.getParentSyntaxList = function () {\r\n        var syntaxList = utils_1.getParentSyntaxList(this.compilerNode);\r\n        return this.getNodeFromCompilerNodeIfExists(syntaxList);\r\n    };\r\n    /**\r\n     * Gets the child index of this node relative to the parent.\r\n     */\r\n    Node.prototype.getChildIndex = function () {\r\n        var e_13, _a;\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var i = 0;\r\n        try {\r\n            for (var _b = tslib_1.__values(parent.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                if (child === this.compilerNode)\r\n                    return i;\r\n                i++;\r\n            }\r\n        }\r\n        catch (e_13_1) { e_13 = { error: e_13_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_13) throw e_13.error; }\r\n        }\r\n        /* istanbul ignore next */\r\n        throw new errors.NotImplementedError(\"For some reason the child's parent did not contain the child.\");\r\n    };\r\n    /**\r\n     * Gets the indentation level of the current node.\r\n     */\r\n    Node.prototype.getIndentationLevel = function () {\r\n        var indentationText = this.context.manipulationSettings.getIndentationText();\r\n        return this.context.languageService.getIdentationAtPosition(this.sourceFile, this.getStart()) / indentationText.length;\r\n    };\r\n    /**\r\n     * Gets the child indentation level of the current node.\r\n     */\r\n    Node.prototype.getChildIndentationLevel = function () {\r\n        if (utils_1.TypeGuards.isSourceFile(this))\r\n            return 0;\r\n        return this.getIndentationLevel() + 1;\r\n    };\r\n    /**\r\n     * Gets the indentation text.\r\n     * @param offset - Optional number of levels of indentation to add or remove.\r\n     */\r\n    Node.prototype.getIndentationText = function (offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return this._getIndentationTextForLevel(this.getIndentationLevel() + offset);\r\n    };\r\n    /**\r\n     * Gets the next indentation level text.\r\n     * @param offset - Optional number of levels of indentation to add or remove.\r\n     */\r\n    Node.prototype.getChildIndentationText = function (offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return this._getIndentationTextForLevel(this.getChildIndentationLevel() + offset);\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Node.prototype._getIndentationTextForLevel = function (level) {\r\n        return utils_1.StringUtils.repeat(this.context.manipulationSettings.getIndentationText(), level);\r\n    };\r\n    /**\r\n     * Gets the position of the start of the line that this node starts on.\r\n     * @param includeJsDocComment - Whether to include the JS doc comment or not.\r\n     */\r\n    Node.prototype.getStartLinePos = function (includeJsDocComment) {\r\n        var sourceFileText = this.sourceFile.getFullText();\r\n        return manipulation_1.getPreviousMatchingPos(sourceFileText, this.getStart(includeJsDocComment), function (char) { return char === \"\\n\" || char === \"\\r\"; });\r\n    };\r\n    /**\r\n     * Gets the line number at the start of the node.\r\n     * @param includeJsDocComment - Whether to include the JS doc comment or not.\r\n     */\r\n    Node.prototype.getStartLineNumber = function (includeJsDocComment) {\r\n        return this.sourceFile.getLineNumberAtPos(this.getStartLinePos(includeJsDocComment));\r\n    };\r\n    /**\r\n     * Gets the line number of the end of the node.\r\n     */\r\n    Node.prototype.getEndLineNumber = function () {\r\n        var sourceFileText = this.sourceFile.getFullText();\r\n        var endLinePos = manipulation_1.getPreviousMatchingPos(sourceFileText, this.getEnd(), function (char) { return char === \"\\n\" || char === \"\\r\"; });\r\n        return this.sourceFile.getLineNumberAtPos(endLinePos);\r\n    };\r\n    /**\r\n     * Gets if this is the first node on the current line.\r\n     */\r\n    Node.prototype.isFirstNodeOnLine = function () {\r\n        var sourceFileText = this.sourceFile.getFullText();\r\n        var startPos = this.getNonWhitespaceStart();\r\n        for (var i = startPos - 1; i >= 0; i--) {\r\n            var currentChar = sourceFileText[i];\r\n            if (currentChar === \" \" || currentChar === \"\\t\")\r\n                continue;\r\n            if (currentChar === \"\\n\")\r\n                return true;\r\n            return false;\r\n        }\r\n        return true; // first node on the first line\r\n    };\r\n    Node.prototype.replaceWithText = function (textOrWriterFunction, writer) {\r\n        var newText = utils_1.getTextFromStringOrWriter(writer || this.getWriter(), textOrWriterFunction);\r\n        if (utils_1.TypeGuards.isSourceFile(this)) {\r\n            this.replaceText([this.getPos(), this.getEnd()], newText);\r\n            return this;\r\n        }\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var childIndex = this.getChildIndex();\r\n        var start = this.getStart(true);\r\n        manipulation_1.insertIntoParentTextRange({\r\n            parent: parent,\r\n            insertPos: start,\r\n            newText: newText,\r\n            replacing: {\r\n                textLength: this.getEnd() - start\r\n            }\r\n        });\r\n        return parent.getChildren()[childIndex];\r\n    };\r\n    /**\r\n     * Prepends the specified whitespace to current node.\r\n     * @param textOrWriterFunction - Text or writer function.\r\n     */\r\n    Node.prototype.prependWhitespace = function (textOrWriterFunction) {\r\n        insertWhiteSpaceTextAtPos(this, this.getStart(true), textOrWriterFunction, \"prependWhitespace\");\r\n    };\r\n    /**\r\n     * Appends the specified whitespace to current node.\r\n     * @param textOrWriterFunction - Text or writer function.\r\n     */\r\n    Node.prototype.appendWhitespace = function (textOrWriterFunction) {\r\n        insertWhiteSpaceTextAtPos(this, this.getEnd(), textOrWriterFunction, \"appendWhitespace\");\r\n    };\r\n    /**\r\n     * Formats the node's text using the internal TypeScript formatting API.\r\n     * @param settings - Format code settings.\r\n     */\r\n    Node.prototype.formatText = function (settings) {\r\n        if (settings === void 0) { settings = {}; }\r\n        var formattingEdits = this.context.languageService.getFormattingEditsForRange(this.sourceFile.getFilePath(), [this.getStart(true), this.getEnd()], settings);\r\n        manipulation_1.replaceSourceFileTextForFormatting({\r\n            sourceFile: this.sourceFile,\r\n            newText: manipulation_1.getTextFromFormattingEdits(this.sourceFile, formattingEdits)\r\n        });\r\n    };\r\n    /**\r\n     * Gets the leading comment ranges of the current node.\r\n     */\r\n    Node.prototype.getLeadingCommentRanges = function () {\r\n        return this._leadingCommentRanges || (this._leadingCommentRanges = this._getCommentsAtPos(this.getFullStart(), typescript_1.ts.getLeadingCommentRanges));\r\n    };\r\n    /**\r\n     * Gets the trailing comment ranges of the current node.\r\n     */\r\n    Node.prototype.getTrailingCommentRanges = function () {\r\n        return this._trailingCommentRanges || (this._trailingCommentRanges = this._getCommentsAtPos(this.getEnd(), typescript_1.ts.getTrailingCommentRanges));\r\n    };\r\n    /** @internal */\r\n    Node.prototype._getCommentsAtPos = function (pos, getComments) {\r\n        var _this = this;\r\n        if (this.getKind() === typescript_1.SyntaxKind.SourceFile)\r\n            return [];\r\n        return (getComments(this.sourceFile.getFullText(), pos) || []).map(function (r) { return new CommentRange_1.CommentRange(r, _this.sourceFile); });\r\n    };\r\n    /**\r\n     * Gets the children based on a kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getChildrenOfKind = function (kind) {\r\n        var _this = this;\r\n        return this.getCompilerChildren().filter(function (c) { return c.kind === kind; }).map(function (c) { return _this.getNodeFromCompilerNode(c); });\r\n    };\r\n    /**\r\n     * Gets the first child by syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstChildByKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstChildByKind(kind), \"A child of the kind \" + utils_1.getSyntaxKindName(kind) + \" was expected.\");\r\n    };\r\n    /**\r\n     * Gets the first child by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstChildByKind = function (kind) {\r\n        var child = this.getCompilerFirstChild(function (c) { return c.kind === kind; });\r\n        return child == null ? undefined : this.getNodeFromCompilerNode(child);\r\n    };\r\n    /**\r\n     * Gets the first child if it matches the specified syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstChildIfKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstChildIfKind(kind), \"A first child of the kind \" + utils_1.getSyntaxKindName(kind) + \" was expected.\");\r\n    };\r\n    /**\r\n     * Gets the first child if it matches the specified syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstChildIfKind = function (kind) {\r\n        var firstChild = this.getCompilerFirstChild();\r\n        return firstChild != null && firstChild.kind === kind ? this.getNodeFromCompilerNode(firstChild) : undefined;\r\n    };\r\n    /**\r\n     * Gets the last child by syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getLastChildByKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getLastChildByKind(kind), \"A child of the kind \" + utils_1.getSyntaxKindName(kind) + \" was expected.\");\r\n    };\r\n    /**\r\n     * Gets the last child by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getLastChildByKind = function (kind) {\r\n        var lastChild = this.getCompilerLastChild(function (c) { return c.kind === kind; });\r\n        return this.getNodeFromCompilerNodeIfExists(lastChild);\r\n    };\r\n    /**\r\n     * Gets the last child if it matches the specified syntax kind or throws an error if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getLastChildIfKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getLastChildIfKind(kind), \"A last child of the kind \" + utils_1.getSyntaxKindName(kind) + \" was expected.\");\r\n    };\r\n    /**\r\n     * Gets the last child if it matches the specified syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getLastChildIfKind = function (kind) {\r\n        var lastChild = this.getCompilerLastChild();\r\n        return lastChild != null && lastChild.kind === kind ? this.getNodeFromCompilerNode(lastChild) : undefined;\r\n    };\r\n    /**\r\n     * Gets the child at the specified index if it's the specified kind or throws an exception.\r\n     * @param index - Child index to get.\r\n     * @param kind - Expected kind.\r\n     */\r\n    Node.prototype.getChildAtIndexIfKindOrThrow = function (index, kind) {\r\n        return errors.throwIfNullOrUndefined(this.getChildAtIndexIfKind(index, kind), \"Child at index \" + index + \" was expected to be \" + utils_1.getSyntaxKindName(kind));\r\n    };\r\n    /**\r\n     * Gets the child at the specified index if it's the specified kind or returns undefined.\r\n     * @param index - Child index to get.\r\n     * @param kind - Expected kind.\r\n     */\r\n    Node.prototype.getChildAtIndexIfKind = function (index, kind) {\r\n        var node = this.getCompilerChildAtIndex(index);\r\n        return node.kind === kind ? this.getNodeFromCompilerNode(node) : undefined;\r\n    };\r\n    /**\r\n     * Gets the previous sibiling if it matches the specified kind, or throws.\r\n     * @param kind - Kind to check.\r\n     */\r\n    Node.prototype.getPreviousSiblingIfKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getPreviousSiblingIfKind(kind), \"A previous sibling of kind \" + utils_1.getSyntaxKindName(kind) + \" was expected.\");\r\n    };\r\n    /**\r\n     * Gets the next sibiling if it matches the specified kind, or throws.\r\n     * @param kind - Kind to check.\r\n     */\r\n    Node.prototype.getNextSiblingIfKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getNextSiblingIfKind(kind), \"A next sibling of kind \" + utils_1.getSyntaxKindName(kind) + \" was expected.\");\r\n    };\r\n    /**\r\n     * Gets the previous sibling if it matches the specified kind.\r\n     * @param kind - Kind to check.\r\n     */\r\n    Node.prototype.getPreviousSiblingIfKind = function (kind) {\r\n        var previousSibling = this.getCompilerPreviousSibling();\r\n        return previousSibling != null && previousSibling.kind === kind ? this.getNodeFromCompilerNode(previousSibling) : undefined;\r\n    };\r\n    /**\r\n     * Gets the next sibling if it matches the specified kind.\r\n     * @param kind - Kind to check.\r\n     */\r\n    Node.prototype.getNextSiblingIfKind = function (kind) {\r\n        var nextSibling = this.getCompilerNextSibling();\r\n        return nextSibling != null && nextSibling.kind === kind ? this.getNodeFromCompilerNode(nextSibling) : undefined;\r\n    };\r\n    /**\r\n     * Gets the parent if it's a certain syntax kind.\r\n     */\r\n    Node.prototype.getParentIfKind = function (kind) {\r\n        var parentNode = this.getParent();\r\n        return parentNode == null || parentNode.getKind() !== kind ? undefined : parentNode;\r\n    };\r\n    /**\r\n     * Gets the parent if it's a certain syntax kind of throws.\r\n     */\r\n    Node.prototype.getParentIfKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getParentIfKind(kind), \"Expected a parent with a syntax kind of \" + utils_1.getSyntaxKindName(kind) + \".\");\r\n    };\r\n    /**\r\n     * Gets the first ancestor by syntax kind or throws if not found.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstAncestorByKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstAncestorByKind(kind), \"Expected an ancestor with a syntax kind of \" + utils_1.getSyntaxKindName(kind) + \".\");\r\n    };\r\n    /**\r\n     * Get the first ancestor by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstAncestorByKind = function (kind) {\r\n        var e_14, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getAncestorsIterator(kind === typescript_1.SyntaxKind.SyntaxList)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var parent = _c.value;\r\n                if (parent.getKind() === kind)\r\n                    return parent;\r\n            }\r\n        }\r\n        catch (e_14_1) { e_14 = { error: e_14_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_14) throw e_14.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    Node.prototype.getFirstAncestorOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstAncestor(condition), \"Expected to find an ancestor that matched the provided condition.\");\r\n    };\r\n    Node.prototype.getFirstAncestor = function (condition) {\r\n        var e_15, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getAncestorsIterator(false)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var ancestor = _c.value;\r\n                if (condition == null || condition(ancestor))\r\n                    return ancestor;\r\n            }\r\n        }\r\n        catch (e_15_1) { e_15 = { error: e_15_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_15) throw e_15.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the descendants that match a specified syntax kind.\r\n     * @param kind - Kind to check.\r\n     */\r\n    Node.prototype.getDescendantsOfKind = function (kind) {\r\n        var e_16, _a;\r\n        var descendants = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getCompilerDescendantsIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var descendant = _c.value;\r\n                if (descendant.kind === kind)\r\n                    descendants.push(this.getNodeFromCompilerNode(descendant));\r\n            }\r\n        }\r\n        catch (e_16_1) { e_16 = { error: e_16_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_16) throw e_16.error; }\r\n        }\r\n        return descendants;\r\n    };\r\n    /**\r\n     * Gets the first descendant by syntax kind or throws.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstDescendantByKindOrThrow = function (kind) {\r\n        return errors.throwIfNullOrUndefined(this.getFirstDescendantByKind(kind), \"A descendant of kind \" + utils_1.getSyntaxKindName(kind) + \" was expected to be found.\");\r\n    };\r\n    /**\r\n     * Gets the first descendant by syntax kind.\r\n     * @param kind - Syntax kind.\r\n     */\r\n    Node.prototype.getFirstDescendantByKind = function (kind) {\r\n        var e_17, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getCompilerDescendantsIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var descendant = _c.value;\r\n                if (descendant.kind === kind)\r\n                    return this.getNodeFromCompilerNode(descendant);\r\n            }\r\n        }\r\n        catch (e_17_1) { e_17 = { error: e_17_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_17) throw e_17.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the compiler children of the node.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerChildren = function () {\r\n        return this.compilerNode.getChildren(this.sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the node's descendant compiler nodes as an iterator.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerDescendantsIterator = function () {\r\n        var compilerSourceFile = this.sourceFile.compilerNode;\r\n        return getDescendantsIterator(this.compilerNode);\r\n        function getDescendantsIterator(node) {\r\n            var e_18, _a, _b, _c, child, e_18_1;\r\n            return tslib_1.__generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        _d.trys.push([0, 6, 7, 8]);\r\n                        _b = tslib_1.__values(node.getChildren(compilerSourceFile)), _c = _b.next();\r\n                        _d.label = 1;\r\n                    case 1:\r\n                        if (!!_c.done) return [3 /*break*/, 5];\r\n                        child = _c.value;\r\n                        return [4 /*yield*/, child];\r\n                    case 2:\r\n                        _d.sent();\r\n                        return [5 /*yield**/, tslib_1.__values(getDescendantsIterator(child))];\r\n                    case 3:\r\n                        _d.sent();\r\n                        _d.label = 4;\r\n                    case 4:\r\n                        _c = _b.next();\r\n                        return [3 /*break*/, 1];\r\n                    case 5: return [3 /*break*/, 8];\r\n                    case 6:\r\n                        e_18_1 = _d.sent();\r\n                        e_18 = { error: e_18_1 };\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        try {\r\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                        }\r\n                        finally { if (e_18) throw e_18.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Gets the first compiler node child that matches the condition.\r\n     * @param condition - Condition.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerFirstChild = function (condition) {\r\n        var e_19, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                if (condition == null || condition(child))\r\n                    return child;\r\n            }\r\n        }\r\n        catch (e_19_1) { e_19 = { error: e_19_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_19) throw e_19.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the last compiler node child that matches the condition.\r\n     * @param condition - Condition.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerLastChild = function (condition) {\r\n        var children = this.getCompilerChildren();\r\n        for (var i = children.length - 1; i >= 0; i--) {\r\n            var child = children[i];\r\n            if (condition == null || condition(child))\r\n                return child;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the previous compiler siblings.\r\n     *\r\n     * Note: Closest sibling is the zero index.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerPreviousSiblings = function () {\r\n        var e_20, _a;\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var previousSiblings = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(parent.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                if (child === this.compilerNode)\r\n                    break;\r\n                previousSiblings.unshift(child);\r\n            }\r\n        }\r\n        catch (e_20_1) { e_20 = { error: e_20_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_20) throw e_20.error; }\r\n        }\r\n        return previousSiblings;\r\n    };\r\n    /**\r\n     * Gets the next compiler siblings.\r\n     *\r\n     * Note: Closest sibling is the zero index.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerNextSiblings = function () {\r\n        var e_21, _a;\r\n        var foundChild = false;\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var nextSiblings = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(parent.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                if (!foundChild) {\r\n                    foundChild = child === this.compilerNode;\r\n                    continue;\r\n                }\r\n                nextSiblings.push(child);\r\n            }\r\n        }\r\n        catch (e_21_1) { e_21 = { error: e_21_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_21) throw e_21.error; }\r\n        }\r\n        return nextSiblings;\r\n    };\r\n    /**\r\n     * Gets the previous compiler sibling.\r\n     * @param condition - Optional condition for getting the previous sibling.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerPreviousSibling = function (condition) {\r\n        var e_22, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getCompilerPreviousSiblings()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var sibling = _c.value;\r\n                if (condition == null || condition(sibling))\r\n                    return sibling;\r\n            }\r\n        }\r\n        catch (e_22_1) { e_22 = { error: e_22_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_22) throw e_22.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the next compiler sibling.\r\n     * @param condition - Optional condition for getting the previous sibling.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerNextSibling = function (condition) {\r\n        var e_23, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getCompilerNextSiblings()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var sibling = _c.value;\r\n                if (condition == null || condition(sibling))\r\n                    return sibling;\r\n            }\r\n        }\r\n        catch (e_23_1) { e_23 = { error: e_23_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_23) throw e_23.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Gets the compiler child at the specified index.\r\n     * @param index - Index.\r\n     * @internal\r\n     */\r\n    Node.prototype.getCompilerChildAtIndex = function (index) {\r\n        var children = this.getCompilerChildren();\r\n        errors.throwIfOutOfRange(index, [0, children.length - 1], \"index\");\r\n        return children[index];\r\n    };\r\n    /**\r\n     * Gets a writer with the indentation text.\r\n     * @internal\r\n     */\r\n    Node.prototype.getWriterWithIndentation = function () {\r\n        var writer = this.getWriter();\r\n        writer.setIndentationLevel(this.getIndentationLevel());\r\n        return writer;\r\n    };\r\n    /**\r\n     * Gets a writer with the queued indentation text.\r\n     * @internal\r\n     */\r\n    Node.prototype.getWriterWithQueuedIndentation = function () {\r\n        var writer = this.getWriter();\r\n        writer.queueIndentationLevel(this.getIndentationLevel());\r\n        return writer;\r\n    };\r\n    /**\r\n     * Gets a writer with the child indentation text.\r\n     * @internal\r\n     */\r\n    Node.prototype.getWriterWithChildIndentation = function () {\r\n        var writer = this.getWriter();\r\n        writer.setIndentationLevel(this.getChildIndentationLevel());\r\n        return writer;\r\n    };\r\n    /**\r\n     * Gets a writer with the queued child indentation text.\r\n     * @internal\r\n     */\r\n    Node.prototype.getWriterWithQueuedChildIndentation = function () {\r\n        var writer = this.getWriter();\r\n        writer.queueIndentationLevel(this.getChildIndentationLevel());\r\n        return writer;\r\n    };\r\n    /**\r\n     * Gets a writer with no child indentation text.\r\n     * @internal\r\n     */\r\n    Node.prototype.getWriter = function () {\r\n        return this.context.createWriter();\r\n    };\r\n    /**\r\n     * Gets or creates a node from the internal cache.\r\n     * @internal\r\n     */\r\n    Node.prototype.getNodeFromCompilerNode = function (compilerNode) {\r\n        return this.context.compilerFactory.getNodeFromCompilerNode(compilerNode, this.sourceFile);\r\n    };\r\n    /**\r\n     * Gets or creates a node from the internal cache, if it exists.\r\n     * @internal\r\n     */\r\n    Node.prototype.getNodeFromCompilerNodeIfExists = function (compilerNode) {\r\n        return compilerNode == null ? undefined : this.getNodeFromCompilerNode(compilerNode);\r\n    };\r\n    /**\r\n     * Ensures that the binder has bound the node before.\r\n     * @internal\r\n     */\r\n    Node.prototype.ensureBound = function () {\r\n        if (this.compilerNode.symbol != null)\r\n            return;\r\n        this.getSymbol(); // binds the node\r\n    };\r\n    return Node;\r\n}());\r\nexports.Node = Node;\r\nfunction getWrappedCondition(thisNode, condition) {\r\n    return condition == null ? undefined : (function (c) { return condition(thisNode.getNodeFromCompilerNode(c)); });\r\n}\r\nfunction insertWhiteSpaceTextAtPos(node, insertPos, textOrWriterFunction, methodName) {\r\n    var parent = utils_1.TypeGuards.isSourceFile(node) ? node.getChildSyntaxListOrThrow() : node.getParentSyntaxList() || node.getParentOrThrow();\r\n    var newText = utils_1.getTextFromStringOrWriter(node.getWriterWithQueuedIndentation(), textOrWriterFunction);\r\n    if (!/^[\\s\\r\\n]*$/.test(newText))\r\n        throw new errors.InvalidOperationError(\"Cannot insert non-whitespace into \" + methodName + \".\");\r\n    manipulation_1.insertIntoParentTextRange({\r\n        parent: parent,\r\n        insertPos: insertPos,\r\n        newText: newText\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/Node.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/QualifiedName.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/QualifiedName.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Node_1 = __webpack_require__(/*! ./Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\");\r\nvar QualifiedName = /** @class */ (function (_super) {\r\n    tslib_1.__extends(QualifiedName, _super);\r\n    function QualifiedName() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the left side of the qualified name.\r\n     */\r\n    QualifiedName.prototype.getLeft = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.left);\r\n    };\r\n    /**\r\n     * Gets the right identifier of the qualified name.\r\n     */\r\n    QualifiedName.prototype.getRight = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.right);\r\n    };\r\n    return QualifiedName;\r\n}(Node_1.Node));\r\nexports.QualifiedName = QualifiedName;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/QualifiedName.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/Scope.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/Scope.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Scope;\r\n(function (Scope) {\r\n    Scope[\"Public\"] = \"public\";\r\n    Scope[\"Protected\"] = \"protected\";\r\n    Scope[\"Private\"] = \"private\";\r\n})(Scope = exports.Scope || (exports.Scope = {}));\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/Scope.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/Signature.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/Signature.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Signature = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance of Signature.\r\n     * @internal\r\n     * @param context - Project context.\r\n     * @param signature - Compiler signature.\r\n     */\r\n    function Signature(context, signature) {\r\n        this.context = context;\r\n        this._compilerSignature = signature;\r\n    }\r\n    Object.defineProperty(Signature.prototype, \"compilerSignature\", {\r\n        /**\r\n         * Gets the underlying compiler signature.\r\n         */\r\n        get: function () {\r\n            return this._compilerSignature;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the type parameters.\r\n     */\r\n    Signature.prototype.getTypeParameters = function () {\r\n        var _this = this;\r\n        var typeParameters = this.compilerSignature.typeParameters || [];\r\n        return typeParameters.map(function (t) { return _this.context.compilerFactory.getTypeParameter(t); });\r\n    };\r\n    /**\r\n     * Gets the parameters.\r\n     */\r\n    Signature.prototype.getParameters = function () {\r\n        var _this = this;\r\n        return this.compilerSignature.parameters.map(function (p) { return _this.context.compilerFactory.getSymbol(p); });\r\n    };\r\n    /**\r\n     * Gets the signature return type.\r\n     */\r\n    Signature.prototype.getReturnType = function () {\r\n        return this.context.compilerFactory.getType(this.compilerSignature.getReturnType());\r\n    };\r\n    /**\r\n     * Get the documentation comments.\r\n     */\r\n    Signature.prototype.getDocumentationComments = function () {\r\n        var _this = this;\r\n        var docs = this.compilerSignature.getDocumentationComment(this.context.typeChecker.compilerObject);\r\n        return docs.map(function (d) { return _this.context.compilerFactory.getSymbolDisplayPart(d); });\r\n    };\r\n    /**\r\n     * Gets the JS doc tags.\r\n     */\r\n    Signature.prototype.getJsDocTags = function () {\r\n        var _this = this;\r\n        var tags = this.compilerSignature.getJsDocTags();\r\n        return tags.map(function (t) { return _this.context.compilerFactory.getJSDocTagInfo(t); });\r\n    };\r\n    return Signature;\r\n}());\r\nexports.Signature = Signature;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/Signature.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/Symbol.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/Symbol.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar Symbol = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance of Symbol.\r\n     * @internal\r\n     * @param context - Project context.\r\n     * @param symbol - Compiler symbol.\r\n     */\r\n    function Symbol(context, symbol) {\r\n        this.context = context;\r\n        this._compilerSymbol = symbol;\r\n        // wrap these immediately, but do not memoize because the underlying symbol might be mutated\r\n        this.getValueDeclaration();\r\n        this.getDeclarations();\r\n    }\r\n    Object.defineProperty(Symbol.prototype, \"compilerSymbol\", {\r\n        /**\r\n         * Gets the underlying compiler symbol.\r\n         */\r\n        get: function () {\r\n            return this._compilerSymbol;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the symbol name.\r\n     */\r\n    Symbol.prototype.getName = function () {\r\n        return this.compilerSymbol.getName();\r\n    };\r\n    /**\r\n     * Gets the escaped name.\r\n     */\r\n    Symbol.prototype.getEscapedName = function () {\r\n        return this.compilerSymbol.escapedName;\r\n    };\r\n    /**\r\n     * Gets the aliased symbol or throws if it doesn't exist.\r\n     */\r\n    Symbol.prototype.getAliasedSymbolOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getAliasedSymbol(), \"Expected to find an aliased symbol.\");\r\n    };\r\n    /**\r\n     * Gets the aliased symbol or returns undefined if it doesn't exist.\r\n     */\r\n    Symbol.prototype.getAliasedSymbol = function () {\r\n        return this.context.typeChecker.getAliasedSymbol(this);\r\n    };\r\n    /**\r\n     * Gets if the symbol is an alias.\r\n     */\r\n    Symbol.prototype.isAlias = function () {\r\n        return (this.getFlags() & typescript_1.SymbolFlags.Alias) === typescript_1.SymbolFlags.Alias;\r\n    };\r\n    /**\r\n     * Gets the symbol flags.\r\n     */\r\n    Symbol.prototype.getFlags = function () {\r\n        return this.compilerSymbol.getFlags();\r\n    };\r\n    /**\r\n     * Gets if the symbol has the specified flags.\r\n     * @param flags - Flags to check if the symbol has.\r\n     */\r\n    Symbol.prototype.hasFlags = function (flags) {\r\n        return (this.compilerSymbol.flags & flags) === flags;\r\n    };\r\n    /**\r\n     * Gets the value declaration of a symbol or throws if it doesn't exist.\r\n     */\r\n    Symbol.prototype.getValueDeclarationOrThrow = function () {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getValueDeclaration(), function () { return \"Expected to find the value declaration of symbol '\" + _this.getName() + \"'.\"; });\r\n    };\r\n    /**\r\n     * Gets the value declaration of the symbol or returns undefined if it doesn't exist.\r\n     */\r\n    Symbol.prototype.getValueDeclaration = function () {\r\n        var declaration = this.compilerSymbol.valueDeclaration;\r\n        if (declaration == null)\r\n            return undefined;\r\n        return this.context.compilerFactory.getNodeFromCompilerNode(declaration, this.context.compilerFactory.getSourceFileForNode(declaration));\r\n    };\r\n    /**\r\n     * Gets the symbol declarations.\r\n     */\r\n    Symbol.prototype.getDeclarations = function () {\r\n        var _this = this;\r\n        return (this.compilerSymbol.declarations || []).map(function (d) {\r\n            return _this.context.compilerFactory.getNodeFromCompilerNode(d, _this.context.compilerFactory.getSourceFileForNode(d));\r\n        });\r\n    };\r\n    /**\r\n     * Gets the export of the symbol by the specified name or throws if not exists.\r\n     * @param name - Name of the export.\r\n     */\r\n    Symbol.prototype.getExportByNameOrThrow = function (name) {\r\n        return errors.throwIfNullOrUndefined(this.getExportByName(name), \"Expected to find export with name: \" + name);\r\n    };\r\n    /**\r\n     * Gets the export of the symbol by the specified name or returns undefined if not exists.\r\n     * @param name - Name of the export.\r\n     */\r\n    Symbol.prototype.getExportByName = function (name) {\r\n        if (this.compilerSymbol.exports == null)\r\n            return undefined;\r\n        var tsSymbol = this.compilerSymbol.exports.get(name);\r\n        return tsSymbol == null ? undefined : this.context.compilerFactory.getSymbol(tsSymbol);\r\n    };\r\n    /**\r\n     * Gets the exports from the symbol.\r\n     */\r\n    Symbol.prototype.getExports = function () {\r\n        var _this = this;\r\n        if (this.compilerSymbol.exports == null)\r\n            return [];\r\n        return utils_1.ArrayUtils.from(this.compilerSymbol.exports.values()).map(function (symbol) { return _this.context.compilerFactory.getSymbol(symbol); });\r\n    };\r\n    /**\r\n     * Gets the member of the symbol by the specified name or throws if not exists.\r\n     * @param name - Name of the export.\r\n     */\r\n    Symbol.prototype.getMemberByNameOrThrow = function (name) {\r\n        return errors.throwIfNullOrUndefined(this.getMemberByName(name), \"Expected to find member with name: \" + name);\r\n    };\r\n    /**\r\n     * Gets the member of the symbol by the specified name or returns undefined if not exists.\r\n     * @param name - Name of the member.\r\n     */\r\n    Symbol.prototype.getMemberByName = function (name) {\r\n        if (this.compilerSymbol.members == null)\r\n            return undefined;\r\n        var tsSymbol = this.compilerSymbol.members.get(name);\r\n        return tsSymbol == null ? undefined : this.context.compilerFactory.getSymbol(tsSymbol);\r\n    };\r\n    /**\r\n     * Gets the members of the symbol\r\n     */\r\n    Symbol.prototype.getMembers = function () {\r\n        var _this = this;\r\n        if (this.compilerSymbol.members == null)\r\n            return [];\r\n        return utils_1.ArrayUtils.from(this.compilerSymbol.members.values()).map(function (symbol) { return _this.context.compilerFactory.getSymbol(symbol); });\r\n    };\r\n    /**\r\n     * Gets the declared type of the symbol.\r\n     */\r\n    Symbol.prototype.getDeclaredType = function () {\r\n        return this.context.typeChecker.getDeclaredTypeOfSymbol(this);\r\n    };\r\n    /**\r\n     * Gets the type of the symbol at a location.\r\n     * @param node - Location to get the type at for this symbol.\r\n     */\r\n    Symbol.prototype.getTypeAtLocation = function (node) {\r\n        return this.context.typeChecker.getTypeOfSymbolAtLocation(this, node);\r\n    };\r\n    /**\r\n     * Gets the fully qualified name.\r\n     */\r\n    Symbol.prototype.getFullyQualifiedName = function () {\r\n        return this.context.typeChecker.getFullyQualifiedName(this);\r\n    };\r\n    return Symbol;\r\n}());\r\nexports.Symbol = Symbol;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/Symbol.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/SyntaxList.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/SyntaxList.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar Node_1 = __webpack_require__(/*! ./Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\");\r\nvar SyntaxList = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SyntaxList, _super);\r\n    function SyntaxList() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Adds text at the end of the current children.\r\n     * @param textOrWriterFunction - Text to add or function that provides a writer to write with.\r\n     * @returns The children that were added.\r\n     */\r\n    SyntaxList.prototype.addChildText = function (textOrWriterFunction) {\r\n        return this.insertChildText(this.getChildCount(), textOrWriterFunction);\r\n    };\r\n    /**\r\n     * Inserts text at the specified child index.\r\n     * @param index - Child index to insert at.\r\n     * @param textOrWriterFunction - Text to insert or function that provides a writer to write with.\r\n     * @returns The children that were inserted.\r\n     */\r\n    SyntaxList.prototype.insertChildText = function (index, textOrWriterFunction) {\r\n        // get index\r\n        var initialChildCount = this.getChildCount();\r\n        var newLineKind = this.context.manipulationSettings.getNewLineKindAsString();\r\n        var parent = this.getParentOrThrow();\r\n        index = manipulation_1.verifyAndGetIndex(index, initialChildCount);\r\n        // get text\r\n        var isInline = this !== parent.getChildSyntaxList();\r\n        var insertText = utils_1.getTextFromStringOrWriter(isInline ? parent.getWriterWithQueuedChildIndentation() : parent.getWriterWithChildIndentation(), textOrWriterFunction);\r\n        if (insertText.length === 0)\r\n            return [];\r\n        if (isInline) {\r\n            if (index === 0)\r\n                insertText += \" \";\r\n            else\r\n                insertText = \" \" + insertText;\r\n        }\r\n        else {\r\n            if (index === 0 && utils_1.TypeGuards.isSourceFile(parent)) {\r\n                if (!utils_1.StringUtils.endsWith(insertText, newLineKind))\r\n                    insertText += newLineKind;\r\n            }\r\n            else\r\n                insertText = newLineKind + insertText;\r\n        }\r\n        // insert\r\n        var insertPos = manipulation_1.getInsertPosFromIndex(index, this, this.getChildren());\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: insertPos,\r\n            newText: insertText,\r\n            parent: this\r\n        });\r\n        // get inserted children\r\n        var finalChildren = this.getChildren();\r\n        return manipulation_1.getNodesToReturn(finalChildren, index, finalChildren.length - initialChildCount);\r\n    };\r\n    return SyntaxList;\r\n}(Node_1.Node));\r\nexports.SyntaxList = SyntaxList;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/SyntaxList.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/common/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/common/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CommentRange */ \"./node_modules/ts-simple-ast/dist/compiler/common/CommentRange.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ComputedPropertyName */ \"./node_modules/ts-simple-ast/dist/compiler/common/ComputedPropertyName.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Identifier */ \"./node_modules/ts-simple-ast/dist/compiler/common/Identifier.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./QualifiedName */ \"./node_modules/ts-simple-ast/dist/compiler/common/QualifiedName.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Scope */ \"./node_modules/ts-simple-ast/dist/compiler/common/Scope.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Signature */ \"./node_modules/ts-simple-ast/dist/compiler/common/Signature.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Symbol */ \"./node_modules/ts-simple-ast/dist/compiler/common/Symbol.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SyntaxList */ \"./node_modules/ts-simple-ast/dist/compiler/common/SyntaxList.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/common/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/decorator/Decorator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/decorator/Decorator.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.DecoratorBase = common_1.Node;\r\nvar Decorator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Decorator, _super);\r\n    function Decorator() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the decorator name.\r\n     */\r\n    Decorator.prototype.getName = function () {\r\n        return this.getNameNode().getText();\r\n    };\r\n    /**\r\n     * Gets the name node of the decorator.\r\n     */\r\n    Decorator.prototype.getNameNode = function () {\r\n        var sourceFile = this.getSourceFile();\r\n        if (this.isDecoratorFactory()) {\r\n            var callExpression = this.getCallExpression();\r\n            return getIdentifierFromName(callExpression.getExpression());\r\n        }\r\n        return getIdentifierFromName(this.getExpression());\r\n        function getIdentifierFromName(expression) {\r\n            var identifier = getNameFromExpression(expression);\r\n            if (!utils_1.TypeGuards.isIdentifier(identifier)) {\r\n                throw new errors.NotImplementedError(\"Expected the decorator expression '\" + identifier.getText() + \"' to be an identifier, \" +\r\n                    \"but it wasn't. Please report this as a bug.\");\r\n            }\r\n            return identifier;\r\n        }\r\n        function getNameFromExpression(expression) {\r\n            if (utils_1.TypeGuards.isPropertyAccessExpression(expression))\r\n                return expression.getNameNode();\r\n            return expression;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the full decorator name.\r\n     */\r\n    Decorator.prototype.getFullName = function () {\r\n        var sourceFile = this.getSourceFile();\r\n        if (this.isDecoratorFactory())\r\n            return this.getCallExpression().getExpression().getText();\r\n        return this.compilerNode.expression.getText(sourceFile.compilerNode);\r\n    };\r\n    /**\r\n     * Gets if the decorator is a decorator factory.\r\n     */\r\n    Decorator.prototype.isDecoratorFactory = function () {\r\n        return this.compilerNode.expression.kind === typescript_1.SyntaxKind.CallExpression;\r\n    };\r\n    /**\r\n     * Set if this decorator is a decorator factory.\r\n     * @param isDecoratorFactory - If it should be a decorator factory or not.\r\n     */\r\n    Decorator.prototype.setIsDecoratorFactory = function (isDecoratorFactory) {\r\n        if (this.isDecoratorFactory() === isDecoratorFactory)\r\n            return this;\r\n        if (isDecoratorFactory) {\r\n            var expression_1 = this.getExpression();\r\n            var expressionText = expression_1.getText();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: expression_1.getStart(),\r\n                newText: expressionText + \"()\",\r\n                replacing: {\r\n                    textLength: expressionText.length\r\n                },\r\n                customMappings: function (newParent) {\r\n                    // the expression will move into the call expression\r\n                    return [{ currentNode: expression_1, newNode: newParent.expression.expression }];\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            var callExpression = this.getCallExpressionOrThrow();\r\n            var expression_2 = callExpression.getExpression();\r\n            var expressionText = expression_2.getText();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                parent: this,\r\n                insertPos: callExpression.getStart(),\r\n                newText: \"\" + expressionText,\r\n                replacing: {\r\n                    textLength: callExpression.getWidth()\r\n                },\r\n                customMappings: function (newParent) {\r\n                    // the expression will move out of the call expression\r\n                    return [{ currentNode: expression_2, newNode: newParent.expression }];\r\n                }\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the call expression if a decorator factory, or throws.\r\n     */\r\n    Decorator.prototype.getCallExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getCallExpression(), \"Expected to find a call expression.\");\r\n    };\r\n    /**\r\n     * Gets the call expression if a decorator factory.\r\n     */\r\n    Decorator.prototype.getCallExpression = function () {\r\n        if (!this.isDecoratorFactory())\r\n            return undefined;\r\n        return this.getExpression();\r\n    };\r\n    /**\r\n     * Gets the expression.\r\n     */\r\n    Decorator.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets the decorator's arguments from its call expression.\r\n     */\r\n    Decorator.prototype.getArguments = function () {\r\n        var callExpression = this.getCallExpression();\r\n        return callExpression == null ? [] : callExpression.getArguments();\r\n    };\r\n    /**\r\n     * Gets the decorator's type arguments from its call expression.\r\n     */\r\n    Decorator.prototype.getTypeArguments = function () {\r\n        var callExpression = this.getCallExpression();\r\n        return callExpression == null ? [] : callExpression.getTypeArguments();\r\n    };\r\n    /**\r\n     * Adds a type argument.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    Decorator.prototype.addTypeArgument = function (argumentText) {\r\n        return this.getCallExpressionOrThrow().addTypeArgument(argumentText);\r\n    };\r\n    /**\r\n     * Adds type arguments.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    Decorator.prototype.addTypeArguments = function (argumentTexts) {\r\n        return this.getCallExpressionOrThrow().addTypeArguments(argumentTexts);\r\n    };\r\n    /**\r\n     * Inserts a type argument.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    Decorator.prototype.insertTypeArgument = function (index, argumentText) {\r\n        return this.getCallExpressionOrThrow().insertTypeArgument(index, argumentText);\r\n    };\r\n    /**\r\n     * Inserts type arguments.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    Decorator.prototype.insertTypeArguments = function (index, argumentTexts) {\r\n        return this.getCallExpressionOrThrow().insertTypeArguments(index, argumentTexts);\r\n    };\r\n    Decorator.prototype.removeTypeArgument = function (typeArgOrIndex) {\r\n        var callExpression = this.getCallExpression();\r\n        if (callExpression == null)\r\n            throw new errors.InvalidOperationError(\"Cannot remove a type argument from a decorator that has no type arguments.\");\r\n        callExpression.removeTypeArgument(typeArgOrIndex);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds an argument.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    Decorator.prototype.addArgument = function (argumentText) {\r\n        return this.addArguments([argumentText])[0];\r\n    };\r\n    /**\r\n     * Adds arguments.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    Decorator.prototype.addArguments = function (argumentTexts) {\r\n        return this.insertArguments(this.getArguments().length, argumentTexts);\r\n    };\r\n    /**\r\n     * Inserts an argument.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument text.\r\n     */\r\n    Decorator.prototype.insertArgument = function (index, argumentText) {\r\n        return this.insertArguments(index, [argumentText])[0];\r\n    };\r\n    /**\r\n     * Inserts arguments.\r\n     * @param index - Child index to insert at.\r\n     * @param argumentTexts - Argument texts.\r\n     */\r\n    Decorator.prototype.insertArguments = function (index, argumentTexts) {\r\n        this.setIsDecoratorFactory(true);\r\n        return this.getCallExpressionOrThrow().insertArguments(index, argumentTexts);\r\n    };\r\n    Decorator.prototype.removeArgument = function (argOrIndex) {\r\n        var callExpression = this.getCallExpression();\r\n        if (callExpression == null)\r\n            throw new errors.InvalidOperationError(\"Cannot remove an argument from a decorator that has no arguments.\");\r\n        callExpression.removeArgument(argOrIndex);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this decorator.\r\n     */\r\n    Decorator.prototype.remove = function () {\r\n        var thisStartLinePos = this.getStartLinePos();\r\n        var previousDecorator = this.getPreviousSiblingIfKind(typescript_1.SyntaxKind.Decorator);\r\n        if (previousDecorator != null && previousDecorator.getStartLinePos() === thisStartLinePos) {\r\n            manipulation_1.removeChildren({\r\n                children: [this],\r\n                removePrecedingSpaces: true\r\n            });\r\n        }\r\n        else\r\n            manipulation_1.removeChildrenWithFormattingFromCollapsibleSyntaxList({\r\n                children: [this],\r\n                getSiblingFormatting: function (parent, sibling) { return sibling.getStartLinePos() === thisStartLinePos ? manipulation_1.FormattingKind.Space : manipulation_1.FormattingKind.Newline; }\r\n            });\r\n    };\r\n    return Decorator;\r\n}(exports.DecoratorBase));\r\nexports.Decorator = Decorator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/decorator/Decorator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/decorator/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/decorator/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Decorator */ \"./node_modules/ts-simple-ast/dist/compiler/decorator/Decorator.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/decorator/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDoc.js":
/*!***************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDoc.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar textSeek_1 = __webpack_require__(/*! ../../manipulation/textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\n/**\r\n * JS doc node.\r\n */\r\nvar JSDoc = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDoc, _super);\r\n    function JSDoc() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the tags of the JSDoc.\r\n     */\r\n    JSDoc.prototype.getTags = function () {\r\n        var _this = this;\r\n        var tags = this.compilerNode.tags;\r\n        if (tags == null)\r\n            return [];\r\n        return tags.map(function (t) { return _this.getNodeFromCompilerNode(t); });\r\n    };\r\n    /**\r\n     * Gets the comment.\r\n     */\r\n    JSDoc.prototype.getComment = function () {\r\n        return this.compilerNode.comment;\r\n    };\r\n    /**\r\n     * Gets the JSDoc's text without the surrounding comment.\r\n     */\r\n    JSDoc.prototype.getInnerText = function () {\r\n        var innerTextWithStars = this.getText().replace(/^\\/\\*\\*[^\\S\\n]*\\n?/, \"\").replace(/(\\r?\\n)?[^\\S\\n]*\\*\\/$/, \"\");\r\n        return innerTextWithStars.split(/\\n/).map(function (line) {\r\n            var starPos = line.indexOf(\"*\");\r\n            if (starPos === -1)\r\n                return line;\r\n            var substringStart = line[starPos + 1] === \" \" ? starPos + 2 : starPos + 1;\r\n            return line.substring(substringStart);\r\n        }).join(\"\\n\");\r\n    };\r\n    JSDoc.prototype.setComment = function (textOrWriterFunction) {\r\n        var tags = this.getTags();\r\n        var startEditPos = this.getStart() + 3;\r\n        var endEditPos = tags.length > 0 ? textSeek_1.getPreviousMatchingPos(this.sourceFile.getFullText(), tags[0].getStart(), function (c) { return c === \"*\"; }) - 1 : this.getEnd() - 2;\r\n        var indentationText = this.getIndentationText();\r\n        var newLineKind = this.context.manipulationSettings.getNewLineKindAsString();\r\n        var text = utils_1.getTextFromStringOrWriter(this.getWriter(), textOrWriterFunction);\r\n        var newText = newLineKind + text.split(/\\r?\\n/).map(function (l) { return indentationText + \" * \" + l; }).join(newLineKind) + newLineKind + indentationText + \" \";\r\n        manipulation_1.replaceTextPossiblyCreatingChildNodes({\r\n            parent: this,\r\n            newText: newText,\r\n            replacePos: startEditPos,\r\n            replacingLength: endEditPos - startEditPos\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this JSDoc.\r\n     */\r\n    JSDoc.prototype.remove = function () {\r\n        manipulation_1.removeChildren({\r\n            children: [this],\r\n            removeFollowingSpaces: true,\r\n            removeFollowingNewLines: true\r\n        });\r\n    };\r\n    return JSDoc;\r\n}(common_1.Node));\r\nexports.JSDoc = JSDoc;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDoc.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocAugmentsTag.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocAugmentsTag.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\n/**\r\n * JS doc augments tag node.\r\n */\r\nvar JSDocAugmentsTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocAugmentsTag, _super);\r\n    function JSDocAugmentsTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocAugmentsTag;\r\n}(JSDocTag_1.JSDocTag));\r\nexports.JSDocAugmentsTag = JSDocAugmentsTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocAugmentsTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocClassTag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocClassTag.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\n/**\r\n * JS doc class tag node.\r\n */\r\nvar JSDocClassTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocClassTag, _super);\r\n    function JSDocClassTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocClassTag;\r\n}(JSDocTag_1.JSDocTag));\r\nexports.JSDocClassTag = JSDocClassTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocClassTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocParameterTag.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocParameterTag.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/doc/base/index.js\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\nexports.JSDocParameterTagBase = base_1.JSDocPropertyLikeTag(JSDocTag_1.JSDocTag);\r\n/**\r\n * JS doc parameter tag node.\r\n */\r\nvar JSDocParameterTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocParameterTag, _super);\r\n    function JSDocParameterTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocParameterTag;\r\n}(exports.JSDocParameterTagBase));\r\nexports.JSDocParameterTag = JSDocParameterTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocParameterTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocPropertyTag.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocPropertyTag.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/doc/base/index.js\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\nexports.JSDocPropertyTagBase = base_1.JSDocPropertyLikeTag(JSDocTag_1.JSDocTag);\r\n/**\r\n * JS doc property tag node.\r\n */\r\nvar JSDocPropertyTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocPropertyTag, _super);\r\n    function JSDocPropertyTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocPropertyTag;\r\n}(exports.JSDocPropertyTagBase));\r\nexports.JSDocPropertyTag = JSDocPropertyTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocPropertyTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocReturnTag.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocReturnTag.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\n/**\r\n * JS doc return tag node.\r\n */\r\nvar JSDocReturnTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocReturnTag, _super);\r\n    function JSDocReturnTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocReturnTag;\r\n}(JSDocTag_1.JSDocTag));\r\nexports.JSDocReturnTag = JSDocReturnTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocReturnTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\n/**\r\n * JS doc tag node.\r\n */\r\nvar JSDocTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocTag, _super);\r\n    function JSDocTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the at token.\r\n     */\r\n    JSDocTag.prototype.getAtToken = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.atToken);\r\n    };\r\n    /**\r\n     * Gets the tag's name as a string.\r\n     */\r\n    JSDocTag.prototype.getName = function () {\r\n        return this.getTagNameNode().getText();\r\n    };\r\n    /**\r\n     * Gets the tag name node.\r\n     */\r\n    JSDocTag.prototype.getTagNameNode = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.tagName);\r\n    };\r\n    /**\r\n     * Gets the tag's comment.\r\n     */\r\n    JSDocTag.prototype.getComment = function () {\r\n        return this.compilerNode.comment;\r\n    };\r\n    return JSDocTag;\r\n}(common_1.Node));\r\nexports.JSDocTag = JSDocTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTagInfo.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTagInfo.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * JS doc tag info.\r\n */\r\nvar JSDocTagInfo = /** @class */ (function () {\r\n    /** @internal */\r\n    function JSDocTagInfo(compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(JSDocTagInfo.prototype, \"compilerObject\", {\r\n        /** Gets the compiler JS doc tag info. */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the name.\r\n     */\r\n    JSDocTagInfo.prototype.getName = function () {\r\n        return this.compilerObject.name;\r\n    };\r\n    /**\r\n     * Gets the text.\r\n     */\r\n    JSDocTagInfo.prototype.getText = function () {\r\n        return this.compilerObject.text;\r\n    };\r\n    return JSDocTagInfo;\r\n}());\r\nexports.JSDocTagInfo = JSDocTagInfo;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTagInfo.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypeTag.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypeTag.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\n/**\r\n * JS doc type tag node.\r\n */\r\nvar JSDocTypeTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocTypeTag, _super);\r\n    function JSDocTypeTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocTypeTag;\r\n}(JSDocTag_1.JSDocTag));\r\nexports.JSDocTypeTag = JSDocTypeTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypeTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypedefTag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypedefTag.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\n/**\r\n * JS doc type def tag node.\r\n */\r\nvar JSDocTypedefTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocTypedefTag, _super);\r\n    function JSDocTypedefTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocTypedefTag;\r\n}(JSDocTag_1.JSDocTag));\r\nexports.JSDocTypedefTag = JSDocTypedefTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypedefTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/JSDocUnknownTag.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/JSDocUnknownTag.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar JSDocTag_1 = __webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\");\r\n/**\r\n * JS doc unknown tag node.\r\n */\r\nvar JSDocUnknownTag = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocUnknownTag, _super);\r\n    function JSDocUnknownTag() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JSDocUnknownTag;\r\n}(JSDocTag_1.JSDocTag));\r\nexports.JSDocUnknownTag = JSDocUnknownTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/JSDocUnknownTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/base/JSDocPropertyLikeTag.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/base/JSDocPropertyLikeTag.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction JSDocPropertyLikeTag(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.JSDocPropertyLikeTag = JSDocPropertyLikeTag;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/base/JSDocPropertyLikeTag.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/base/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/base/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocPropertyLikeTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/base/JSDocPropertyLikeTag.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/base/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/doc/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/doc/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/doc/base/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDoc */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDoc.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocAugmentsTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocAugmentsTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocClassTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocClassTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocParameterTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocParameterTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocPropertyTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocPropertyTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocReturnTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocReturnTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocTagInfo */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTagInfo.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocTypedefTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypedefTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocTypeTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocTypeTag.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocUnknownTag */ \"./node_modules/ts-simple-ast/dist/compiler/doc/JSDocUnknownTag.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/doc/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/enum/EnumDeclaration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/enum/EnumDeclaration.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar namespace_1 = __webpack_require__(/*! ../namespace */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nexports.EnumDeclarationBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(namespace_1.NamespaceChildableNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement))))))));\r\nvar EnumDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EnumDeclaration, _super);\r\n    function EnumDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    EnumDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.EnumDeclarationBase.prototype, this, structure);\r\n        if (structure.isConst != null)\r\n            this.setIsConstEnum(structure.isConst);\r\n        if (structure.members != null && structure.members.length > 0)\r\n            this.addMembers(structure.members);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a member to the enum.\r\n     * @param structure - Structure of the enum.\r\n     */\r\n    EnumDeclaration.prototype.addMember = function (structure) {\r\n        return this.addMembers([structure])[0];\r\n    };\r\n    /**\r\n     * Adds members to the enum.\r\n     * @param structures - Structures of the enums.\r\n     */\r\n    EnumDeclaration.prototype.addMembers = function (structures) {\r\n        return this.insertMembers(this.getMembers().length, structures);\r\n    };\r\n    /**\r\n     * Inserts a member to the enum.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the enum.\r\n     */\r\n    EnumDeclaration.prototype.insertMember = function (index, structure) {\r\n        return this.insertMembers(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts members to an enum.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures of the enums.\r\n     */\r\n    EnumDeclaration.prototype.insertMembers = function (index, structures) {\r\n        var members = this.getMembers();\r\n        index = manipulation_1.verifyAndGetIndex(index, members.length);\r\n        if (structures.length === 0)\r\n            return [];\r\n        // create member code\r\n        // todo: pass in the StructureToText to the function below\r\n        var writer = this.getWriterWithChildIndentation();\r\n        var structurePrinter = this.context.structurePrinterFactory.forEnumMember();\r\n        structurePrinter.printTexts(writer, structures);\r\n        // insert\r\n        manipulation_1.insertIntoCommaSeparatedNodes({\r\n            parent: this.getChildSyntaxListOrThrow(),\r\n            currentNodes: members,\r\n            insertIndex: index,\r\n            newText: writer.toString(),\r\n            useNewLines: true\r\n        });\r\n        // get the members\r\n        return manipulation_1.getNodesToReturn(this.getMembers(), index, structures.length);\r\n    };\r\n    EnumDeclaration.prototype.getMember = function (nameOrFindFunction) {\r\n        return utils_1.getNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);\r\n    };\r\n    EnumDeclaration.prototype.getMemberOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"enum member\", nameOrFindFunction); });\r\n    };\r\n    /**\r\n     * Gets the enum's members.\r\n     */\r\n    EnumDeclaration.prototype.getMembers = function () {\r\n        var _this = this;\r\n        return this.compilerNode.members.map(function (m) { return _this.getNodeFromCompilerNode(m); });\r\n    };\r\n    /**\r\n     * Toggle if it's a const enum\r\n     */\r\n    EnumDeclaration.prototype.setIsConstEnum = function (value) {\r\n        return this.toggleModifier(\"const\", value);\r\n    };\r\n    /**\r\n     * Gets if it's a const enum.\r\n     */\r\n    EnumDeclaration.prototype.isConstEnum = function () {\r\n        return this.getConstKeyword() != null;\r\n    };\r\n    /**\r\n     * Gets the const enum keyword or undefined if not exists.\r\n     */\r\n    EnumDeclaration.prototype.getConstKeyword = function () {\r\n        return this.getFirstModifierByKind(typescript_1.SyntaxKind.ConstKeyword);\r\n    };\r\n    return EnumDeclaration;\r\n}(exports.EnumDeclarationBase));\r\nexports.EnumDeclaration = EnumDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/enum/EnumDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/enum/EnumMember.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/enum/EnumMember.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.EnumMemberBase = base_1.JSDocableNode(base_1.InitializerExpressionableNode(base_1.PropertyNamedNode(common_1.Node)));\r\nvar EnumMember = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EnumMember, _super);\r\n    function EnumMember() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    EnumMember.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.EnumMemberBase.prototype, this, structure);\r\n        if (structure.value != null)\r\n            this.setValue(structure.value);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the constant value of the enum.\r\n     */\r\n    EnumMember.prototype.getValue = function () {\r\n        return this.context.typeChecker.getConstantValue(this);\r\n    };\r\n    /**\r\n     * Sets the enum value.\r\n     * @param value - Enum value.\r\n     */\r\n    EnumMember.prototype.setValue = function (value) {\r\n        var text;\r\n        if (typeof value === \"string\") {\r\n            var quoteKind = this.context.manipulationSettings.getQuoteKind();\r\n            text = quoteKind + utils_1.StringUtils.escapeForWithinString(value, quoteKind) + quoteKind;\r\n        }\r\n        else {\r\n            text = value.toString();\r\n        }\r\n        this.setInitializer(text);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this enum member.\r\n     */\r\n    EnumMember.prototype.remove = function () {\r\n        var childrenToRemove = [this];\r\n        var commaToken = this.getNextSiblingIfKind(typescript_1.SyntaxKind.CommaToken);\r\n        if (commaToken != null)\r\n            childrenToRemove.push(commaToken);\r\n        manipulation_1.removeChildrenWithFormatting({\r\n            children: childrenToRemove,\r\n            getSiblingFormatting: function () { return manipulation_1.FormattingKind.Newline; }\r\n        });\r\n    };\r\n    return EnumMember;\r\n}(exports.EnumMemberBase));\r\nexports.EnumMember = EnumMember;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/enum/EnumMember.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/enum/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/enum/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EnumDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/enum/EnumDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EnumMember */ \"./node_modules/ts-simple-ast/dist/compiler/enum/EnumMember.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/enum/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/AsExpression.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/AsExpression.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nexports.AsExpressionBase = base_1.TypedNode(expressioned_1.ExpressionedNode(Expression_1.Expression));\r\nvar AsExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AsExpression, _super);\r\n    function AsExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return AsExpression;\r\n}(exports.AsExpressionBase));\r\nexports.AsExpression = AsExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/AsExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/AssignmentExpression.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/AssignmentExpression.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BinaryExpression_1 = __webpack_require__(/*! ./BinaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/BinaryExpression.js\");\r\nexports.AssignmentExpressionBase = BinaryExpression_1.BinaryExpression;\r\nvar AssignmentExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AssignmentExpression, _super);\r\n    function AssignmentExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the operator token of the assignment expression.\r\n     */\r\n    AssignmentExpression.prototype.getOperatorToken = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.operatorToken);\r\n    };\r\n    return AssignmentExpression;\r\n}(exports.AssignmentExpressionBase));\r\nexports.AssignmentExpression = AssignmentExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/AssignmentExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/AwaitExpression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/AwaitExpression.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.AwaitExpressionBase = expressioned_1.UnaryExpressionedNode(UnaryExpression_1.UnaryExpression);\r\nvar AwaitExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(AwaitExpression, _super);\r\n    function AwaitExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return AwaitExpression;\r\n}(exports.AwaitExpressionBase));\r\nexports.AwaitExpression = AwaitExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/AwaitExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/BinaryExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/BinaryExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nexports.BinaryExpressionBase = Expression_1.Expression;\r\nvar BinaryExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BinaryExpression, _super);\r\n    function BinaryExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the left side of the binary expression.\r\n     */\r\n    BinaryExpression.prototype.getLeft = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.left);\r\n    };\r\n    /**\r\n     * Gets the operator token of the binary expression.\r\n     */\r\n    BinaryExpression.prototype.getOperatorToken = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.operatorToken);\r\n    };\r\n    /**\r\n     * Gets the right side of the binary expression.\r\n     */\r\n    BinaryExpression.prototype.getRight = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.right);\r\n    };\r\n    return BinaryExpression;\r\n}(exports.BinaryExpressionBase));\r\nexports.BinaryExpression = BinaryExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/BinaryExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/CallExpression.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/CallExpression.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar LeftHandSideExpression_1 = __webpack_require__(/*! ./LeftHandSideExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js\");\r\nexports.CallExpressionBase = base_1.TypeArgumentedNode(base_1.ArgumentedNode(expressioned_1.LeftHandSideExpressionedNode(LeftHandSideExpression_1.LeftHandSideExpression)));\r\nvar CallExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CallExpression, _super);\r\n    function CallExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the return type of the call expression.\r\n     */\r\n    CallExpression.prototype.getReturnType = function () {\r\n        return this.context.typeChecker.getTypeAtLocation(this);\r\n    };\r\n    return CallExpression;\r\n}(exports.CallExpressionBase));\r\nexports.CallExpression = CallExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/CallExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/CommaListExpression.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/CommaListExpression.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nexports.CommaListExpressionBase = Expression_1.Expression;\r\nvar CommaListExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CommaListExpression, _super);\r\n    function CommaListExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the elements.\r\n     */\r\n    CommaListExpression.prototype.getElements = function () {\r\n        var _this = this;\r\n        return this.compilerNode.elements.map(function (e) { return _this.getNodeFromCompilerNode(e); });\r\n    };\r\n    return CommaListExpression;\r\n}(exports.CommaListExpressionBase));\r\nexports.CommaListExpression = CommaListExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/CommaListExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/ConditionalExpression.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/ConditionalExpression.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nexports.ConditionalExpressionBase = Expression_1.Expression;\r\nvar ConditionalExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConditionalExpression, _super);\r\n    function ConditionalExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the condition of the conditional expression.\r\n     */\r\n    ConditionalExpression.prototype.getCondition = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.condition);\r\n    };\r\n    /**\r\n     * Gets the question token of the conditional expression.\r\n     */\r\n    ConditionalExpression.prototype.getQuestionToken = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.questionToken);\r\n    };\r\n    /**\r\n     * Gets the when true expression of the conditional expression.\r\n     */\r\n    ConditionalExpression.prototype.getWhenTrue = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.whenTrue);\r\n    };\r\n    /**\r\n     * Gets the colon token of the conditional expression.\r\n     */\r\n    ConditionalExpression.prototype.getColonToken = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.colonToken);\r\n    };\r\n    /**\r\n     * Gets the when false expression of the conditional expression.\r\n     */\r\n    ConditionalExpression.prototype.getWhenFalse = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.whenFalse);\r\n    };\r\n    return ConditionalExpression;\r\n}(exports.ConditionalExpressionBase));\r\nexports.ConditionalExpression = ConditionalExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/ConditionalExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/DeleteExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/DeleteExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.DeleteExpressionBase = expressioned_1.UnaryExpressionedNode(UnaryExpression_1.UnaryExpression);\r\nvar DeleteExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DeleteExpression, _super);\r\n    function DeleteExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return DeleteExpression;\r\n}(exports.DeleteExpressionBase));\r\nexports.DeleteExpression = DeleteExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/DeleteExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/ElementAccessExpression.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/ElementAccessExpression.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar MemberExpression_1 = __webpack_require__(/*! ./MemberExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js\");\r\nexports.ElementAccessExpressionBase = expressioned_1.LeftHandSideExpressionedNode(MemberExpression_1.MemberExpression);\r\nvar ElementAccessExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ElementAccessExpression, _super);\r\n    function ElementAccessExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this element access expression's argument expression or undefined if none exists.\r\n     */\r\n    ElementAccessExpression.prototype.getArgumentExpression = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.argumentExpression);\r\n    };\r\n    /**\r\n     * Gets this element access expression's argument expression or throws if none exists.\r\n     */\r\n    ElementAccessExpression.prototype.getArgumentExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getArgumentExpression(), \"Expected to find an argument expression.\");\r\n    };\r\n    return ElementAccessExpression;\r\n}(exports.ElementAccessExpressionBase));\r\nexports.ElementAccessExpression = ElementAccessExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/ElementAccessExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Node_1 = __webpack_require__(/*! ../common/Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\");\r\nvar Expression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Expression, _super);\r\n    function Expression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the contextual type of the expression.\r\n     */\r\n    Expression.prototype.getContextualType = function () {\r\n        return this.context.typeChecker.getContextualType(this);\r\n    };\r\n    return Expression;\r\n}(Node_1.Node));\r\nexports.Expression = Expression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/ImportExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/ImportExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.ImportExpressionBase = PrimaryExpression_1.PrimaryExpression;\r\nvar ImportExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImportExpression, _super);\r\n    function ImportExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return ImportExpression;\r\n}(exports.ImportExpressionBase));\r\nexports.ImportExpression = ImportExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/ImportExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar UpdateExpression_1 = __webpack_require__(/*! ./UpdateExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UpdateExpression.js\");\r\nvar LeftHandSideExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(LeftHandSideExpression, _super);\r\n    function LeftHandSideExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return LeftHandSideExpression;\r\n}(UpdateExpression_1.UpdateExpression));\r\nexports.LeftHandSideExpression = LeftHandSideExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/LiteralExpression.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/LiteralExpression.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.LiteralExpressionBase = base_1.LiteralLikeNode(PrimaryExpression_1.PrimaryExpression);\r\nvar LiteralExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(LiteralExpression, _super);\r\n    function LiteralExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return LiteralExpression;\r\n}(exports.LiteralExpressionBase));\r\nexports.LiteralExpression = LiteralExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/LiteralExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar LeftHandSideExpression_1 = __webpack_require__(/*! ./LeftHandSideExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js\");\r\nvar MemberExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MemberExpression, _super);\r\n    function MemberExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return MemberExpression;\r\n}(LeftHandSideExpression_1.LeftHandSideExpression));\r\nexports.MemberExpression = MemberExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/MetaProperty.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/MetaProperty.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.MetaPropertyBase = base_1.NamedNode(PrimaryExpression_1.PrimaryExpression);\r\nvar MetaProperty = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MetaProperty, _super);\r\n    function MetaProperty() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the keyword token.\r\n     */\r\n    MetaProperty.prototype.getKeywordToken = function () {\r\n        return this.compilerNode.keywordToken;\r\n    };\r\n    return MetaProperty;\r\n}(exports.MetaPropertyBase));\r\nexports.MetaProperty = MetaProperty;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/MetaProperty.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/NewExpression.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/NewExpression.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.NewExpressionBase = base_1.TypeArgumentedNode(base_1.ArgumentedNode(expressioned_1.LeftHandSideExpressionedNode(PrimaryExpression_1.PrimaryExpression)));\r\nvar NewExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NewExpression, _super);\r\n    function NewExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return NewExpression;\r\n}(exports.NewExpressionBase));\r\nexports.NewExpression = NewExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/NewExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/NonNullExpression.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/NonNullExpression.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar LeftHandSideExpression_1 = __webpack_require__(/*! ./LeftHandSideExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js\");\r\nexports.NonNullExpressionBase = expressioned_1.ExpressionedNode(LeftHandSideExpression_1.LeftHandSideExpression);\r\nvar NonNullExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NonNullExpression, _super);\r\n    function NonNullExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return NonNullExpression;\r\n}(exports.NonNullExpressionBase));\r\nexports.NonNullExpression = NonNullExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/NonNullExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/OmittedExpression.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/OmittedExpression.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nexports.OmittedExpressionBase = Expression_1.Expression;\r\nvar OmittedExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(OmittedExpression, _super);\r\n    function OmittedExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return OmittedExpression;\r\n}(exports.OmittedExpressionBase));\r\nexports.OmittedExpression = OmittedExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/OmittedExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/ParenthesizedExpression.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/ParenthesizedExpression.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nexports.ParenthesizedExpressionBase = expressioned_1.ExpressionedNode(Expression_1.Expression);\r\nvar ParenthesizedExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParenthesizedExpression, _super);\r\n    function ParenthesizedExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return ParenthesizedExpression;\r\n}(exports.ParenthesizedExpressionBase));\r\nexports.ParenthesizedExpression = ParenthesizedExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/ParenthesizedExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/PartiallyEmittedExpression.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/PartiallyEmittedExpression.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nexports.PartiallyEmittedExpressionBase = expressioned_1.ExpressionedNode(Expression_1.Expression);\r\nvar PartiallyEmittedExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PartiallyEmittedExpression, _super);\r\n    function PartiallyEmittedExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return PartiallyEmittedExpression;\r\n}(exports.PartiallyEmittedExpressionBase));\r\nexports.PartiallyEmittedExpression = PartiallyEmittedExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/PartiallyEmittedExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/PostfixUnaryExpression.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/PostfixUnaryExpression.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.PostfixUnaryExpressionBase = UnaryExpression_1.UnaryExpression;\r\nvar PostfixUnaryExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PostfixUnaryExpression, _super);\r\n    function PostfixUnaryExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the operator token of the postfix unary expression.\r\n     */\r\n    PostfixUnaryExpression.prototype.getOperatorToken = function () {\r\n        return this.compilerNode.operator;\r\n    };\r\n    /**\r\n     * Gets the operand of the postfix unary expression.\r\n     */\r\n    PostfixUnaryExpression.prototype.getOperand = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.operand);\r\n    };\r\n    return PostfixUnaryExpression;\r\n}(exports.PostfixUnaryExpressionBase));\r\nexports.PostfixUnaryExpression = PostfixUnaryExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/PostfixUnaryExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/PrefixUnaryExpression.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/PrefixUnaryExpression.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.PrefixUnaryExpressionBase = UnaryExpression_1.UnaryExpression;\r\nvar PrefixUnaryExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PrefixUnaryExpression, _super);\r\n    function PrefixUnaryExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the operator token of the prefix unary expression.\r\n     */\r\n    PrefixUnaryExpression.prototype.getOperatorToken = function () {\r\n        return this.compilerNode.operator;\r\n    };\r\n    /**\r\n     * Gets the operand of the prefix unary expression.\r\n     */\r\n    PrefixUnaryExpression.prototype.getOperand = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.operand);\r\n    };\r\n    return PrefixUnaryExpression;\r\n}(exports.PrefixUnaryExpressionBase));\r\nexports.PrefixUnaryExpression = PrefixUnaryExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/PrefixUnaryExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar MemberExpression_1 = __webpack_require__(/*! ./MemberExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js\");\r\nvar PrimaryExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PrimaryExpression, _super);\r\n    function PrimaryExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return PrimaryExpression;\r\n}(MemberExpression_1.MemberExpression));\r\nexports.PrimaryExpression = PrimaryExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/PropertyAccessExpression.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/PropertyAccessExpression.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar MemberExpression_1 = __webpack_require__(/*! ./MemberExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js\");\r\nexports.PropertyAccessExpressionBase = base_1.NamedNode(expressioned_1.LeftHandSideExpressionedNode(MemberExpression_1.MemberExpression));\r\nvar PropertyAccessExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertyAccessExpression, _super);\r\n    function PropertyAccessExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return PropertyAccessExpression;\r\n}(exports.PropertyAccessExpressionBase));\r\nexports.PropertyAccessExpression = PropertyAccessExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/PropertyAccessExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/SpreadElement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/SpreadElement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nexports.SpreadElementBase = expressioned_1.ExpressionedNode(Expression_1.Expression);\r\nvar SpreadElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SpreadElement, _super);\r\n    function SpreadElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return SpreadElement;\r\n}(exports.SpreadElementBase));\r\nexports.SpreadElement = SpreadElement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/SpreadElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/SuperElementAccessExpression.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/SuperElementAccessExpression.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar ElementAccessExpression_1 = __webpack_require__(/*! ./ElementAccessExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/ElementAccessExpression.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nexports.SuperElementAccessExpressionBase = expressioned_1.SuperExpressionedNode(ElementAccessExpression_1.ElementAccessExpression);\r\nvar SuperElementAccessExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SuperElementAccessExpression, _super);\r\n    function SuperElementAccessExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return SuperElementAccessExpression;\r\n}(exports.SuperElementAccessExpressionBase));\r\nexports.SuperElementAccessExpression = SuperElementAccessExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/SuperElementAccessExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/SuperExpression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/SuperExpression.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.SuperExpressionBase = PrimaryExpression_1.PrimaryExpression;\r\nvar SuperExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SuperExpression, _super);\r\n    function SuperExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return SuperExpression;\r\n}(exports.SuperExpressionBase));\r\nexports.SuperExpression = SuperExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/SuperExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/SuperPropertyAccessExpression.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/SuperPropertyAccessExpression.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar PropertyAccessExpression_1 = __webpack_require__(/*! ./PropertyAccessExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PropertyAccessExpression.js\");\r\nexports.SuperPropertyAccessExpressionBase = expressioned_1.SuperExpressionedNode(PropertyAccessExpression_1.PropertyAccessExpression);\r\nvar SuperPropertyAccessExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SuperPropertyAccessExpression, _super);\r\n    function SuperPropertyAccessExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return SuperPropertyAccessExpression;\r\n}(exports.SuperPropertyAccessExpressionBase));\r\nexports.SuperPropertyAccessExpression = SuperPropertyAccessExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/SuperPropertyAccessExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/ThisExpression.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/ThisExpression.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.ThisExpressionBase = PrimaryExpression_1.PrimaryExpression;\r\nvar ThisExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ThisExpression, _super);\r\n    function ThisExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return ThisExpression;\r\n}(exports.ThisExpressionBase));\r\nexports.ThisExpression = ThisExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/ThisExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/TypeAssertion.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/TypeAssertion.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.TypeAssertionBase = base_1.TypedNode(expressioned_1.UnaryExpressionedNode(UnaryExpression_1.UnaryExpression));\r\nvar TypeAssertion = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeAssertion, _super);\r\n    function TypeAssertion() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TypeAssertion;\r\n}(exports.TypeAssertionBase));\r\nexports.TypeAssertion = TypeAssertion;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/TypeAssertion.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/TypeOfExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/TypeOfExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.TypeOfExpressionBase = expressioned_1.UnaryExpressionedNode(UnaryExpression_1.UnaryExpression);\r\nvar TypeOfExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeOfExpression, _super);\r\n    function TypeOfExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TypeOfExpression;\r\n}(exports.TypeOfExpressionBase));\r\nexports.TypeOfExpression = TypeOfExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/TypeOfExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nvar UnaryExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(UnaryExpression, _super);\r\n    function UnaryExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return UnaryExpression;\r\n}(Expression_1.Expression));\r\nexports.UnaryExpression = UnaryExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/UpdateExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/UpdateExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nvar UpdateExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(UpdateExpression, _super);\r\n    function UpdateExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return UpdateExpression;\r\n}(UnaryExpression_1.UnaryExpression));\r\nexports.UpdateExpression = UpdateExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/UpdateExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/VoidExpression.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/VoidExpression.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expressioned_1 = __webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar UnaryExpression_1 = __webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\");\r\nexports.VoidExpressionBase = expressioned_1.UnaryExpressionedNode(UnaryExpression_1.UnaryExpression);\r\nvar VoidExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(VoidExpression, _super);\r\n    function VoidExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return VoidExpression;\r\n}(exports.VoidExpressionBase));\r\nexports.VoidExpression = VoidExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/VoidExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/YieldExpression.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/YieldExpression.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Expression_1 = __webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\");\r\nexports.YieldExpressionBase = base_1.GeneratorableNode(Expression_1.Expression);\r\nvar YieldExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(YieldExpression, _super);\r\n    function YieldExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the expression or undefined of the yield expression.\r\n     */\r\n    YieldExpression.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets the expression of the yield expression or throws if it does not exist.\r\n     */\r\n    YieldExpression.prototype.getExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExpression(), \"Expected to find an expression.\");\r\n    };\r\n    return YieldExpression;\r\n}(exports.YieldExpressionBase));\r\nexports.YieldExpression = YieldExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/YieldExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayDestructuringAssignment.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayDestructuringAssignment.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar AssignmentExpression_1 = __webpack_require__(/*! ../AssignmentExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/AssignmentExpression.js\");\r\nexports.ArrayDestructuringAssignmentBase = AssignmentExpression_1.AssignmentExpression;\r\nvar ArrayDestructuringAssignment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrayDestructuringAssignment, _super);\r\n    function ArrayDestructuringAssignment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the left array literal expression of the array destructuring assignment.\r\n     */\r\n    ArrayDestructuringAssignment.prototype.getLeft = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.left);\r\n    };\r\n    return ArrayDestructuringAssignment;\r\n}(exports.ArrayDestructuringAssignmentBase));\r\nexports.ArrayDestructuringAssignment = ArrayDestructuringAssignment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayDestructuringAssignment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayLiteralExpression.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayLiteralExpression.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar structurePrinters_1 = __webpack_require__(/*! ../../../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ../PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nvar ArrayLiteralExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrayLiteralExpression, _super);\r\n    function ArrayLiteralExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the array's elements.\r\n     */\r\n    ArrayLiteralExpression.prototype.getElements = function () {\r\n        var _this = this;\r\n        return this.compilerNode.elements.map(function (e) { return _this.getNodeFromCompilerNode(e); });\r\n    };\r\n    /**\r\n     * Adds an element to the array.\r\n     * @param text - Text to add as an element.\r\n     * @param options - Options.\r\n     */\r\n    ArrayLiteralExpression.prototype.addElement = function (text, options) {\r\n        return this.addElements([text], options)[0];\r\n    };\r\n    /**\r\n     * Adds elements to the array.\r\n     * @param texts - Texts to add as elements.\r\n     * @param options - Options.\r\n     */\r\n    ArrayLiteralExpression.prototype.addElements = function (texts, options) {\r\n        return this.insertElements(this.compilerNode.elements.length, texts, options);\r\n    };\r\n    /**\r\n     * Insert an element into the array.\r\n     * @param index - Child index to insert at.\r\n     * @param text - Text to insert as an element.\r\n     * @param options - Options.\r\n     */\r\n    ArrayLiteralExpression.prototype.insertElement = function (index, text, options) {\r\n        return this.insertElements(index, [text], options)[0];\r\n    };\r\n    ArrayLiteralExpression.prototype.insertElements = function (index, textsOrWriterFunction, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var elements = this.getElements();\r\n        index = manipulation_1.verifyAndGetIndex(index, elements.length);\r\n        var useNewLines = getUseNewLines(this);\r\n        var writer = useNewLines ? this.getWriterWithChildIndentation() : this.getWriterWithQueuedChildIndentation();\r\n        var stringStructurePrinter = new structurePrinters_1.StringStructurePrinter();\r\n        var structurePrinter = useNewLines ?\r\n            new structurePrinters_1.CommaNewLineSeparatedStructuresPrinter(stringStructurePrinter) :\r\n            new structurePrinters_1.CommaSeparatedStructuresPrinter(stringStructurePrinter);\r\n        structurePrinter.printText(writer, textsOrWriterFunction instanceof Function ? [textsOrWriterFunction] : textsOrWriterFunction);\r\n        return insertTexts(this);\r\n        function insertTexts(node) {\r\n            manipulation_1.insertIntoCommaSeparatedNodes({\r\n                parent: node.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                currentNodes: elements,\r\n                insertIndex: index,\r\n                newText: writer.toString(),\r\n                useNewLines: useNewLines\r\n            });\r\n            var newElements = node.getElements();\r\n            return manipulation_1.getNodesToReturn(newElements, index, newElements.length - elements.length);\r\n        }\r\n        function getUseNewLines(node) {\r\n            if (options.useNewLines != null)\r\n                return options.useNewLines;\r\n            if (elements.length > 1)\r\n                return allElementsOnDifferentLines();\r\n            return node.getStartLineNumber() !== node.getEndLineNumber();\r\n            function allElementsOnDifferentLines() {\r\n                var previousLine = elements[0].getStartLineNumber();\r\n                for (var i = 1; i < elements.length; i++) {\r\n                    var currentLine = elements[i].getStartLineNumber();\r\n                    if (previousLine === currentLine)\r\n                        return false;\r\n                    previousLine = currentLine;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    };\r\n    ArrayLiteralExpression.prototype.removeElement = function (elementOrIndex) {\r\n        var elements = this.getElements();\r\n        if (elements.length === 0)\r\n            throw new errors.InvalidOperationError(\"Cannot remove an element when none exist.\");\r\n        var elementToRemove = typeof elementOrIndex === \"number\" ? getElementFromIndex(elementOrIndex) : elementOrIndex;\r\n        manipulation_1.removeCommaSeparatedChild(elementToRemove);\r\n        function getElementFromIndex(index) {\r\n            return elements[manipulation_1.verifyAndGetIndex(index, elements.length - 1)];\r\n        }\r\n    };\r\n    return ArrayLiteralExpression;\r\n}(PrimaryExpression_1.PrimaryExpression));\r\nexports.ArrayLiteralExpression = ArrayLiteralExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayLiteralExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/array/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/array/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArrayDestructuringAssignment */ \"./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayDestructuringAssignment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArrayLiteralExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/array/ArrayLiteralExpression.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/array/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ExpressionedNode.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ExpressionedNode.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction ExpressionedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getExpression = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ExpressionedNode = ExpressionedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ExpressionedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ImportExpressionedNode.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ImportExpressionedNode.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction ImportExpressionedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getExpression = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.ImportExpressionedNode = ImportExpressionedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ImportExpressionedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/LeftHandSideExpressionedNode.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/LeftHandSideExpressionedNode.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction LeftHandSideExpressionedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getExpression = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.LeftHandSideExpressionedNode = LeftHandSideExpressionedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/LeftHandSideExpressionedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/SuperExpressionedNode.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/SuperExpressionedNode.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction SuperExpressionedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getExpression = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.SuperExpressionedNode = SuperExpressionedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/SuperExpressionedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/UnaryExpressionedNode.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/UnaryExpressionedNode.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction UnaryExpressionedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getExpression = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.UnaryExpressionedNode = UnaryExpressionedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/UnaryExpressionedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExpressionedNode */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ExpressionedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportExpressionedNode */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/ImportExpressionedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LeftHandSideExpressionedNode */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/LeftHandSideExpressionedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SuperExpressionedNode */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/SuperExpressionedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UnaryExpressionedNode */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/UnaryExpressionedNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./array */ \"./node_modules/ts-simple-ast/dist/compiler/expression/array/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AsExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/AsExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AssignmentExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/AssignmentExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AwaitExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/AwaitExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BinaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/BinaryExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CallExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/CallExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CommaListExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/CommaListExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConditionalExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/ConditionalExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DeleteExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/DeleteExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ElementAccessExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/ElementAccessExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/Expression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/ImportExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LeftHandSideExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/LeftHandSideExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LiteralExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/LiteralExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./MemberExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/MemberExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./MetaProperty */ \"./node_modules/ts-simple-ast/dist/compiler/expression/MetaProperty.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NewExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/NewExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NonNullExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/NonNullExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./object */ \"./node_modules/ts-simple-ast/dist/compiler/expression/object/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./OmittedExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/OmittedExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ParenthesizedExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/ParenthesizedExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PartiallyEmittedExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PartiallyEmittedExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PostfixUnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PostfixUnaryExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PrefixUnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrefixUnaryExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyAccessExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PropertyAccessExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SpreadElement */ \"./node_modules/ts-simple-ast/dist/compiler/expression/SpreadElement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SuperElementAccessExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/SuperElementAccessExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SuperExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/SuperExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SuperPropertyAccessExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/SuperPropertyAccessExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ThisExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/ThisExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeAssertion */ \"./node_modules/ts-simple-ast/dist/compiler/expression/TypeAssertion.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeOfExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/TypeOfExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UnaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UnaryExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UpdateExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/UpdateExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VoidExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/VoidExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./YieldExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/YieldExpression.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectDestructuringAssignment.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectDestructuringAssignment.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar AssignmentExpression_1 = __webpack_require__(/*! ../AssignmentExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/AssignmentExpression.js\");\r\nexports.ObjectDestructuringAssignmentBase = AssignmentExpression_1.AssignmentExpression;\r\nvar ObjectDestructuringAssignment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ObjectDestructuringAssignment, _super);\r\n    function ObjectDestructuringAssignment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the left object literal expression of the object destructuring assignment.\r\n     */\r\n    ObjectDestructuringAssignment.prototype.getLeft = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.left);\r\n    };\r\n    return ObjectDestructuringAssignment;\r\n}(exports.ObjectDestructuringAssignmentBase));\r\nexports.ObjectDestructuringAssignment = ObjectDestructuringAssignment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectDestructuringAssignment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectLiteralExpression.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectLiteralExpression.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar structurePrinters_1 = __webpack_require__(/*! ../../../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar PrimaryExpression_1 = __webpack_require__(/*! ../PrimaryExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/PrimaryExpression.js\");\r\nexports.ObjectLiteralExpressionBase = PrimaryExpression_1.PrimaryExpression;\r\nvar ObjectLiteralExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ObjectLiteralExpression, _super);\r\n    function ObjectLiteralExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ObjectLiteralExpression.prototype.getPropertyOrThrow = function (nameOrFindFunction) {\r\n        return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), \"Expected to find a property.\");\r\n    };\r\n    ObjectLiteralExpression.prototype.getProperty = function (nameOrFindFunction) {\r\n        var findFunc;\r\n        if (typeof nameOrFindFunction === \"string\")\r\n            findFunc = function (prop) {\r\n                if (prop[\"getName\"] == null)\r\n                    return false;\r\n                return prop.getName() === nameOrFindFunction;\r\n            };\r\n        else\r\n            findFunc = nameOrFindFunction;\r\n        return utils_1.ArrayUtils.find(this.getProperties(), findFunc);\r\n    };\r\n    /**\r\n     * Gets the properties.\r\n     */\r\n    ObjectLiteralExpression.prototype.getProperties = function () {\r\n        var _this = this;\r\n        var properties = this.compilerNode.properties; // explicit type for validation\r\n        return properties.map(function (p) { return _this.getNodeFromCompilerNode(p); });\r\n    };\r\n    /* Property Assignments */\r\n    /**\r\n     * Adds a property assignment.\r\n     * @param structure - Structure that represents the property assignment to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addPropertyAssignment = function (structure) {\r\n        return this.addPropertyAssignments([structure])[0];\r\n    };\r\n    /**\r\n     * Adds property assignments.\r\n     * @param structures - Structure that represents the property assignments to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addPropertyAssignments = function (structures) {\r\n        return this.insertPropertyAssignments(this.compilerNode.properties.length, structures);\r\n    };\r\n    /**\r\n     * Inserts a property assignment at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the property assignment to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertPropertyAssignment = function (index, structure) {\r\n        return this.insertPropertyAssignments(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts property assignments at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the property assignments to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertPropertyAssignments = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertProperty(index, structures, function () { return _this.context.structurePrinterFactory.forPropertyAssignment(); });\r\n    };\r\n    /* Shorthand Property Assignments */\r\n    /**\r\n     * Adds a shorthand property assignment.\r\n     * @param structure - Structure that represents the shorthand property assignment to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addShorthandPropertyAssignment = function (structure) {\r\n        return this.addShorthandPropertyAssignments([structure])[0];\r\n    };\r\n    /**\r\n     * Adds shorthand property assignments.\r\n     * @param structures - Structure that represents the shorthand property assignments to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addShorthandPropertyAssignments = function (structures) {\r\n        return this.insertShorthandPropertyAssignments(this.compilerNode.properties.length, structures);\r\n    };\r\n    /**\r\n     * Inserts a shorthand property assignment at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the shorthand property assignment to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertShorthandPropertyAssignment = function (index, structure) {\r\n        return this.insertShorthandPropertyAssignments(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts shorthand property assignments at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the shorthand property assignments to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertShorthandPropertyAssignments = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertProperty(index, structures, function () { return _this.context.structurePrinterFactory.forShorthandPropertyAssignment(); });\r\n    };\r\n    /* Spread Assignments */\r\n    /**\r\n     * Adds a spread assignment.\r\n     * @param structure - Structure that represents the spread assignment to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addSpreadAssignment = function (structure) {\r\n        return this.addSpreadAssignments([structure])[0];\r\n    };\r\n    /**\r\n     * Adds spread assignments.\r\n     * @param structures - Structure that represents the spread assignments to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addSpreadAssignments = function (structures) {\r\n        return this.insertSpreadAssignments(this.compilerNode.properties.length, structures);\r\n    };\r\n    /**\r\n     * Inserts a spread assignment at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the spread assignment to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertSpreadAssignment = function (index, structure) {\r\n        return this.insertSpreadAssignments(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts spread assignments at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the spread assignments to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertSpreadAssignments = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertProperty(index, structures, function () { return _this.context.structurePrinterFactory.forSpreadAssignment(); });\r\n    };\r\n    /* Method Declarations */\r\n    /**\r\n     * Adds a method.\r\n     * @param structure - Structure that represents the method to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addMethod = function (structure) {\r\n        return this.addMethods([structure])[0];\r\n    };\r\n    /**\r\n     * Adds methods.\r\n     * @param structures - Structure that represents the methods to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addMethods = function (structures) {\r\n        return this.insertMethods(this.compilerNode.properties.length, structures);\r\n    };\r\n    /**\r\n     * Inserts a method at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the method to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertMethod = function (index, structure) {\r\n        return this.insertMethods(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts methods at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the methods to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertMethods = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertProperty(index, structures, function () { return _this.context.structurePrinterFactory.forMethodDeclaration({ isAmbient: false }); });\r\n    };\r\n    /* Get Accessor Declarations */\r\n    /**\r\n     * Adds a get accessor.\r\n     * @param structure - Structure that represents the property assignment to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addGetAccessor = function (structure) {\r\n        return this.addGetAccessors([structure])[0];\r\n    };\r\n    /**\r\n     * Adds get accessors.\r\n     * @param structures - Structure that represents the get accessors to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addGetAccessors = function (structures) {\r\n        return this.insertGetAccessors(this.compilerNode.properties.length, structures);\r\n    };\r\n    /**\r\n     * Inserts a get accessor at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the get accessor to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertGetAccessor = function (index, structure) {\r\n        return this.insertGetAccessors(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts get accessors at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the get accessors to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertGetAccessors = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertProperty(index, structures, function () { return _this.context.structurePrinterFactory.forGetAccessorDeclaration({ isAmbient: false }); });\r\n    };\r\n    /* Set Accessor Declarations */\r\n    /**\r\n     * Adds a set accessor.\r\n     * @param structure - Structure that represents the property assignment to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addSetAccessor = function (structure) {\r\n        return this.addSetAccessors([structure])[0];\r\n    };\r\n    /**\r\n     * Adds set accessors.\r\n     * @param structures - Structure that represents the set accessors to add.\r\n     */\r\n    ObjectLiteralExpression.prototype.addSetAccessors = function (structures) {\r\n        return this.insertSetAccessors(this.compilerNode.properties.length, structures);\r\n    };\r\n    /**\r\n     * Inserts a set accessor at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the set accessor to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertSetAccessor = function (index, structure) {\r\n        return this.insertSetAccessors(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts set accessors at the specified index.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the set accessors to insert.\r\n     */\r\n    ObjectLiteralExpression.prototype.insertSetAccessors = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertProperty(index, structures, function () { return _this.context.structurePrinterFactory.forSetAccessorDeclaration({ isAmbient: false }); });\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    ObjectLiteralExpression.prototype._insertProperty = function (index, structures, createStructurePrinter) {\r\n        index = manipulation_1.verifyAndGetIndex(index, this.compilerNode.properties.length);\r\n        var writer = this.getWriterWithChildIndentation();\r\n        var structurePrinter = new structurePrinters_1.CommaNewLineSeparatedStructuresPrinter(createStructurePrinter());\r\n        structurePrinter.printText(writer, structures);\r\n        manipulation_1.insertIntoCommaSeparatedNodes({\r\n            parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n            currentNodes: this.getProperties(),\r\n            insertIndex: index,\r\n            newText: writer.toString(),\r\n            useNewLines: true\r\n        });\r\n        return manipulation_1.getNodesToReturn(this.getProperties(), index, structures.length);\r\n    };\r\n    return ObjectLiteralExpression;\r\n}(exports.ObjectLiteralExpressionBase));\r\nexports.ObjectLiteralExpression = ObjectLiteralExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectLiteralExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/object/PropertyAssignment.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/object/PropertyAssignment.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\n// This node only has a question token in order to tell the user about bad code.\r\n// (See https://github.com/Microsoft/TypeScript/pull/5121/files)\r\nexports.PropertyAssignmentBase = base_1.InitializerGetExpressionableNode(base_1.QuestionTokenableNode(base_1.PropertyNamedNode(common_1.Node)));\r\nvar PropertyAssignment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertyAssignment, _super);\r\n    function PropertyAssignment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Removes the initializer and returns the new shorthand property assignment.\r\n     *\r\n     * Note: The current node will no longer be valid because it's no longer a property assignment.\r\n     */\r\n    PropertyAssignment.prototype.removeInitializer = function () {\r\n        var initializer = this.getInitializerOrThrow();\r\n        var colonToken = initializer.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.ColonToken);\r\n        var childIndex = this.getChildIndex();\r\n        var sourceFileText = this.sourceFile.getFullText();\r\n        var insertPos = this.getStart();\r\n        var newText = sourceFileText.substring(insertPos, colonToken.getPos()) + sourceFileText.substring(initializer.getEnd(), this.getEnd());\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: insertPos,\r\n            newText: newText,\r\n            parent: parent,\r\n            replacing: {\r\n                textLength: this.getWidth()\r\n            }\r\n        });\r\n        return parent.getChildAtIndexIfKindOrThrow(childIndex, typescript_1.SyntaxKind.ShorthandPropertyAssignment);\r\n    };\r\n    PropertyAssignment.prototype.setInitializer = function (textOrWriterFunction) {\r\n        var initializer = this.getInitializerOrThrow();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: initializer.getStart(),\r\n            newText: utils_1.getTextFromStringOrWriter(this.getWriterWithQueuedChildIndentation(), textOrWriterFunction),\r\n            parent: this,\r\n            replacing: {\r\n                textLength: initializer.getWidth()\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this property.\r\n     */\r\n    PropertyAssignment.prototype.remove = function () {\r\n        manipulation_1.removeCommaSeparatedChild(this);\r\n    };\r\n    return PropertyAssignment;\r\n}(exports.PropertyAssignmentBase));\r\nexports.PropertyAssignment = PropertyAssignment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/object/PropertyAssignment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/object/ShorthandPropertyAssignment.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/object/ShorthandPropertyAssignment.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Node_1 = __webpack_require__(/*! ../../common/Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\");\r\n// This node only has an object assignment initializer, equals token, and question token, in order to tell the user about bad code\r\n// (See https://github.com/Microsoft/TypeScript/pull/5121/files)\r\nexports.ShorthandPropertyAssignmentBase = base_1.InitializerGetExpressionableNode(base_1.QuestionTokenableNode(base_1.NamedNode(Node_1.Node)));\r\nvar ShorthandPropertyAssignment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ShorthandPropertyAssignment, _super);\r\n    function ShorthandPropertyAssignment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets if the shorthand property assignment has an object assignment initializer.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.hasObjectAssignmentInitializer = function () {\r\n        return this.compilerNode.objectAssignmentInitializer != null;\r\n    };\r\n    /**\r\n     * Gets the object assignment initializer or throws if it doesn't exist.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.getObjectAssignmentInitializerOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getObjectAssignmentInitializer(), \"Expected to find an object assignment initializer.\");\r\n    };\r\n    /**\r\n     * Gets the object assignment initializer if it exists.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.getObjectAssignmentInitializer = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.objectAssignmentInitializer);\r\n    };\r\n    /**\r\n     * Gets the equals token or throws if it doesn't exist.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.getEqualsTokenOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getEqualsToken(), \"Expected to find an equals token.\");\r\n    };\r\n    /**\r\n     * Gets the equals token if it exists.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.getEqualsToken = function () {\r\n        var equalsToken = this.compilerNode.equalsToken;\r\n        if (equalsToken == null)\r\n            return undefined;\r\n        return this.getNodeFromCompilerNode(equalsToken);\r\n    };\r\n    /**\r\n     * Remove the object assignment initializer.\r\n     *\r\n     * This is only useful to remove bad code.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.removeObjectAssignmentInitializer = function () {\r\n        if (!this.hasObjectAssignmentInitializer())\r\n            return this;\r\n        manipulation_1.removeChildren({\r\n            children: [this.getEqualsTokenOrThrow(), this.getObjectAssignmentInitializerOrThrow()],\r\n            removePrecedingSpaces: true\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the initializer.\r\n     *\r\n     * Note: The current node will no longer be valid because it's no longer a shorthand property assignment.\r\n     * @param text - New text to set for the initializer.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.setInitializer = function (text) {\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var childIndex = this.getChildIndex();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: this.getStart(),\r\n            newText: this.getText() + (\": \" + text),\r\n            parent: parent,\r\n            replacing: {\r\n                textLength: this.getWidth()\r\n            }\r\n        });\r\n        return parent.getChildAtIndexIfKindOrThrow(childIndex, typescript_1.SyntaxKind.PropertyAssignment);\r\n    };\r\n    /**\r\n     * Removes this property.\r\n     */\r\n    ShorthandPropertyAssignment.prototype.remove = function () {\r\n        manipulation_1.removeCommaSeparatedChild(this);\r\n    };\r\n    return ShorthandPropertyAssignment;\r\n}(exports.ShorthandPropertyAssignmentBase));\r\nexports.ShorthandPropertyAssignment = ShorthandPropertyAssignment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/object/ShorthandPropertyAssignment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/object/SpreadAssignment.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/object/SpreadAssignment.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Node_1 = __webpack_require__(/*! ../../common/Node */ \"./node_modules/ts-simple-ast/dist/compiler/common/Node.js\");\r\nvar expressioned_1 = __webpack_require__(/*! ../expressioned */ \"./node_modules/ts-simple-ast/dist/compiler/expression/expressioned/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nexports.SpreadAssignmentBase = expressioned_1.ExpressionedNode(Node_1.Node);\r\nvar SpreadAssignment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SpreadAssignment, _super);\r\n    function SpreadAssignment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Removes this property.\r\n     */\r\n    SpreadAssignment.prototype.remove = function () {\r\n        manipulation_1.removeCommaSeparatedChild(this);\r\n    };\r\n    return SpreadAssignment;\r\n}(exports.SpreadAssignmentBase));\r\nexports.SpreadAssignment = SpreadAssignment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/object/SpreadAssignment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/expression/object/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/expression/object/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ObjectDestructuringAssignment */ \"./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectDestructuringAssignment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ObjectLiteralExpression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/object/ObjectLiteralExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyAssignment */ \"./node_modules/ts-simple-ast/dist/compiler/expression/object/PropertyAssignment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ShorthandPropertyAssignment */ \"./node_modules/ts-simple-ast/dist/compiler/expression/object/ShorthandPropertyAssignment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SpreadAssignment */ \"./node_modules/ts-simple-ast/dist/compiler/expression/object/SpreadAssignment.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/expression/object/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ExportAssignment.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ExportAssignment.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar ExportAssignment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExportAssignment, _super);\r\n    function ExportAssignment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets if this is an export equals assignemnt.\r\n     *\r\n     * If this is false, then it's `export default`.\r\n     */\r\n    ExportAssignment.prototype.isExportEquals = function () {\r\n        return this.compilerNode.isExportEquals || false;\r\n    };\r\n    /**\r\n     * Gets the export assignment expression.\r\n     */\r\n    ExportAssignment.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return ExportAssignment;\r\n}(statement_1.Statement));\r\nexports.ExportAssignment = ExportAssignment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ExportAssignment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ExportDeclaration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ExportDeclaration.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar ExportDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExportDeclaration, _super);\r\n    function ExportDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ExportDeclaration.prototype.setModuleSpecifier = function (textOrSourceFile) {\r\n        var text = typeof textOrSourceFile === \"string\" ? textOrSourceFile : this.sourceFile.getRelativePathAsModuleSpecifierTo(textOrSourceFile);\r\n        var stringLiteral = this.getModuleSpecifier();\r\n        if (stringLiteral == null) {\r\n            var semiColonToken = this.getLastChildIfKind(typescript_1.SyntaxKind.SemicolonToken);\r\n            var quoteKind = this.context.manipulationSettings.getQuoteKind();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: semiColonToken != null ? semiColonToken.getPos() : this.getEnd(),\r\n                parent: this,\r\n                newText: \" from \" + quoteKind + text + quoteKind\r\n            });\r\n        }\r\n        else\r\n            stringLiteral.setLiteralValue(text);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the module specifier or undefined if it doesn't exist.\r\n     */\r\n    ExportDeclaration.prototype.getModuleSpecifier = function () {\r\n        var moduleSpecifier = this.getNodeFromCompilerNodeIfExists(this.compilerNode.moduleSpecifier);\r\n        if (moduleSpecifier == null)\r\n            return undefined;\r\n        if (!utils_1.TypeGuards.isStringLiteral(moduleSpecifier))\r\n            throw new errors.InvalidOperationError(\"Expected the module specifier to be a string literal.\");\r\n        return moduleSpecifier;\r\n    };\r\n    /**\r\n     * Gets the module specifier value or undefined if it doesn't exist.\r\n     */\r\n    ExportDeclaration.prototype.getModuleSpecifierValue = function () {\r\n        var moduleSpecifier = this.getModuleSpecifier();\r\n        return moduleSpecifier == null ? undefined : moduleSpecifier.getLiteralValue();\r\n    };\r\n    /**\r\n     * Gets the source file referenced in the module specifier or throws if it can't find it or it doesn't exist.\r\n     */\r\n    ExportDeclaration.prototype.getModuleSpecifierSourceFileOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getModuleSpecifierSourceFile(), \"A module specifier source file was expected.\");\r\n    };\r\n    /**\r\n     * Gets the source file referenced in the module specifier.\r\n     */\r\n    ExportDeclaration.prototype.getModuleSpecifierSourceFile = function () {\r\n        var stringLiteral = this.getLastChildByKind(typescript_1.SyntaxKind.StringLiteral);\r\n        if (stringLiteral == null)\r\n            return undefined;\r\n        var symbol = stringLiteral.getSymbol();\r\n        if (symbol == null)\r\n            return undefined;\r\n        var declarations = symbol.getDeclarations();\r\n        if (declarations.length === 0 || declarations[0].getKind() !== typescript_1.SyntaxKind.SourceFile)\r\n            return undefined;\r\n        return declarations[0];\r\n    };\r\n    /**\r\n     * Gets if the module specifier starts with `./` or `../`.\r\n     */\r\n    ExportDeclaration.prototype.isModuleSpecifierRelative = function () {\r\n        var moduleSpecifierValue = this.getModuleSpecifierValue();\r\n        if (moduleSpecifierValue == null)\r\n            return false;\r\n        return utils_1.ModuleUtils.isModuleSpecifierRelative(moduleSpecifierValue);\r\n    };\r\n    /**\r\n     * Gets if the module specifier exists\r\n     */\r\n    ExportDeclaration.prototype.hasModuleSpecifier = function () {\r\n        return this.getLastChildByKind(typescript_1.SyntaxKind.StringLiteral) != null;\r\n    };\r\n    /**\r\n     * Gets if this export declaration is a namespace export.\r\n     */\r\n    ExportDeclaration.prototype.isNamespaceExport = function () {\r\n        return !this.hasNamedExports();\r\n    };\r\n    /**\r\n     * Gets if the export declaration has named exports.\r\n     */\r\n    ExportDeclaration.prototype.hasNamedExports = function () {\r\n        return this.compilerNode.exportClause != null;\r\n    };\r\n    ExportDeclaration.prototype.addNamedExport = function (structureOrName) {\r\n        return this.addNamedExports([structureOrName])[0];\r\n    };\r\n    /**\r\n     * Adds named exports.\r\n     * @param structuresOrNames - Structures or names that represent the named exports.\r\n     */\r\n    ExportDeclaration.prototype.addNamedExports = function (structuresOrNames) {\r\n        return this.insertNamedExports(this.getNamedExports().length, structuresOrNames);\r\n    };\r\n    ExportDeclaration.prototype.insertNamedExport = function (index, structureOrName) {\r\n        return this.insertNamedExports(index, [structureOrName])[0];\r\n    };\r\n    /**\r\n     * Inserts named exports into the export declaration.\r\n     * @param index - Child index to insert at.\r\n     * @param structuresOrNames - Structures or names that represent the named exports.\r\n     */\r\n    ExportDeclaration.prototype.insertNamedExports = function (index, structuresOrNames) {\r\n        if (utils_1.ArrayUtils.isNullOrEmpty(structuresOrNames))\r\n            return [];\r\n        var namedExports = this.getNamedExports();\r\n        var writer = this.getWriterWithQueuedChildIndentation();\r\n        var namedExportStructurePrinter = this.context.structurePrinterFactory.forNamedImportExportSpecifier();\r\n        index = manipulation_1.verifyAndGetIndex(index, namedExports.length);\r\n        if (namedExports.length === 0) {\r\n            namedExportStructurePrinter.printTextsWithBraces(writer, structuresOrNames);\r\n            var asteriskToken = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.AsteriskToken);\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: asteriskToken.getStart(),\r\n                parent: this,\r\n                newText: writer.toString(),\r\n                replacing: {\r\n                    textLength: 1\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            namedExportStructurePrinter.printTexts(writer, structuresOrNames);\r\n            manipulation_1.insertIntoCommaSeparatedNodes({\r\n                parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.NamedExports).getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                currentNodes: namedExports,\r\n                insertIndex: index,\r\n                newText: writer.toString(),\r\n                surroundWithSpaces: this.context.getFormatCodeSettings().insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\r\n            });\r\n        }\r\n        return manipulation_1.getNodesToReturn(this.getNamedExports(), index, structuresOrNames.length);\r\n    };\r\n    /**\r\n     * Gets the named exports.\r\n     */\r\n    ExportDeclaration.prototype.getNamedExports = function () {\r\n        var _this = this;\r\n        var namedExports = this.compilerNode.exportClause;\r\n        if (namedExports == null)\r\n            return [];\r\n        return namedExports.elements.map(function (e) { return _this.getNodeFromCompilerNode(e); });\r\n    };\r\n    /**\r\n     * Changes the export declaration to namespace export. Removes all the named exports.\r\n     */\r\n    ExportDeclaration.prototype.toNamespaceExport = function () {\r\n        if (!this.hasModuleSpecifier())\r\n            throw new errors.InvalidOperationError(\"Cannot change to a namespace export when no module specifier exists.\");\r\n        var namedExportsNode = this.getFirstChildByKind(typescript_1.SyntaxKind.NamedExports);\r\n        if (namedExportsNode == null)\r\n            return this;\r\n        manipulation_1.insertIntoParentTextRange({\r\n            parent: this,\r\n            newText: \"*\",\r\n            insertPos: namedExportsNode.getStart(),\r\n            replacing: {\r\n                textLength: namedExportsNode.getWidth()\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    return ExportDeclaration;\r\n}(statement_1.Statement));\r\nexports.ExportDeclaration = ExportDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ExportDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ExportSpecifier.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ExportSpecifier.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar ExportSpecifier = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExportSpecifier, _super);\r\n    function ExportSpecifier() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Sets the name of what's being exported.\r\n     */\r\n    ExportSpecifier.prototype.setName = function (name) {\r\n        var nameNode = this.getNameNode();\r\n        if (nameNode.getText() === name)\r\n            return this;\r\n        var start = nameNode.getStart();\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: start,\r\n            replacingLength: nameNode.getWidth(),\r\n            newText: name\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the name node of what's being exported.\r\n     */\r\n    ExportSpecifier.prototype.getNameNode = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.propertyName || this.compilerNode.name);\r\n    };\r\n    /**\r\n     * Sets the alias for the name being exported.\r\n     * @param alias - Alias to set.\r\n     */\r\n    ExportSpecifier.prototype.setAlias = function (alias) {\r\n        var aliasIdentifier = this.getAliasNode();\r\n        if (aliasIdentifier == null) {\r\n            // trick is to insert an alias with the same name, then rename the alias. TS compiler will take care of the rest.\r\n            var nameNode = this.getNameNode();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: nameNode.getEnd(),\r\n                parent: this,\r\n                newText: \" as \" + nameNode.getText()\r\n            });\r\n            aliasIdentifier = this.getAliasNode();\r\n        }\r\n        aliasIdentifier.rename(alias);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the alias identifier, if it exists.\r\n     */\r\n    ExportSpecifier.prototype.getAliasNode = function () {\r\n        if (this.compilerNode.propertyName == null)\r\n            return undefined;\r\n        return this.getNodeFromCompilerNode(this.compilerNode.name);\r\n    };\r\n    /**\r\n     * Gets the export declaration associated with this export specifier.\r\n     */\r\n    ExportSpecifier.prototype.getExportDeclaration = function () {\r\n        return this.getFirstAncestorByKindOrThrow(typescript_1.SyntaxKind.ExportDeclaration);\r\n    };\r\n    /**\r\n     * Gets the local target symbol of the export specifier or throws if it doesn't exist.\r\n     */\r\n    ExportSpecifier.prototype.getLocalTargetSymbolOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getLocalTargetSymbol(), \"The export specifier's local target symbol was expected.\");\r\n    };\r\n    /**\r\n     * Gets the local target symbol of the export specifier or undefined if it doesn't exist.\r\n     */\r\n    ExportSpecifier.prototype.getLocalTargetSymbol = function () {\r\n        return this.context.typeChecker.getExportSpecifierLocalTargetSymbol(this);\r\n    };\r\n    /**\r\n     * Gets all the declarations referenced by the export specifier.\r\n     */\r\n    ExportSpecifier.prototype.getLocalTargetDeclarations = function () {\r\n        var symbol = this.getLocalTargetSymbol();\r\n        return symbol == null ? [] : symbol.getDeclarations();\r\n    };\r\n    /**\r\n     * Removes the export specifier.\r\n     */\r\n    ExportSpecifier.prototype.remove = function () {\r\n        var exportDeclaration = this.getExportDeclaration();\r\n        var exports = exportDeclaration.getNamedExports();\r\n        if (exports.length > 1)\r\n            manipulation_1.removeCommaSeparatedChild(this);\r\n        else if (exportDeclaration.hasModuleSpecifier())\r\n            exportDeclaration.toNamespaceExport();\r\n        else\r\n            exportDeclaration.remove();\r\n    };\r\n    return ExportSpecifier;\r\n}(common_1.Node));\r\nexports.ExportSpecifier = ExportSpecifier;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ExportSpecifier.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ExternalModuleReference.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ExternalModuleReference.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar ExternalModuleReference = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExternalModuleReference, _super);\r\n    function ExternalModuleReference() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the expression or undefined of the yield expression.\r\n     */\r\n    ExternalModuleReference.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets the expression of the yield expression or throws if it does not exist.\r\n     */\r\n    ExternalModuleReference.prototype.getExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExpression(), \"Expected to find an expression.\");\r\n    };\r\n    /**\r\n     * Gets the source file referenced or throws if it can't find it.\r\n     */\r\n    ExternalModuleReference.prototype.getReferencedSourceFileOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getReferencedSourceFile(), \"Expected to find the referenced source file.\");\r\n    };\r\n    /**\r\n     * Gets if the external module reference is relative.\r\n     */\r\n    ExternalModuleReference.prototype.isRelative = function () {\r\n        var expression = this.getExpression();\r\n        if (expression == null || !utils_1.TypeGuards.isStringLiteral(expression))\r\n            return false;\r\n        return utils_1.ModuleUtils.isModuleSpecifierRelative(expression.getLiteralText());\r\n    };\r\n    /**\r\n     * Gets the source file referenced or returns undefined if it can't find it.\r\n     */\r\n    ExternalModuleReference.prototype.getReferencedSourceFile = function () {\r\n        var expression = this.getExpression();\r\n        if (expression == null)\r\n            return undefined;\r\n        var symbol = expression.getSymbol();\r\n        if (symbol == null)\r\n            return undefined;\r\n        return utils_1.ModuleUtils.getReferencedSourceFileFromSymbol(symbol);\r\n    };\r\n    return ExternalModuleReference;\r\n}(common_1.Node));\r\nexports.ExternalModuleReference = ExternalModuleReference;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ExternalModuleReference.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/FileSystemRefreshResult.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/FileSystemRefreshResult.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Result of refreshing a source file from the file system.\r\n */\r\nvar FileSystemRefreshResult;\r\n(function (FileSystemRefreshResult) {\r\n    /** The source file did not change. */\r\n    FileSystemRefreshResult[FileSystemRefreshResult[\"NoChange\"] = 0] = \"NoChange\";\r\n    /** The source file was updated from the file system. */\r\n    FileSystemRefreshResult[FileSystemRefreshResult[\"Updated\"] = 1] = \"Updated\";\r\n    /** The source file was deleted. */\r\n    FileSystemRefreshResult[FileSystemRefreshResult[\"Deleted\"] = 2] = \"Deleted\";\r\n})(FileSystemRefreshResult = exports.FileSystemRefreshResult || (exports.FileSystemRefreshResult = {}));\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/FileSystemRefreshResult.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ImportDeclaration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ImportDeclaration.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar ImportDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImportDeclaration, _super);\r\n    function ImportDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ImportDeclaration.prototype.setModuleSpecifier = function (textOrSourceFile) {\r\n        var text = typeof textOrSourceFile === \"string\" ? textOrSourceFile : this.sourceFile.getRelativePathAsModuleSpecifierTo(textOrSourceFile);\r\n        this.getModuleSpecifier().setLiteralValue(text);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the module specifier.\r\n     */\r\n    ImportDeclaration.prototype.getModuleSpecifier = function () {\r\n        var moduleSpecifier = this.getNodeFromCompilerNode(this.compilerNode.moduleSpecifier);\r\n        if (!utils_1.TypeGuards.isStringLiteral(moduleSpecifier))\r\n            throw new errors.InvalidOperationError(\"Expected the module specifier to be a string literal.\");\r\n        return moduleSpecifier;\r\n    };\r\n    /**\r\n     * Gets the module specifier string literal value.\r\n     */\r\n    ImportDeclaration.prototype.getModuleSpecifierValue = function () {\r\n        return this.getModuleSpecifier().getLiteralValue();\r\n    };\r\n    /**\r\n     * Gets the source file referenced in the module specifier or throws if it can't find it.\r\n     */\r\n    ImportDeclaration.prototype.getModuleSpecifierSourceFileOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getModuleSpecifierSourceFile(), \"A module specifier source file was expected.\");\r\n    };\r\n    /**\r\n     * Gets the source file referenced in the module specifier or returns undefined if it can't find it.\r\n     */\r\n    ImportDeclaration.prototype.getModuleSpecifierSourceFile = function () {\r\n        var symbol = this.getModuleSpecifier().getSymbol();\r\n        if (symbol == null)\r\n            return undefined;\r\n        return utils_1.ModuleUtils.getReferencedSourceFileFromSymbol(symbol);\r\n    };\r\n    /**\r\n     * Gets if the module specifier starts with `./` or `../`.\r\n     */\r\n    ImportDeclaration.prototype.isModuleSpecifierRelative = function () {\r\n        return utils_1.ModuleUtils.isModuleSpecifierRelative(this.getModuleSpecifierValue());\r\n    };\r\n    /**\r\n     * Sets the default import.\r\n     * @param text - Text to set as the default import.\r\n     */\r\n    ImportDeclaration.prototype.setDefaultImport = function (text) {\r\n        errors.throwIfNotStringOrWhitespace(text, \"text\");\r\n        var defaultImport = this.getDefaultImport();\r\n        if (defaultImport != null) {\r\n            defaultImport.rename(text);\r\n            return this;\r\n        }\r\n        var importKeyword = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.ImportKeyword);\r\n        var importClause = this.getImportClause();\r\n        if (importClause == null) {\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: importKeyword.getEnd(),\r\n                parent: this,\r\n                newText: \" \" + text + \" from\"\r\n            });\r\n            return this;\r\n        }\r\n        // a namespace import or named import must exist... insert it beforehand\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: importKeyword.getEnd(),\r\n            parent: importClause,\r\n            newText: \" \" + text + \",\"\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the default import or throws if it doesn't exit.\r\n     */\r\n    ImportDeclaration.prototype.getDefaultImportOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDefaultImport(), \"Expected to find a default import.\");\r\n    };\r\n    /**\r\n     * Gets the default import or returns undefined if it doesn't exist.\r\n     */\r\n    ImportDeclaration.prototype.getDefaultImport = function () {\r\n        var importClause = this.getImportClause();\r\n        if (importClause == null)\r\n            return undefined;\r\n        var firstChild = importClause.getFirstChild();\r\n        if (firstChild == null || firstChild.getKind() !== typescript_1.SyntaxKind.Identifier)\r\n            return undefined;\r\n        return firstChild;\r\n    };\r\n    /**\r\n     * Sets the namespace import.\r\n     * @param text - Text to set as the namespace import.\r\n     * @throws - InvalidOperationError if a named import exists.\r\n     */\r\n    ImportDeclaration.prototype.setNamespaceImport = function (text) {\r\n        if (utils_1.StringUtils.isNullOrWhitespace(text))\r\n            return this.removeNamespaceImport();\r\n        var namespaceImport = this.getNamespaceImport();\r\n        if (namespaceImport != null) {\r\n            namespaceImport.rename(text);\r\n            return this;\r\n        }\r\n        if (this.getNamedImports().length > 0)\r\n            throw new errors.InvalidOperationError(\"Cannot add a namespace import to an import declaration that has named imports.\");\r\n        var defaultImport = this.getDefaultImport();\r\n        if (defaultImport != null) {\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: defaultImport.getEnd(),\r\n                parent: this.getImportClause(),\r\n                newText: \", * as \" + text\r\n            });\r\n            return this;\r\n        }\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.ImportKeyword).getEnd(),\r\n            parent: this,\r\n            newText: \" * as \" + text + \" from\"\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the namespace import.\r\n     */\r\n    ImportDeclaration.prototype.removeNamespaceImport = function () {\r\n        var namespaceImport = this.getNamespaceImport();\r\n        if (namespaceImport == null)\r\n            return this;\r\n        manipulation_1.removeChildren({\r\n            children: getChildrenToRemove.call(this),\r\n            removePrecedingSpaces: true,\r\n            removePrecedingNewLines: true\r\n        });\r\n        return this;\r\n        function getChildrenToRemove() {\r\n            var defaultImport = this.getDefaultImport();\r\n            if (defaultImport == null)\r\n                return [this.getImportClauseOrThrow(), this.getLastChildByKindOrThrow(typescript_1.SyntaxKind.FromKeyword)];\r\n            else\r\n                return [defaultImport.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.CommaToken), namespaceImport];\r\n        }\r\n    };\r\n    /**\r\n     * Gets the namespace import if it exists or throws.\r\n     */\r\n    ImportDeclaration.prototype.getNamespaceImportOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getNamespaceImport(), \"Expected to find a namespace import.\");\r\n    };\r\n    /**\r\n     * Gets the namespace import, if it exists.\r\n     */\r\n    ImportDeclaration.prototype.getNamespaceImport = function () {\r\n        var importClause = this.getImportClause();\r\n        if (importClause == null)\r\n            return undefined;\r\n        var namespaceImport = importClause.getFirstChildByKind(typescript_1.SyntaxKind.NamespaceImport);\r\n        if (namespaceImport == null)\r\n            return undefined;\r\n        return namespaceImport.getFirstChildByKind(typescript_1.SyntaxKind.Identifier);\r\n    };\r\n    ImportDeclaration.prototype.addNamedImport = function (structureOrName) {\r\n        return this.addNamedImports([structureOrName])[0];\r\n    };\r\n    /**\r\n     * Adds named imports.\r\n     * @param structuresOrNames - Structures or names that represent the named imports.\r\n     */\r\n    ImportDeclaration.prototype.addNamedImports = function (structuresOrNames) {\r\n        return this.insertNamedImports(this.getNamedImports().length, structuresOrNames);\r\n    };\r\n    ImportDeclaration.prototype.insertNamedImport = function (index, structureOrName) {\r\n        return this.insertNamedImports(index, [structureOrName])[0];\r\n    };\r\n    /**\r\n     * Inserts named imports into the import declaration.\r\n     * @param index - Child index to insert at.\r\n     * @param structuresOrNames - Structures or names that represent the named imports.\r\n     */\r\n    ImportDeclaration.prototype.insertNamedImports = function (index, structuresOrNames) {\r\n        if (utils_1.ArrayUtils.isNullOrEmpty(structuresOrNames))\r\n            return [];\r\n        var namedImports = this.getNamedImports();\r\n        var writer = this.getWriterWithQueuedChildIndentation();\r\n        var namedImportStructurePrinter = this.context.structurePrinterFactory.forNamedImportExportSpecifier();\r\n        var importClause = this.getImportClause();\r\n        index = manipulation_1.verifyAndGetIndex(index, namedImports.length);\r\n        if (namedImports.length === 0) {\r\n            namedImportStructurePrinter.printTextsWithBraces(writer, structuresOrNames);\r\n            if (importClause == null)\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.ImportKeyword).getEnd(),\r\n                    parent: this,\r\n                    newText: \" \" + writer.toString() + \" from\"\r\n                });\r\n            else if (this.getNamespaceImport() != null)\r\n                throw new errors.InvalidOperationError(\"Cannot add a named import to an import declaration that has a namespace import.\");\r\n            else\r\n                manipulation_1.insertIntoParentTextRange({\r\n                    insertPos: this.getDefaultImport().getEnd(),\r\n                    parent: importClause,\r\n                    newText: \", \" + writer.toString()\r\n                });\r\n        }\r\n        else {\r\n            if (importClause == null)\r\n                throw new errors.NotImplementedError(\"Expected to have an import clause.\");\r\n            namedImportStructurePrinter.printTexts(writer, structuresOrNames);\r\n            manipulation_1.insertIntoCommaSeparatedNodes({\r\n                parent: importClause.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.NamedImports).getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n                currentNodes: namedImports,\r\n                insertIndex: index,\r\n                newText: writer.toString(),\r\n                surroundWithSpaces: this.context.getFormatCodeSettings().insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\r\n            });\r\n        }\r\n        return manipulation_1.getNodesToReturn(this.getNamedImports(), index, structuresOrNames.length);\r\n    };\r\n    /**\r\n     * Gets the named imports.\r\n     */\r\n    ImportDeclaration.prototype.getNamedImports = function () {\r\n        var importClause = this.getImportClause();\r\n        if (importClause == null)\r\n            return [];\r\n        var namedImports = importClause.getFirstChildByKind(typescript_1.SyntaxKind.NamedImports);\r\n        if (namedImports == null)\r\n            return [];\r\n        return namedImports.getChildSyntaxListOrThrow().getChildren().filter(function (c) { return utils_1.TypeGuards.isImportSpecifier(c); });\r\n    };\r\n    /**\r\n     * Removes all the named imports.\r\n     */\r\n    ImportDeclaration.prototype.removeNamedImports = function () {\r\n        var importClause = this.getImportClause();\r\n        if (importClause == null)\r\n            return this;\r\n        var namedImportsNode = importClause.getFirstChildByKind(typescript_1.SyntaxKind.NamedImports);\r\n        if (namedImportsNode == null)\r\n            return this;\r\n        // ex. import defaultExport, {Export1} from \"module-name\";\r\n        var defaultImport = this.getDefaultImport();\r\n        if (defaultImport != null) {\r\n            var commaToken = defaultImport.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.CommaToken);\r\n            manipulation_1.removeChildren({ children: [commaToken, namedImportsNode] });\r\n            return this;\r\n        }\r\n        // ex. import {Export1} from \"module-name\";\r\n        var fromKeyword = importClause.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.FromKeyword);\r\n        manipulation_1.removeChildren({ children: [importClause, fromKeyword], removePrecedingSpaces: true });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the import clause or throws if it doesn't exist.\r\n     */\r\n    ImportDeclaration.prototype.getImportClauseOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getImportClause(), \"Expected to find an import clause.\");\r\n    };\r\n    /**\r\n     * Gets the import clause or returns undefined if it doesn't exist.\r\n     */\r\n    ImportDeclaration.prototype.getImportClause = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.importClause);\r\n    };\r\n    return ImportDeclaration;\r\n}(statement_1.Statement));\r\nexports.ImportDeclaration = ImportDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ImportDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ImportEqualsDeclaration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ImportEqualsDeclaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nexports.ImportEqualsDeclarationBase = base_1.JSDocableNode(base_1.NamedNode(statement_1.Statement));\r\nvar ImportEqualsDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImportEqualsDeclaration, _super);\r\n    function ImportEqualsDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the module reference of the import equals declaration.\r\n     */\r\n    ImportEqualsDeclaration.prototype.getModuleReference = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.moduleReference);\r\n    };\r\n    /**\r\n     * Gets if the external module reference is relative.\r\n     */\r\n    ImportEqualsDeclaration.prototype.isExternalModuleReferenceRelative = function () {\r\n        var moduleReference = this.getModuleReference();\r\n        if (!utils_1.TypeGuards.isExternalModuleReference(moduleReference))\r\n            return false;\r\n        return moduleReference.isRelative();\r\n    };\r\n    ImportEqualsDeclaration.prototype.setExternalModuleReference = function (textOrSourceFile) {\r\n        var text = typeof textOrSourceFile === \"string\" ? textOrSourceFile : this.sourceFile.getRelativePathAsModuleSpecifierTo(textOrSourceFile);\r\n        var moduleReference = this.getModuleReference();\r\n        if (utils_1.TypeGuards.isExternalModuleReference(moduleReference) && moduleReference.getExpression() != null)\r\n            moduleReference.getExpressionOrThrow().replaceWithText(function (writer) { return writer.quote(text); });\r\n        else\r\n            moduleReference.replaceWithText(function (writer) { return writer.write(\"require(\").quote(text).write(\")\"); });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the source file referenced in the external module reference or throws if it doesn't exist.\r\n     */\r\n    ImportEqualsDeclaration.prototype.getExternalModuleReferenceSourceFileOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExternalModuleReferenceSourceFile(), \"Expected to find an external module reference's referenced source file.\");\r\n    };\r\n    /**\r\n     * Gets the source file referenced in the external module reference or returns undefined if it doesn't exist.\r\n     */\r\n    ImportEqualsDeclaration.prototype.getExternalModuleReferenceSourceFile = function () {\r\n        var moduleReference = this.getModuleReference();\r\n        if (!utils_1.TypeGuards.isExternalModuleReference(moduleReference))\r\n            return undefined;\r\n        return moduleReference.getReferencedSourceFile();\r\n    };\r\n    return ImportEqualsDeclaration;\r\n}(exports.ImportEqualsDeclarationBase));\r\nexports.ImportEqualsDeclaration = ImportEqualsDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ImportEqualsDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/ImportSpecifier.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/ImportSpecifier.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar ImportSpecifier = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImportSpecifier, _super);\r\n    function ImportSpecifier() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Sets the identifier being imported.\r\n     * @param name - Name being imported.\r\n     */\r\n    ImportSpecifier.prototype.setName = function (name) {\r\n        var nameNode = this.getNameNode();\r\n        if (nameNode.getText() === name)\r\n            return this;\r\n        var start = nameNode.getStart();\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: start,\r\n            replacingLength: nameNode.getWidth(),\r\n            newText: name\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the name of the import specifier.\r\n     */\r\n    ImportSpecifier.prototype.getName = function () {\r\n        return this.getNameNode().getText();\r\n    };\r\n    /**\r\n     * Gets the name node of what's being imported.\r\n     */\r\n    ImportSpecifier.prototype.getNameNode = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.propertyName || this.compilerNode.name);\r\n    };\r\n    /**\r\n     * Sets the alias for the name being imported.\r\n     * @param alias - Alias to set.\r\n     */\r\n    ImportSpecifier.prototype.setAlias = function (alias) {\r\n        var aliasIdentifier = this.getAliasNode();\r\n        if (aliasIdentifier == null) {\r\n            // trick is to insert an alias with the same name, then rename the alias. TS compiler will take care of the rest.\r\n            var nameNode = this.getNameNode();\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: nameNode.getEnd(),\r\n                parent: this,\r\n                newText: \" as \" + nameNode.getText()\r\n            });\r\n            aliasIdentifier = this.getAliasNode();\r\n        }\r\n        aliasIdentifier.rename(alias);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the alias identifier, if it exists.\r\n     */\r\n    ImportSpecifier.prototype.getAliasNode = function () {\r\n        if (this.compilerNode.propertyName == null)\r\n            return undefined;\r\n        return this.getNodeFromCompilerNode(this.compilerNode.name);\r\n    };\r\n    /**\r\n     * Gets the import declaration associated with this import specifier.\r\n     */\r\n    ImportSpecifier.prototype.getImportDeclaration = function () {\r\n        return this.getFirstAncestorByKindOrThrow(typescript_1.SyntaxKind.ImportDeclaration);\r\n    };\r\n    /**\r\n     * Remove the import specifier.\r\n     */\r\n    ImportSpecifier.prototype.remove = function () {\r\n        var importDeclaration = this.getImportDeclaration();\r\n        var namedImports = importDeclaration.getNamedImports();\r\n        if (namedImports.length > 1)\r\n            manipulation_1.removeCommaSeparatedChild(this);\r\n        else\r\n            importDeclaration.removeNamedImports();\r\n    };\r\n    return ImportSpecifier;\r\n}(common_1.Node));\r\nexports.ImportSpecifier = ImportSpecifier;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/ImportSpecifier.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/SourceFile.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/SourceFile.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar textSeek_1 = __webpack_require__(/*! ../../manipulation/textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar FileSystemRefreshResult_1 = __webpack_require__(/*! ./FileSystemRefreshResult */ \"./node_modules/ts-simple-ast/dist/compiler/file/FileSystemRefreshResult.js\");\r\n// todo: not sure why I need to explicitly type this in order to get VS to not complain... (TS 2.4.1)\r\nexports.SourceFileBase = base_1.TextInsertableNode(statement_1.StatementedNode(common_1.Node));\r\nvar SourceFile = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SourceFile, _super);\r\n    /**\r\n     * Initializes a new instance.\r\n     * @internal\r\n     * @param context - Project context.\r\n     * @param node - Underlying node.\r\n     */\r\n    function SourceFile(context, node) {\r\n        var _this = \r\n        // start hack :(\r\n        _super.call(this, context, node, undefined) || this;\r\n        /** @internal */\r\n        _this._isSaved = false;\r\n        /** @internal */\r\n        _this._modifiedEventContainer = new utils_1.EventContainer();\r\n        /** @internal */\r\n        _this._referenceContainer = new utils_1.SourceFileReferenceContainer(_this);\r\n        _this.sourceFile = _this;\r\n        return _this;\r\n        // end hack\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    SourceFile.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.SourceFileBase.prototype, this, structure);\r\n        if (structure.imports != null)\r\n            this.addImportDeclarations(structure.imports);\r\n        if (structure.exports != null)\r\n            this.addExportDeclarations(structure.exports);\r\n        return this;\r\n    };\r\n    /**\r\n     * @internal\r\n     *\r\n     * WARNING: This should only be called by the compiler factory!\r\n     */\r\n    SourceFile.prototype.replaceCompilerNodeFromFactory = function (compilerNode) {\r\n        _super.prototype.replaceCompilerNodeFromFactory.call(this, compilerNode);\r\n        this.context.resetProgram(); // make sure the program has the latest source file\r\n        this._isSaved = false;\r\n        this._modifiedEventContainer.fire(this);\r\n    };\r\n    /**\r\n     * Gets the file path.\r\n     */\r\n    SourceFile.prototype.getFilePath = function () {\r\n        return this.compilerNode.fileName;\r\n    };\r\n    /**\r\n     * Gets the file path's base name.\r\n     */\r\n    SourceFile.prototype.getBaseName = function () {\r\n        return utils_1.FileUtils.getBaseName(this.getFilePath());\r\n    };\r\n    /**\r\n     * Gets the file path's base name without the extension.\r\n     */\r\n    SourceFile.prototype.getBaseNameWithoutExtension = function () {\r\n        var baseName = this.getBaseName();\r\n        var extension = this.getExtension();\r\n        return baseName.substring(0, baseName.length - extension.length);\r\n    };\r\n    /**\r\n     * Gets the file path's extension.\r\n     */\r\n    SourceFile.prototype.getExtension = function () {\r\n        return utils_1.FileUtils.getExtension(this.getFilePath());\r\n    };\r\n    /**\r\n     * Gets the directory that the source file is contained in.\r\n     */\r\n    SourceFile.prototype.getDirectory = function () {\r\n        return this.context.compilerFactory.getDirectoryFromCache(this.getDirectoryPath());\r\n    };\r\n    /**\r\n     * Gets the directory path that the source file is contained in.\r\n     */\r\n    SourceFile.prototype.getDirectoryPath = function () {\r\n        return utils_1.FileUtils.getDirPath(this.compilerNode.fileName);\r\n    };\r\n    /**\r\n     * Gets the full text with leading trivia.\r\n     */\r\n    SourceFile.prototype.getFullText = function () {\r\n        // return the string instead of letting Node.getFullText() do a substring to prevent an extra allocation\r\n        return this.compilerNode.text;\r\n    };\r\n    /**\r\n     * Gets the line number at the provided position.\r\n     * @param pos - Position\r\n     */\r\n    SourceFile.prototype.getLineNumberAtPos = function (pos) {\r\n        return utils_1.StringUtils.getLineNumberAtPos(this.getFullText(), pos);\r\n    };\r\n    /**\r\n     * Gets the character count from the start of the line to the provided position.\r\n     * @param pos - Position.\r\n     */\r\n    SourceFile.prototype.getLengthFromLineStartAtPos = function (pos) {\r\n        return utils_1.StringUtils.getLengthFromLineStartAtPos(this.getFullText(), pos);\r\n    };\r\n    /**\r\n     * Copy this source file to a new file.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for copying.\r\n     */\r\n    SourceFile.prototype.copy = function (filePath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var result = this._copyInternal(filePath, options);\r\n        if (result === false)\r\n            return this;\r\n        var copiedSourceFile = result;\r\n        if (copiedSourceFile.getDirectoryPath() !== this.getDirectoryPath())\r\n            copiedSourceFile._updateReferencesForCopyInternal(this._getReferencesForCopyInternal());\r\n        return copiedSourceFile;\r\n    };\r\n    /** @internal */\r\n    SourceFile.prototype._copyInternal = function (filePath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.overwrite, overwrite = _a === void 0 ? false : _a;\r\n        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath, this.getDirectoryPath());\r\n        if (filePath === this.getFilePath())\r\n            return false;\r\n        return getCopiedSourceFile(this);\r\n        function getCopiedSourceFile(currentFile) {\r\n            try {\r\n                return currentFile.context.compilerFactory.createSourceFileFromText(filePath, currentFile.getFullText(), { overwrite: overwrite });\r\n            }\r\n            catch (err) {\r\n                if (err instanceof errors.InvalidOperationError)\r\n                    throw new errors.InvalidOperationError(\"Did you mean to provide the overwrite option? \" + err.message);\r\n                else\r\n                    throw err;\r\n            }\r\n        }\r\n    };\r\n    /** @internal */\r\n    SourceFile.prototype._getReferencesForCopyInternal = function () {\r\n        return utils_1.ArrayUtils.from(this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries());\r\n    };\r\n    /** @internal */\r\n    SourceFile.prototype._updateReferencesForCopyInternal = function (literalReferences) {\r\n        var e_1, _a;\r\n        try {\r\n            // update the nodes in this list to point to the nodes in this copied source file\r\n            for (var literalReferences_1 = tslib_1.__values(literalReferences), literalReferences_1_1 = literalReferences_1.next(); !literalReferences_1_1.done; literalReferences_1_1 = literalReferences_1.next()) {\r\n                var reference = literalReferences_1_1.value;\r\n                reference[0] = this.getChildSyntaxListOrThrow().getDescendantAtStartWithWidth(reference[0].getStart(), reference[0].getWidth());\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (literalReferences_1_1 && !literalReferences_1_1.done && (_a = literalReferences_1.return)) _a.call(literalReferences_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        // update the string literals in the copied file\r\n        updateStringLiteralReferences(literalReferences);\r\n    };\r\n    /**\r\n     * Copy this source file to a new file and immediately saves it to the file system asynchronously.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for copying.\r\n     */\r\n    SourceFile.prototype.copyImmediately = function (filePath, options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var newSourceFile;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        newSourceFile = this.copy(filePath, options);\r\n                        return [4 /*yield*/, newSourceFile.save()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, newSourceFile];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Copy this source file to a new file and immediately saves it to the file system synchronously.\r\n     *\r\n     * This will modify the module specifiers in the new file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for copying.\r\n     */\r\n    SourceFile.prototype.copyImmediatelySync = function (filePath, options) {\r\n        var newSourceFile = this.copy(filePath, options);\r\n        newSourceFile.saveSync();\r\n        return newSourceFile;\r\n    };\r\n    /**\r\n     * Moves this source file to a new file.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for moving.\r\n     */\r\n    SourceFile.prototype.move = function (filePath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var oldDirPath = this.getDirectoryPath();\r\n        var sourceFileReferences = this._getReferencesForMoveInternal();\r\n        var oldFilePath = this.getFilePath();\r\n        if (!this._moveInternal(filePath, options))\r\n            return this;\r\n        this.context.fileSystemWrapper.queueFileDelete(oldFilePath);\r\n        this._updateReferencesForMoveInternal(sourceFileReferences, oldDirPath);\r\n        // ignore any modifications in other source files\r\n        this.context.lazyReferenceCoordinator.clearDirtySourceFiles();\r\n        // need to add the current source file as being dirty because it was removed and added to the cache in the move\r\n        this.context.lazyReferenceCoordinator.addDirtySourceFile(this);\r\n        return this;\r\n    };\r\n    /** @internal */\r\n    SourceFile.prototype._moveInternal = function (filePath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.overwrite, overwrite = _a === void 0 ? false : _a;\r\n        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath, this.getDirectoryPath());\r\n        if (filePath === this.getFilePath())\r\n            return false;\r\n        if (overwrite) {\r\n            // remove the past file if it exists\r\n            var existingSourceFile = this.context.compilerFactory.getSourceFileFromCacheFromFilePath(filePath);\r\n            if (existingSourceFile != null)\r\n                existingSourceFile.forget();\r\n        }\r\n        else\r\n            this.context.compilerFactory.throwIfFileExists(filePath, \"Did you mean to provide the overwrite option?\");\r\n        manipulation_1.replaceSourceFileForFilePathMove({\r\n            newFilePath: filePath,\r\n            sourceFile: this\r\n        });\r\n        return true;\r\n    };\r\n    /** @internal */\r\n    SourceFile.prototype._getReferencesForMoveInternal = function () {\r\n        return {\r\n            literalReferences: utils_1.ArrayUtils.from(this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries()),\r\n            referencingLiterals: utils_1.ArrayUtils.from(this._referenceContainer.getReferencingLiteralsInOtherSourceFiles())\r\n        };\r\n    };\r\n    /** @internal */\r\n    SourceFile.prototype._updateReferencesForMoveInternal = function (sourceFileReferences, oldDirPath) {\r\n        var _this = this;\r\n        var literalReferences = sourceFileReferences.literalReferences, referencingLiterals = sourceFileReferences.referencingLiterals;\r\n        // update the literals in this file if the directory has changed\r\n        if (oldDirPath !== this.getDirectoryPath())\r\n            updateStringLiteralReferences(literalReferences);\r\n        // update the string literals in other files\r\n        updateStringLiteralReferences(referencingLiterals.map(function (node) { return ([node, _this]); }));\r\n    };\r\n    /**\r\n     * Moves this source file to a new file and asynchronously updates the file system immediately.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for moving.\r\n     */\r\n    SourceFile.prototype.moveImmediately = function (filePath, options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var oldFilePath, newFilePath;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        oldFilePath = this.getFilePath();\r\n                        newFilePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath, this.getDirectoryPath());\r\n                        this.move(filePath, options);\r\n                        if (!(oldFilePath !== newFilePath)) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.context.fileSystemWrapper.moveFileImmediately(oldFilePath, newFilePath, this.getFullText())];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this._isSaved = true;\r\n                        return [3 /*break*/, 4];\r\n                    case 2: return [4 /*yield*/, this.save()];\r\n                    case 3:\r\n                        _a.sent();\r\n                        _a.label = 4;\r\n                    case 4: return [2 /*return*/, this];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Moves this source file to a new file and synchronously updates the file system immediately.\r\n     *\r\n     * This will modify the module specifiers in other files that specify this file and the module specifiers in the current file, if necessary.\r\n     * @param filePath - New file path. Can be relative to the original file or an absolute path.\r\n     * @param options - Options for moving.\r\n     */\r\n    SourceFile.prototype.moveImmediatelySync = function (filePath, options) {\r\n        var oldFilePath = this.getFilePath();\r\n        var newFilePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath, this.getDirectoryPath());\r\n        this.move(filePath, options);\r\n        if (oldFilePath !== newFilePath) {\r\n            this.context.fileSystemWrapper.moveFileImmediatelySync(oldFilePath, newFilePath, this.getFullText());\r\n            this._isSaved = true;\r\n        }\r\n        else\r\n            this.saveSync();\r\n        return this;\r\n    };\r\n    /**\r\n     * Queues a deletion of the file to the file system.\r\n     *\r\n     * The file will be deleted when you call ast.save(). If you wish to immediately delete the file, then use deleteImmediately().\r\n     */\r\n    SourceFile.prototype.delete = function () {\r\n        var filePath = this.getFilePath();\r\n        this.forget();\r\n        this.context.fileSystemWrapper.queueFileDelete(filePath);\r\n    };\r\n    /**\r\n     * Asynchronously deletes the file from the file system.\r\n     */\r\n    SourceFile.prototype.deleteImmediately = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var filePath;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        filePath = this.getFilePath();\r\n                        this.forget();\r\n                        return [4 /*yield*/, this.context.fileSystemWrapper.deleteFileImmediately(filePath)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronously deletes the file from the file system.\r\n     */\r\n    SourceFile.prototype.deleteImmediatelySync = function () {\r\n        var filePath = this.getFilePath();\r\n        this.forget();\r\n        this.context.fileSystemWrapper.deleteFileImmediatelySync(filePath);\r\n    };\r\n    /**\r\n     * Asynchronously saves this file with any changes.\r\n     */\r\n    SourceFile.prototype.save = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.context.fileSystemWrapper.writeFile(this.getFilePath(), this.getFullText())];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this._isSaved = true;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronously saves this file with any changes.\r\n     */\r\n    SourceFile.prototype.saveSync = function () {\r\n        this.context.fileSystemWrapper.writeFileSync(this.getFilePath(), this.getFullText());\r\n        this._isSaved = true;\r\n    };\r\n    /**\r\n     * Gets any referenced files.\r\n     */\r\n    SourceFile.prototype.getReferencedFiles = function () {\r\n        var _this = this;\r\n        // todo: add tests\r\n        var dirPath = this.getDirectoryPath();\r\n        return (this.compilerNode.referencedFiles || [])\r\n            .map(function (f) { return _this.context.compilerFactory.addOrGetSourceFileFromFilePath(utils_1.FileUtils.pathJoin(dirPath, f.fileName)); })\r\n            .filter(function (f) { return f != null; });\r\n    };\r\n    /**\r\n     * Gets the source files for any type reference directives.\r\n     */\r\n    SourceFile.prototype.getTypeReferenceDirectives = function () {\r\n        var _this = this;\r\n        // todo: add tests\r\n        var dirPath = this.getDirectoryPath();\r\n        return (this.compilerNode.typeReferenceDirectives || [])\r\n            .map(function (f) { return _this.context.compilerFactory.addOrGetSourceFileFromFilePath(utils_1.FileUtils.pathJoin(dirPath, f.fileName)); })\r\n            .filter(function (f) { return f != null; });\r\n    };\r\n    /**\r\n     * Get any source files that reference this source file.\r\n     */\r\n    SourceFile.prototype.getReferencingSourceFiles = function () {\r\n        return utils_1.ArrayUtils.from(this._referenceContainer.getDependentSourceFiles());\r\n    };\r\n    /**\r\n     * Gets the import and exports in other source files that reference this source file.\r\n     */\r\n    SourceFile.prototype.getReferencingNodesInOtherSourceFiles = function () {\r\n        return utils_1.ArrayUtils.from(this._referenceContainer.getReferencingNodesInOtherSourceFiles());\r\n    };\r\n    /**\r\n     * Gets the string literals in other source files that reference this source file.\r\n     */\r\n    SourceFile.prototype.getReferencingLiteralsInOtherSourceFiles = function () {\r\n        return utils_1.ArrayUtils.from(this._referenceContainer.getReferencingLiteralsInOtherSourceFiles());\r\n    };\r\n    /**\r\n     * Gets all the descendant string literals that reference a source file.\r\n     */\r\n    SourceFile.prototype.getImportStringLiterals = function () {\r\n        var _this = this;\r\n        this.ensureBound();\r\n        var literals = (this.compilerNode.imports || []);\r\n        return literals.filter(function (l) { return (l.flags & typescript_1.ts.NodeFlags.Synthesized) === 0; }).map(function (l) { return _this.getNodeFromCompilerNode(l); });\r\n    };\r\n    /**\r\n     * Gets the script target of the source file.\r\n     */\r\n    SourceFile.prototype.getLanguageVersion = function () {\r\n        return this.compilerNode.languageVersion;\r\n    };\r\n    /**\r\n     * Gets the language variant of the source file.\r\n     */\r\n    SourceFile.prototype.getLanguageVariant = function () {\r\n        return this.compilerNode.languageVariant;\r\n    };\r\n    /**\r\n     * Gets if this is a declaration file.\r\n     */\r\n    SourceFile.prototype.isDeclarationFile = function () {\r\n        return this.compilerNode.isDeclarationFile;\r\n    };\r\n    /**\r\n     * Gets if the source file is from an external library.\r\n     */\r\n    SourceFile.prototype.isFromExternalLibrary = function () {\r\n        return this.context.program.isSourceFileFromExternalLibrary(this);\r\n    };\r\n    /**\r\n     * Gets if this source file has been saved or if the latest changes have been saved.\r\n     */\r\n    SourceFile.prototype.isSaved = function () {\r\n        return this._isSaved;\r\n    };\r\n    /**\r\n     * Sets if this source file has been saved.\r\n     * @internal\r\n     */\r\n    SourceFile.prototype.setIsSaved = function (value) {\r\n        this._isSaved = value;\r\n    };\r\n    /**\r\n     * Adds an import.\r\n     * @param structure - Structure that represents the import.\r\n     */\r\n    SourceFile.prototype.addImportDeclaration = function (structure) {\r\n        return this.addImportDeclarations([structure])[0];\r\n    };\r\n    /**\r\n     * Adds imports.\r\n     * @param structures - Structures that represent the imports.\r\n     */\r\n    SourceFile.prototype.addImportDeclarations = function (structures) {\r\n        var imports = this.getImportDeclarations();\r\n        var insertIndex = imports.length === 0 ? 0 : imports[imports.length - 1].getChildIndex() + 1;\r\n        return this.insertImportDeclarations(insertIndex, structures);\r\n    };\r\n    /**\r\n     * Insert an import.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the import.\r\n     */\r\n    SourceFile.prototype.insertImportDeclaration = function (index, structure) {\r\n        return this.insertImportDeclarations(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert imports into a file.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the imports to insert.\r\n     */\r\n    SourceFile.prototype.insertImportDeclarations = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertChildren({\r\n            expectedKind: typescript_1.SyntaxKind.ImportDeclaration,\r\n            index: index,\r\n            structures: structures,\r\n            write: function (writer, info) {\r\n                _this._standardWrite(writer, info, function () {\r\n                    _this.context.structurePrinterFactory.forImportDeclaration().printTexts(writer, structures);\r\n                }, {\r\n                    previousNewLine: function (previousMember) { return utils_1.TypeGuards.isImportDeclaration(previousMember); },\r\n                    nextNewLine: function (nextMember) { return utils_1.TypeGuards.isImportDeclaration(nextMember); }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the first import declaration that matches a condition, or undefined if it doesn't exist.\r\n     * @param condition - Condition to get the import by.\r\n     */\r\n    SourceFile.prototype.getImportDeclaration = function (condition) {\r\n        return utils_1.ArrayUtils.find(this.getImportDeclarations(), condition);\r\n    };\r\n    /**\r\n     * Gets the first import declaration that matches a condition, or throws if it doesn't exist.\r\n     * @param condition - Condition to get the import by.\r\n     */\r\n    SourceFile.prototype.getImportDeclarationOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getImportDeclaration(condition), \"Expected to find an import with the provided condition.\");\r\n    };\r\n    /**\r\n     * Get the file's import declarations.\r\n     */\r\n    SourceFile.prototype.getImportDeclarations = function () {\r\n        // todo: remove type assertion\r\n        return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ImportDeclaration);\r\n    };\r\n    /**\r\n     * Add export declarations.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    SourceFile.prototype.addExportDeclaration = function (structure) {\r\n        return this.addExportDeclarations([structure])[0];\r\n    };\r\n    /**\r\n     * Add export declarations.\r\n     * @param structures - Structures that represent the exports.\r\n     */\r\n    SourceFile.prototype.addExportDeclarations = function (structures) {\r\n        // always insert at end of file because of export {Identifier}; statements\r\n        return this.insertExportDeclarations(this.getChildSyntaxListOrThrow().getChildCount(), structures);\r\n    };\r\n    /**\r\n     * Insert an export declaration.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    SourceFile.prototype.insertExportDeclaration = function (index, structure) {\r\n        return this.insertExportDeclarations(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert export declarations into a file.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the exports to insert.\r\n     */\r\n    SourceFile.prototype.insertExportDeclarations = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertChildren({\r\n            expectedKind: typescript_1.SyntaxKind.ExportDeclaration,\r\n            index: index,\r\n            structures: structures,\r\n            write: function (writer, info) {\r\n                _this._standardWrite(writer, info, function () {\r\n                    _this.context.structurePrinterFactory.forExportDeclaration().printTexts(writer, structures);\r\n                }, {\r\n                    previousNewLine: function (previousMember) { return utils_1.TypeGuards.isExportDeclaration(previousMember); },\r\n                    nextNewLine: function (nextMember) { return utils_1.TypeGuards.isExportDeclaration(nextMember); }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the first export declaration that matches a condition, or undefined if it doesn't exist.\r\n     * @param condition - Condition to get the export declaration by.\r\n     */\r\n    SourceFile.prototype.getExportDeclaration = function (condition) {\r\n        return utils_1.ArrayUtils.find(this.getExportDeclarations(), condition);\r\n    };\r\n    /**\r\n     * Gets the first export declaration that matches a condition, or throws if it doesn't exist.\r\n     * @param condition - Condition to get the export declaration by.\r\n     */\r\n    SourceFile.prototype.getExportDeclarationOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getExportDeclaration(condition), \"Expected to find an export declaration with the provided condition.\");\r\n    };\r\n    /**\r\n     * Get the file's export declarations.\r\n     */\r\n    SourceFile.prototype.getExportDeclarations = function () {\r\n        return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ExportDeclaration);\r\n    };\r\n    /**\r\n     * Gets the export symbols of the source file.\r\n     */\r\n    SourceFile.prototype.getExportSymbols = function () {\r\n        var symbol = this.getSymbol();\r\n        return symbol == null ? [] : this.context.typeChecker.getExportsOfModule(symbol);\r\n    };\r\n    /**\r\n     * Gets all the declarations that are exported from the file.\r\n     *\r\n     * This will include declarations that are transitively exported from other files. If you mean to get the export\r\n     * declarations then use sourceFile.getExportDeclarations().\r\n     */\r\n    SourceFile.prototype.getExportedDeclarations = function () {\r\n        var exportSymbols = this.getExportSymbols();\r\n        return utils_1.ArrayUtils.from(getDeclarationsForSymbols());\r\n        function getDeclarationsForSymbols() {\r\n            function getDeclarationHandlingExportSpecifiers(declaration) {\r\n                var e_4, _a, e_5, _b, _c, _d, d, e_4_1, identifier, symbol, _e, _f, d, e_5_1;\r\n                return tslib_1.__generator(this, function (_g) {\r\n                    switch (_g.label) {\r\n                        case 0:\r\n                            if (handledDeclarations.has(declaration))\r\n                                return [2 /*return*/];\r\n                            handledDeclarations.add(declaration);\r\n                            if (!(declaration.getKind() === typescript_1.SyntaxKind.ExportSpecifier)) return [3 /*break*/, 9];\r\n                            _g.label = 1;\r\n                        case 1:\r\n                            _g.trys.push([1, 6, 7, 8]);\r\n                            _c = tslib_1.__values(declaration.getLocalTargetDeclarations()), _d = _c.next();\r\n                            _g.label = 2;\r\n                        case 2:\r\n                            if (!!_d.done) return [3 /*break*/, 5];\r\n                            d = _d.value;\r\n                            return [5 /*yield**/, tslib_1.__values(getDeclarationHandlingExportSpecifiers(d))];\r\n                        case 3:\r\n                            _g.sent();\r\n                            _g.label = 4;\r\n                        case 4:\r\n                            _d = _c.next();\r\n                            return [3 /*break*/, 2];\r\n                        case 5: return [3 /*break*/, 8];\r\n                        case 6:\r\n                            e_4_1 = _g.sent();\r\n                            e_4 = { error: e_4_1 };\r\n                            return [3 /*break*/, 8];\r\n                        case 7:\r\n                            try {\r\n                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n                            }\r\n                            finally { if (e_4) throw e_4.error; }\r\n                            return [7 /*endfinally*/];\r\n                        case 8: return [3 /*break*/, 20];\r\n                        case 9:\r\n                            if (!(declaration.getKind() === typescript_1.SyntaxKind.ExportAssignment)) return [3 /*break*/, 18];\r\n                            identifier = declaration.getExpression();\r\n                            if (identifier == null || identifier.getKind() !== typescript_1.SyntaxKind.Identifier)\r\n                                return [2 /*return*/];\r\n                            symbol = identifier.getSymbol();\r\n                            if (symbol == null)\r\n                                return [2 /*return*/];\r\n                            _g.label = 10;\r\n                        case 10:\r\n                            _g.trys.push([10, 15, 16, 17]);\r\n                            _e = tslib_1.__values(symbol.getDeclarations()), _f = _e.next();\r\n                            _g.label = 11;\r\n                        case 11:\r\n                            if (!!_f.done) return [3 /*break*/, 14];\r\n                            d = _f.value;\r\n                            return [5 /*yield**/, tslib_1.__values(getDeclarationHandlingExportSpecifiers(d))];\r\n                        case 12:\r\n                            _g.sent();\r\n                            _g.label = 13;\r\n                        case 13:\r\n                            _f = _e.next();\r\n                            return [3 /*break*/, 11];\r\n                        case 14: return [3 /*break*/, 17];\r\n                        case 15:\r\n                            e_5_1 = _g.sent();\r\n                            e_5 = { error: e_5_1 };\r\n                            return [3 /*break*/, 17];\r\n                        case 16:\r\n                            try {\r\n                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                            }\r\n                            finally { if (e_5) throw e_5.error; }\r\n                            return [7 /*endfinally*/];\r\n                        case 17: return [3 /*break*/, 20];\r\n                        case 18: return [4 /*yield*/, declaration];\r\n                        case 19:\r\n                            _g.sent();\r\n                            _g.label = 20;\r\n                        case 20: return [2 /*return*/];\r\n                    }\r\n                });\r\n            }\r\n            var e_2, _a, e_3, _b, handledDeclarations, exportSymbols_1, exportSymbols_1_1, symbol, _c, _d, declaration, e_3_1, e_2_1;\r\n            return tslib_1.__generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        handledDeclarations = utils_1.createHashSet();\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        _e.trys.push([1, 12, 13, 14]);\r\n                        exportSymbols_1 = tslib_1.__values(exportSymbols), exportSymbols_1_1 = exportSymbols_1.next();\r\n                        _e.label = 2;\r\n                    case 2:\r\n                        if (!!exportSymbols_1_1.done) return [3 /*break*/, 11];\r\n                        symbol = exportSymbols_1_1.value;\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        _e.trys.push([3, 8, 9, 10]);\r\n                        _c = tslib_1.__values(symbol.getDeclarations()), _d = _c.next();\r\n                        _e.label = 4;\r\n                    case 4:\r\n                        if (!!_d.done) return [3 /*break*/, 7];\r\n                        declaration = _d.value;\r\n                        return [5 /*yield**/, tslib_1.__values(getDeclarationHandlingExportSpecifiers(declaration))];\r\n                    case 5:\r\n                        _e.sent();\r\n                        _e.label = 6;\r\n                    case 6:\r\n                        _d = _c.next();\r\n                        return [3 /*break*/, 4];\r\n                    case 7: return [3 /*break*/, 10];\r\n                    case 8:\r\n                        e_3_1 = _e.sent();\r\n                        e_3 = { error: e_3_1 };\r\n                        return [3 /*break*/, 10];\r\n                    case 9:\r\n                        try {\r\n                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\r\n                        }\r\n                        finally { if (e_3) throw e_3.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 10:\r\n                        exportSymbols_1_1 = exportSymbols_1.next();\r\n                        return [3 /*break*/, 2];\r\n                    case 11: return [3 /*break*/, 14];\r\n                    case 12:\r\n                        e_2_1 = _e.sent();\r\n                        e_2 = { error: e_2_1 };\r\n                        return [3 /*break*/, 14];\r\n                    case 13:\r\n                        try {\r\n                            if (exportSymbols_1_1 && !exportSymbols_1_1.done && (_a = exportSymbols_1.return)) _a.call(exportSymbols_1);\r\n                        }\r\n                        finally { if (e_2) throw e_2.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 14: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Add export assignments.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    SourceFile.prototype.addExportAssignment = function (structure) {\r\n        return this.addExportAssignments([structure])[0];\r\n    };\r\n    /**\r\n     * Add export assignments.\r\n     * @param structures - Structures that represent the exports.\r\n     */\r\n    SourceFile.prototype.addExportAssignments = function (structures) {\r\n        // always insert at end of file because of export {Identifier}; statements\r\n        return this.insertExportAssignments(this.getChildSyntaxListOrThrow().getChildCount(), structures);\r\n    };\r\n    /**\r\n     * Insert an export assignment.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure that represents the export.\r\n     */\r\n    SourceFile.prototype.insertExportAssignment = function (index, structure) {\r\n        return this.insertExportAssignments(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Insert export assignments into a file.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures that represent the exports to insert.\r\n     */\r\n    SourceFile.prototype.insertExportAssignments = function (index, structures) {\r\n        var _this = this;\r\n        return this._insertChildren({\r\n            expectedKind: typescript_1.SyntaxKind.ExportAssignment,\r\n            index: index,\r\n            structures: structures,\r\n            write: function (writer, info) {\r\n                _this._standardWrite(writer, info, function () {\r\n                    _this.context.structurePrinterFactory.forExportAssignment().printTexts(writer, structures);\r\n                }, {\r\n                    previousNewLine: function (previousMember) { return utils_1.TypeGuards.isExportAssignment(previousMember); },\r\n                    nextNewLine: function (nextMember) { return utils_1.TypeGuards.isExportAssignment(nextMember); }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the first export assignment that matches a condition, or undefined if it doesn't exist.\r\n     * @param condition - Condition to get the export assignment by.\r\n     */\r\n    SourceFile.prototype.getExportAssignment = function (condition) {\r\n        return utils_1.ArrayUtils.find(this.getExportAssignments(), condition);\r\n    };\r\n    /**\r\n     * Gets the first export assignment that matches a condition, or throws if it doesn't exist.\r\n     * @param condition - Condition to get the export assignment by.\r\n     */\r\n    SourceFile.prototype.getExportAssignmentOrThrow = function (condition) {\r\n        return errors.throwIfNullOrUndefined(this.getExportAssignment(condition), \"Expected to find an export assignment with the provided condition.\");\r\n    };\r\n    /**\r\n     * Get the file's export assignments.\r\n     */\r\n    SourceFile.prototype.getExportAssignments = function () {\r\n        return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ExportAssignment);\r\n    };\r\n    /**\r\n     * Gets the default export symbol of the file.\r\n     */\r\n    SourceFile.prototype.getDefaultExportSymbol = function () {\r\n        var sourceFileSymbol = this.getSymbol();\r\n        // will be undefined when the source file doesn't have an export\r\n        if (sourceFileSymbol == null)\r\n            return undefined;\r\n        return sourceFileSymbol.getExportByName(\"default\");\r\n    };\r\n    /**\r\n     * Gets the default export symbol of the file or throws if it doesn't exist.\r\n     */\r\n    SourceFile.prototype.getDefaultExportSymbolOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDefaultExportSymbol(), \"Expected to find a default export symbol\");\r\n    };\r\n    /**\r\n     * Gets the pre-emit diagnostics of the specified source file.\r\n     */\r\n    SourceFile.prototype.getPreEmitDiagnostics = function () {\r\n        return this.context.getPreEmitDiagnostics(this);\r\n    };\r\n    /**\r\n     * Removes any \"export default\";\r\n     */\r\n    SourceFile.prototype.removeDefaultExport = function (defaultExportSymbol) {\r\n        defaultExportSymbol = defaultExportSymbol || this.getDefaultExportSymbol();\r\n        if (defaultExportSymbol == null)\r\n            return this;\r\n        var declaration = defaultExportSymbol.getDeclarations()[0];\r\n        if (declaration.compilerNode.kind === typescript_1.SyntaxKind.ExportAssignment)\r\n            manipulation_1.removeChildrenWithFormatting({ children: [declaration], getSiblingFormatting: function () { return manipulation_1.FormattingKind.Newline; } });\r\n        else if (utils_1.TypeGuards.isModifierableNode(declaration)) {\r\n            declaration.toggleModifier(\"default\", false);\r\n            declaration.toggleModifier(\"export\", false);\r\n        }\r\n        return this;\r\n    };\r\n    SourceFile.prototype.unindent = function (positionRangeOrPos, times) {\r\n        if (times === void 0) { times = 1; }\r\n        return this.indent(positionRangeOrPos, times * -1);\r\n    };\r\n    SourceFile.prototype.indent = function (positionRangeOrPos, times) {\r\n        if (times === void 0) { times = 1; }\r\n        var e_6, _a;\r\n        if (times === 0)\r\n            return this;\r\n        var sourceFileText = this.getFullText();\r\n        var positionRange = typeof positionRangeOrPos === \"number\" ? [positionRangeOrPos, positionRangeOrPos] : positionRangeOrPos;\r\n        errors.throwIfRangeOutOfRange(positionRange, [0, sourceFileText.length], \"positionRange\");\r\n        var startLinePos = textSeek_1.getPreviousMatchingPos(sourceFileText, positionRange[0], function (char) { return char === \"\\n\"; });\r\n        var endLinePos = textSeek_1.getNextMatchingPos(sourceFileText, positionRange[1], function (char) { return char === \"\\r\" || char === \"\\n\"; });\r\n        var indentText = this.context.manipulationSettings.getIndentationText();\r\n        var unindentRegex = times > 0 ? undefined : new RegExp(getDeindentRegexText());\r\n        var pos = startLinePos;\r\n        var newLines = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(sourceFileText.substring(startLinePos, endLinePos).split(\"\\n\")), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var line = _c.value;\r\n                if (this.isInStringAtPos(pos))\r\n                    newLines.push(line);\r\n                else if (times > 0)\r\n                    newLines.push(utils_1.StringUtils.repeat(indentText, times) + line);\r\n                else // negative\r\n                    newLines.push(line.replace(unindentRegex, \"\"));\r\n                pos += line.length;\r\n            }\r\n        }\r\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_6) throw e_6.error; }\r\n        }\r\n        manipulation_1.replaceSourceFileTextForFormatting({\r\n            sourceFile: this,\r\n            newText: sourceFileText.substring(0, startLinePos) + newLines.join(\"\\n\") + sourceFileText.substring(endLinePos)\r\n        });\r\n        return this;\r\n        function getDeindentRegexText() {\r\n            var isSpaces = /^ +$/;\r\n            var text = \"^\";\r\n            for (var i = 0; i < Math.abs(times); i++) {\r\n                text += \"(\";\r\n                if (isSpaces.test(indentText)) {\r\n                    // the optional string makes it possible to unindent when a line doesn't have the full number of spaces\r\n                    for (var j = 0; j < indentText.length; j++)\r\n                        text += \" ?\";\r\n                }\r\n                else\r\n                    text += indentText;\r\n                text += \"|\\t)?\";\r\n            }\r\n            return text;\r\n        }\r\n    };\r\n    /**\r\n     * Emits the source file.\r\n     */\r\n    SourceFile.prototype.emit = function (options) {\r\n        return this.context.program.emit(tslib_1.__assign({ targetSourceFile: this }, options));\r\n    };\r\n    /**\r\n     * Gets the emit output of this source file.\r\n     * @param options - Emit options.\r\n     */\r\n    SourceFile.prototype.getEmitOutput = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        return this.context.languageService.getEmitOutput(this, options.emitOnlyDtsFiles || false);\r\n    };\r\n    /**\r\n     * Formats the source file text using the internal TypeScript formatting API.\r\n     * @param settings - Format code settings.\r\n     */\r\n    SourceFile.prototype.formatText = function (settings) {\r\n        if (settings === void 0) { settings = {}; }\r\n        manipulation_1.replaceSourceFileTextForFormatting({\r\n            sourceFile: this,\r\n            newText: this.context.languageService.getFormattedDocumentText(this.getFilePath(), settings)\r\n        });\r\n    };\r\n    /**\r\n     * Refresh the source file from the file system.\r\n     *\r\n     * WARNING: When updating from the file system, this will \"forget\" any previously navigated nodes.\r\n     * @returns What action ended up taking place.\r\n     */\r\n    SourceFile.prototype.refreshFromFileSystem = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var fileReadResult;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.context.fileSystemWrapper.readFileOrNotExists(this.getFilePath(), this.context.getEncoding())];\r\n                    case 1:\r\n                        fileReadResult = _a.sent();\r\n                        return [2 /*return*/, this._refreshFromFileSystemInternal(fileReadResult)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronously refreshes the source file from the file system.\r\n     *\r\n     * WARNING: When updating from the file system, this will \"forget\" any previously navigated nodes.\r\n     * @returns What action ended up taking place.\r\n     */\r\n    SourceFile.prototype.refreshFromFileSystemSync = function () {\r\n        var fileReadResult = this.context.fileSystemWrapper.readFileOrNotExistsSync(this.getFilePath(), this.context.getEncoding());\r\n        return this._refreshFromFileSystemInternal(fileReadResult);\r\n    };\r\n    SourceFile.prototype.getRelativePathTo = function (sourceFileOrDir) {\r\n        return this.getDirectory().getRelativePathTo(sourceFileOrDir);\r\n    };\r\n    SourceFile.prototype.getRelativePathAsModuleSpecifierTo = function (sourceFileOrDir) {\r\n        return this.getDirectory().getRelativePathAsModuleSpecifierTo(sourceFileOrDir);\r\n    };\r\n    /**\r\n     * Subscribe to when the source file is modified.\r\n     * @param subscription - Subscription.\r\n     * @param subscribe - Optional and defaults to true. Use an explicit false to unsubscribe.\r\n     */\r\n    SourceFile.prototype.onModified = function (subscription, subscribe) {\r\n        if (subscribe === void 0) { subscribe = true; }\r\n        if (subscribe)\r\n            this._modifiedEventContainer.subscribe(subscription);\r\n        else\r\n            this._modifiedEventContainer.unsubscribe(subscription);\r\n        return this;\r\n    };\r\n    /**\r\n     * Organizes the imports in the file.\r\n     *\r\n     * WARNING! This will forget all the nodes in the file! It's best to do this after you're all done with the file.\r\n     * @param settings - Format code settings.\r\n     * @param userPreferences - User preferences for refactoring.\r\n     */\r\n    SourceFile.prototype.organizeImports = function (settings, userPreferences) {\r\n        if (settings === void 0) { settings = {}; }\r\n        if (userPreferences === void 0) { userPreferences = {}; }\r\n        this.applyTextChanges(utils_1.ArrayUtils.flatten(this.context.languageService.organizeImports(this, settings, userPreferences).map(function (r) { return r.getTextChanges(); })));\r\n        return this;\r\n    };\r\n    /**\r\n     * Applies the text changes to the source file.\r\n     *\r\n     * WARNING! This will forget all the nodes in the file! It's best to do this after you're all done with the file.\r\n     * @param textChanges - Text changes.\r\n     */\r\n    SourceFile.prototype.applyTextChanges = function (textChanges) {\r\n        this.getChildSyntaxListOrThrow().forget();\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: 0,\r\n            replacingLength: this.getFullWidth(),\r\n            newText: manipulation_1.getTextFromFormattingEdits(this, textChanges)\r\n        });\r\n        return this;\r\n    };\r\n    SourceFile.prototype._refreshFromFileSystemInternal = function (fileReadResult) {\r\n        if (fileReadResult === false) {\r\n            this.forget();\r\n            return FileSystemRefreshResult_1.FileSystemRefreshResult.Deleted;\r\n        }\r\n        var fileText = fileReadResult;\r\n        if (fileText === this.getFullText())\r\n            return FileSystemRefreshResult_1.FileSystemRefreshResult.NoChange;\r\n        this.replaceText([0, this.getEnd()], fileText);\r\n        this.setIsSaved(true); // saved when loaded from file system\r\n        return FileSystemRefreshResult_1.FileSystemRefreshResult.Updated;\r\n    };\r\n    return SourceFile;\r\n}(exports.SourceFileBase));\r\nexports.SourceFile = SourceFile;\r\nfunction updateStringLiteralReferences(nodeReferences) {\r\n    var e_7, _a;\r\n    try {\r\n        for (var nodeReferences_1 = tslib_1.__values(nodeReferences), nodeReferences_1_1 = nodeReferences_1.next(); !nodeReferences_1_1.done; nodeReferences_1_1 = nodeReferences_1.next()) {\r\n            var _b = tslib_1.__read(nodeReferences_1_1.value, 2), stringLiteral = _b[0], sourceFile = _b[1];\r\n            if (utils_1.ModuleUtils.isModuleSpecifierRelative(stringLiteral.getLiteralText()))\r\n                stringLiteral.setLiteralValue(stringLiteral.sourceFile.getRelativePathAsModuleSpecifierTo(sourceFile));\r\n        }\r\n    }\r\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n    finally {\r\n        try {\r\n            if (nodeReferences_1_1 && !nodeReferences_1_1.done && (_a = nodeReferences_1.return)) _a.call(nodeReferences_1);\r\n        }\r\n        finally { if (e_7) throw e_7.error; }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/SourceFile.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/file/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/file/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExportAssignment */ \"./node_modules/ts-simple-ast/dist/compiler/file/ExportAssignment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExportDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/file/ExportDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExportSpecifier */ \"./node_modules/ts-simple-ast/dist/compiler/file/ExportSpecifier.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExternalModuleReference */ \"./node_modules/ts-simple-ast/dist/compiler/file/ExternalModuleReference.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FileSystemRefreshResult */ \"./node_modules/ts-simple-ast/dist/compiler/file/FileSystemRefreshResult.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/file/ImportDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportEqualsDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/file/ImportEqualsDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportSpecifier */ \"./node_modules/ts-simple-ast/dist/compiler/file/ImportSpecifier.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SourceFile */ \"./node_modules/ts-simple-ast/dist/compiler/file/SourceFile.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/file/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/ArrowFunction.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/ArrowFunction.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar FunctionLikeDeclaration_1 = __webpack_require__(/*! ./FunctionLikeDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/function/FunctionLikeDeclaration.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.ArrowFunctionBase = base_1.TextInsertableNode(base_1.BodiedNode(base_1.AsyncableNode(FunctionLikeDeclaration_1.FunctionLikeDeclaration(expression_1.Expression))));\r\nvar ArrowFunction = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrowFunction, _super);\r\n    function ArrowFunction() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the equals greater than token of the arrow function.\r\n     */\r\n    ArrowFunction.prototype.getEqualsGreaterThan = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.equalsGreaterThanToken);\r\n    };\r\n    return ArrowFunction;\r\n}(exports.ArrowFunctionBase));\r\nexports.ArrowFunction = ArrowFunction;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/ArrowFunction.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/FunctionDeclaration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/FunctionDeclaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar getStructureFuncs = __webpack_require__(/*! ../../manipulation/helpers/getStructureFunctions */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar namespace_1 = __webpack_require__(/*! ../namespace */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar FunctionLikeDeclaration_1 = __webpack_require__(/*! ./FunctionLikeDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/function/FunctionLikeDeclaration.js\");\r\nvar OverloadableNode_1 = __webpack_require__(/*! ./OverloadableNode */ \"./node_modules/ts-simple-ast/dist/compiler/function/OverloadableNode.js\");\r\nexports.FunctionDeclarationBase = base_1.ChildOrderableNode(base_1.UnwrappableNode(base_1.TextInsertableNode(OverloadableNode_1.OverloadableNode(base_1.BodyableNode(base_1.AsyncableNode(base_1.GeneratorableNode(FunctionLikeDeclaration_1.FunctionLikeDeclaration(statement_1.StatementedNode(base_1.AmbientableNode(namespace_1.NamespaceChildableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NameableNode(common_1.Node))))))))))))));\r\nvar FunctionDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FunctionDeclaration, _super);\r\n    function FunctionDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    FunctionDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.FunctionDeclarationBase.prototype, this, structure);\r\n        if (structure.overloads != null && structure.overloads.length > 0)\r\n            this.addOverloads(structure.overloads);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a function overload.\r\n     * @param structure - Structure of the overload.\r\n     */\r\n    FunctionDeclaration.prototype.addOverload = function (structure) {\r\n        return this.addOverloads([structure])[0];\r\n    };\r\n    /**\r\n     * Adds function overloads.\r\n     * @param structures - Structures of the overloads.\r\n     */\r\n    FunctionDeclaration.prototype.addOverloads = function (structures) {\r\n        return this.insertOverloads(this.getOverloads().length, structures);\r\n    };\r\n    /**\r\n     * Inserts a function overload.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure of the overload.\r\n     */\r\n    FunctionDeclaration.prototype.insertOverload = function (index, structure) {\r\n        return this.insertOverloads(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts function overloads.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structures of the overloads.\r\n     */\r\n    FunctionDeclaration.prototype.insertOverloads = function (index, structures) {\r\n        var thisName = this.getName();\r\n        var childCodes = structures.map(function (structure) { return \"function \" + thisName + \"();\"; });\r\n        return OverloadableNode_1.insertOverloads({\r\n            node: this,\r\n            index: index,\r\n            structures: structures,\r\n            childCodes: childCodes,\r\n            getThisStructure: getStructureFuncs.fromFunctionDeclarationOverload,\r\n            fillNodeFromStructure: function (node, structure) { return node.fill(structure); },\r\n            expectedSyntaxKind: typescript_1.SyntaxKind.FunctionDeclaration\r\n        });\r\n    };\r\n    /**\r\n     * Removes this function declaration.\r\n     */\r\n    FunctionDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeOverloadableStatementedNodeChild(this);\r\n    };\r\n    return FunctionDeclaration;\r\n}(exports.FunctionDeclarationBase));\r\nexports.FunctionDeclaration = FunctionDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/FunctionDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/FunctionExpression.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/FunctionExpression.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nexports.FunctionExpressionBase = base_1.JSDocableNode(base_1.TextInsertableNode(base_1.BodiedNode(base_1.AsyncableNode(base_1.GeneratorableNode(statement_1.StatementedNode(base_1.TypeParameteredNode(base_1.SignaturedDeclaration(base_1.ModifierableNode(base_1.NameableNode(expression_1.PrimaryExpression))))))))));\r\nvar FunctionExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FunctionExpression, _super);\r\n    function FunctionExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return FunctionExpression;\r\n}(exports.FunctionExpressionBase));\r\nexports.FunctionExpression = FunctionExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/FunctionExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/FunctionLikeDeclaration.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/FunctionLikeDeclaration.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nfunction FunctionLikeDeclaration(Base) {\r\n    return base_1.JSDocableNode(base_1.TypeParameteredNode(base_1.SignaturedDeclaration(statement_1.StatementedNode(base_1.ModifierableNode(Base)))));\r\n}\r\nexports.FunctionLikeDeclaration = FunctionLikeDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/FunctionLikeDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/OverloadableNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/OverloadableNode.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar objectAssign = __webpack_require__(/*! object-assign */ \"object-assign\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction OverloadableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getOverloads = function () {\r\n            return getOverloadsAndImplementation(this).filter(function (n) { return n.isOverload(); });\r\n        };\r\n        class_1.prototype.getImplementation = function () {\r\n            if (this.isImplementation())\r\n                return this;\r\n            return utils_1.ArrayUtils.find(getOverloadsAndImplementation(this), function (n) { return n.isImplementation(); });\r\n        };\r\n        class_1.prototype.getImplementationOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getImplementation(), \"Expected to find a corresponding implementation for the overload.\");\r\n        };\r\n        class_1.prototype.isOverload = function () {\r\n            return !this.isImplementation();\r\n        };\r\n        class_1.prototype.isImplementation = function () {\r\n            return this.getBody() != null;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.OverloadableNode = OverloadableNode;\r\nfunction getOverloadsAndImplementation(node) {\r\n    var parentSyntaxList = node.getParentSyntaxListOrThrow();\r\n    var name = getNameIfNamedNode(node);\r\n    var kind = node.getKind();\r\n    return parentSyntaxList.getChildren().filter(function (n) {\r\n        var hasSameName = getNameIfNamedNode(n) === name;\r\n        var hasSameKind = n.getKind() === kind;\r\n        return hasSameName && hasSameKind;\r\n    });\r\n}\r\nfunction getNameIfNamedNode(node) {\r\n    var nodeAsNamedNode = node;\r\n    if (nodeAsNamedNode.getName instanceof Function)\r\n        return nodeAsNamedNode.getName();\r\n    return undefined;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction insertOverloads(opts) {\r\n    if (opts.structures.length === 0)\r\n        return [];\r\n    var overloads = opts.node.getOverloads();\r\n    var overloadsCount = overloads.length;\r\n    var parentSyntaxList = opts.node.getParentSyntaxListOrThrow();\r\n    var firstIndex = overloads.length > 0 ? overloads[0].getChildIndex() : opts.node.getChildIndex();\r\n    var index = manipulation_1.verifyAndGetIndex(opts.index, overloadsCount);\r\n    var mainIndex = firstIndex + index;\r\n    var thisStructure = opts.getThisStructure(opts.node.getImplementation() || opts.node);\r\n    var structures = tslib_1.__spread(opts.structures);\r\n    for (var i = 0; i < structures.length; i++) {\r\n        structures[i] = objectAssign(objectAssign({}, thisStructure), structures[i]);\r\n        // structures[i] = {...thisStructure, ...structures[i]}; // not supported by TS as of 2.4.1\r\n    }\r\n    var indentationText = opts.node.getIndentationText();\r\n    var newLineKind = opts.node.context.manipulationSettings.getNewLineKindAsString();\r\n    manipulation_1.insertIntoParentTextRange({\r\n        parent: parentSyntaxList,\r\n        insertPos: opts.node.getNonWhitespaceStart(),\r\n        newText: opts.childCodes.map(function (c, i) { return (i > 0 ? indentationText : \"\") + c; }).join(newLineKind) + newLineKind + indentationText\r\n    });\r\n    var children = manipulation_1.getRangeFromArray(parentSyntaxList.getChildren(), mainIndex, structures.length, opts.expectedSyntaxKind);\r\n    // todo: Do not fill here... this should be printed\r\n    children.forEach(function (child, i) {\r\n        opts.fillNodeFromStructure(child, structures[i]);\r\n    });\r\n    return children;\r\n}\r\nexports.insertOverloads = insertOverloads;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/OverloadableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/ParameterDeclaration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/ParameterDeclaration.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.ParameterDeclarationBase = base_1.QuestionTokenableNode(base_1.DecoratableNode(base_1.ScopeableNode(base_1.ReadonlyableNode(base_1.ModifierableNode(base_1.TypedNode(base_1.InitializerExpressionableNode(base_1.DeclarationNamedNode(common_1.Node))))))));\r\nvar ParameterDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParameterDeclaration, _super);\r\n    function ParameterDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    ParameterDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.ParameterDeclarationBase.prototype, this, structure);\r\n        if (structure.isRestParameter != null)\r\n            this.setIsRestParameter(structure.isRestParameter);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the dot dot dot token (...) if it exists, for a rest parameter.\r\n     */\r\n    ParameterDeclaration.prototype.getDotDotDotToken = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);\r\n    };\r\n    /**\r\n     * Gets if it's a rest parameter.\r\n     */\r\n    ParameterDeclaration.prototype.isRestParameter = function () {\r\n        return this.compilerNode.dotDotDotToken != null;\r\n    };\r\n    /**\r\n     * Gets if this is a parameter property.\r\n     */\r\n    ParameterDeclaration.prototype.isParameterProperty = function () {\r\n        return this.getScope() != null || this.isReadonly();\r\n    };\r\n    /**\r\n     * Sets if it's a rest parameter.\r\n     * @param value - Sets if it's a rest parameter or not.\r\n     */\r\n    ParameterDeclaration.prototype.setIsRestParameter = function (value) {\r\n        if (this.isRestParameter() === value)\r\n            return this;\r\n        if (value) {\r\n            addParensIfNecessary(this);\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: this.getNameNodeOrThrow().getStart(),\r\n                parent: this,\r\n                newText: \"...\"\r\n            });\r\n        }\r\n        else\r\n            manipulation_1.removeChildren({ children: [this.getDotDotDotToken()] });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets if it's optional.\r\n     */\r\n    ParameterDeclaration.prototype.isOptional = function () {\r\n        return this.compilerNode.questionToken != null || this.isRestParameter() || this.hasInitializer();\r\n    };\r\n    /**\r\n     * Remove this parameter.\r\n     */\r\n    ParameterDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeCommaSeparatedChild(this);\r\n    };\r\n    // ------ Methods to override to add parens ------\r\n    /**\r\n     * Sets if this node has a question token.\r\n     * @param value - If it should have a question token or not.\r\n     */\r\n    ParameterDeclaration.prototype.setHasQuestionToken = function (value) {\r\n        if (value)\r\n            addParensIfNecessary(this);\r\n        _super.prototype.setHasQuestionToken.call(this, value);\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the initializer.\r\n     * @param text - Text or writer function to set for the initializer.\r\n     */\r\n    ParameterDeclaration.prototype.setInitializer = function (textOrWriterFunction) {\r\n        addParensIfNecessary(this);\r\n        _super.prototype.setInitializer.call(this, textOrWriterFunction);\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the type.\r\n     * @param textOrWriterFunction - Text or writer function to set the type with.\r\n     */\r\n    ParameterDeclaration.prototype.setType = function (textOrWriterFunction) {\r\n        addParensIfNecessary(this);\r\n        _super.prototype.setType.call(this, textOrWriterFunction);\r\n        return this;\r\n    };\r\n    return ParameterDeclaration;\r\n}(exports.ParameterDeclarationBase));\r\nexports.ParameterDeclaration = ParameterDeclaration;\r\nfunction addParensIfNecessary(parameter) {\r\n    var parent = parameter.getParentOrThrow();\r\n    if (isParameterWithoutParens())\r\n        addParens();\r\n    function isParameterWithoutParens() {\r\n        return utils_1.TypeGuards.isArrowFunction(parent)\r\n            && parent.compilerNode.parameters.length === 1\r\n            && parameter.getParentSyntaxListOrThrow().getPreviousSiblingIfKind(typescript_1.SyntaxKind.OpenParenToken) == null;\r\n    }\r\n    function addParens() {\r\n        var paramText = parameter.getText();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            parent: parent,\r\n            insertPos: parameter.getStart(),\r\n            newText: \"(\" + paramText + \")\",\r\n            replacing: {\r\n                textLength: paramText.length\r\n            },\r\n            customMappings: function (newParent) {\r\n                return [{ currentNode: parameter, newNode: newParent.parameters[0] }];\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/ParameterDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/function/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/function/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArrowFunction */ \"./node_modules/ts-simple-ast/dist/compiler/function/ArrowFunction.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FunctionDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/function/FunctionDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FunctionExpression */ \"./node_modules/ts-simple-ast/dist/compiler/function/FunctionExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FunctionLikeDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/function/FunctionLikeDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./OverloadableNode */ \"./node_modules/ts-simple-ast/dist/compiler/function/OverloadableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ParameterDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/function/ParameterDeclaration.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/function/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/general/HeritageClause.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/general/HeritageClause.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar HeritageClause = /** @class */ (function (_super) {\r\n    tslib_1.__extends(HeritageClause, _super);\r\n    function HeritageClause() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets all the type nodes for the heritage clause.\r\n     */\r\n    HeritageClause.prototype.getTypeNodes = function () {\r\n        var _this = this;\r\n        if (this.compilerNode.types == null)\r\n            return [];\r\n        return this.compilerNode.types.map(function (t) { return _this.getNodeFromCompilerNode(t); });\r\n    };\r\n    /**\r\n     * Gets the heritage clause token.\r\n     */\r\n    HeritageClause.prototype.getToken = function () {\r\n        return this.compilerNode.token;\r\n    };\r\n    HeritageClause.prototype.removeExpression = function (expressionNodeOrIndex) {\r\n        var expressions = this.getTypeNodes();\r\n        var expressionNodeToRemove = typeof expressionNodeOrIndex === \"number\" ? getExpressionFromIndex(expressionNodeOrIndex) : expressionNodeOrIndex;\r\n        if (expressions.length === 1) {\r\n            var heritageClauses = this.getParentSyntaxListOrThrow().getChildren();\r\n            if (heritageClauses.length === 1)\r\n                manipulation_1.removeChildren({ children: [heritageClauses[0].getParentSyntaxListOrThrow()], removePrecedingSpaces: true });\r\n            else\r\n                manipulation_1.removeChildren({ children: [this], removePrecedingSpaces: true });\r\n        }\r\n        else\r\n            manipulation_1.removeCommaSeparatedChild(expressionNodeToRemove);\r\n        return this;\r\n        function getExpressionFromIndex(index) {\r\n            return expressions[manipulation_1.verifyAndGetIndex(index, expressions.length - 1)];\r\n        }\r\n    };\r\n    return HeritageClause;\r\n}(common_1.Node));\r\nexports.HeritageClause = HeritageClause;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/general/HeritageClause.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/general/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/general/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./HeritageClause */ \"./node_modules/ts-simple-ast/dist/compiler/general/HeritageClause.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/general/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./binding */ \"./node_modules/ts-simple-ast/dist/compiler/binding/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./class */ \"./node_modules/ts-simple-ast/dist/compiler/class/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./decorator */ \"./node_modules/ts-simple-ast/dist/compiler/decorator/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./doc */ \"./node_modules/ts-simple-ast/dist/compiler/doc/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./enum */ \"./node_modules/ts-simple-ast/dist/compiler/enum/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./file */ \"./node_modules/ts-simple-ast/dist/compiler/file/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./function */ \"./node_modules/ts-simple-ast/dist/compiler/function/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./general */ \"./node_modules/ts-simple-ast/dist/compiler/general/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./interface */ \"./node_modules/ts-simple-ast/dist/compiler/interface/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./jsx */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./literal */ \"./node_modules/ts-simple-ast/dist/compiler/literal/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./namespace */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./tools */ \"./node_modules/ts-simple-ast/dist/compiler/tools/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./type */ \"./node_modules/ts-simple-ast/dist/compiler/type/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./variable */ \"./node_modules/ts-simple-ast/dist/compiler/variable/index.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/CallSignatureDeclaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/CallSignatureDeclaration.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar TypeElement_1 = __webpack_require__(/*! ./TypeElement */ \"./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js\");\r\nexports.CallSignatureDeclarationBase = base_1.TypeParameteredNode(base_1.ChildOrderableNode(base_1.JSDocableNode(base_1.SignaturedDeclaration(TypeElement_1.TypeElement))));\r\nvar CallSignatureDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CallSignatureDeclaration, _super);\r\n    function CallSignatureDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    CallSignatureDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.CallSignatureDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this call signature.\r\n     */\r\n    CallSignatureDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeInterfaceMember(this);\r\n    };\r\n    return CallSignatureDeclaration;\r\n}(exports.CallSignatureDeclarationBase));\r\nexports.CallSignatureDeclaration = CallSignatureDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/CallSignatureDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/ConstructSignatureDeclaration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/ConstructSignatureDeclaration.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar TypeElement_1 = __webpack_require__(/*! ./TypeElement */ \"./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js\");\r\nexports.ConstructSignatureDeclarationBase = base_1.TypeParameteredNode(base_1.ChildOrderableNode(base_1.JSDocableNode(base_1.SignaturedDeclaration(TypeElement_1.TypeElement))));\r\nvar ConstructSignatureDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConstructSignatureDeclaration, _super);\r\n    function ConstructSignatureDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    ConstructSignatureDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.ConstructSignatureDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this construct signature.\r\n     */\r\n    ConstructSignatureDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeInterfaceMember(this);\r\n    };\r\n    return ConstructSignatureDeclaration;\r\n}(exports.ConstructSignatureDeclarationBase));\r\nexports.ConstructSignatureDeclaration = ConstructSignatureDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/ConstructSignatureDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/IndexSignatureDeclaration.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/IndexSignatureDeclaration.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar TypeElement_1 = __webpack_require__(/*! ./TypeElement */ \"./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js\");\r\nexports.IndexSignatureDeclarationBase = base_1.ChildOrderableNode(base_1.JSDocableNode(base_1.ReadonlyableNode(base_1.ModifierableNode(TypeElement_1.TypeElement))));\r\nvar IndexSignatureDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(IndexSignatureDeclaration, _super);\r\n    function IndexSignatureDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    IndexSignatureDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.IndexSignatureDeclarationBase.prototype, this, structure);\r\n        if (structure.keyName != null)\r\n            this.setKeyName(structure.keyName);\r\n        if (structure.keyType != null)\r\n            this.setKeyType(structure.keyType);\r\n        if (structure.returnType != null)\r\n            this.setReturnType(structure.returnType);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the key name.\r\n     */\r\n    IndexSignatureDeclaration.prototype.getKeyName = function () {\r\n        return this.getKeyNameNode().getText();\r\n    };\r\n    /**\r\n     * Sets the key name.\r\n     * @param name - New name.\r\n     */\r\n    IndexSignatureDeclaration.prototype.setKeyName = function (name) {\r\n        if (this.getKeyName() === name)\r\n            return;\r\n        this.getKeyNameNode().replaceWithText(name, this.getWriterWithQueuedChildIndentation());\r\n    };\r\n    /**\r\n     * Gets the key name node.\r\n     */\r\n    IndexSignatureDeclaration.prototype.getKeyNameNode = function () {\r\n        var param = this.compilerNode.parameters[0];\r\n        return this.getNodeFromCompilerNode(param.name);\r\n    };\r\n    /**\r\n     * Gets the key type.\r\n     */\r\n    IndexSignatureDeclaration.prototype.getKeyType = function () {\r\n        return this.getKeyTypeNode().getType();\r\n    };\r\n    /**\r\n     * Sets the key type.\r\n     * @param type - Type.\r\n     */\r\n    IndexSignatureDeclaration.prototype.setKeyType = function (type) {\r\n        if (this.getKeyTypeNode().getText() === type)\r\n            return;\r\n        this.getKeyTypeNode().replaceWithText(type, this.getWriterWithQueuedChildIndentation());\r\n    };\r\n    /**\r\n     * Gets the key type node.\r\n     */\r\n    IndexSignatureDeclaration.prototype.getKeyTypeNode = function () {\r\n        var param = this.compilerNode.parameters[0];\r\n        return this.getNodeFromCompilerNode(param.type);\r\n    };\r\n    /**\r\n     * Gets the return type.\r\n     */\r\n    IndexSignatureDeclaration.prototype.getReturnType = function () {\r\n        return this.getReturnTypeNode().getType();\r\n    };\r\n    /**\r\n     * Gets the return type node.\r\n     */\r\n    IndexSignatureDeclaration.prototype.getReturnTypeNode = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.type);\r\n    };\r\n    IndexSignatureDeclaration.prototype.setReturnType = function (textOrWriterFunction) {\r\n        var returnTypeNode = this.getReturnTypeNode();\r\n        var text = utils_1.getTextFromStringOrWriter(this.getWriterWithQueuedChildIndentation(), textOrWriterFunction);\r\n        if (returnTypeNode.getText() === text)\r\n            return this;\r\n        returnTypeNode.replaceWithText(text);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this index signature.\r\n     */\r\n    IndexSignatureDeclaration.prototype.remove = function () {\r\n        manipulation_1.removeInterfaceMember(this);\r\n    };\r\n    return IndexSignatureDeclaration;\r\n}(exports.IndexSignatureDeclarationBase));\r\nexports.IndexSignatureDeclaration = IndexSignatureDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/IndexSignatureDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/InterfaceDeclaration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/InterfaceDeclaration.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar namespace_1 = __webpack_require__(/*! ../namespace */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/index.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nexports.InterfaceDeclarationBase = base_1.TypeElementMemberedNode(base_1.ChildOrderableNode(base_1.TextInsertableNode(base_1.ExtendsClauseableNode(base_1.HeritageClauseableNode(base_1.TypeParameteredNode(base_1.JSDocableNode(base_1.AmbientableNode(namespace_1.NamespaceChildableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement))))))))))));\r\nvar InterfaceDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(InterfaceDeclaration, _super);\r\n    function InterfaceDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    InterfaceDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.InterfaceDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the base types.\r\n     */\r\n    InterfaceDeclaration.prototype.getBaseTypes = function () {\r\n        return this.getType().getBaseTypes();\r\n    };\r\n    /**\r\n     * Gets the base declarations.\r\n     */\r\n    InterfaceDeclaration.prototype.getBaseDeclarations = function () {\r\n        return utils_1.ArrayUtils.flatten(this.getType().getBaseTypes().map(function (t) {\r\n            var symbol = t.getSymbol();\r\n            return symbol == null ? [] : symbol.getDeclarations();\r\n        }));\r\n    };\r\n    /**\r\n     * Gets all the implementations of the interface.\r\n     *\r\n     * This is similar to \"go to implementation.\"\r\n     */\r\n    InterfaceDeclaration.prototype.getImplementations = function () {\r\n        return this.getNameNode().getImplementations();\r\n    };\r\n    return InterfaceDeclaration;\r\n}(exports.InterfaceDeclarationBase));\r\nexports.InterfaceDeclaration = InterfaceDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/InterfaceDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/MethodSignature.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/MethodSignature.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar TypeElement_1 = __webpack_require__(/*! ./TypeElement */ \"./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js\");\r\nexports.MethodSignatureBase = base_1.ChildOrderableNode(base_1.JSDocableNode(base_1.QuestionTokenableNode(base_1.TypeParameteredNode(base_1.SignaturedDeclaration(base_1.PropertyNamedNode(TypeElement_1.TypeElement))))));\r\nvar MethodSignature = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MethodSignature, _super);\r\n    function MethodSignature() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    MethodSignature.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.MethodSignatureBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this method signature.\r\n     */\r\n    MethodSignature.prototype.remove = function () {\r\n        manipulation_1.removeInterfaceMember(this);\r\n    };\r\n    return MethodSignature;\r\n}(exports.MethodSignatureBase));\r\nexports.MethodSignature = MethodSignature;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/MethodSignature.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/PropertySignature.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/PropertySignature.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar TypeElement_1 = __webpack_require__(/*! ./TypeElement */ \"./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js\");\r\nexports.PropertySignatureBase = base_1.ChildOrderableNode(base_1.JSDocableNode(base_1.ReadonlyableNode(base_1.QuestionTokenableNode(base_1.InitializerExpressionableNode(base_1.TypedNode(base_1.PropertyNamedNode(base_1.ModifierableNode(TypeElement_1.TypeElement))))))));\r\nvar PropertySignature = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertySignature, _super);\r\n    function PropertySignature() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    PropertySignature.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.PropertySignatureBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this property signature.\r\n     */\r\n    PropertySignature.prototype.remove = function () {\r\n        manipulation_1.removeInterfaceMember(this);\r\n    };\r\n    return PropertySignature;\r\n}(exports.PropertySignatureBase));\r\nexports.PropertySignature = PropertySignature;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/PropertySignature.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar TypeElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeElement, _super);\r\n    function TypeElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TypeElement;\r\n}(common_1.Node));\r\nexports.TypeElement = TypeElement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/interface/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/interface/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CallSignatureDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/interface/CallSignatureDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConstructSignatureDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/interface/ConstructSignatureDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./IndexSignatureDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/interface/IndexSignatureDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InterfaceDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/interface/InterfaceDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./MethodSignature */ \"./node_modules/ts-simple-ast/dist/compiler/interface/MethodSignature.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertySignature */ \"./node_modules/ts-simple-ast/dist/compiler/interface/PropertySignature.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeElement */ \"./node_modules/ts-simple-ast/dist/compiler/interface/TypeElement.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/interface/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxAttribute.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxAttribute.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.JsxAttributeBase = base_1.NamedNode(common_1.Node);\r\nvar JsxAttribute = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxAttribute, _super);\r\n    function JsxAttribute() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the JSX attribute's initializer or throws if it doesn't exist.\r\n     */\r\n    JsxAttribute.prototype.getInitializerOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getInitializer(), \"Expected to find an initializer for the JSX attribute '\" + this.getName() + \"'\");\r\n    };\r\n    /**\r\n     * Gets the JSX attribute's initializer or returns undefined if it doesn't exist.\r\n     */\r\n    JsxAttribute.prototype.getInitializer = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.initializer);\r\n    };\r\n    /**\r\n     * Removes the JSX attribute.\r\n     */\r\n    JsxAttribute.prototype.remove = function () {\r\n        manipulation_1.removeChildren({\r\n            children: [this],\r\n            removePrecedingNewLines: true,\r\n            removePrecedingSpaces: true\r\n        });\r\n    };\r\n    return JsxAttribute;\r\n}(exports.JsxAttributeBase));\r\nexports.JsxAttribute = JsxAttribute;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxAttribute.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingElement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingElement.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar base_1 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js\");\r\nexports.JsxClosingElementBase = base_1.JsxTagNamedNode(common_1.Node);\r\nvar JsxClosingElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxClosingElement, _super);\r\n    function JsxClosingElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JsxClosingElement;\r\n}(exports.JsxClosingElementBase));\r\nexports.JsxClosingElement = JsxClosingElement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingFragment.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingFragment.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar JsxClosingFragment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxClosingFragment, _super);\r\n    function JsxClosingFragment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JsxClosingFragment;\r\n}(expression_1.Expression));\r\nexports.JsxClosingFragment = JsxClosingFragment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingFragment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxElement.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxElement.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar helpers_1 = __webpack_require__(/*! ../base/helpers */ \"./node_modules/ts-simple-ast/dist/compiler/base/helpers/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar JsxElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxElement, _super);\r\n    function JsxElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the children of the JSX element.\r\n     */\r\n    JsxElement.prototype.getJsxChildren = function () {\r\n        var _this = this;\r\n        return this.compilerNode.children.map(function (c) { return _this.getNodeFromCompilerNode(c); });\r\n    };\r\n    /**\r\n     * Gets the opening element.\r\n     */\r\n    JsxElement.prototype.getOpeningElement = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.openingElement);\r\n    };\r\n    /**\r\n     * Gets the closing element.\r\n     */\r\n    JsxElement.prototype.getClosingElement = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.closingElement);\r\n    };\r\n    JsxElement.prototype.setBodyText = function (textOrWriterFunction) {\r\n        var newText = helpers_1.getBodyText(this.getWriterWithIndentation(), textOrWriterFunction);\r\n        setText(this, newText);\r\n        return this;\r\n    };\r\n    JsxElement.prototype.setBodyTextInline = function (textOrWriterFunction) {\r\n        var writer = this.getWriterWithQueuedChildIndentation();\r\n        utils_1.printTextFromStringOrWriter(writer, textOrWriterFunction);\r\n        if (writer.isLastNewLine()) {\r\n            writer.setIndentationLevel(Math.max(0, this.getIndentationLevel() - 1));\r\n            writer.write(\"\"); // indentation\r\n        }\r\n        setText(this, writer.toString());\r\n        return this;\r\n    };\r\n    return JsxElement;\r\n}(expression_1.PrimaryExpression));\r\nexports.JsxElement = JsxElement;\r\nfunction setText(element, newText) {\r\n    var openingElement = element.getOpeningElement();\r\n    var closingElement = element.getClosingElement();\r\n    manipulation_1.insertIntoParentTextRange({\r\n        insertPos: openingElement.getEnd(),\r\n        newText: newText,\r\n        parent: element.getChildSyntaxListOrThrow(),\r\n        replacing: {\r\n            textLength: closingElement.getStart() - openingElement.getEnd()\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxExpression.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxExpression.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar JsxExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxExpression, _super);\r\n    function JsxExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the dot dot dot token (...) or throws if it doesn't exist.\r\n     */\r\n    JsxExpression.prototype.getDotDotDotTokenOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDotDotDotToken(), \"Expected to find a dot dot dot token for the JSX expression.\");\r\n    };\r\n    /**\r\n     * Gets the dot dot dot token (...) or returns undefined if it doesn't exist.\r\n     */\r\n    JsxExpression.prototype.getDotDotDotToken = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);\r\n    };\r\n    /**\r\n     * Gets the expression or throws if it doesn't exist.\r\n     */\r\n    JsxExpression.prototype.getExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExpression(), \"Expected to find an expression for the JSX expression.\");\r\n    };\r\n    /**\r\n     * Gets the expression or returns undefined if it doesn't exist\r\n     */\r\n    JsxExpression.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.expression);\r\n    };\r\n    return JsxExpression;\r\n}(expression_1.Expression));\r\nexports.JsxExpression = JsxExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxFragment.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxFragment.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar JsxFragment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxFragment, _super);\r\n    function JsxFragment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the children of the JSX fragment.\r\n     */\r\n    JsxFragment.prototype.getJsxChildren = function () {\r\n        var _this = this;\r\n        return this.compilerNode.children.map(function (c) { return _this.getNodeFromCompilerNode(c); });\r\n    };\r\n    /**\r\n     * Gets the opening fragment.\r\n     */\r\n    JsxFragment.prototype.getOpeningFragment = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.openingFragment);\r\n    };\r\n    /**\r\n     * Gets the closing fragment.\r\n     */\r\n    JsxFragment.prototype.getClosingFragment = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.closingFragment);\r\n    };\r\n    return JsxFragment;\r\n}(expression_1.PrimaryExpression));\r\nexports.JsxFragment = JsxFragment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxFragment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningElement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningElement.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar base_1 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js\");\r\nexports.JsxOpeningElementBase = base_1.JsxAttributedNode(base_1.JsxTagNamedNode(expression_1.Expression));\r\nvar JsxOpeningElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxOpeningElement, _super);\r\n    function JsxOpeningElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JsxOpeningElement;\r\n}(exports.JsxOpeningElementBase));\r\nexports.JsxOpeningElement = JsxOpeningElement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningFragment.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningFragment.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar JsxOpeningFragment = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxOpeningFragment, _super);\r\n    function JsxOpeningFragment() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JsxOpeningFragment;\r\n}(expression_1.Expression));\r\nexports.JsxOpeningFragment = JsxOpeningFragment;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningFragment.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSelfClosingElement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSelfClosingElement.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar base_1 = __webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js\");\r\nexports.JsxSelfClosingElementBase = base_1.JsxAttributedNode(base_1.JsxTagNamedNode(expression_1.PrimaryExpression));\r\nvar JsxSelfClosingElement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxSelfClosingElement, _super);\r\n    function JsxSelfClosingElement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return JsxSelfClosingElement;\r\n}(exports.JsxSelfClosingElementBase));\r\nexports.JsxSelfClosingElement = JsxSelfClosingElement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSelfClosingElement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSpreadAttribute.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSpreadAttribute.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar JsxSpreadAttribute = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxSpreadAttribute, _super);\r\n    function JsxSpreadAttribute() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the JSX spread attribute's expression.\r\n     */\r\n    JsxSpreadAttribute.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Removes the JSX spread attribute.\r\n     */\r\n    JsxSpreadAttribute.prototype.remove = function () {\r\n        manipulation_1.removeChildren({\r\n            children: [this],\r\n            removePrecedingNewLines: true,\r\n            removePrecedingSpaces: true\r\n        });\r\n    };\r\n    return JsxSpreadAttribute;\r\n}(common_1.Node));\r\nexports.JsxSpreadAttribute = JsxSpreadAttribute;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSpreadAttribute.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/JsxText.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/JsxText.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar JsxText = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxText, _super);\r\n    function JsxText() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets if the JSX text contains only white spaces.\r\n     */\r\n    JsxText.prototype.containsOnlyWhiteSpaces = function () {\r\n        return this.compilerNode.containsOnlyWhiteSpaces;\r\n    };\r\n    return JsxText;\r\n}(common_1.Node));\r\nexports.JsxText = JsxText;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/JsxText.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxAttributedNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxAttributedNode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar structurePrinters_1 = __webpack_require__(/*! ../../../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction JsxAttributedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getAttributes = function () {\r\n            var _this = this;\r\n            return this.compilerNode.attributes.properties.map(function (p) { return _this.getNodeFromCompilerNode(p); });\r\n        };\r\n        class_1.prototype.getAttributeOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getAttribute(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"attribute\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.getAttribute = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getAttributes(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.addAttribute = function (structure) {\r\n            return this.addAttributes([structure])[0];\r\n        };\r\n        class_1.prototype.addAttributes = function (structures) {\r\n            return this.insertAttributes(this.compilerNode.attributes.properties.length, structures);\r\n        };\r\n        class_1.prototype.insertAttribute = function (index, structure) {\r\n            return this.insertAttributes(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertAttributes = function (index, structures) {\r\n            if (structures.length === 0)\r\n                return [];\r\n            index = manipulation_1.verifyAndGetIndex(index, this.compilerNode.attributes.properties.length);\r\n            var insertPos = index === 0 ? this.getTagName().getEnd() : this.getAttributes()[index - 1].getEnd();\r\n            var writer = this.getWriterWithQueuedChildIndentation();\r\n            var structuresPrinter = new structurePrinters_1.SpaceFormattingStructuresPrinter(this.context.structurePrinterFactory.forJsxAttribute());\r\n            structuresPrinter.printText(writer, structures);\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: insertPos,\r\n                newText: \" \" + writer.toString(),\r\n                parent: this.getNodeProperty(\"attributes\").getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList)\r\n            });\r\n            return manipulation_1.getNodesToReturn(this.getAttributes(), index, structures.length);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.JsxAttributedNode = JsxAttributedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxAttributedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxTagNamedNode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxTagNamedNode.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction JsxTagNamedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        /**\r\n         * Gets the tag name of the JSX element.\r\n         */\r\n        class_1.prototype.getTagName = function () {\r\n            return this.getNodeFromCompilerNode(this.compilerNode.tagName);\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.JsxTagNamedNode = JsxTagNamedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxTagNamedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxAttributedNode */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxAttributedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxTagNamedNode */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/base/JsxTagNamedNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/jsx/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/jsx/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/base/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxAttribute */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxAttribute.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxClosingElement */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingElement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxClosingFragment */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxClosingFragment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxElement */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxElement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxExpression */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxFragment */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxFragment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxOpeningElement */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningElement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxOpeningFragment */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxOpeningFragment.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxSelfClosingElement */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSelfClosingElement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxSpreadAttribute */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxSpreadAttribute.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxText */ \"./node_modules/ts-simple-ast/dist/compiler/jsx/JsxText.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/jsx/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/BooleanLiteral.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/BooleanLiteral.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.BooleanLiteralBase = expression_1.PrimaryExpression;\r\nvar BooleanLiteral = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BooleanLiteral, _super);\r\n    function BooleanLiteral() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    BooleanLiteral.prototype.getLiteralValue = function () {\r\n        return this.getKind() === typescript_1.SyntaxKind.TrueKeyword;\r\n    };\r\n    /**\r\n     * Sets the literal value.\r\n     *\r\n     * Note: For the time being, this forgets the current node and returns the new node.\r\n     * @param value - Value to set.\r\n     */\r\n    BooleanLiteral.prototype.setLiteralValue = function (value) {\r\n        if (this.getLiteralValue() === value)\r\n            return this;\r\n        // todo: make this not forget the current node\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var index = this.getChildIndex();\r\n        this.replaceWithText(value ? \"true\" : \"false\");\r\n        return parent.getChildAtIndex(index);\r\n    };\r\n    return BooleanLiteral;\r\n}(exports.BooleanLiteralBase));\r\nexports.BooleanLiteral = BooleanLiteral;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/BooleanLiteral.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/NullLiteral.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/NullLiteral.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.NullLiteralBase = expression_1.PrimaryExpression;\r\nvar NullLiteral = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NullLiteral, _super);\r\n    function NullLiteral() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return NullLiteral;\r\n}(exports.NullLiteralBase));\r\nexports.NullLiteral = NullLiteral;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/NullLiteral.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/NumericLiteral.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/NumericLiteral.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.NumericLiteralBase = expression_1.LiteralExpression;\r\nvar NumericLiteral = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NumericLiteral, _super);\r\n    function NumericLiteral() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    NumericLiteral.prototype.getLiteralValue = function () {\r\n        var text = this.compilerNode.text;\r\n        if (text.indexOf(\".\") >= 0)\r\n            return parseFloat(text);\r\n        return parseInt(text, 10);\r\n    };\r\n    /**\r\n     * Sets the literal value.\r\n     * @param value - Value to set.\r\n     */\r\n    NumericLiteral.prototype.setLiteralValue = function (value) {\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: this.getStart(),\r\n            replacingLength: this.getWidth(),\r\n            newText: value.toString(10)\r\n        });\r\n        return this;\r\n    };\r\n    return NumericLiteral;\r\n}(exports.NumericLiteralBase));\r\nexports.NumericLiteral = NumericLiteral;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/NumericLiteral.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/QuoteKind.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/QuoteKind.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** Quote type for a string literal. */\r\nvar QuoteKind;\r\n(function (QuoteKind) {\r\n    /** Single quote */\r\n    QuoteKind[\"Single\"] = \"'\";\r\n    /** Double quote */\r\n    QuoteKind[\"Double\"] = \"\\\"\";\r\n})(QuoteKind = exports.QuoteKind || (exports.QuoteKind = {}));\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/QuoteKind.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/RegularExpressionLiteral.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/RegularExpressionLiteral.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.RegularExpressionLiteralBase = expression_1.LiteralExpression;\r\nvar RegularExpressionLiteral = /** @class */ (function (_super) {\r\n    tslib_1.__extends(RegularExpressionLiteral, _super);\r\n    function RegularExpressionLiteral() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    RegularExpressionLiteral.prototype.getLiteralValue = function () {\r\n        var pattern = /^\\/(.*)\\/([^\\/]*)$/;\r\n        var text = this.compilerNode.text;\r\n        var matches = pattern.exec(text);\r\n        return new RegExp(matches[1], matches[2]);\r\n    };\r\n    RegularExpressionLiteral.prototype.setLiteralValue = function (regExpOrPattern, flags) {\r\n        var pattern;\r\n        if (typeof regExpOrPattern === \"string\")\r\n            pattern = regExpOrPattern;\r\n        else {\r\n            pattern = regExpOrPattern.source;\r\n            flags = regExpOrPattern.flags;\r\n        }\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: this.getStart(),\r\n            replacingLength: this.getWidth(),\r\n            newText: \"/\" + pattern + \"/\" + (flags || \"\")\r\n        });\r\n        return this;\r\n    };\r\n    return RegularExpressionLiteral;\r\n}(exports.RegularExpressionLiteralBase));\r\nexports.RegularExpressionLiteral = RegularExpressionLiteral;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/RegularExpressionLiteral.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/StringLiteral.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/StringLiteral.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar QuoteKind_1 = __webpack_require__(/*! ./QuoteKind */ \"./node_modules/ts-simple-ast/dist/compiler/literal/QuoteKind.js\");\r\nexports.StringLiteralBase = expression_1.LiteralExpression;\r\nvar StringLiteral = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StringLiteral, _super);\r\n    function StringLiteral() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the literal value.\r\n     *\r\n     * This is equivalent to .getLiteralText() for string literals and only exists for consistency with other literals.\r\n     */\r\n    StringLiteral.prototype.getLiteralValue = function () {\r\n        return this.compilerNode.text;\r\n    };\r\n    /**\r\n     * Sets the literal value.\r\n     * @param value - Value to set.\r\n     */\r\n    StringLiteral.prototype.setLiteralValue = function (value) {\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: this.getStart() + 1,\r\n            replacingLength: this.getWidth() - 2,\r\n            newText: utils_1.StringUtils.escapeForWithinString(value, this.getQuoteKind())\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the quote kind.\r\n     */\r\n    StringLiteral.prototype.getQuoteKind = function () {\r\n        return this.getText()[0] === \"'\" ? QuoteKind_1.QuoteKind.Single : QuoteKind_1.QuoteKind.Double;\r\n    };\r\n    return StringLiteral;\r\n}(exports.StringLiteralBase));\r\nexports.StringLiteral = StringLiteral;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/StringLiteral.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BooleanLiteral */ \"./node_modules/ts-simple-ast/dist/compiler/literal/BooleanLiteral.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NullLiteral */ \"./node_modules/ts-simple-ast/dist/compiler/literal/NullLiteral.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NumericLiteral */ \"./node_modules/ts-simple-ast/dist/compiler/literal/NumericLiteral.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./QuoteKind */ \"./node_modules/ts-simple-ast/dist/compiler/literal/QuoteKind.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RegularExpressionLiteral */ \"./node_modules/ts-simple-ast/dist/compiler/literal/RegularExpressionLiteral.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StringLiteral */ \"./node_modules/ts-simple-ast/dist/compiler/literal/StringLiteral.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./template */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/index.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/NoSubstitutionTemplateLiteral.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/NoSubstitutionTemplateLiteral.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.NoSubstitutionTemplateLiteralBase = expression_1.LiteralExpression;\r\nvar NoSubstitutionTemplateLiteral = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NoSubstitutionTemplateLiteral, _super);\r\n    function NoSubstitutionTemplateLiteral() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the literal value.\r\n     */\r\n    NoSubstitutionTemplateLiteral.prototype.getLiteralValue = function () {\r\n        // for consistency with other literals\r\n        return this.compilerNode.text;\r\n    };\r\n    /**\r\n     * Sets the literal value.\r\n     *\r\n     * Note: This could possibly replace the node if you add a tagged template.\r\n     * @param value - Value to set.\r\n     * @returns The new node if the kind changed; the current node otherwise.\r\n     */\r\n    NoSubstitutionTemplateLiteral.prototype.setLiteralValue = function (value) {\r\n        var childIndex = this.getChildIndex();\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: this.getStart() + 1,\r\n            replacingLength: this.getWidth() - 2,\r\n            newText: value\r\n        });\r\n        return parent.getChildAtIndex(childIndex);\r\n    };\r\n    return NoSubstitutionTemplateLiteral;\r\n}(exports.NoSubstitutionTemplateLiteralBase));\r\nexports.NoSubstitutionTemplateLiteral = NoSubstitutionTemplateLiteral;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/NoSubstitutionTemplateLiteral.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/TaggedTemplateExpression.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/TaggedTemplateExpression.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar TaggedTemplateExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TaggedTemplateExpression, _super);\r\n    function TaggedTemplateExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the tag.\r\n     */\r\n    TaggedTemplateExpression.prototype.getTag = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.tag);\r\n    };\r\n    /**\r\n     * Gets the template literal.\r\n     */\r\n    TaggedTemplateExpression.prototype.getTemplate = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.template);\r\n    };\r\n    /**\r\n     * Removes the tag from the tagged template.\r\n     * @returns The new template expression.\r\n     */\r\n    TaggedTemplateExpression.prototype.removeTag = function () {\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        var index = this.getChildIndex();\r\n        var template = this.getTemplate();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            customMappings: function (newParent) { return [{ currentNode: template, newNode: newParent.getChildren()[index] }]; },\r\n            parent: parent,\r\n            insertPos: this.getStart(),\r\n            newText: this.getTemplate().getText(),\r\n            replacing: {\r\n                textLength: this.getWidth(),\r\n                nodes: [this]\r\n            }\r\n        });\r\n        return parent.getChildAtIndex(index);\r\n    };\r\n    return TaggedTemplateExpression;\r\n}(expression_1.MemberExpression));\r\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/TaggedTemplateExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateExpression.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateExpression.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.TemplateExpressionBase = expression_1.PrimaryExpression;\r\nvar TemplateExpression = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TemplateExpression, _super);\r\n    function TemplateExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the template head.\r\n     */\r\n    TemplateExpression.prototype.getHead = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.head);\r\n    };\r\n    /**\r\n     * Gets the template spans.\r\n     */\r\n    TemplateExpression.prototype.getTemplateSpans = function () {\r\n        var _this = this;\r\n        return this.compilerNode.templateSpans.map(function (s) { return _this.getNodeFromCompilerNode(s); });\r\n    };\r\n    /**\r\n     * Sets the literal value.\r\n     *\r\n     * Note: This could possibly replace the node if you remove all the tagged templates.\r\n     * @param value - Value to set.\r\n     * @returns The new node if the kind changed; the current node otherwise.\r\n     */\r\n    TemplateExpression.prototype.setLiteralValue = function (value) {\r\n        var childIndex = this.getChildIndex();\r\n        var parent = this.getParentSyntaxList() || this.getParentOrThrow();\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: this.getStart() + 1,\r\n            replacingLength: this.getWidth() - 2,\r\n            newText: value\r\n        });\r\n        return parent.getChildAtIndex(childIndex);\r\n    };\r\n    return TemplateExpression;\r\n}(exports.TemplateExpressionBase));\r\nexports.TemplateExpression = TemplateExpression;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateExpression.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateHead.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateHead.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.TemplateHeadBase = base_1.LiteralLikeNode(common_1.Node);\r\nvar TemplateHead = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TemplateHead, _super);\r\n    function TemplateHead() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TemplateHead;\r\n}(exports.TemplateHeadBase));\r\nexports.TemplateHead = TemplateHead;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateHead.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateMiddle.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateMiddle.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.TemplateMiddleBase = base_1.LiteralLikeNode(common_1.Node);\r\nvar TemplateMiddle = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TemplateMiddle, _super);\r\n    function TemplateMiddle() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TemplateMiddle;\r\n}(exports.TemplateMiddleBase));\r\nexports.TemplateMiddle = TemplateMiddle;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateMiddle.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateSpan.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateSpan.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar expression_1 = __webpack_require__(/*! ../../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nexports.TemplateSpanBase = expression_1.ExpressionedNode(common_1.Node);\r\nvar TemplateSpan = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TemplateSpan, _super);\r\n    function TemplateSpan() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the template literal.\r\n     */\r\n    TemplateSpan.prototype.getLiteral = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.literal);\r\n    };\r\n    return TemplateSpan;\r\n}(exports.TemplateSpanBase));\r\nexports.TemplateSpan = TemplateSpan;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateSpan.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateTail.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateTail.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.TemplateTailBase = base_1.LiteralLikeNode(common_1.Node);\r\nvar TemplateTail = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TemplateTail, _super);\r\n    function TemplateTail() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TemplateTail;\r\n}(exports.TemplateTailBase));\r\nexports.TemplateTail = TemplateTail;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateTail.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/literal/template/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/literal/template/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NoSubstitutionTemplateLiteral */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/NoSubstitutionTemplateLiteral.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TaggedTemplateExpression */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/TaggedTemplateExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TemplateExpression */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateExpression.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TemplateHead */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateHead.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TemplateMiddle */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateMiddle.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TemplateSpan */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateSpan.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TemplateTail */ \"./node_modules/ts-simple-ast/dist/compiler/literal/template/TemplateTail.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/literal/template/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceChildableNode.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceChildableNode.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nfunction NamespaceChildableNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        class_1.prototype.getParentNamespaceOrThrow = function () {\r\n            return errors.throwIfNullOrUndefined(this.getParentNamespace(), \"Expected to find the parent namespace.\");\r\n        };\r\n        class_1.prototype.getParentNamespace = function () {\r\n            var parent = this.getParentOrThrow();\r\n            if (parent.getKind() !== typescript_1.SyntaxKind.ModuleBlock)\r\n                return undefined;\r\n            while (parent.getParentOrThrow().getKind() === typescript_1.SyntaxKind.ModuleDeclaration)\r\n                parent = parent.getParentOrThrow();\r\n            return parent;\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.NamespaceChildableNode = NamespaceChildableNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceChildableNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceDeclaration.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceDeclaration.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\nvar NamespaceChildableNode_1 = __webpack_require__(/*! ./NamespaceChildableNode */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceChildableNode.js\");\r\nexports.NamespaceDeclarationBase = base_1.ChildOrderableNode(base_1.UnwrappableNode(base_1.TextInsertableNode(base_1.BodiedNode(NamespaceChildableNode_1.NamespaceChildableNode(statement_1.StatementedNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement)))))))))));\r\nvar NamespaceDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NamespaceDeclaration, _super);\r\n    function NamespaceDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    NamespaceDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.NamespaceDeclarationBase.prototype, this, structure);\r\n        if (structure.hasModuleKeyword != null)\r\n            this.setHasModuleKeyword(structure.hasModuleKeyword);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the full name of the namespace.\r\n     */\r\n    NamespaceDeclaration.prototype.getName = function () {\r\n        return this.getNameNodes().map(function (n) { return n.getText(); }).join(\".\");\r\n    };\r\n    /**\r\n     * Sets the name without renaming references.\r\n     * @param newName - New full namespace name.\r\n     */\r\n    NamespaceDeclaration.prototype.setName = function (newName) {\r\n        var nameNodes = this.getNameNodes();\r\n        var openIssueText = \"Please open an issue if you really need this and I'll up the priority.\";\r\n        if (nameNodes.length > 1)\r\n            throw new errors.NotImplementedError(\"Not implemented to set a namespace name that uses dot notation. \" + openIssueText);\r\n        if (newName.indexOf(\".\") >= 0)\r\n            throw new errors.NotImplementedError(\"Not implemented to set a namespace name to a name containing a period. \" + openIssueText);\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.sourceFile,\r\n            start: nameNodes[0].getStart(),\r\n            replacingLength: nameNodes[0].getWidth(),\r\n            newText: newName\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Renames the name.\r\n     * @param newName - New name.\r\n     */\r\n    NamespaceDeclaration.prototype.rename = function (newName) {\r\n        var nameNodes = this.getNameNodes();\r\n        if (nameNodes.length > 1)\r\n            throw new errors.NotSupportedError(\"Cannot rename a namespace name that uses dot notation. Rename the individual nodes via .\" + \"getNameNodes\" + \"()\");\r\n        if (newName.indexOf(\".\") >= 0)\r\n            throw new errors.NotSupportedError(\"Cannot rename a namespace name to a name containing a period.\");\r\n        nameNodes[0].rename(newName);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the name nodes.\r\n     */\r\n    NamespaceDeclaration.prototype.getNameNodes = function () {\r\n        var nodes = [];\r\n        var current = this;\r\n        do {\r\n            nodes.push(this.getNodeFromCompilerNode(current.compilerNode.name));\r\n            current = current.getFirstChildByKind(typescript_1.SyntaxKind.ModuleDeclaration);\r\n        } while (current != null);\r\n        return nodes;\r\n    };\r\n    /**\r\n     * Gets if this namespace has a namespace keyword.\r\n     */\r\n    NamespaceDeclaration.prototype.hasNamespaceKeyword = function () {\r\n        return (this.compilerNode.flags & typescript_1.ts.NodeFlags.Namespace) === typescript_1.ts.NodeFlags.Namespace;\r\n    };\r\n    /**\r\n     * Gets if this namespace has a namespace keyword.\r\n     */\r\n    NamespaceDeclaration.prototype.hasModuleKeyword = function () {\r\n        return !this.hasNamespaceKeyword();\r\n    };\r\n    /**\r\n     * Set if this namespace has a namespace keyword.\r\n     * @param value - Whether to set it or not.\r\n     */\r\n    NamespaceDeclaration.prototype.setHasNamespaceKeyword = function (value) {\r\n        if (value === void 0) { value = true; }\r\n        if (this.hasNamespaceKeyword() === value)\r\n            return this;\r\n        var declarationKindKeyword = this.getDeclarationKindKeyword();\r\n        manipulation_1.replaceNodeText({\r\n            sourceFile: this.getSourceFile(),\r\n            start: declarationKindKeyword.getStart(),\r\n            replacingLength: declarationKindKeyword.getWidth(),\r\n            newText: value ? \"namespace\" : \"module\"\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Set if this namespace has a namepsace keyword.\r\n     * @param value - Whether to set it or not.\r\n     */\r\n    NamespaceDeclaration.prototype.setHasModuleKeyword = function (value) {\r\n        if (value === void 0) { value = true; }\r\n        return this.setHasNamespaceKeyword(!value);\r\n    };\r\n    /**\r\n     * Gets the namespace or module keyword.\r\n     */\r\n    NamespaceDeclaration.prototype.getDeclarationKindKeyword = function () {\r\n        var keyword = this.getFirstChild(function (child) {\r\n            return child.getKind() === typescript_1.SyntaxKind.NamespaceKeyword ||\r\n                child.getKind() === typescript_1.SyntaxKind.ModuleKeyword;\r\n        });\r\n        /* istanbul ignore if */\r\n        if (keyword == null)\r\n            throw new errors.NotImplementedError(\"Expected the declaration kind keyword to exist on a namespace.\");\r\n        return keyword;\r\n    };\r\n    return NamespaceDeclaration;\r\n}(exports.NamespaceDeclarationBase));\r\nexports.NamespaceDeclaration = NamespaceDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/namespace/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/namespace/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NamespaceChildableNode */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceChildableNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NamespaceDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/NamespaceDeclaration.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/namespace/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/Block.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/Block.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nvar StatementedNode_1 = __webpack_require__(/*! ./StatementedNode */ \"./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js\");\r\nexports.BlockBase = base_1.TextInsertableNode(StatementedNode_1.StatementedNode(Statement_1.Statement));\r\nvar Block = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Block, _super);\r\n    function Block() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Block;\r\n}(exports.BlockBase));\r\nexports.Block = Block;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/Block.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/BreakStatement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/BreakStatement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.BreakStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar BreakStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BreakStatement, _super);\r\n    function BreakStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this break statement's label or undefined if it does not exist.\r\n     */\r\n    BreakStatement.prototype.getLabel = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.label);\r\n    };\r\n    /**\r\n     * Gets this break statement's label or throw if it does not exist.\r\n     */\r\n    BreakStatement.prototype.getLabelOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getLabel(), \"Expected to find a label.\");\r\n    };\r\n    return BreakStatement;\r\n}(exports.BreakStatementBase));\r\nexports.BreakStatement = BreakStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/BreakStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/CaseBlock.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/CaseBlock.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.CaseBlockBase = base_1.TextInsertableNode(common_1.Node);\r\nvar CaseBlock = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CaseBlock, _super);\r\n    function CaseBlock() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the clauses.\r\n     */\r\n    CaseBlock.prototype.getClauses = function () {\r\n        var _this = this;\r\n        var clauses = this.compilerNode.clauses || [];\r\n        return clauses.map(function (s) { return _this.getNodeFromCompilerNode(s); });\r\n    };\r\n    /**\r\n     * Removes the clause at the specified index.\r\n     * @param index - Index.\r\n     */\r\n    CaseBlock.prototype.removeClause = function (index) {\r\n        index = manipulation_1.verifyAndGetIndex(index, this.getClauses().length - 1);\r\n        return this.removeClauses([index, index]);\r\n    };\r\n    /**\r\n     * Removes the clauses in the specified range.\r\n     * @param indexRange - Index range.\r\n     */\r\n    CaseBlock.prototype.removeClauses = function (indexRange) {\r\n        var clauses = this.getClauses();\r\n        errors.throwIfRangeOutOfRange(indexRange, [0, clauses.length], \"indexRange\");\r\n        manipulation_1.removeClausedNodeChildren(clauses.slice(indexRange[0], indexRange[1] + 1));\r\n        return this;\r\n    };\r\n    return CaseBlock;\r\n}(exports.CaseBlockBase));\r\nexports.CaseBlock = CaseBlock;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/CaseBlock.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/CaseClause.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/CaseClause.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar StatementedNode_1 = __webpack_require__(/*! ./StatementedNode */ \"./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js\");\r\nexports.CaseClauseBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(StatementedNode_1.StatementedNode(common_1.Node)));\r\nvar CaseClause = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CaseClause, _super);\r\n    function CaseClause() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this switch statement's expression.\r\n     */\r\n    CaseClause.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Removes this case clause.\r\n     */\r\n    CaseClause.prototype.remove = function () {\r\n        manipulation_1.removeClausedNodeChild(this);\r\n    };\r\n    return CaseClause;\r\n}(exports.CaseClauseBase));\r\nexports.CaseClause = CaseClause;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/CaseClause.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/CatchClause.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/CatchClause.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.CatchClauseBase = common_1.Node;\r\nvar CatchClause = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CatchClause, _super);\r\n    function CatchClause() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this catch clause's block.\r\n     */\r\n    CatchClause.prototype.getBlock = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.block);\r\n    };\r\n    /**\r\n     * Gets this catch clause's variable declaration or undefined if none exists.\r\n     */\r\n    CatchClause.prototype.getVariableDeclaration = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.variableDeclaration);\r\n    };\r\n    /**\r\n     * Gets this catch clause's variable declaration or throws if none exists.\r\n     */\r\n    CatchClause.prototype.getVariableDeclarationOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getVariableDeclaration(), \"Expected to find a variable declaration.\");\r\n    };\r\n    return CatchClause;\r\n}(exports.CatchClauseBase));\r\nexports.CatchClause = CatchClause;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/CatchClause.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ContinueStatement.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ContinueStatement.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.ContinueStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar ContinueStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ContinueStatement, _super);\r\n    function ContinueStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this continue statement's label or undefined if it does not exist.\r\n     */\r\n    ContinueStatement.prototype.getLabel = function () {\r\n        return this.compilerNode.label == null\r\n            ? undefined\r\n            : this.getNodeFromCompilerNode(this.compilerNode.label);\r\n    };\r\n    /**\r\n     * Gets this continue statement's label or throw if it does not exist.\r\n     */\r\n    ContinueStatement.prototype.getLabelOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getLabel(), \"Expected to find a label.\");\r\n    };\r\n    return ContinueStatement;\r\n}(exports.ContinueStatementBase));\r\nexports.ContinueStatement = ContinueStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ContinueStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/DebuggerStatement.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/DebuggerStatement.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.DebuggerStatementBase = Statement_1.Statement;\r\nvar DebuggerStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DebuggerStatement, _super);\r\n    function DebuggerStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return DebuggerStatement;\r\n}(exports.DebuggerStatementBase));\r\nexports.DebuggerStatement = DebuggerStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/DebuggerStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/DefaultClause.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/DefaultClause.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar StatementedNode_1 = __webpack_require__(/*! ./StatementedNode */ \"./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js\");\r\nexports.DefaultClauseBase = base_1.ChildOrderableNode(base_1.TextInsertableNode(StatementedNode_1.StatementedNode(common_1.Node)));\r\nvar DefaultClause = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DefaultClause, _super);\r\n    function DefaultClause() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Removes the default clause.\r\n     */\r\n    DefaultClause.prototype.remove = function () {\r\n        manipulation_1.removeClausedNodeChild(this);\r\n    };\r\n    return DefaultClause;\r\n}(exports.DefaultClauseBase));\r\nexports.DefaultClause = DefaultClause;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/DefaultClause.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/DoStatement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/DoStatement.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar IterationStatement_1 = __webpack_require__(/*! ./IterationStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js\");\r\nexports.DoStatementBase = IterationStatement_1.IterationStatement;\r\nvar DoStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DoStatement, _super);\r\n    function DoStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this do statement's expression.\r\n     */\r\n    DoStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return DoStatement;\r\n}(exports.DoStatementBase));\r\nexports.DoStatement = DoStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/DoStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/EmptyStatement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/EmptyStatement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.EmptyStatementBase = Statement_1.Statement;\r\nvar EmptyStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EmptyStatement, _super);\r\n    function EmptyStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return EmptyStatement;\r\n}(exports.EmptyStatementBase));\r\nexports.EmptyStatement = EmptyStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/EmptyStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ExpressionStatement.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ExpressionStatement.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.ExpressionStatementBase = base_1.JSDocableNode(base_1.ChildOrderableNode(Statement_1.Statement));\r\nvar ExpressionStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExpressionStatement, _super);\r\n    function ExpressionStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this expression statement's expression.\r\n     */\r\n    ExpressionStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return ExpressionStatement;\r\n}(exports.ExpressionStatementBase));\r\nexports.ExpressionStatement = ExpressionStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ExpressionStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ForInStatement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ForInStatement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar IterationStatement_1 = __webpack_require__(/*! ./IterationStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js\");\r\nexports.ForInStatementBase = IterationStatement_1.IterationStatement;\r\nvar ForInStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ForInStatement, _super);\r\n    function ForInStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this for in statement's initializer.\r\n     */\r\n    ForInStatement.prototype.getInitializer = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.initializer);\r\n    };\r\n    /**\r\n     * Gets this for in statement's expression.\r\n     */\r\n    ForInStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return ForInStatement;\r\n}(exports.ForInStatementBase));\r\nexports.ForInStatement = ForInStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ForInStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ForOfStatement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ForOfStatement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar IterationStatement_1 = __webpack_require__(/*! ./IterationStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js\");\r\nexports.ForOfStatementBase = base_1.AwaitableNode(IterationStatement_1.IterationStatement);\r\nvar ForOfStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ForOfStatement, _super);\r\n    function ForOfStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this for of statement's initializer.\r\n     */\r\n    ForOfStatement.prototype.getInitializer = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.initializer);\r\n    };\r\n    /**\r\n     * Gets this for of statement's expression.\r\n     */\r\n    ForOfStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return ForOfStatement;\r\n}(exports.ForOfStatementBase));\r\nexports.ForOfStatement = ForOfStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ForOfStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ForStatement.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ForStatement.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar IterationStatement_1 = __webpack_require__(/*! ./IterationStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js\");\r\nexports.ForStatementBase = IterationStatement_1.IterationStatement;\r\nvar ForStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ForStatement, _super);\r\n    function ForStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this for statement's initializer or undefined if none exists.\r\n     */\r\n    ForStatement.prototype.getInitializer = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.initializer);\r\n    };\r\n    /**\r\n     * Gets this for statement's initializer or throws if none exists.\r\n     */\r\n    ForStatement.prototype.getInitializerOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getInitializer(), \"Expected to find an initializer.\");\r\n    };\r\n    /**\r\n     * Gets this for statement's condition or undefined if none exists.\r\n     */\r\n    ForStatement.prototype.getCondition = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.condition);\r\n    };\r\n    /**\r\n     * Gets this for statement's condition or throws if none exists.\r\n     */\r\n    ForStatement.prototype.getConditionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getCondition(), \"Expected to find a condition.\");\r\n    };\r\n    /**\r\n     * Gets this for statement's incrementor.\r\n     */\r\n    ForStatement.prototype.getIncrementor = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.incrementor);\r\n    };\r\n    /**\r\n     * Gets this for statement's incrementor or throws if none exists.\r\n     */\r\n    ForStatement.prototype.getIncrementorOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getIncrementor(), \"Expected to find an incrementor.\");\r\n    };\r\n    return ForStatement;\r\n}(exports.ForStatementBase));\r\nexports.ForStatement = ForStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ForStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/IfStatement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/IfStatement.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.IfStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar IfStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(IfStatement, _super);\r\n    function IfStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this if statement's expression.\r\n     */\r\n    IfStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets this if statement's then statement.\r\n     */\r\n    IfStatement.prototype.getThenStatement = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.thenStatement);\r\n    };\r\n    /**\r\n     * Gets this if statement's else statement.\r\n     */\r\n    IfStatement.prototype.getElseStatement = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.elseStatement);\r\n    };\r\n    return IfStatement;\r\n}(exports.IfStatementBase));\r\nexports.IfStatement = IfStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/IfStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.IterationStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar IterationStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(IterationStatement, _super);\r\n    function IterationStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this iteration statement's statement.\r\n     */\r\n    IterationStatement.prototype.getStatement = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.statement);\r\n    };\r\n    return IterationStatement;\r\n}(exports.IterationStatementBase));\r\nexports.IterationStatement = IterationStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/LabeledStatement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/LabeledStatement.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.LabeledStatementBase = base_1.JSDocableNode(base_1.ChildOrderableNode(Statement_1.Statement));\r\nvar LabeledStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(LabeledStatement, _super);\r\n    function LabeledStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this labeled statement's label\r\n     */\r\n    LabeledStatement.prototype.getLabel = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.label);\r\n    };\r\n    /**\r\n     * Gets this labeled statement's statement\r\n     */\r\n    LabeledStatement.prototype.getStatement = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.statement);\r\n    };\r\n    return LabeledStatement;\r\n}(exports.LabeledStatementBase));\r\nexports.LabeledStatement = LabeledStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/LabeledStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/NotEmittedStatement.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/NotEmittedStatement.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.NotEmittedStatementBase = Statement_1.Statement;\r\nvar NotEmittedStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NotEmittedStatement, _super);\r\n    function NotEmittedStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return NotEmittedStatement;\r\n}(exports.NotEmittedStatementBase));\r\nexports.NotEmittedStatement = NotEmittedStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/NotEmittedStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ReturnStatement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ReturnStatement.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.ReturnStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar ReturnStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ReturnStatement, _super);\r\n    function ReturnStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this return statement's expression if it exists or throws.\r\n     */\r\n    ReturnStatement.prototype.getExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExpression(), \"Expected to find a return expression's expression.\");\r\n    };\r\n    /**\r\n     * Gets this return statement's expression if it exists.\r\n     */\r\n    ReturnStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.expression);\r\n    };\r\n    return ReturnStatement;\r\n}(exports.ReturnStatementBase));\r\nexports.ReturnStatement = ReturnStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ReturnStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar Statement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(Statement, _super);\r\n    function Statement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Removes the statement.\r\n     */\r\n    Statement.prototype.remove = function () {\r\n        manipulation_1.removeStatementedNodeChild(this);\r\n    };\r\n    return Statement;\r\n}(common_1.Node));\r\nexports.Statement = Statement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nfunction StatementedNode(Base) {\r\n    return /** @class */ (function (_super) {\r\n        tslib_1.__extends(class_1, _super);\r\n        function class_1() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        /* General */\r\n        class_1.prototype.getStatements = function () {\r\n            var _this = this;\r\n            return this.getCompilerStatements().map(function (s) { return _this.getNodeFromCompilerNode(s); });\r\n        };\r\n        class_1.prototype.getStatement = function (findFunction) {\r\n            // explicit type arg necessary in ts 3.0 for some reason\r\n            return utils_1.ArrayUtils.find(this.getStatements(), findFunction);\r\n        };\r\n        class_1.prototype.getStatementOrThrow = function (findFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getStatement(findFunction), \"Expected to find a statement matching the provided condition.\");\r\n        };\r\n        class_1.prototype.getStatementByKind = function (kind) {\r\n            var statement = utils_1.ArrayUtils.find(this.getCompilerStatements(), function (s) { return s.kind === kind; });\r\n            return this.getNodeFromCompilerNodeIfExists(statement);\r\n        };\r\n        class_1.prototype.getStatementByKindOrThrow = function (kind) {\r\n            return errors.throwIfNullOrUndefined(this.getStatementByKind(kind), \"Expected to find a statement with syntax kind \" + utils_1.getSyntaxKindName(kind) + \".\");\r\n        };\r\n        class_1.prototype.addStatements = function (textOrWriterFunction) {\r\n            return this.insertStatements(this.getCompilerStatements().length, textOrWriterFunction);\r\n        };\r\n        class_1.prototype.insertStatements = function (index, textOrWriterFunction) {\r\n            return getChildSyntaxList.call(this).insertChildText(index, textOrWriterFunction);\r\n            function getChildSyntaxList() {\r\n                var childSyntaxList = this.getChildSyntaxListOrThrow();\r\n                // case and default clauses can optionally have blocks\r\n                if (utils_1.TypeGuards.isCaseClause(this) || utils_1.TypeGuards.isDefaultClause(this)) {\r\n                    var block = childSyntaxList.getFirstChildIfKind(typescript_1.SyntaxKind.Block);\r\n                    if (block != null)\r\n                        return block.getChildSyntaxListOrThrow();\r\n                }\r\n                return childSyntaxList;\r\n            }\r\n        };\r\n        class_1.prototype.removeStatement = function (index) {\r\n            index = manipulation_1.verifyAndGetIndex(index, this.getCompilerStatements().length - 1);\r\n            return this.removeStatements([index, index]);\r\n        };\r\n        class_1.prototype.removeStatements = function (indexRange) {\r\n            var statements = this.getStatements();\r\n            errors.throwIfRangeOutOfRange(indexRange, [0, statements.length], \"indexRange\");\r\n            manipulation_1.removeStatementedNodeChildren(statements.slice(indexRange[0], indexRange[1] + 1));\r\n            return this;\r\n        };\r\n        /* Classes */\r\n        class_1.prototype.addClass = function (structure) {\r\n            return this.addClasses([structure])[0];\r\n        };\r\n        class_1.prototype.addClasses = function (structures) {\r\n            return this.insertClasses(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertClass = function (index, structure) {\r\n            return this.insertClasses(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertClasses = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.ClassDeclaration,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forClassDeclaration({ isAmbient: utils_1.isNodeAmbientOrInAmbientContext(_this) }).printTexts(writer, structures);\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        class_1.prototype.getClasses = function () {\r\n            // todo: remove type assertion\r\n            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ClassDeclaration);\r\n        };\r\n        class_1.prototype.getClass = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getClasses(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getClassOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getClass(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"class\", nameOrFindFunction); });\r\n        };\r\n        /* Enums */\r\n        class_1.prototype.addEnum = function (structure) {\r\n            return this.addEnums([structure])[0];\r\n        };\r\n        class_1.prototype.addEnums = function (structures) {\r\n            return this.insertEnums(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertEnum = function (index, structure) {\r\n            return this.insertEnums(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertEnums = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.EnumDeclaration,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forEnumDeclaration().printTexts(writer, structures);\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        class_1.prototype.getEnums = function () {\r\n            // todo: remove type assertion\r\n            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.EnumDeclaration);\r\n        };\r\n        class_1.prototype.getEnum = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getEnums(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getEnumOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getEnum(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"enum\", nameOrFindFunction); });\r\n        };\r\n        /* Functions */\r\n        class_1.prototype.addFunction = function (structure) {\r\n            return this.addFunctions([structure])[0];\r\n        };\r\n        class_1.prototype.addFunctions = function (structures) {\r\n            return this.insertFunctions(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertFunction = function (index, structure) {\r\n            return this.insertFunctions(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertFunctions = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.FunctionDeclaration,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forFunctionDeclaration().printTexts(writer, structures);\r\n                    }, {\r\n                        previousNewLine: function (previousMember) {\r\n                            return structures[0].hasDeclareKeyword && utils_1.TypeGuards.isFunctionDeclaration(previousMember) && previousMember.getBody() == null;\r\n                        },\r\n                        nextNewLine: function (nextMember) {\r\n                            return structures[structures.length - 1].hasDeclareKeyword && utils_1.TypeGuards.isFunctionDeclaration(nextMember) && nextMember.getBody() == null;\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        class_1.prototype.getFunctions = function () {\r\n            // todo: remove type assertion\r\n            return (this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.FunctionDeclaration))\r\n                .filter(function (f) { return f.isAmbient() || f.isImplementation(); });\r\n        };\r\n        class_1.prototype.getFunction = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getFunctions(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getFunctionOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getFunction(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"function\", nameOrFindFunction); });\r\n        };\r\n        /* Interfaces */\r\n        class_1.prototype.addInterface = function (structure) {\r\n            return this.addInterfaces([structure])[0];\r\n        };\r\n        class_1.prototype.addInterfaces = function (structures) {\r\n            return this.insertInterfaces(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertInterface = function (index, structure) {\r\n            return this.insertInterfaces(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertInterfaces = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.InterfaceDeclaration,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forInterfaceDeclaration().printTexts(writer, structures);\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        class_1.prototype.getInterfaces = function () {\r\n            // todo: remove type assertion\r\n            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.InterfaceDeclaration);\r\n        };\r\n        class_1.prototype.getInterface = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getInterfaces(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getInterfaceOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getInterface(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"interface\", nameOrFindFunction); });\r\n        };\r\n        /* Namespaces */\r\n        class_1.prototype.addNamespace = function (structure) {\r\n            return this.addNamespaces([structure])[0];\r\n        };\r\n        class_1.prototype.addNamespaces = function (structures) {\r\n            return this.insertNamespaces(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertNamespace = function (index, structure) {\r\n            return this.insertNamespaces(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertNamespaces = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.ModuleDeclaration,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forNamespaceDeclaration({ isAmbient: utils_1.isNodeAmbientOrInAmbientContext(_this) }).printTexts(writer, structures);\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        class_1.prototype.getNamespaces = function () {\r\n            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ModuleDeclaration);\r\n        };\r\n        class_1.prototype.getNamespace = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getNamespaces(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getNamespaceOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getNamespace(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"namespace\", nameOrFindFunction); });\r\n        };\r\n        /* Type aliases */\r\n        class_1.prototype.addTypeAlias = function (structure) {\r\n            return this.addTypeAliases([structure])[0];\r\n        };\r\n        class_1.prototype.addTypeAliases = function (structures) {\r\n            return this.insertTypeAliases(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertTypeAlias = function (index, structure) {\r\n            return this.insertTypeAliases(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertTypeAliases = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.TypeAliasDeclaration,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forTypeAliasDeclaration().printTexts(writer, structures);\r\n                    }, {\r\n                        previousNewLine: function (previousMember) { return utils_1.TypeGuards.isTypeAliasDeclaration(previousMember); },\r\n                        nextNewLine: function (nextMember) { return utils_1.TypeGuards.isTypeAliasDeclaration(nextMember); }\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        class_1.prototype.getTypeAliases = function () {\r\n            // todo: remove type assertion\r\n            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.TypeAliasDeclaration);\r\n        };\r\n        class_1.prototype.getTypeAlias = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getTypeAliases(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getTypeAliasOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getTypeAlias(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"type alias\", nameOrFindFunction); });\r\n        };\r\n        /* Variable statements */\r\n        class_1.prototype.getVariableStatements = function () {\r\n            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.VariableStatement);\r\n        };\r\n        class_1.prototype.getVariableStatement = function (findFunction) {\r\n            return utils_1.ArrayUtils.find(this.getVariableStatements(), findFunction);\r\n        };\r\n        class_1.prototype.getVariableStatementOrThrow = function (findFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getVariableStatement(findFunction), \"Expected to find a variable statement that matched the provided condition.\");\r\n        };\r\n        class_1.prototype.addVariableStatement = function (structure) {\r\n            return this.addVariableStatements([structure])[0];\r\n        };\r\n        class_1.prototype.addVariableStatements = function (structures) {\r\n            return this.insertVariableStatements(this.getCompilerStatements().length, structures);\r\n        };\r\n        class_1.prototype.insertVariableStatement = function (index, structure) {\r\n            return this.insertVariableStatements(index, [structure])[0];\r\n        };\r\n        class_1.prototype.insertVariableStatements = function (index, structures) {\r\n            var _this = this;\r\n            return this._insertChildren({\r\n                expectedKind: typescript_1.SyntaxKind.VariableStatement,\r\n                index: index,\r\n                structures: structures,\r\n                write: function (writer, info) {\r\n                    _this._standardWrite(writer, info, function () {\r\n                        _this.context.structurePrinterFactory.forVariableStatement().printTexts(writer, structures);\r\n                    }, {\r\n                        previousNewLine: function (previousMember) { return utils_1.TypeGuards.isVariableStatement(previousMember); },\r\n                        nextNewLine: function (nextMember) { return utils_1.TypeGuards.isVariableStatement(nextMember); }\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        /* Variable declarations */\r\n        class_1.prototype.getVariableDeclarations = function () {\r\n            var e_1, _a;\r\n            var variables = [];\r\n            try {\r\n                for (var _b = tslib_1.__values(this.getVariableStatements()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var list = _c.value;\r\n                    variables.push.apply(variables, tslib_1.__spread(list.getDeclarations()));\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return variables;\r\n        };\r\n        class_1.prototype.getVariableDeclaration = function (nameOrFindFunction) {\r\n            return utils_1.getNodeByNameOrFindFunction(this.getVariableDeclarations(), nameOrFindFunction);\r\n        };\r\n        class_1.prototype.getVariableDeclarationOrThrow = function (nameOrFindFunction) {\r\n            return errors.throwIfNullOrUndefined(this.getVariableDeclaration(nameOrFindFunction), function () { return utils_1.getNotFoundErrorMessageForNameOrFindFunction(\"variable declaration\", nameOrFindFunction); });\r\n        };\r\n        class_1.prototype.fill = function (structure) {\r\n            callBaseFill_1.callBaseFill(Base.prototype, this, structure);\r\n            if (structure.classes != null && structure.classes.length > 0)\r\n                this.addClasses(structure.classes);\r\n            if (structure.enums != null && structure.enums.length > 0)\r\n                this.addEnums(structure.enums);\r\n            if (structure.functions != null && structure.functions.length > 0)\r\n                this.addFunctions(structure.functions);\r\n            if (structure.interfaces != null && structure.interfaces.length > 0)\r\n                this.addInterfaces(structure.interfaces);\r\n            if (structure.namespaces != null && structure.namespaces.length > 0)\r\n                this.addNamespaces(structure.namespaces);\r\n            if (structure.typeAliases != null && structure.typeAliases.length > 0)\r\n                this.addTypeAliases(structure.typeAliases);\r\n            return this;\r\n        };\r\n        /**\r\n         * @internal\r\n         */\r\n        class_1.prototype.getCompilerStatements = function () {\r\n            if (utils_1.TypeGuards.isSourceFile(this) || utils_1.TypeGuards.isCaseClause(this) || utils_1.TypeGuards.isDefaultClause(this))\r\n                return this.compilerNode.statements;\r\n            else if (utils_1.TypeGuards.isNamespaceDeclaration(this)) {\r\n                // need to get the inner-most body for namespaces\r\n                var node = this;\r\n                while (utils_1.TypeGuards.isBodiedNode(node) && node.compilerNode.statements == null) {\r\n                    node = node.getBody();\r\n                }\r\n                return node.compilerNode.statements;\r\n            }\r\n            else if (utils_1.TypeGuards.isBodyableNode(this))\r\n                return this.getBodyOrThrow().compilerNode.statements;\r\n            else if (utils_1.TypeGuards.isBodiedNode(this))\r\n                return this.getBody().compilerNode.statements;\r\n            else if (utils_1.TypeGuards.isBlock(this))\r\n                return this.compilerNode.statements;\r\n            else\r\n                throw new errors.NotImplementedError(\"Could not find the statements for node kind: \" + this.getKindName() + \", text: \" + this.getText());\r\n        };\r\n        class_1.prototype._insertChildren = function (opts) {\r\n            var _this = this;\r\n            return manipulation_1.insertIntoBracesOrSourceFileWithGetChildren({\r\n                expectedKind: opts.expectedKind,\r\n                getIndexedChildren: function () { return _this.getStatements(); },\r\n                index: opts.index,\r\n                parent: this,\r\n                structures: opts.structures,\r\n                write: function (writer, info) { return opts.write(writer, info); }\r\n            });\r\n        };\r\n        class_1.prototype._standardWrite = function (writer, info, writeStructures, opts) {\r\n            if (opts === void 0) { opts = {}; }\r\n            if (info.previousMember != null && (opts.previousNewLine == null || !opts.previousNewLine(info.previousMember)))\r\n                writer.blankLine();\r\n            else if (!info.isStartOfFile)\r\n                writer.newLine();\r\n            writeStructures();\r\n            if (info.nextMember != null && (opts.nextNewLine == null || !opts.nextNewLine(info.nextMember)))\r\n                writer.blankLine();\r\n            else\r\n                writer.newLine();\r\n        };\r\n        return class_1;\r\n    }(Base));\r\n}\r\nexports.StatementedNode = StatementedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/SwitchStatement.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/SwitchStatement.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.SwitchStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar SwitchStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SwitchStatement, _super);\r\n    function SwitchStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this switch statement's expression.\r\n     */\r\n    SwitchStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets this switch statement's case block.\r\n     */\r\n    SwitchStatement.prototype.getCaseBlock = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.caseBlock);\r\n    };\r\n    /**\r\n     * Gets the switch statement's case block's clauses.\r\n     */\r\n    SwitchStatement.prototype.getClauses = function () {\r\n        // convenience method\r\n        return this.getCaseBlock().getClauses();\r\n    };\r\n    /**\r\n     * Removes the specified clause based on the provided index.\r\n     * @param index - Index.\r\n     */\r\n    SwitchStatement.prototype.removeClause = function (index) {\r\n        return this.getCaseBlock().removeClause(index);\r\n    };\r\n    /**\r\n     * Removes the specified clauses based on the provided index range.\r\n     * @param indexRange - Index range.\r\n     */\r\n    SwitchStatement.prototype.removeClauses = function (indexRange) {\r\n        return this.getCaseBlock().removeClauses(indexRange);\r\n    };\r\n    return SwitchStatement;\r\n}(exports.SwitchStatementBase));\r\nexports.SwitchStatement = SwitchStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/SwitchStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/ThrowStatement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/ThrowStatement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nvar errors = __webpack_require__(/*! ./../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nexports.ThrowStatementBase = Statement_1.Statement;\r\nvar ThrowStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ThrowStatement, _super);\r\n    function ThrowStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the throw statement's expression.\r\n     */\r\n    ThrowStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets the throw statement's expression or throws undefined if it doesn't exist.\r\n     */\r\n    ThrowStatement.prototype.getExpressionOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getExpression(), \"Expected to find the throw statement's expression.\");\r\n    };\r\n    return ThrowStatement;\r\n}(exports.ThrowStatementBase));\r\nexports.ThrowStatement = ThrowStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/ThrowStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/TryStatement.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/TryStatement.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.TryStatementBase = Statement_1.Statement;\r\nvar TryStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TryStatement, _super);\r\n    function TryStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this try statement's try block.\r\n     */\r\n    TryStatement.prototype.getTryBlock = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.tryBlock);\r\n    };\r\n    /**\r\n     * Gets this try statement's catch clause or undefined if none exists.\r\n     */\r\n    TryStatement.prototype.getCatchClause = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.catchClause);\r\n    };\r\n    /**\r\n     * Gets this try statement's catch clause or throws if none exists.\r\n     */\r\n    TryStatement.prototype.getCatchClauseOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getCatchClause(), \"Expected to find a catch clause.\");\r\n    };\r\n    /**\r\n     * Gets this try statement's finally block or undefined if none exists.\r\n     */\r\n    TryStatement.prototype.getFinallyBlock = function () {\r\n        if (this.compilerNode.finallyBlock == null || this.compilerNode.finallyBlock.getFullWidth() === 0)\r\n            return undefined;\r\n        return this.getNodeFromCompilerNode(this.compilerNode.finallyBlock);\r\n    };\r\n    /**\r\n     * Gets this try statement's finally block or throws if none exists.\r\n     */\r\n    TryStatement.prototype.getFinallyBlockOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getFinallyBlock(), \"Expected to find a finally block.\");\r\n    };\r\n    return TryStatement;\r\n}(exports.TryStatementBase));\r\nexports.TryStatement = TryStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/TryStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/VariableStatement.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/VariableStatement.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar namespace_1 = __webpack_require__(/*! ../namespace */ \"./node_modules/ts-simple-ast/dist/compiler/namespace/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.VariableStatementBase = base_1.ChildOrderableNode(namespace_1.NamespaceChildableNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(Statement_1.Statement))))));\r\nvar VariableStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(VariableStatement, _super);\r\n    function VariableStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Get variable declaration list.\r\n     */\r\n    VariableStatement.prototype.getDeclarationList = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.declarationList);\r\n    };\r\n    /**\r\n     * Get the variable declarations.\r\n     */\r\n    VariableStatement.prototype.getDeclarations = function () {\r\n        return this.getDeclarationList().getDeclarations();\r\n    };\r\n    /**\r\n     * Gets the variable declaration kind.\r\n     */\r\n    VariableStatement.prototype.getDeclarationKind = function () {\r\n        return this.getDeclarationList().getDeclarationKind();\r\n    };\r\n    /**\r\n     * Gets the variable declaration kind keyword.\r\n     */\r\n    VariableStatement.prototype.getDeclarationKindKeyword = function () {\r\n        return this.getDeclarationList().getDeclarationKindKeyword();\r\n    };\r\n    /**\r\n     * Sets the variable declaration kind.\r\n     * @param type - Type to set.\r\n     */\r\n    VariableStatement.prototype.setDeclarationKind = function (type) {\r\n        return this.getDeclarationList().setDeclarationKind(type);\r\n    };\r\n    /**\r\n     * Add a variable declaration to the statement.\r\n     * @param structure - Structure representing the variable declaration to add.\r\n     */\r\n    VariableStatement.prototype.addDeclaration = function (structure) {\r\n        return this.getDeclarationList().addDeclaration(structure);\r\n    };\r\n    /**\r\n     * Adds variable declarations to the statement.\r\n     * @param structures - Structures representing the variable declarations to add.\r\n     */\r\n    VariableStatement.prototype.addDeclarations = function (structures) {\r\n        return this.getDeclarationList().addDeclarations(structures);\r\n    };\r\n    /**\r\n     * Inserts a variable declaration at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the variable declaration to insert.\r\n     */\r\n    VariableStatement.prototype.insertDeclaration = function (index, structure) {\r\n        return this.getDeclarationList().insertDeclaration(index, structure);\r\n    };\r\n    /**\r\n     * Inserts variable declarations at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the variable declarations to insert.\r\n     */\r\n    VariableStatement.prototype.insertDeclarations = function (index, structures) {\r\n        return this.getDeclarationList().insertDeclarations(index, structures);\r\n    };\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    VariableStatement.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.VariableStatementBase.prototype, this, structure);\r\n        if (structure.declarationKind != null)\r\n            this.setDeclarationKind(structure.declarationKind);\r\n        if (structure.declarations != null)\r\n            this.addDeclarations(structure.declarations);\r\n        return this;\r\n    };\r\n    return VariableStatement;\r\n}(exports.VariableStatementBase));\r\nexports.VariableStatement = VariableStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/VariableStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/WhileStatement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/WhileStatement.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar IterationStatement_1 = __webpack_require__(/*! ./IterationStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js\");\r\nexports.WhileStatementBase = IterationStatement_1.IterationStatement;\r\nvar WhileStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(WhileStatement, _super);\r\n    function WhileStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this while statement's expression.\r\n     */\r\n    WhileStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    return WhileStatement;\r\n}(exports.WhileStatementBase));\r\nexports.WhileStatement = WhileStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/WhileStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/WithStatement.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/WithStatement.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\");\r\nexports.WithStatementBase = base_1.ChildOrderableNode(Statement_1.Statement);\r\nvar WithStatement = /** @class */ (function (_super) {\r\n    tslib_1.__extends(WithStatement, _super);\r\n    function WithStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets this with statement's expression.\r\n     */\r\n    WithStatement.prototype.getExpression = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.expression);\r\n    };\r\n    /**\r\n     * Gets this with statement's statement.\r\n     */\r\n    WithStatement.prototype.getStatement = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.statement);\r\n    };\r\n    return WithStatement;\r\n}(exports.WithStatementBase));\r\nexports.WithStatement = WithStatement;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/WithStatement.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/statement/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/statement/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Block */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Block.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BreakStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/BreakStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CaseBlock */ \"./node_modules/ts-simple-ast/dist/compiler/statement/CaseBlock.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CaseClause */ \"./node_modules/ts-simple-ast/dist/compiler/statement/CaseClause.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CatchClause */ \"./node_modules/ts-simple-ast/dist/compiler/statement/CatchClause.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ContinueStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ContinueStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DebuggerStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/DebuggerStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DefaultClause */ \"./node_modules/ts-simple-ast/dist/compiler/statement/DefaultClause.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DoStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/DoStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EmptyStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/EmptyStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExpressionStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ExpressionStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ForInStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ForInStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ForOfStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ForOfStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ForStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ForStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./IfStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IfStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./IterationStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/IterationStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LabeledStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/LabeledStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NotEmittedStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/NotEmittedStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReturnStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ReturnStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/Statement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StatementedNode */ \"./node_modules/ts-simple-ast/dist/compiler/statement/StatementedNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SwitchStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/SwitchStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ThrowStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/ThrowStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TryStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/TryStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VariableStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/VariableStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./WhileStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/WhileStatement.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./WithStatement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/WithStatement.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/statement/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/LanguageService.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/LanguageService.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar fileSystem_1 = __webpack_require__(/*! ../../fileSystem */ \"./node_modules/ts-simple-ast/dist/fileSystem/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar Program_1 = __webpack_require__(/*! ./Program */ \"./node_modules/ts-simple-ast/dist/compiler/tools/Program.js\");\r\nvar results_1 = __webpack_require__(/*! ./results */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/index.js\");\r\nvar LanguageService = /** @class */ (function () {\r\n    /** @internal */\r\n    function LanguageService(context) {\r\n        var _this = this;\r\n        this.context = context;\r\n        var version = 0;\r\n        var fileExistsSync = function (path) { return _this.context.compilerFactory.containsSourceFileAtPath(path) || context.fileSystemWrapper.fileExistsSync(path); };\r\n        var languageServiceHost = {\r\n            getCompilationSettings: function () { return context.compilerOptions.get(); },\r\n            getNewLine: function () { return context.manipulationSettings.getNewLineKindAsString(); },\r\n            getScriptFileNames: function () { return _this.context.compilerFactory.getSourceFilePaths(); },\r\n            getScriptVersion: function (fileName) {\r\n                var sourceFile = _this.context.compilerFactory.getSourceFileFromCacheFromFilePath(fileName);\r\n                if (sourceFile == null)\r\n                    return (version++).toString();\r\n                return _this.context.compilerFactory.documentRegistry.getSourceFileVersion(sourceFile.compilerNode);\r\n            },\r\n            getScriptSnapshot: function (fileName) {\r\n                if (!fileExistsSync(fileName))\r\n                    return undefined;\r\n                return typescript_1.ts.ScriptSnapshot.fromString(_this.context.compilerFactory.addOrGetSourceFileFromFilePath(fileName).getFullText());\r\n            },\r\n            getCurrentDirectory: function () { return context.fileSystemWrapper.getCurrentDirectory(); },\r\n            getDefaultLibFileName: function (options) {\r\n                if (_this.context.fileSystemWrapper.getFileSystem() instanceof fileSystem_1.DefaultFileSystemHost)\r\n                    return typescript_1.ts.getDefaultLibFilePath(context.compilerOptions.get());\r\n                else\r\n                    return utils_1.FileUtils.pathJoin(context.fileSystemWrapper.getCurrentDirectory(), \"node_modules/typescript/lib/\" + typescript_1.ts.getDefaultLibFileName(context.compilerOptions.get()));\r\n            },\r\n            useCaseSensitiveFileNames: function () { return true; },\r\n            readFile: function (path, encoding) {\r\n                if (_this.context.compilerFactory.containsSourceFileAtPath(path))\r\n                    return _this.context.compilerFactory.getSourceFileFromCacheFromFilePath(path).getFullText();\r\n                return _this.context.fileSystemWrapper.readFileSync(path, encoding);\r\n            },\r\n            fileExists: fileExistsSync,\r\n            directoryExists: function (dirName) { return _this.context.compilerFactory.containsDirectoryAtPath(dirName) || _this.context.fileSystemWrapper.directoryExistsSync(dirName); }\r\n        };\r\n        this.compilerHost = {\r\n            getSourceFile: function (fileName, languageVersion, onError) {\r\n                var sourceFile = _this.context.compilerFactory.addOrGetSourceFileFromFilePath(fileName);\r\n                return sourceFile == null ? undefined : sourceFile.compilerNode;\r\n            },\r\n            // getSourceFileByPath: (...) => {}, // not providing these will force it to use the file name as the file path\r\n            // getDefaultLibLocation: (...) => {},\r\n            getDefaultLibFileName: function (options) { return languageServiceHost.getDefaultLibFileName(options); },\r\n            writeFile: function (filePath, data, writeByteOrderMark, onError, sourceFiles) {\r\n                _this.context.fileSystemWrapper.writeFileSync(filePath, data);\r\n            },\r\n            getCurrentDirectory: function () { return languageServiceHost.getCurrentDirectory(); },\r\n            getDirectories: function (path) { return _this.context.fileSystemWrapper.getDirectories(path); },\r\n            fileExists: function (fileName) { return languageServiceHost.fileExists(fileName); },\r\n            readFile: function (fileName) { return languageServiceHost.readFile(fileName); },\r\n            getCanonicalFileName: function (fileName) { return _this.context.fileSystemWrapper.getStandardizedAbsolutePath(fileName); },\r\n            useCaseSensitiveFileNames: function () { return languageServiceHost.useCaseSensitiveFileNames(); },\r\n            getNewLine: function () { return languageServiceHost.getNewLine(); },\r\n            getEnvironmentVariable: function (name) { return process.env[name]; },\r\n            directoryExists: function (dirName) { return languageServiceHost.directoryExists(dirName); }\r\n        };\r\n        this._compilerObject = typescript_1.ts.createLanguageService(languageServiceHost, this.context.compilerFactory.documentRegistry);\r\n        this.program = new Program_1.Program(this.context, this.context.compilerFactory.getSourceFilePaths(), this.compilerHost);\r\n        this.context.compilerFactory.onSourceFileAdded(function () { return _this.resetProgram(); });\r\n        this.context.compilerFactory.onSourceFileRemoved(function () { return _this.resetProgram(); });\r\n    }\r\n    Object.defineProperty(LanguageService.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the compiler language service.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets the program. This should be done whenever any modifications happen.\r\n     * @internal\r\n     */\r\n    LanguageService.prototype.resetProgram = function () {\r\n        this.program.reset(this.context.compilerFactory.getSourceFilePaths(), this.compilerHost);\r\n    };\r\n    /**\r\n     * Gets the language service's program.\r\n     */\r\n    LanguageService.prototype.getProgram = function () {\r\n        return this.program;\r\n    };\r\n    /**\r\n     * Rename the specified node.\r\n     * @param node - Node to rename.\r\n     * @param newName - New name for the node.\r\n     * @param options - Options for renaming the node.\r\n     */\r\n    LanguageService.prototype.renameNode = function (node, newName, options) {\r\n        if (options === void 0) { options = {}; }\r\n        errors.throwIfNotStringOrWhitespace(newName, \"newName\");\r\n        if (node.getText() === newName)\r\n            return;\r\n        this.renameLocations(this.findRenameLocations(node, options), newName);\r\n    };\r\n    /**\r\n     * Rename the provided rename locations.\r\n     * @param renameLocations - Rename locations.\r\n     * @param newName - New name for the node.\r\n     */\r\n    LanguageService.prototype.renameLocations = function (renameLocations, newName) {\r\n        var e_1, _a, e_2, _b;\r\n        var renameLocationsBySourceFile = new utils_1.KeyValueCache();\r\n        try {\r\n            for (var renameLocations_1 = tslib_1.__values(renameLocations), renameLocations_1_1 = renameLocations_1.next(); !renameLocations_1_1.done; renameLocations_1_1 = renameLocations_1.next()) {\r\n                var renameLocation = renameLocations_1_1.value;\r\n                var locations = renameLocationsBySourceFile.getOrCreate(renameLocation.getSourceFile(), function () { return []; });\r\n                locations.push(renameLocation);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (renameLocations_1_1 && !renameLocations_1_1.done && (_a = renameLocations_1.return)) _a.call(renameLocations_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        try {\r\n            for (var _c = tslib_1.__values(renameLocationsBySourceFile.getEntries()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var _e = tslib_1.__read(_d.value, 2), sourceFile = _e[0], locations = _e[1];\r\n                manipulation_1.replaceSourceFileTextForRename({\r\n                    sourceFile: sourceFile,\r\n                    renameLocations: locations,\r\n                    newName: newName\r\n                });\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    /**\r\n     * Gets the definitions for the specified node.\r\n     * @param node - Node.\r\n     */\r\n    LanguageService.prototype.getDefinitions = function (node) {\r\n        return this.getDefinitionsAtPosition(node.sourceFile, node.getStart());\r\n    };\r\n    /**\r\n     * Gets the definitions at the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param pos - Position.\r\n     */\r\n    LanguageService.prototype.getDefinitionsAtPosition = function (sourceFile, pos) {\r\n        var _this = this;\r\n        var results = this.compilerObject.getDefinitionAtPosition(sourceFile.getFilePath(), pos) || [];\r\n        return results.map(function (info) { return _this.context.compilerFactory.getDefinitionInfo(info); });\r\n    };\r\n    /**\r\n     * Gets the implementations for the specified node.\r\n     * @param node - Node.\r\n     */\r\n    LanguageService.prototype.getImplementations = function (node) {\r\n        return this.getImplementationsAtPosition(node.sourceFile, node.getStart());\r\n    };\r\n    /**\r\n     * Gets the implementations at the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param pos - Position.\r\n     */\r\n    LanguageService.prototype.getImplementationsAtPosition = function (sourceFile, pos) {\r\n        var _this = this;\r\n        var results = this.compilerObject.getImplementationAtPosition(sourceFile.getFilePath(), pos) || [];\r\n        return results.map(function (location) { return new results_1.ImplementationLocation(_this.context, location); });\r\n    };\r\n    /**\r\n     * Finds references based on the specified node.\r\n     * @param node - Node to find references for.\r\n     */\r\n    LanguageService.prototype.findReferences = function (node) {\r\n        return this.findReferencesAtPosition(node.sourceFile, node.getStart());\r\n    };\r\n    /**\r\n     * Finds the nodes that reference the definition(s) of the specified node.\r\n     * @param node - Node.\r\n     */\r\n    LanguageService.prototype.findReferencesAsNodes = function (node) {\r\n        var references = this.findReferences(node);\r\n        return utils_1.ArrayUtils.from(getReferencingNodes());\r\n        function getReferencingNodes() {\r\n            var e_3, _a, e_4, _b, references_1, references_1_1, referenceSymbol, isAlias, _c, _d, reference, e_4_1, e_3_1;\r\n            return tslib_1.__generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        _e.trys.push([0, 11, 12, 13]);\r\n                        references_1 = tslib_1.__values(references), references_1_1 = references_1.next();\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        if (!!references_1_1.done) return [3 /*break*/, 10];\r\n                        referenceSymbol = references_1_1.value;\r\n                        isAlias = referenceSymbol.getDefinition().getKind() === typescript_1.ts.ScriptElementKind.alias;\r\n                        _e.label = 2;\r\n                    case 2:\r\n                        _e.trys.push([2, 7, 8, 9]);\r\n                        _c = tslib_1.__values(referenceSymbol.getReferences()), _d = _c.next();\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        if (!!_d.done) return [3 /*break*/, 6];\r\n                        reference = _d.value;\r\n                        if (!(isAlias || !reference.isDefinition())) return [3 /*break*/, 5];\r\n                        return [4 /*yield*/, reference.getNode()];\r\n                    case 4:\r\n                        _e.sent();\r\n                        _e.label = 5;\r\n                    case 5:\r\n                        _d = _c.next();\r\n                        return [3 /*break*/, 3];\r\n                    case 6: return [3 /*break*/, 9];\r\n                    case 7:\r\n                        e_4_1 = _e.sent();\r\n                        e_4 = { error: e_4_1 };\r\n                        return [3 /*break*/, 9];\r\n                    case 8:\r\n                        try {\r\n                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\r\n                        }\r\n                        finally { if (e_4) throw e_4.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 9:\r\n                        references_1_1 = references_1.next();\r\n                        return [3 /*break*/, 1];\r\n                    case 10: return [3 /*break*/, 13];\r\n                    case 11:\r\n                        e_3_1 = _e.sent();\r\n                        e_3 = { error: e_3_1 };\r\n                        return [3 /*break*/, 13];\r\n                    case 12:\r\n                        try {\r\n                            if (references_1_1 && !references_1_1.done && (_a = references_1.return)) _a.call(references_1);\r\n                        }\r\n                        finally { if (e_3) throw e_3.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 13: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Finds references based on the specified position.\r\n     * @param sourceFile - Source file.\r\n     * @param pos - Position to find the reference at.\r\n     */\r\n    LanguageService.prototype.findReferencesAtPosition = function (sourceFile, pos) {\r\n        var _this = this;\r\n        var results = this.compilerObject.findReferences(sourceFile.getFilePath(), pos) || [];\r\n        return results.map(function (s) { return _this.context.compilerFactory.getReferencedSymbol(s); });\r\n    };\r\n    /**\r\n     * Find the rename locations for the specified node.\r\n     * @param node - Node to get the rename locations for.\r\n     * @param options - Options for renaming.\r\n     */\r\n    LanguageService.prototype.findRenameLocations = function (node, options) {\r\n        var _this = this;\r\n        if (options === void 0) { options = {}; }\r\n        var renameLocations = this.compilerObject.findRenameLocations(node.sourceFile.getFilePath(), node.getStart(), options.renameInStrings || false, options.renameInComments || false) || [];\r\n        return renameLocations.map(function (l) { return new results_1.RenameLocation(_this.context, l); });\r\n    };\r\n    /**\r\n     * Gets the formatting edits for a range.\r\n     * @param filePath - File path.\r\n     * @param range - Position range.\r\n     * @param settings - Settings.\r\n     */\r\n    LanguageService.prototype.getFormattingEditsForRange = function (filePath, range, settings) {\r\n        return (this.compilerObject.getFormattingEditsForRange(filePath, range[0], range[1], this._getFilledSettings(settings)) || []).map(function (e) { return new results_1.TextChange(e); });\r\n    };\r\n    /**\r\n     * Gets the formatting edits for a document.\r\n     * @param filePath - File path of the source file.\r\n     * @param settings - Format code settings.\r\n     */\r\n    LanguageService.prototype.getFormattingEditsForDocument = function (filePath, settings) {\r\n        return (this.compilerObject.getFormattingEditsForDocument(filePath, this._getFilledSettings(settings)) || []).map(function (e) { return new results_1.TextChange(e); });\r\n    };\r\n    /**\r\n     * Gets the formatted text for a document.\r\n     * @param filePath - File path of the source file.\r\n     * @param settings - Format code settings.\r\n     */\r\n    LanguageService.prototype.getFormattedDocumentText = function (filePath, settings) {\r\n        var sourceFile = this.context.compilerFactory.getSourceFileFromCacheFromFilePath(filePath);\r\n        if (sourceFile == null)\r\n            throw new errors.FileNotFoundError(filePath);\r\n        settings = this._getFilledSettings(settings);\r\n        var formattingEdits = this.getFormattingEditsForDocument(filePath, settings);\r\n        var newText = manipulation_1.getTextFromFormattingEdits(sourceFile, formattingEdits);\r\n        var newLineChar = settings.newLineCharacter;\r\n        if (settings.ensureNewLineAtEndOfFile && !utils_1.StringUtils.endsWith(newText, newLineChar))\r\n            newText += newLineChar;\r\n        return newText.replace(/\\r?\\n/g, newLineChar);\r\n    };\r\n    LanguageService.prototype.getEmitOutput = function (filePathOrSourceFile, emitOnlyDtsFiles) {\r\n        var filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);\r\n        return new results_1.EmitOutput(this.context, filePath, this.compilerObject.getEmitOutput(filePath, emitOnlyDtsFiles));\r\n    };\r\n    LanguageService.prototype.getIdentationAtPosition = function (filePathOrSourceFile, position, settings) {\r\n        var filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);\r\n        if (settings == null)\r\n            settings = this.context.manipulationSettings.getEditorSettings();\r\n        else\r\n            utils_1.fillDefaultEditorSettings(settings, this.context.manipulationSettings);\r\n        return this.compilerObject.getIndentationAtPosition(filePath, position, settings);\r\n    };\r\n    LanguageService.prototype.organizeImports = function (filePathOrSourceFile, settings, userPreferences) {\r\n        if (settings === void 0) { settings = {}; }\r\n        if (userPreferences === void 0) { userPreferences = {}; }\r\n        var scope = {\r\n            type: \"file\",\r\n            fileName: this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile)\r\n        };\r\n        return this.compilerObject.organizeImports(scope, this._getFilledSettings(settings), this._getFilledUserPreferences(userPreferences))\r\n            .map(function (fileTextChanges) { return new results_1.FileTextChanges(fileTextChanges); });\r\n    };\r\n    LanguageService.prototype._getFilePathFromFilePathOrSourceFile = function (filePathOrSourceFile) {\r\n        var filePath = typeof filePathOrSourceFile === \"string\"\r\n            ? this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePathOrSourceFile)\r\n            : filePathOrSourceFile.getFilePath();\r\n        if (!this.context.compilerFactory.containsSourceFileAtPath(filePath))\r\n            throw new errors.FileNotFoundError(filePath);\r\n        return filePath;\r\n    };\r\n    LanguageService.prototype._getFilledSettings = function (settings) {\r\n        if (settings[\"_filled\"]) // optimization\r\n            return settings;\r\n        settings = utils_1.ObjectUtils.assign(this.context.getFormatCodeSettings(), settings);\r\n        utils_1.fillDefaultFormatCodeSettings(settings, this.context.manipulationSettings);\r\n        settings[\"_filled\"] = true;\r\n        return settings;\r\n    };\r\n    LanguageService.prototype._getFilledUserPreferences = function (userPreferences) {\r\n        return utils_1.ObjectUtils.assign(this.context.getUserPreferences(), userPreferences);\r\n    };\r\n    return LanguageService;\r\n}());\r\nexports.LanguageService = LanguageService;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/LanguageService.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/Program.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/Program.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar tsInternal = __webpack_require__(/*! ../../typescript/tsInternal */ \"./node_modules/ts-simple-ast/dist/typescript/tsInternal.js\");\r\nvar results_1 = __webpack_require__(/*! ./results */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/index.js\");\r\nvar TypeChecker_1 = __webpack_require__(/*! ./TypeChecker */ \"./node_modules/ts-simple-ast/dist/compiler/tools/TypeChecker.js\");\r\n/**\r\n * Wrapper around Program.\r\n */\r\nvar Program = /** @class */ (function () {\r\n    /** @internal */\r\n    function Program(context, rootNames, host) {\r\n        this.context = context;\r\n        this.typeChecker = new TypeChecker_1.TypeChecker(this.context);\r\n        this.reset(rootNames, host);\r\n    }\r\n    Object.defineProperty(Program.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the underlying compiler program.\r\n         */\r\n        get: function () {\r\n            return this._getOrCreateCompilerObject();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets the program.\r\n     * @internal\r\n     */\r\n    Program.prototype.reset = function (rootNames, host) {\r\n        var _this = this;\r\n        var compilerOptions = this.context.compilerOptions.get();\r\n        this._getOrCreateCompilerObject = function () {\r\n            // need to use ts.createProgram instead of languageService.getProgram() because the\r\n            // program created by the language service is not fully featured (ex. does not write to the file system)\r\n            if (_this._createdCompilerObject == null)\r\n                _this._createdCompilerObject = typescript_1.ts.createProgram(rootNames, compilerOptions, host);\r\n            // this needs to be on a separate line in case the program was reset between the line above and here\r\n            return _this._createdCompilerObject || _this._getOrCreateCompilerObject();\r\n        };\r\n        this._createdCompilerObject = undefined;\r\n        this.typeChecker.reset(function () { return _this.compilerObject.getTypeChecker(); });\r\n    };\r\n    /**\r\n     * Get the program's type checker.\r\n     */\r\n    Program.prototype.getTypeChecker = function () {\r\n        return this.typeChecker;\r\n    };\r\n    /**\r\n     * Emits the TypeScript files to JavaScript files.\r\n     * @param options - Options for emitting.\r\n     */\r\n    Program.prototype.emit = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        return new results_1.EmitResult(this.context, this._emit(options));\r\n    };\r\n    /**\r\n     * Emits the TypeScript files to JavaScript files to memory.\r\n     * @param options - Options for emitting.\r\n     */\r\n    Program.prototype.emitToMemory = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        var sourceFiles = [];\r\n        var fileSystemWrapper = this.context.fileSystemWrapper;\r\n        var emitResult = this._emit(tslib_1.__assign({ writeFile: function (filePath, text, writeByteOrderMark) {\r\n                sourceFiles.push({\r\n                    filePath: fileSystemWrapper.getStandardizedAbsolutePath(filePath),\r\n                    text: text,\r\n                    writeByteOrderMark: writeByteOrderMark || false\r\n                });\r\n            } }, options));\r\n        return new results_1.MemoryEmitResult(this.context, emitResult, sourceFiles);\r\n    };\r\n    /** @internal */\r\n    Program.prototype._emit = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        var targetSourceFile = options.targetSourceFile != null ? options.targetSourceFile.compilerNode : undefined;\r\n        var emitOnlyDtsFiles = options.emitOnlyDtsFiles, customTransformers = options.customTransformers, writeFile = options.writeFile;\r\n        var cancellationToken = undefined; // todo: expose this\r\n        return this.compilerObject.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\r\n    };\r\n    /**\r\n     * Gets the syntactic diagnostics.\r\n     * @param sourceFile - Optional source file to filter by.\r\n     */\r\n    Program.prototype.getSyntacticDiagnostics = function (sourceFile) {\r\n        var _this = this;\r\n        var compilerDiagnostics = this.compilerObject.getSyntacticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);\r\n        return compilerDiagnostics.map(function (d) { return _this.context.compilerFactory.getDiagnosticWithLocation(d); });\r\n    };\r\n    /**\r\n     * Gets the semantic diagnostics.\r\n     * @param sourceFile - Optional source file to filter by.\r\n     */\r\n    Program.prototype.getSemanticDiagnostics = function (sourceFile) {\r\n        var _this = this;\r\n        var compilerDiagnostics = this.compilerObject.getSemanticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);\r\n        return compilerDiagnostics.map(function (d) { return _this.context.compilerFactory.getDiagnostic(d); });\r\n    };\r\n    /**\r\n     * Gets the declaration diagnostics.\r\n     * @param sourceFile - Optional source file to filter by.\r\n     */\r\n    Program.prototype.getDeclarationDiagnostics = function (sourceFile) {\r\n        var _this = this;\r\n        var compilerDiagnostics = this.compilerObject.getDeclarationDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);\r\n        return compilerDiagnostics.map(function (d) { return _this.context.compilerFactory.getDiagnosticWithLocation(d); });\r\n    };\r\n    /**\r\n     * Gets the global diagnostics.\r\n     */\r\n    Program.prototype.getGlobalDiagnostics = function () {\r\n        var _this = this;\r\n        var compilerDiagnostics = this.compilerObject.getGlobalDiagnostics();\r\n        return compilerDiagnostics.map(function (d) { return _this.context.compilerFactory.getDiagnostic(d); });\r\n    };\r\n    /**\r\n     * Gets the emit module resolution kind.\r\n     */\r\n    Program.prototype.getEmitModuleResolutionKind = function () {\r\n        return tsInternal.getEmitModuleResolutionKind(this.compilerObject.getCompilerOptions());\r\n    };\r\n    /**\r\n     * Gets if the provided source file is from an external library.\r\n     * @param sourceFile - Source file.\r\n     */\r\n    Program.prototype.isSourceFileFromExternalLibrary = function (sourceFile) {\r\n        return this.compilerObject.isSourceFileFromExternalLibrary(sourceFile.compilerNode);\r\n    };\r\n    return Program;\r\n}());\r\nexports.Program = Program;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/Program.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/TypeChecker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/TypeChecker.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\n/**\r\n * Wrapper around the TypeChecker.\r\n */\r\nvar TypeChecker = /** @class */ (function () {\r\n    /** @internal */\r\n    function TypeChecker(context) {\r\n        this.context = context;\r\n    }\r\n    Object.defineProperty(TypeChecker.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the compiler's TypeChecker.\r\n         */\r\n        get: function () {\r\n            return this._getCompilerObject();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets the type checker.\r\n     * @internal\r\n     */\r\n    TypeChecker.prototype.reset = function (getTypeChecker) {\r\n        this._getCompilerObject = getTypeChecker;\r\n    };\r\n    /**\r\n     * Gets the apparent type of a type.\r\n     * @param type - Type to get the apparent type of.\r\n     */\r\n    TypeChecker.prototype.getApparentType = function (type) {\r\n        return this.context.compilerFactory.getType(this.compilerObject.getApparentType(type.compilerType));\r\n    };\r\n    /**\r\n     * Gets the constant value of a declaration.\r\n     * @param node - Node to get the constant value from.\r\n     */\r\n    TypeChecker.prototype.getConstantValue = function (node) {\r\n        return this.compilerObject.getConstantValue(node.compilerNode);\r\n    };\r\n    /**\r\n     * Gets the fully qualified name of a symbol.\r\n     * @param symbol - Symbol to get the fully qualified name of.\r\n     */\r\n    TypeChecker.prototype.getFullyQualifiedName = function (symbol) {\r\n        return this.compilerObject.getFullyQualifiedName(symbol.compilerSymbol);\r\n    };\r\n    /**\r\n     * Gets the type at the specified location.\r\n     * @param node - Node to get the type for.\r\n     */\r\n    TypeChecker.prototype.getTypeAtLocation = function (node) {\r\n        return this.context.compilerFactory.getType(this.compilerObject.getTypeAtLocation(node.compilerNode));\r\n    };\r\n    /**\r\n     * Gets the contextual type of an expression.\r\n     * @param expression - Expression.\r\n     */\r\n    TypeChecker.prototype.getContextualType = function (expression) {\r\n        var contextualType = this.compilerObject.getContextualType(expression.compilerNode);\r\n        return contextualType == null ? undefined : this.context.compilerFactory.getType(contextualType);\r\n    };\r\n    /**\r\n     * Gets the type of a symbol at the specified location.\r\n     * @param symbol - Symbol to get the type for.\r\n     * @param node - Location to get the type for.\r\n     */\r\n    TypeChecker.prototype.getTypeOfSymbolAtLocation = function (symbol, node) {\r\n        return this.context.compilerFactory.getType(this.compilerObject.getTypeOfSymbolAtLocation(symbol.compilerSymbol, node.compilerNode));\r\n    };\r\n    /**\r\n     * Gets the declared type of a symbol.\r\n     * @param symbol - Symbol to get the type for.\r\n     */\r\n    TypeChecker.prototype.getDeclaredTypeOfSymbol = function (symbol) {\r\n        return this.context.compilerFactory.getType(this.compilerObject.getDeclaredTypeOfSymbol(symbol.compilerSymbol));\r\n    };\r\n    /**\r\n     * Gets the symbol at the specified location or undefined if none exists.\r\n     * @param node - Node to get the symbol for.\r\n     */\r\n    TypeChecker.prototype.getSymbolAtLocation = function (node) {\r\n        var compilerSymbol = this.compilerObject.getSymbolAtLocation(node.compilerNode);\r\n        return compilerSymbol == null ? undefined : this.context.compilerFactory.getSymbol(compilerSymbol);\r\n    };\r\n    /**\r\n     * Gets the aliased symbol of a symbol.\r\n     * @param symbol - Symbol to get the alias symbol of.\r\n     */\r\n    TypeChecker.prototype.getAliasedSymbol = function (symbol) {\r\n        if (!symbol.hasFlags(typescript_1.SymbolFlags.Alias))\r\n            return undefined;\r\n        var tsAliasSymbol = this.compilerObject.getAliasedSymbol(symbol.compilerSymbol);\r\n        return tsAliasSymbol == null ? undefined : this.context.compilerFactory.getSymbol(tsAliasSymbol);\r\n    };\r\n    /**\r\n     * Gets the properties of a type.\r\n     * @param type - Type.\r\n     */\r\n    TypeChecker.prototype.getPropertiesOfType = function (type) {\r\n        var _this = this;\r\n        return this.compilerObject.getPropertiesOfType(type.compilerType).map(function (p) { return _this.context.compilerFactory.getSymbol(p); });\r\n    };\r\n    /**\r\n     * Gets the type text\r\n     * @param type - Type to get the text of.\r\n     * @param enclosingNode - Enclosing node.\r\n     * @param typeFormatFlags - Type format flags.\r\n     */\r\n    TypeChecker.prototype.getTypeText = function (type, enclosingNode, typeFormatFlags) {\r\n        if (typeFormatFlags == null)\r\n            typeFormatFlags = this.getDefaultTypeFormatFlags(enclosingNode);\r\n        var compilerNode = enclosingNode == null ? undefined : enclosingNode.compilerNode;\r\n        return this.compilerObject.typeToString(type.compilerType, compilerNode, typeFormatFlags);\r\n    };\r\n    /**\r\n     * Gets the return type of a signature.\r\n     * @param signature - Signature to get the return type of.\r\n     */\r\n    TypeChecker.prototype.getReturnTypeOfSignature = function (signature) {\r\n        return this.context.compilerFactory.getType(this.compilerObject.getReturnTypeOfSignature(signature.compilerSignature));\r\n    };\r\n    /**\r\n     * Gets a signature from a node.\r\n     * @param node - Node to get the signature from.\r\n     */\r\n    TypeChecker.prototype.getSignatureFromNode = function (node) {\r\n        var signature = this.compilerObject.getSignatureFromDeclaration(node.compilerNode);\r\n        return signature == null ? undefined : this.context.compilerFactory.getSignature(signature);\r\n    };\r\n    /**\r\n     * Gets the exports of a module.\r\n     * @param moduleSymbol - Module symbol.\r\n     */\r\n    TypeChecker.prototype.getExportsOfModule = function (moduleSymbol) {\r\n        var _this = this;\r\n        var symbols = this.compilerObject.getExportsOfModule(moduleSymbol.compilerSymbol);\r\n        return (symbols || []).map(function (s) { return _this.context.compilerFactory.getSymbol(s); });\r\n    };\r\n    /**\r\n     * Gets the local target symbol of the provided export specifier.\r\n     * @param exportSpecifier - Export specifier.\r\n     */\r\n    TypeChecker.prototype.getExportSpecifierLocalTargetSymbol = function (exportSpecifier) {\r\n        var symbol = this.compilerObject.getExportSpecifierLocalTargetSymbol(exportSpecifier.compilerNode);\r\n        return symbol == null ? undefined : this.context.compilerFactory.getSymbol(symbol);\r\n    };\r\n    /**\r\n     * Gets the base type of a literal type.\r\n     *\r\n     * For example, for a number literal type it will return the number type.\r\n     * @param type - Literal type to get the base type of.\r\n     */\r\n    TypeChecker.prototype.getBaseTypeOfLiteralType = function (type) {\r\n        return this.context.compilerFactory.getType(this.compilerObject.getBaseTypeOfLiteralType(type.compilerType));\r\n    };\r\n    TypeChecker.prototype.getDefaultTypeFormatFlags = function (enclosingNode) {\r\n        var formatFlags = (typescript_1.TypeFormatFlags.UseTypeOfFunction | typescript_1.TypeFormatFlags.NoTruncation | typescript_1.TypeFormatFlags.UseFullyQualifiedType |\r\n            typescript_1.TypeFormatFlags.WriteTypeArgumentsOfSignature);\r\n        if (enclosingNode != null && enclosingNode.getKind() === typescript_1.SyntaxKind.TypeAliasDeclaration)\r\n            formatFlags |= typescript_1.TypeFormatFlags.InTypeAlias;\r\n        return formatFlags;\r\n    };\r\n    return TypeChecker;\r\n}());\r\nexports.TypeChecker = TypeChecker;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/TypeChecker.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LanguageService */ \"./node_modules/ts-simple-ast/dist/compiler/tools/LanguageService.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Program */ \"./node_modules/ts-simple-ast/dist/compiler/tools/Program.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./results */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeChecker */ \"./node_modules/ts-simple-ast/dist/compiler/tools/TypeChecker.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/DefinitionInfo.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/DefinitionInfo.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar DocumentSpan_1 = __webpack_require__(/*! ./DocumentSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js\");\r\n/**\r\n * Definition info.\r\n */\r\nvar DefinitionInfo = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DefinitionInfo, _super);\r\n    /**\r\n     * @internal\r\n     */\r\n    function DefinitionInfo(context, compilerObject) {\r\n        var _this = _super.call(this, context, compilerObject) || this;\r\n        // fill memoize\r\n        _this.getDeclarationNode();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Gets the kind.\r\n     */\r\n    DefinitionInfo.prototype.getKind = function () {\r\n        return this.compilerObject.kind;\r\n    };\r\n    /**\r\n     * Gets the name.\r\n     */\r\n    DefinitionInfo.prototype.getName = function () {\r\n        return this.compilerObject.name;\r\n    };\r\n    /**\r\n     * Gets the container kind.\r\n     */\r\n    DefinitionInfo.prototype.getContainerKind = function () {\r\n        return this.compilerObject.containerKind;\r\n    };\r\n    /**\r\n     * Gets the container name.\r\n     */\r\n    DefinitionInfo.prototype.getContainerName = function () {\r\n        return this.compilerObject.containerName;\r\n    };\r\n    /**\r\n     * Gets the declaration node.\r\n     */\r\n    DefinitionInfo.prototype.getDeclarationNode = function () {\r\n        var start = this.getTextSpan().getStart();\r\n        var identifier = findIdentifier(this.getSourceFile());\r\n        return identifier == null ? undefined : identifier.getParentOrThrow();\r\n        function findIdentifier(node) {\r\n            var e_1, _a;\r\n            if (node.getKind() === typescript_1.SyntaxKind.Identifier && node.getStart() === start)\r\n                return node;\r\n            try {\r\n                for (var _b = tslib_1.__values(node.getChildrenIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var child = _c.value;\r\n                    if (child.getPos() <= start && child.getEnd() >= start)\r\n                        return findIdentifier(child);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return undefined;\r\n        }\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], DefinitionInfo.prototype, \"getDeclarationNode\", null);\r\n    return DefinitionInfo;\r\n}(DocumentSpan_1.DocumentSpan));\r\nexports.DefinitionInfo = DefinitionInfo;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/DefinitionInfo.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/Diagnostic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/Diagnostic.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DiagnosticMessageChain_1 = __webpack_require__(/*! ./DiagnosticMessageChain */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticMessageChain.js\");\r\n/**\r\n * Diagnostic.\r\n */\r\nvar Diagnostic = /** @class */ (function () {\r\n    /** @internal */\r\n    function Diagnostic(context, compilerObject) {\r\n        this.context = context;\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(Diagnostic.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the underlying compiler diagnostic.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the source file.\r\n     */\r\n    Diagnostic.prototype.getSourceFile = function () {\r\n        if (this.context == null)\r\n            return undefined;\r\n        var file = this.compilerObject.file;\r\n        return file == null ? undefined : this.context.compilerFactory.getSourceFile(file);\r\n    };\r\n    /**\r\n     * Gets the message text.\r\n     */\r\n    Diagnostic.prototype.getMessageText = function () {\r\n        var messageText = this._compilerObject.messageText;\r\n        if (typeof messageText === \"string\")\r\n            return messageText;\r\n        if (this.context == null)\r\n            return new DiagnosticMessageChain_1.DiagnosticMessageChain(messageText);\r\n        else\r\n            return this.context.compilerFactory.getDiagnosticMessageChain(messageText);\r\n    };\r\n    /**\r\n     * Gets the line number.\r\n     */\r\n    Diagnostic.prototype.getLineNumber = function () {\r\n        var sourceFile = this.getSourceFile();\r\n        var start = this.getStart();\r\n        if (sourceFile == null || start == null)\r\n            return undefined;\r\n        return sourceFile.getLineNumberAtPos(start);\r\n    };\r\n    /**\r\n     * Gets the start.\r\n     */\r\n    Diagnostic.prototype.getStart = function () {\r\n        return this.compilerObject.start;\r\n    };\r\n    /**\r\n     * Gets the length.\r\n     */\r\n    Diagnostic.prototype.getLength = function () {\r\n        return this.compilerObject.length;\r\n    };\r\n    /**\r\n     * Gets the diagnostic category.\r\n     */\r\n    Diagnostic.prototype.getCategory = function () {\r\n        return this.compilerObject.category;\r\n    };\r\n    /**\r\n     * Gets the code of the diagnostic.\r\n     */\r\n    Diagnostic.prototype.getCode = function () {\r\n        return this.compilerObject.code;\r\n    };\r\n    /**\r\n     * Gets the source.\r\n     */\r\n    Diagnostic.prototype.getSource = function () {\r\n        return this.compilerObject.source;\r\n    };\r\n    return Diagnostic;\r\n}());\r\nexports.Diagnostic = Diagnostic;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/Diagnostic.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticMessageChain.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticMessageChain.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Diagnostic message chain.\r\n */\r\nvar DiagnosticMessageChain = /** @class */ (function () {\r\n    /** @internal */\r\n    function DiagnosticMessageChain(compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(DiagnosticMessageChain.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the underlying compiler object.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the message text.\r\n     */\r\n    DiagnosticMessageChain.prototype.getMessageText = function () {\r\n        return this.compilerObject.messageText;\r\n    };\r\n    /**\r\n     * Gets th enext diagnostic message chain in the chain.\r\n     */\r\n    DiagnosticMessageChain.prototype.getNext = function () {\r\n        var next = this.compilerObject.next;\r\n        if (next == null)\r\n            return undefined;\r\n        return new DiagnosticMessageChain(next);\r\n    };\r\n    /**\r\n     * Gets the code of the diagnostic message chain.\r\n     */\r\n    DiagnosticMessageChain.prototype.getCode = function () {\r\n        return this.compilerObject.code;\r\n    };\r\n    /**\r\n     * Gets the category of the diagnostic message chain.\r\n     */\r\n    DiagnosticMessageChain.prototype.getCategory = function () {\r\n        return this.compilerObject.category;\r\n    };\r\n    return DiagnosticMessageChain;\r\n}());\r\nexports.DiagnosticMessageChain = DiagnosticMessageChain;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticMessageChain.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticWithLocation.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticWithLocation.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Diagnostic_1 = __webpack_require__(/*! ./Diagnostic */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/Diagnostic.js\");\r\nvar DiagnosticWithLocation = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DiagnosticWithLocation, _super);\r\n    /** @internal */\r\n    function DiagnosticWithLocation(context, compilerObject) {\r\n        return _super.call(this, context, compilerObject) || this;\r\n    }\r\n    /**\r\n     * Gets the line number.\r\n     */\r\n    DiagnosticWithLocation.prototype.getLineNumber = function () {\r\n        return _super.prototype.getLineNumber.call(this);\r\n    };\r\n    /**\r\n     * Gets the start.\r\n     */\r\n    DiagnosticWithLocation.prototype.getStart = function () {\r\n        return _super.prototype.getStart.call(this);\r\n    };\r\n    /**\r\n     * Gets the length\r\n     */\r\n    DiagnosticWithLocation.prototype.getLength = function () {\r\n        return _super.prototype.getLength.call(this);\r\n    };\r\n    /**\r\n     * Gets the source file.\r\n     */\r\n    DiagnosticWithLocation.prototype.getSourceFile = function () {\r\n        return _super.prototype.getSourceFile.call(this);\r\n    };\r\n    return DiagnosticWithLocation;\r\n}(Diagnostic_1.Diagnostic));\r\nexports.DiagnosticWithLocation = DiagnosticWithLocation;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticWithLocation.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar TextSpan_1 = __webpack_require__(/*! ./TextSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/TextSpan.js\");\r\n/**\r\n * Document span.\r\n */\r\nvar DocumentSpan = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function DocumentSpan(context, compilerObject) {\r\n        this.context = context;\r\n        this._compilerObject = compilerObject;\r\n        // store this node so that it's start doesn't go out of date because of manipulation (though the text span may)\r\n        this.sourceFile = this.context.compilerFactory.getSourceFileFromCacheFromFilePath(this.compilerObject.fileName);\r\n        // fill the memoize\r\n        this.getNode();\r\n    }\r\n    Object.defineProperty(DocumentSpan.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the compiler object.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the source file this reference is in.\r\n     */\r\n    DocumentSpan.prototype.getSourceFile = function () {\r\n        return this.sourceFile;\r\n    };\r\n    /**\r\n     * Gets the text span.\r\n     */\r\n    DocumentSpan.prototype.getTextSpan = function () {\r\n        return new TextSpan_1.TextSpan(this.compilerObject.textSpan);\r\n    };\r\n    /**\r\n     * Gets the node at the start of the text span.\r\n     */\r\n    DocumentSpan.prototype.getNode = function () {\r\n        return this.getSourceFile().getDescendantAtStartWithWidth(this.getTextSpan().getStart(), this.getTextSpan().getLength());\r\n    };\r\n    /**\r\n     * Gets the original text span if the span represents a location that was remapped.\r\n     */\r\n    DocumentSpan.prototype.getOriginalTextSpan = function () {\r\n        var originalTextSpan = this.compilerObject.originalTextSpan;\r\n        return originalTextSpan == null ? undefined : new TextSpan_1.TextSpan(originalTextSpan);\r\n    };\r\n    /**\r\n     * Gets the original file name if the span represents a location that was remapped.\r\n     */\r\n    DocumentSpan.prototype.getOriginalFileName = function () {\r\n        return this.compilerObject.originalFileName;\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], DocumentSpan.prototype, \"getTextSpan\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], DocumentSpan.prototype, \"getNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], DocumentSpan.prototype, \"getOriginalTextSpan\", null);\r\n    return DocumentSpan;\r\n}());\r\nexports.DocumentSpan = DocumentSpan;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitOutput.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitOutput.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar OutputFile_1 = __webpack_require__(/*! ./OutputFile */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/OutputFile.js\");\r\n/**\r\n * Output of an emit on a single file.\r\n */\r\nvar EmitOutput = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function EmitOutput(context, filePath, compilerObject) {\r\n        this.filePath = filePath;\r\n        this.context = context;\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(EmitOutput.prototype, \"compilerObject\", {\r\n        /**\r\n         * TypeScript compiler emit result.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets if the emit was skipped.\r\n     */\r\n    EmitOutput.prototype.getEmitSkipped = function () {\r\n        return this.compilerObject.emitSkipped;\r\n    };\r\n    /**\r\n     * Gets the output files.\r\n     */\r\n    EmitOutput.prototype.getOutputFiles = function () {\r\n        var _this = this;\r\n        return this.compilerObject.outputFiles.map(function (f) { return new OutputFile_1.OutputFile(_this.context, f); });\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], EmitOutput.prototype, \"getOutputFiles\", null);\r\n    return EmitOutput;\r\n}());\r\nexports.EmitOutput = EmitOutput;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitOutput.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitResult.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitResult.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Result of an emit.\r\n */\r\nvar EmitResult = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function EmitResult(context, compilerObject) {\r\n        this.context = context;\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(EmitResult.prototype, \"compilerObject\", {\r\n        /**\r\n         * TypeScript compiler emit result.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * If the emit was skipped.\r\n     */\r\n    EmitResult.prototype.getEmitSkipped = function () {\r\n        return this.compilerObject.emitSkipped;\r\n    };\r\n    /**\r\n     * Contains declaration emit diagnostics.\r\n     */\r\n    EmitResult.prototype.getDiagnostics = function () {\r\n        var _this = this;\r\n        return this.compilerObject.diagnostics.map(function (d) { return _this.context.compilerFactory.getDiagnostic(d); });\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], EmitResult.prototype, \"getDiagnostics\", null);\r\n    return EmitResult;\r\n}());\r\nexports.EmitResult = EmitResult;\r\n/**\r\n * Result of an emit to memory.\r\n */\r\nvar MemoryEmitResult = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MemoryEmitResult, _super);\r\n    /**\r\n     * @internal\r\n     */\r\n    function MemoryEmitResult(context, compilerObject, files) {\r\n        var _this = _super.call(this, context, compilerObject) || this;\r\n        _this.files = files;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Gets the files that were emitted to memory.\r\n     */\r\n    MemoryEmitResult.prototype.getFiles = function () {\r\n        return this.files;\r\n    };\r\n    return MemoryEmitResult;\r\n}(EmitResult));\r\nexports.MemoryEmitResult = MemoryEmitResult;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitResult.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/FileTextChanges.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/FileTextChanges.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar TextChange_1 = __webpack_require__(/*! ./TextChange */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/TextChange.js\");\r\nvar FileTextChanges = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function FileTextChanges(compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    /**\r\n     * Gets the file path.\r\n     */\r\n    FileTextChanges.prototype.getFilePath = function () {\r\n        return this._compilerObject.fileName;\r\n    };\r\n    /**\r\n     * Gets the text changes\r\n     */\r\n    FileTextChanges.prototype.getTextChanges = function () {\r\n        return this._compilerObject.textChanges.map(function (c) { return new TextChange_1.TextChange(c); });\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], FileTextChanges.prototype, \"getTextChanges\", null);\r\n    return FileTextChanges;\r\n}());\r\nexports.FileTextChanges = FileTextChanges;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/FileTextChanges.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/ImplementationLocation.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/ImplementationLocation.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar DocumentSpan_1 = __webpack_require__(/*! ./DocumentSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js\");\r\nvar ImplementationLocation = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImplementationLocation, _super);\r\n    /**\r\n     * @internal\r\n     */\r\n    function ImplementationLocation(context, compilerObject) {\r\n        return _super.call(this, context, compilerObject) || this;\r\n    }\r\n    /**\r\n     * Gets the kind.\r\n     */\r\n    ImplementationLocation.prototype.getKind = function () {\r\n        return this.compilerObject.kind;\r\n    };\r\n    /**\r\n     * Gets the display parts.\r\n     */\r\n    ImplementationLocation.prototype.getDisplayParts = function () {\r\n        var _this = this;\r\n        return this.compilerObject.displayParts.map(function (p) { return _this.context.compilerFactory.getSymbolDisplayPart(p); });\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], ImplementationLocation.prototype, \"getDisplayParts\", null);\r\n    return ImplementationLocation;\r\n}(DocumentSpan_1.DocumentSpan));\r\nexports.ImplementationLocation = ImplementationLocation;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/ImplementationLocation.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/OutputFile.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/OutputFile.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Output file of an emit.\r\n */\r\nvar OutputFile = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function OutputFile(context, compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n        this._context = context;\r\n    }\r\n    Object.defineProperty(OutputFile.prototype, \"compilerObject\", {\r\n        /**\r\n         * TypeScript compiler output file.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the file path.\r\n     */\r\n    OutputFile.prototype.getFilePath = function () {\r\n        return this._context.fileSystemWrapper.getStandardizedAbsolutePath(this.compilerObject.name);\r\n    };\r\n    /**\r\n     * Gets whether the byte order mark should be written.\r\n     */\r\n    OutputFile.prototype.getWriteByteOrderMark = function () {\r\n        return this.compilerObject.writeByteOrderMark || false;\r\n    };\r\n    /**\r\n     * Gets the file text.\r\n     */\r\n    OutputFile.prototype.getText = function () {\r\n        return this.compilerObject.text;\r\n    };\r\n    return OutputFile;\r\n}());\r\nexports.OutputFile = OutputFile;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/OutputFile.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferenceEntry.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferenceEntry.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar DocumentSpan_1 = __webpack_require__(/*! ./DocumentSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js\");\r\nvar ReferenceEntry = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ReferenceEntry, _super);\r\n    /**\r\n     * @internal\r\n     */\r\n    function ReferenceEntry(context, compilerObject) {\r\n        return _super.call(this, context, compilerObject) || this;\r\n    }\r\n    ReferenceEntry.prototype.isWriteAccess = function () {\r\n        // todo: not sure what this does\r\n        return this.compilerObject.isWriteAccess;\r\n    };\r\n    /**\r\n     * If this is the definition reference.\r\n     */\r\n    ReferenceEntry.prototype.isDefinition = function () {\r\n        return this.compilerObject.isDefinition;\r\n    };\r\n    ReferenceEntry.prototype.isInString = function () {\r\n        // todo: not sure what this does and why it can be undefined\r\n        return this.compilerObject.isInString;\r\n    };\r\n    return ReferenceEntry;\r\n}(DocumentSpan_1.DocumentSpan));\r\nexports.ReferenceEntry = ReferenceEntry;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferenceEntry.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbol.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbol.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Referenced symbol.\r\n */\r\nvar ReferencedSymbol = /** @class */ (function () {\r\n    /**\r\n     * @internal\r\n     */\r\n    function ReferencedSymbol(context, compilerObject) {\r\n        this.context = context;\r\n        this._compilerObject = compilerObject;\r\n        // it's important to store the references so that the nodes referenced inside will point\r\n        // to the right node in case the user does manipulation between getting this object and getting the references\r\n        this.references = this.compilerObject.references.map(function (r) { return context.compilerFactory.getReferenceEntry(r); });\r\n    }\r\n    Object.defineProperty(ReferencedSymbol.prototype, \"compilerObject\", {\r\n        /**\r\n         * Gets the compiler referenced symbol.\r\n         */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the definition.\r\n     */\r\n    ReferencedSymbol.prototype.getDefinition = function () {\r\n        return this.context.compilerFactory.getReferencedSymbolDefinitionInfo(this.compilerObject.definition);\r\n    };\r\n    /**\r\n     * Gets the references.\r\n     */\r\n    ReferencedSymbol.prototype.getReferences = function () {\r\n        return this.references;\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], ReferencedSymbol.prototype, \"getDefinition\", null);\r\n    return ReferencedSymbol;\r\n}());\r\nexports.ReferencedSymbol = ReferencedSymbol;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbol.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbolDefinitionInfo.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbolDefinitionInfo.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar DefinitionInfo_1 = __webpack_require__(/*! ./DefinitionInfo */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DefinitionInfo.js\");\r\nvar ReferencedSymbolDefinitionInfo = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ReferencedSymbolDefinitionInfo, _super);\r\n    /**\r\n     * @internal\r\n     */\r\n    function ReferencedSymbolDefinitionInfo(context, compilerObject) {\r\n        return _super.call(this, context, compilerObject) || this;\r\n    }\r\n    /**\r\n     * Gets the display parts.\r\n     */\r\n    ReferencedSymbolDefinitionInfo.prototype.getDisplayParts = function () {\r\n        var _this = this;\r\n        return this.compilerObject.displayParts.map(function (p) { return _this.context.compilerFactory.getSymbolDisplayPart(p); });\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], ReferencedSymbolDefinitionInfo.prototype, \"getDisplayParts\", null);\r\n    return ReferencedSymbolDefinitionInfo;\r\n}(DefinitionInfo_1.DefinitionInfo));\r\nexports.ReferencedSymbolDefinitionInfo = ReferencedSymbolDefinitionInfo;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbolDefinitionInfo.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/RenameLocation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/RenameLocation.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar DocumentSpan_1 = __webpack_require__(/*! ./DocumentSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js\");\r\n/**\r\n * Rename location.\r\n */\r\nvar RenameLocation = /** @class */ (function (_super) {\r\n    tslib_1.__extends(RenameLocation, _super);\r\n    function RenameLocation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return RenameLocation;\r\n}(DocumentSpan_1.DocumentSpan));\r\nexports.RenameLocation = RenameLocation;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/RenameLocation.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/SymbolDisplayPart.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/SymbolDisplayPart.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Symbol display part.\r\n */\r\nvar SymbolDisplayPart = /** @class */ (function () {\r\n    /** @internal */\r\n    function SymbolDisplayPart(compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(SymbolDisplayPart.prototype, \"compilerObject\", {\r\n        /** Gets the compiler symbol display part. */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the text.\r\n     */\r\n    SymbolDisplayPart.prototype.getText = function () {\r\n        return this.compilerObject.text;\r\n    };\r\n    /**\r\n     * Gets the kind.\r\n     *\r\n     * Examples: \"text\", \"lineBreak\"\r\n     */\r\n    SymbolDisplayPart.prototype.getKind = function () {\r\n        return this.compilerObject.kind;\r\n    };\r\n    return SymbolDisplayPart;\r\n}());\r\nexports.SymbolDisplayPart = SymbolDisplayPart;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/SymbolDisplayPart.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/TextChange.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/TextChange.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar TextSpan_1 = __webpack_require__(/*! ./TextSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/TextSpan.js\");\r\n/**\r\n * Represents a text change.\r\n */\r\nvar TextChange = /** @class */ (function () {\r\n    /** @internal */\r\n    function TextChange(compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(TextChange.prototype, \"compilerObject\", {\r\n        /** Gets the compiler text change. */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the text span.\r\n     */\r\n    TextChange.prototype.getSpan = function () {\r\n        return new TextSpan_1.TextSpan(this.compilerObject.span);\r\n    };\r\n    /**\r\n     * Gets the new text.\r\n     */\r\n    TextChange.prototype.getNewText = function () {\r\n        return this.compilerObject.newText;\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], TextChange.prototype, \"getSpan\", null);\r\n    return TextChange;\r\n}());\r\nexports.TextChange = TextChange;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/TextChange.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/TextSpan.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/TextSpan.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Represents a span of text.\r\n */\r\nvar TextSpan = /** @class */ (function () {\r\n    /** @internal */\r\n    function TextSpan(compilerObject) {\r\n        this._compilerObject = compilerObject;\r\n    }\r\n    Object.defineProperty(TextSpan.prototype, \"compilerObject\", {\r\n        /** Gets the compiler text span. */\r\n        get: function () {\r\n            return this._compilerObject;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the start.\r\n     */\r\n    TextSpan.prototype.getStart = function () {\r\n        return this.compilerObject.start;\r\n    };\r\n    /**\r\n     * Gets the start + length.\r\n     */\r\n    TextSpan.prototype.getEnd = function () {\r\n        return this.compilerObject.start + this.compilerObject.length;\r\n    };\r\n    /**\r\n     * Gets the length.\r\n     */\r\n    TextSpan.prototype.getLength = function () {\r\n        return this.compilerObject.length;\r\n    };\r\n    return TextSpan;\r\n}());\r\nexports.TextSpan = TextSpan;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/TextSpan.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/tools/results/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/tools/results/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DefinitionInfo */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DefinitionInfo.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Diagnostic */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/Diagnostic.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DiagnosticMessageChain */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticMessageChain.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DiagnosticWithLocation */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DiagnosticWithLocation.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DocumentSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/DocumentSpan.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EmitOutput */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitOutput.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EmitResult */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/EmitResult.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FileTextChanges */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/FileTextChanges.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImplementationLocation */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/ImplementationLocation.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./OutputFile */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/OutputFile.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReferencedSymbol */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbol.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReferencedSymbolDefinitionInfo */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferencedSymbolDefinitionInfo.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReferenceEntry */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/ReferenceEntry.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RenameLocation */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/RenameLocation.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SymbolDisplayPart */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/SymbolDisplayPart.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TextChange */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/TextChange.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TextSpan */ \"./node_modules/ts-simple-ast/dist/compiler/tools/results/TextSpan.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/tools/results/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/ArrayTypeNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/ArrayTypeNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar ArrayTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArrayTypeNode, _super);\r\n    function ArrayTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the array type node's element type node.\r\n     */\r\n    ArrayTypeNode.prototype.getElementTypeNode = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.elementType);\r\n    };\r\n    return ArrayTypeNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.ArrayTypeNode = ArrayTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/ArrayTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/ConstructorTypeNode.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/ConstructorTypeNode.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FunctionOrConstructorTypeNodeBase_1 = __webpack_require__(/*! ./FunctionOrConstructorTypeNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/type/FunctionOrConstructorTypeNodeBase.js\");\r\nvar ConstructorTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConstructorTypeNode, _super);\r\n    function ConstructorTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return ConstructorTypeNode;\r\n}(FunctionOrConstructorTypeNodeBase_1.FunctionOrConstructorTypeNodeBase));\r\nexports.ConstructorTypeNode = ConstructorTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/ConstructorTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/ExpressionWithTypeArguments.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/ExpressionWithTypeArguments.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar expression_1 = __webpack_require__(/*! ../expression */ \"./node_modules/ts-simple-ast/dist/compiler/expression/index.js\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nexports.ExpressionWithTypeArgumentsBase = expression_1.LeftHandSideExpressionedNode(TypeNode_1.TypeNode);\r\nvar ExpressionWithTypeArguments = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExpressionWithTypeArguments, _super);\r\n    function ExpressionWithTypeArguments() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the type arguments.\r\n     */\r\n    ExpressionWithTypeArguments.prototype.getTypeArguments = function () {\r\n        var _this = this;\r\n        var typeArguments = this.compilerNode.typeArguments;\r\n        if (typeArguments == null)\r\n            return [];\r\n        return typeArguments.map(function (a) { return _this.getNodeFromCompilerNode(a); });\r\n    };\r\n    return ExpressionWithTypeArguments;\r\n}(exports.ExpressionWithTypeArgumentsBase));\r\nexports.ExpressionWithTypeArguments = ExpressionWithTypeArguments;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/ExpressionWithTypeArguments.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/FunctionOrConstructorTypeNodeBase.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/FunctionOrConstructorTypeNodeBase.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nexports.FunctionOrConstructorTypeNodeBaseBase = base_1.SignaturedDeclaration(TypeNode_1.TypeNode);\r\nvar FunctionOrConstructorTypeNodeBase = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FunctionOrConstructorTypeNodeBase, _super);\r\n    function FunctionOrConstructorTypeNodeBase() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return FunctionOrConstructorTypeNodeBase;\r\n}(exports.FunctionOrConstructorTypeNodeBaseBase));\r\nexports.FunctionOrConstructorTypeNodeBase = FunctionOrConstructorTypeNodeBase;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/FunctionOrConstructorTypeNodeBase.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/FunctionTypeNode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/FunctionTypeNode.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar FunctionOrConstructorTypeNodeBase_1 = __webpack_require__(/*! ./FunctionOrConstructorTypeNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/type/FunctionOrConstructorTypeNodeBase.js\");\r\nexports.FunctionTypeNodeBase = base_1.TypeParameteredNode(FunctionOrConstructorTypeNodeBase_1.FunctionOrConstructorTypeNodeBase);\r\nvar FunctionTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FunctionTypeNode, _super);\r\n    function FunctionTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return FunctionTypeNode;\r\n}(exports.FunctionTypeNodeBase));\r\nexports.FunctionTypeNode = FunctionTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/FunctionTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/ImportTypeNode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/ImportTypeNode.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nexports.ImportTypeNodeBase = base_1.TypeArgumentedNode(TypeNode_1.TypeNode);\r\nvar ImportTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImportTypeNode, _super);\r\n    function ImportTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Sets the argument text.\r\n     * @param text - Text of the argument.\r\n     */\r\n    ImportTypeNode.prototype.setArgument = function (text) {\r\n        var arg = this.getArgument();\r\n        if (utils_1.TypeGuards.isLiteralTypeNode(arg)) {\r\n            var literal = arg.getLiteral();\r\n            if (utils_1.TypeGuards.isStringLiteral(literal)) {\r\n                literal.setLiteralValue(text);\r\n                return this;\r\n            }\r\n        }\r\n        arg.replaceWithText(function (writer) { return writer.quote(text); }, this.getWriterWithQueuedChildIndentation());\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the argument passed into the import type.\r\n     */\r\n    ImportTypeNode.prototype.getArgument = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.argument);\r\n    };\r\n    /**\r\n     * Sets the qualifier text.\r\n     * @param text - Text.\r\n     */\r\n    ImportTypeNode.prototype.setQualifier = function (text) {\r\n        var qualifier = this.getQualifier();\r\n        if (qualifier != null)\r\n            qualifier.replaceWithText(text, this.getWriterWithQueuedChildIndentation());\r\n        else {\r\n            var paren = this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.CloseParenToken);\r\n            manipulation_1.insertIntoParentTextRange({\r\n                insertPos: paren.getEnd(),\r\n                parent: this,\r\n                newText: this.getWriterWithQueuedIndentation().write(\".\").write(text).toString()\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the qualifier of the import type if it exists or throws\r\n     */\r\n    ImportTypeNode.prototype.getQualifierOrThrow = function () {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getQualifier(), function () { return \"Expected to find a qualifier for the import type: \" + _this.getText(); });\r\n    };\r\n    /**\r\n     * Gets the qualifier of the import type if it exists or returns undefined.\r\n     */\r\n    ImportTypeNode.prototype.getQualifier = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.qualifier);\r\n    };\r\n    return ImportTypeNode;\r\n}(exports.ImportTypeNodeBase));\r\nexports.ImportTypeNode = ImportTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/ImportTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/IntersectionTypeNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/IntersectionTypeNode.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar IntersectionTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(IntersectionTypeNode, _super);\r\n    function IntersectionTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the intersection type nodes.\r\n     */\r\n    IntersectionTypeNode.prototype.getTypeNodes = function () {\r\n        var _this = this;\r\n        return this.compilerNode.types.map(function (t) { return _this.getNodeFromCompilerNode(t); });\r\n    };\r\n    return IntersectionTypeNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.IntersectionTypeNode = IntersectionTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/IntersectionTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/LiteralTypeNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/LiteralTypeNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar LiteralTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(LiteralTypeNode, _super);\r\n    function LiteralTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the literal type node's literal.\r\n     */\r\n    LiteralTypeNode.prototype.getLiteral = function () {\r\n        // this statement is to be notified in case this changes\r\n        var tsLiteral = this.compilerNode.literal;\r\n        return this.getNodeFromCompilerNode(tsLiteral);\r\n    };\r\n    return LiteralTypeNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.LiteralTypeNode = LiteralTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/LiteralTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/ParenthesizedTypeNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/ParenthesizedTypeNode.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar ParenthesizedTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParenthesizedTypeNode, _super);\r\n    function ParenthesizedTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the node within the parentheses.\r\n     */\r\n    ParenthesizedTypeNode.prototype.getTypeNode = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.type);\r\n    };\r\n    /**\r\n     * Sets the type within the parentheses.\r\n     * @param textOrWriterFunction - Text or writer function to set the type with.\r\n     */\r\n    ParenthesizedTypeNode.prototype.setType = function (textOrWriterFunction) {\r\n        this.getTypeNode().replaceWithText(textOrWriterFunction);\r\n        return this;\r\n    };\r\n    return ParenthesizedTypeNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.ParenthesizedTypeNode = ParenthesizedTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/ParenthesizedTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TupleTypeNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TupleTypeNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar TupleTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TupleTypeNode, _super);\r\n    function TupleTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the tuple element type nodes.\r\n     */\r\n    TupleTypeNode.prototype.getElementTypeNodes = function () {\r\n        var _this = this;\r\n        return this.compilerNode.elementTypes.map(function (t) { return _this.getNodeFromCompilerNode(t); });\r\n    };\r\n    return TupleTypeNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.TupleTypeNode = TupleTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TupleTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/Type.js":
/*!***************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/Type.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar Type = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance of Type.\r\n     * @internal\r\n     * @param context - Project context.\r\n     * @param type - Compiler type.\r\n     */\r\n    function Type(context, type) {\r\n        this.context = context;\r\n        this._compilerType = type;\r\n    }\r\n    Object.defineProperty(Type.prototype, \"compilerType\", {\r\n        /**\r\n         * Gets the underlying compiler type.\r\n         */\r\n        get: function () {\r\n            return this._compilerType;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the type text.\r\n     * @param enclosingNode - The enclosing node.\r\n     * @param typeFormatFlags - Format flags for the type text.\r\n     */\r\n    Type.prototype.getText = function (enclosingNode, typeFormatFlags) {\r\n        return this.context.typeChecker.getTypeText(this, enclosingNode, typeFormatFlags);\r\n    };\r\n    /**\r\n     * Gets the alias symbol if it exists.\r\n     */\r\n    Type.prototype.getAliasSymbol = function () {\r\n        return this.compilerType.aliasSymbol == null ? undefined : this.context.compilerFactory.getSymbol(this.compilerType.aliasSymbol);\r\n    };\r\n    /**\r\n     * Gets the alias symbol if it exists, or throws.\r\n     */\r\n    Type.prototype.getAliasSymbolOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getAliasSymbol(), \"Expected to find an alias symbol.\");\r\n    };\r\n    /**\r\n     * Gets the alias type arguments.\r\n     */\r\n    Type.prototype.getAliasTypeArguments = function () {\r\n        var _this = this;\r\n        var aliasTypeArgs = this.compilerType.aliasTypeArguments || [];\r\n        return aliasTypeArgs.map(function (t) { return _this.context.compilerFactory.getType(t); });\r\n    };\r\n    /**\r\n     * Gets the apparent type.\r\n     */\r\n    Type.prototype.getApparentType = function () {\r\n        return this.context.typeChecker.getApparentType(this);\r\n    };\r\n    /**\r\n     * Gets the array type\r\n     */\r\n    Type.prototype.getArrayType = function () {\r\n        if (!this.isArray())\r\n            return undefined;\r\n        return this.getTypeArguments()[0];\r\n    };\r\n    /**\r\n     * Gets the base types.\r\n     */\r\n    Type.prototype.getBaseTypes = function () {\r\n        var _this = this;\r\n        var baseTypes = this.compilerType.getBaseTypes() || [];\r\n        return baseTypes.map(function (t) { return _this.context.compilerFactory.getType(t); });\r\n    };\r\n    /**\r\n     * Gets the base type of a literal type.\r\n     *\r\n     * For example, for a number literal type it will return the number type.\r\n     */\r\n    Type.prototype.getBaseTypeOfLiteralType = function () {\r\n        return this.context.typeChecker.getBaseTypeOfLiteralType(this);\r\n    };\r\n    /**\r\n     * Gets the call signatures.\r\n     */\r\n    Type.prototype.getCallSignatures = function () {\r\n        var _this = this;\r\n        return this.compilerType.getCallSignatures().map(function (s) { return _this.context.compilerFactory.getSignature(s); });\r\n    };\r\n    /**\r\n     * Gets the construct signatures.\r\n     */\r\n    Type.prototype.getConstructSignatures = function () {\r\n        var _this = this;\r\n        return this.compilerType.getConstructSignatures().map(function (s) { return _this.context.compilerFactory.getSignature(s); });\r\n    };\r\n    /**\r\n     * Gets the constraint or throws if it doesn't exist.\r\n     */\r\n    Type.prototype.getConstraintOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getConstraint(), \"Expected to find a constraint.\");\r\n    };\r\n    /**\r\n     * Gets the constraint or returns undefined if it doesn't exist.\r\n     */\r\n    Type.prototype.getConstraint = function () {\r\n        var constraint = this.compilerType.getConstraint();\r\n        return constraint == null ? undefined : this.context.compilerFactory.getType(constraint);\r\n    };\r\n    /**\r\n     * Gets the default type or throws if it doesn't exist.\r\n     */\r\n    Type.prototype.getDefaultOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDefault(), \"Expected to find a constraint.\");\r\n    };\r\n    /**\r\n     * Gets the default type or returns undefined if it doesn't exist.\r\n     */\r\n    Type.prototype.getDefault = function () {\r\n        var defaultType = this.compilerType.getDefault();\r\n        return defaultType == null ? undefined : this.context.compilerFactory.getType(defaultType);\r\n    };\r\n    /**\r\n     * Gets the properties of the type.\r\n     */\r\n    Type.prototype.getProperties = function () {\r\n        var _this = this;\r\n        return this.compilerType.getProperties().map(function (s) { return _this.context.compilerFactory.getSymbol(s); });\r\n    };\r\n    Type.prototype.getProperty = function (nameOrFindFunction) {\r\n        return utils_1.getSymbolByNameOrFindFunction(this.getProperties(), nameOrFindFunction);\r\n    };\r\n    /**\r\n     * Gets the apparent properties of the type.\r\n     */\r\n    Type.prototype.getApparentProperties = function () {\r\n        var _this = this;\r\n        return this.compilerType.getApparentProperties().map(function (s) { return _this.context.compilerFactory.getSymbol(s); });\r\n    };\r\n    Type.prototype.getApparentProperty = function (nameOrFindFunction) {\r\n        return utils_1.getSymbolByNameOrFindFunction(this.getApparentProperties(), nameOrFindFunction);\r\n    };\r\n    /**\r\n     * Gets if the type is possibly null or undefined.\r\n     */\r\n    Type.prototype.isNullable = function () {\r\n        return this.getUnionTypes().some(function (t) { return t.isNull() || t.isUndefined(); });\r\n    };\r\n    /**\r\n     * Gets the non-nullable type.\r\n     */\r\n    Type.prototype.getNonNullableType = function () {\r\n        return this.context.compilerFactory.getType(this.compilerType.getNonNullableType());\r\n    };\r\n    /**\r\n     * Gets the number index type.\r\n     */\r\n    Type.prototype.getNumberIndexType = function () {\r\n        var numberIndexType = this.compilerType.getNumberIndexType();\r\n        return numberIndexType == null ? undefined : this.context.compilerFactory.getType(numberIndexType);\r\n    };\r\n    /**\r\n     * Gets the string index type.\r\n     */\r\n    Type.prototype.getStringIndexType = function () {\r\n        var stringIndexType = this.compilerType.getStringIndexType();\r\n        return stringIndexType == null ? undefined : this.context.compilerFactory.getType(stringIndexType);\r\n    };\r\n    /**\r\n     * Gets the target type of a type reference if it exists.\r\n     */\r\n    Type.prototype.getTargetType = function () {\r\n        var targetType = this.compilerType.target || undefined;\r\n        return targetType == null ? undefined : this.context.compilerFactory.getType(targetType);\r\n    };\r\n    /**\r\n     * Gets the target type of a type reference or throws if it doesn't exist.\r\n     */\r\n    Type.prototype.getTargetTypeOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getTargetType(), \"Expected to find the target type.\");\r\n    };\r\n    /**\r\n     * Gets type arguments.\r\n     */\r\n    Type.prototype.getTypeArguments = function () {\r\n        var _this = this;\r\n        var typeArguments = this.compilerType.typeArguments || [];\r\n        return typeArguments.map(function (t) { return _this.context.compilerFactory.getType(t); });\r\n    };\r\n    /**\r\n     * Gets the individual element types of the tuple.\r\n     */\r\n    Type.prototype.getTupleElements = function () {\r\n        return this.isTuple() ? this.getTypeArguments() : [];\r\n    };\r\n    /**\r\n     * Gets the union types.\r\n     */\r\n    Type.prototype.getUnionTypes = function () {\r\n        var _this = this;\r\n        if (!this.isUnion())\r\n            return [];\r\n        return this.compilerType.types.map(function (t) { return _this.context.compilerFactory.getType(t); });\r\n    };\r\n    /**\r\n     * Gets the intersection types.\r\n     */\r\n    Type.prototype.getIntersectionTypes = function () {\r\n        var _this = this;\r\n        if (!this.isIntersection())\r\n            return [];\r\n        return this.compilerType.types.map(function (t) { return _this.context.compilerFactory.getType(t); });\r\n    };\r\n    /**\r\n     * Gets the symbol of the type.\r\n     */\r\n    Type.prototype.getSymbol = function () {\r\n        var tsSymbol = this.compilerType.getSymbol();\r\n        return tsSymbol == null ? undefined : this.context.compilerFactory.getSymbol(tsSymbol);\r\n    };\r\n    /**\r\n     * Gets the symbol of the type or throws.\r\n     */\r\n    Type.prototype.getSymbolOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getSymbol(), \"Expected to find a symbol.\");\r\n    };\r\n    /**\r\n     * Gets if this is an anonymous type.\r\n     */\r\n    Type.prototype.isAnonymous = function () {\r\n        return this._hasObjectFlag(typescript_1.ObjectFlags.Anonymous);\r\n    };\r\n    /**\r\n     * Gets if this is an array type.\r\n     */\r\n    Type.prototype.isArray = function () {\r\n        var symbol = this.getSymbol();\r\n        if (symbol == null)\r\n            return false;\r\n        return symbol.getName() === \"Array\" && this.getTypeArguments().length === 1;\r\n    };\r\n    /**\r\n     * Gets if this is a boolean type.\r\n     */\r\n    Type.prototype.isBoolean = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.Boolean);\r\n    };\r\n    /**\r\n     * Gets if this is a string type.\r\n     */\r\n    Type.prototype.isString = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.String);\r\n    };\r\n    /**\r\n     * Gets if this is a number type.\r\n     */\r\n    Type.prototype.isNumber = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.Number);\r\n    };\r\n    /**\r\n     * Gets if this is a literal type.\r\n     */\r\n    Type.prototype.isLiteral = function () {\r\n        // todo: remove this in TS 3.1 when https://github.com/Microsoft/TypeScript/issues/26075 is fixed\r\n        var isBooleanLiteralForTs3_0 = this.isBooleanLiteral();\r\n        return this.compilerType.isLiteral() || isBooleanLiteralForTs3_0;\r\n    };\r\n    /**\r\n     * Gets if this is a boolean literal type.\r\n     */\r\n    Type.prototype.isBooleanLiteral = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.BooleanLiteral);\r\n    };\r\n    /**\r\n     * Gets if this is an enum literal type.\r\n     */\r\n    Type.prototype.isEnumLiteral = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.EnumLiteral);\r\n    };\r\n    /**\r\n     * Gets if this is a number literal type.\r\n     */\r\n    Type.prototype.isNumberLiteral = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.NumberLiteral);\r\n    };\r\n    /**\r\n     * Gets if this is a string literal type.\r\n     */\r\n    Type.prototype.isStringLiteral = function () {\r\n        return this.compilerType.isStringLiteral();\r\n    };\r\n    /**\r\n     * Gets if this is a class type.\r\n     */\r\n    Type.prototype.isClass = function () {\r\n        return this.compilerType.isClass();\r\n    };\r\n    /**\r\n     * Gets if this is a class or interface type.\r\n     */\r\n    Type.prototype.isClassOrInterface = function () {\r\n        return this.compilerType.isClassOrInterface();\r\n    };\r\n    /**\r\n     * Gets if this is an enum type.\r\n     */\r\n    Type.prototype.isEnum = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.Enum);\r\n    };\r\n    /**\r\n     * Gets if this is an interface type.\r\n     */\r\n    Type.prototype.isInterface = function () {\r\n        return this._hasObjectFlag(typescript_1.ObjectFlags.Interface);\r\n    };\r\n    /**\r\n     * Gets if this is an object type.\r\n     */\r\n    Type.prototype.isObject = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.Object);\r\n    };\r\n    /**\r\n     * Gets if this is a type parameter.\r\n     */\r\n    Type.prototype.isTypeParameter = function () {\r\n        return this.compilerType.isTypeParameter();\r\n    };\r\n    /**\r\n     * Gets if this is a tuple type.\r\n     */\r\n    Type.prototype.isTuple = function () {\r\n        var targetType = this.getTargetType();\r\n        if (targetType == null)\r\n            return false;\r\n        return targetType._hasObjectFlag(typescript_1.ObjectFlags.Tuple);\r\n    };\r\n    /**\r\n     * Gets if this is a union type.\r\n     */\r\n    Type.prototype.isUnion = function () {\r\n        return this.compilerType.isUnion();\r\n    };\r\n    /**\r\n     * Gets if this is an intersection type.\r\n     */\r\n    Type.prototype.isIntersection = function () {\r\n        return this.compilerType.isIntersection();\r\n    };\r\n    /**\r\n     * Gets if this is a union or intersection type.\r\n     */\r\n    Type.prototype.isUnionOrIntersection = function () {\r\n        return this.compilerType.isUnionOrIntersection();\r\n    };\r\n    /**\r\n     * Gets if this is the null type.\r\n     */\r\n    Type.prototype.isNull = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.Null);\r\n    };\r\n    /**\r\n     * Gets if this is the undefined type.\r\n     */\r\n    Type.prototype.isUndefined = function () {\r\n        return this._hasTypeFlag(typescript_1.TypeFlags.Undefined);\r\n    };\r\n    /**\r\n     * Gets the type flags.\r\n     */\r\n    Type.prototype.getFlags = function () {\r\n        return this.compilerType.flags;\r\n    };\r\n    /**\r\n     * Gets the object flags.\r\n     * @remarks Returns 0 for a non-object type.\r\n     */\r\n    Type.prototype.getObjectFlags = function () {\r\n        if (!this.isObject())\r\n            return 0;\r\n        return this.compilerType.objectFlags || 0;\r\n    };\r\n    Type.prototype._hasTypeFlag = function (flag) {\r\n        return (this.compilerType.flags & flag) === flag;\r\n    };\r\n    Type.prototype._hasAnyTypeFlag = function (flag) {\r\n        return (this.compilerType.flags & flag) !== 0;\r\n    };\r\n    Type.prototype._hasObjectFlag = function (flag) {\r\n        return (this.getObjectFlags() & flag) === flag;\r\n    };\r\n    return Type;\r\n}());\r\nexports.Type = Type;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/Type.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TypeAliasDeclaration.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TypeAliasDeclaration.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar statement_1 = __webpack_require__(/*! ../statement */ \"./node_modules/ts-simple-ast/dist/compiler/statement/index.js\");\r\n// todo: type node should not be able to return undefined\r\nexports.TypeAliasDeclarationBase = base_1.ChildOrderableNode(base_1.TypeParameteredNode(base_1.TypedNode(base_1.JSDocableNode(base_1.AmbientableNode(base_1.ExportableNode(base_1.ModifierableNode(base_1.NamedNode(statement_1.Statement))))))));\r\nvar TypeAliasDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeAliasDeclaration, _super);\r\n    function TypeAliasDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    TypeAliasDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.TypeAliasDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    return TypeAliasDeclaration;\r\n}(exports.TypeAliasDeclarationBase));\r\nexports.TypeAliasDeclaration = TypeAliasDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TypeAliasDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TypeLiteralNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TypeLiteralNode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nexports.TypeLiteralNodeBase = base_1.TypeElementMemberedNode(TypeNode_1.TypeNode);\r\nvar TypeLiteralNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeLiteralNode, _super);\r\n    function TypeLiteralNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TypeLiteralNode;\r\n}(exports.TypeLiteralNodeBase));\r\nexports.TypeLiteralNode = TypeLiteralNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TypeLiteralNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar TypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeNode, _super);\r\n    function TypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return TypeNode;\r\n}(common_1.Node));\r\nexports.TypeNode = TypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TypeParameter.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TypeParameter.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar Type_1 = __webpack_require__(/*! ./Type */ \"./node_modules/ts-simple-ast/dist/compiler/type/Type.js\");\r\nvar TypeParameter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeParameter, _super);\r\n    function TypeParameter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the constraint or throws if it doesn't exist.\r\n     */\r\n    TypeParameter.prototype.getConstraintOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getConstraint(), \"Expected type parameter to have a constraint.\");\r\n    };\r\n    /**\r\n     * Gets the constraint type.\r\n     */\r\n    TypeParameter.prototype.getConstraint = function () {\r\n        var declaration = this._getTypeParameterDeclaration();\r\n        if (declaration == null)\r\n            return undefined;\r\n        var constraintNode = declaration.getConstraint();\r\n        if (constraintNode == null)\r\n            return undefined;\r\n        return this.context.typeChecker.getTypeAtLocation(constraintNode);\r\n    };\r\n    /**\r\n     * Gets the default type or throws if it doesn't exist.\r\n     */\r\n    TypeParameter.prototype.getDefaultOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDefault(), \"Expected type parameter to have a default type.\");\r\n    };\r\n    /**\r\n     * Gets the default type or undefined if it doesn't exist.\r\n     */\r\n    TypeParameter.prototype.getDefault = function () {\r\n        var declaration = this._getTypeParameterDeclaration();\r\n        if (declaration == null)\r\n            return undefined;\r\n        var defaultNode = declaration.getDefault();\r\n        if (defaultNode == null)\r\n            return undefined;\r\n        return this.context.typeChecker.getTypeAtLocation(defaultNode);\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    TypeParameter.prototype._getTypeParameterDeclaration = function () {\r\n        var symbol = this.getSymbol();\r\n        if (symbol == null)\r\n            return undefined;\r\n        var declaration = symbol.getDeclarations()[0];\r\n        if (declaration == null)\r\n            return undefined;\r\n        if (!utils_1.TypeGuards.isTypeParameterDeclaration(declaration))\r\n            return undefined;\r\n        return declaration;\r\n    };\r\n    return TypeParameter;\r\n}(Type_1.Type));\r\nexports.TypeParameter = TypeParameter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TypeParameter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TypeParameterDeclaration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TypeParameterDeclaration.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.TypeParameterDeclarationBase = base_1.NamedNode(common_1.Node);\r\nvar TypeParameterDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeParameterDeclaration, _super);\r\n    function TypeParameterDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the constraint node of the type parameter.\r\n     * @deprecated - Use .getConstraint().\r\n     */\r\n    TypeParameterDeclaration.prototype.getConstraintNode = function () {\r\n        return this.getConstraint();\r\n    };\r\n    /**\r\n     * Gets the constraint of the type parameter.\r\n     */\r\n    TypeParameterDeclaration.prototype.getConstraint = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.constraint);\r\n    };\r\n    /**\r\n     * Gets the constraint of the type parameter or throws if it doesn't exist.\r\n     */\r\n    TypeParameterDeclaration.prototype.getConstraintOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getConstraint(), \"Expected to find the type parameter's constraint.\");\r\n    };\r\n    /**\r\n     * Sets the type parameter constraint.\r\n     * @param text - Text to set as the constraint.\r\n     */\r\n    TypeParameterDeclaration.prototype.setConstraint = function (text) {\r\n        if (utils_1.StringUtils.isNullOrWhitespace(text)) {\r\n            this.removeConstraint();\r\n            return this;\r\n        }\r\n        var constraint = this.getConstraint();\r\n        if (constraint != null) {\r\n            constraint.replaceWithText(text);\r\n            return this;\r\n        }\r\n        var nameNode = this.getNameNode();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            parent: this,\r\n            insertPos: nameNode.getEnd(),\r\n            newText: \" extends \" + text\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the constraint type node.\r\n     */\r\n    TypeParameterDeclaration.prototype.removeConstraint = function () {\r\n        removeConstraintOrDefault(this.getConstraint(), typescript_1.SyntaxKind.ExtendsKeyword);\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the default node of the type parameter.\r\n     */\r\n    TypeParameterDeclaration.prototype.getDefault = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.default);\r\n    };\r\n    /**\r\n     * Gets the default node of the type parameter or throws if it doesn't exist.\r\n     */\r\n    TypeParameterDeclaration.prototype.getDefaultOrThrow = function () {\r\n        return errors.throwIfNullOrUndefined(this.getDefault(), \"Expected to find the type parameter's default.\");\r\n    };\r\n    /**\r\n     * Gets the default node of the type parameter.\r\n     * @deprecated Use .getDefault().\r\n     */\r\n    TypeParameterDeclaration.prototype.getDefaultNode = function () {\r\n        return this.getNodeFromCompilerNodeIfExists(this.compilerNode.default);\r\n    };\r\n    /**\r\n     * Sets the type parameter default type node.\r\n     * @param text - Text to set as the default type node.\r\n     */\r\n    TypeParameterDeclaration.prototype.setDefault = function (text) {\r\n        if (utils_1.StringUtils.isNullOrWhitespace(text)) {\r\n            this.removeDefault();\r\n            return this;\r\n        }\r\n        var defaultNode = this.getDefault();\r\n        if (defaultNode != null) {\r\n            defaultNode.replaceWithText(text);\r\n            return this;\r\n        }\r\n        var insertAfterNode = this.getConstraint() || this.getNameNode();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            parent: this,\r\n            insertPos: insertAfterNode.getEnd(),\r\n            newText: \" = \" + text\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the default type node.\r\n     */\r\n    TypeParameterDeclaration.prototype.removeDefault = function () {\r\n        removeConstraintOrDefault(this.getDefault(), typescript_1.SyntaxKind.EqualsToken);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this type parameter.\r\n     */\r\n    TypeParameterDeclaration.prototype.remove = function () {\r\n        var parentSyntaxList = this.getParentSyntaxListOrThrow();\r\n        var typeParameters = parentSyntaxList.getChildrenOfKind(typescript_1.SyntaxKind.TypeParameter);\r\n        if (typeParameters.length === 1)\r\n            removeAllTypeParameters();\r\n        else\r\n            manipulation_1.removeCommaSeparatedChild(this);\r\n        function removeAllTypeParameters() {\r\n            var children = [\r\n                parentSyntaxList.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.LessThanToken),\r\n                parentSyntaxList,\r\n                parentSyntaxList.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.GreaterThanToken)\r\n            ];\r\n            manipulation_1.removeChildren({ children: children });\r\n        }\r\n    };\r\n    return TypeParameterDeclaration;\r\n}(exports.TypeParameterDeclarationBase));\r\nexports.TypeParameterDeclaration = TypeParameterDeclaration;\r\nfunction removeConstraintOrDefault(nodeToRemove, siblingKind) {\r\n    if (nodeToRemove == null)\r\n        return;\r\n    manipulation_1.removeChildren({\r\n        children: [nodeToRemove.getPreviousSiblingIfKindOrThrow(siblingKind), nodeToRemove],\r\n        removePrecedingSpaces: true\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TypeParameterDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/TypeReferenceNode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/TypeReferenceNode.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar TypeReferenceNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeReferenceNode, _super);\r\n    function TypeReferenceNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the type name.\r\n     */\r\n    TypeReferenceNode.prototype.getTypeName = function () {\r\n        return this.getNodeFromCompilerNode(this.compilerNode.typeName);\r\n    };\r\n    /**\r\n     * Gets the type arguments.\r\n     */\r\n    TypeReferenceNode.prototype.getTypeArguments = function () {\r\n        var _this = this;\r\n        if (this.compilerNode.typeArguments == null)\r\n            return [];\r\n        return this.compilerNode.typeArguments.map(function (a) { return _this.getNodeFromCompilerNode(a); });\r\n    };\r\n    return TypeReferenceNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.TypeReferenceNode = TypeReferenceNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/TypeReferenceNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/UnionTypeNode.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/UnionTypeNode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar TypeNode_1 = __webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\");\r\nvar UnionTypeNode = /** @class */ (function (_super) {\r\n    tslib_1.__extends(UnionTypeNode, _super);\r\n    function UnionTypeNode() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Gets the union type nodes.\r\n     */\r\n    UnionTypeNode.prototype.getTypeNodes = function () {\r\n        var _this = this;\r\n        return this.compilerNode.types.map(function (t) { return _this.getNodeFromCompilerNode(t); });\r\n    };\r\n    return UnionTypeNode;\r\n}(TypeNode_1.TypeNode));\r\nexports.UnionTypeNode = UnionTypeNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/UnionTypeNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/type/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/type/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArrayTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/ArrayTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConstructorTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/ConstructorTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExpressionWithTypeArguments */ \"./node_modules/ts-simple-ast/dist/compiler/type/ExpressionWithTypeArguments.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FunctionTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/FunctionTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FunctionOrConstructorTypeNodeBase */ \"./node_modules/ts-simple-ast/dist/compiler/type/FunctionOrConstructorTypeNodeBase.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/ImportTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./IntersectionTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/IntersectionTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LiteralTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/LiteralTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ParenthesizedTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/ParenthesizedTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TupleTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TupleTypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Type */ \"./node_modules/ts-simple-ast/dist/compiler/type/Type.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeAliasDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeAliasDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeLiteralNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeLiteralNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeParameter */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeParameter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeParameterDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeParameterDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeReferenceNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/TypeReferenceNode.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UnionTypeNode */ \"./node_modules/ts-simple-ast/dist/compiler/type/UnionTypeNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/type/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclaration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclaration.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nexports.VariableDeclarationBase = base_1.ExclamationTokenableNode(base_1.TypedNode(base_1.InitializerExpressionableNode(base_1.BindingNamedNode(common_1.Node))));\r\nvar VariableDeclaration = /** @class */ (function (_super) {\r\n    tslib_1.__extends(VariableDeclaration, _super);\r\n    function VariableDeclaration() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Fills this node with the specified structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    VariableDeclaration.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.VariableDeclarationBase.prototype, this, structure);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes this variable declaration.\r\n     */\r\n    VariableDeclaration.prototype.remove = function () {\r\n        var parent = this.getParentOrThrow();\r\n        switch (parent.getKind()) {\r\n            case typescript_1.SyntaxKind.VariableDeclarationList:\r\n                removeFromDeclarationList(this);\r\n                break;\r\n            case typescript_1.SyntaxKind.CatchClause:\r\n                removeFromCatchClause(this);\r\n                break;\r\n            default:\r\n                throw new errors.NotImplementedError(\"Not implemented for syntax kind: \" + parent.getKindName());\r\n        }\r\n        function removeFromDeclarationList(node) {\r\n            var variableStatement = parent.getParentIfKindOrThrow(typescript_1.SyntaxKind.VariableStatement);\r\n            var declarations = variableStatement.getDeclarations();\r\n            if (declarations.length === 1)\r\n                variableStatement.remove();\r\n            else\r\n                manipulation_1.removeCommaSeparatedChild(node);\r\n        }\r\n        function removeFromCatchClause(node) {\r\n            manipulation_1.removeChildren({\r\n                children: [\r\n                    node.getPreviousSiblingIfKindOrThrow(typescript_1.SyntaxKind.OpenParenToken),\r\n                    node,\r\n                    node.getNextSiblingIfKindOrThrow(typescript_1.SyntaxKind.CloseParenToken)\r\n                ],\r\n                removePrecedingSpaces: true\r\n            });\r\n        }\r\n    };\r\n    return VariableDeclaration;\r\n}(exports.VariableDeclarationBase));\r\nexports.VariableDeclaration = VariableDeclaration;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclaration.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationKind.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationKind.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar VariableDeclarationKind;\r\n(function (VariableDeclarationKind) {\r\n    VariableDeclarationKind[\"Var\"] = \"var\";\r\n    VariableDeclarationKind[\"Let\"] = \"let\";\r\n    VariableDeclarationKind[\"Const\"] = \"const\";\r\n})(VariableDeclarationKind = exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationKind.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationList.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationList.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar structurePrinters_1 = __webpack_require__(/*! ../../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar base_1 = __webpack_require__(/*! ../base */ \"./node_modules/ts-simple-ast/dist/compiler/base/index.js\");\r\nvar callBaseFill_1 = __webpack_require__(/*! ../callBaseFill */ \"./node_modules/ts-simple-ast/dist/compiler/callBaseFill.js\");\r\nvar common_1 = __webpack_require__(/*! ../common */ \"./node_modules/ts-simple-ast/dist/compiler/common/index.js\");\r\nvar VariableDeclarationKind_1 = __webpack_require__(/*! ./VariableDeclarationKind */ \"./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationKind.js\");\r\nexports.VariableDeclarationListBase = base_1.ModifierableNode(common_1.Node);\r\nvar VariableDeclarationList = /** @class */ (function (_super) {\r\n    tslib_1.__extends(VariableDeclarationList, _super);\r\n    function VariableDeclarationList() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Get the variable declarations.\r\n     */\r\n    VariableDeclarationList.prototype.getDeclarations = function () {\r\n        var _this = this;\r\n        return this.compilerNode.declarations.map(function (d) { return _this.getNodeFromCompilerNode(d); });\r\n    };\r\n    /**\r\n     * Gets the variable declaration kind.\r\n     */\r\n    VariableDeclarationList.prototype.getDeclarationKind = function () {\r\n        var nodeFlags = this.compilerNode.flags;\r\n        if (nodeFlags & typescript_1.ts.NodeFlags.Let)\r\n            return VariableDeclarationKind_1.VariableDeclarationKind.Let;\r\n        else if (nodeFlags & typescript_1.ts.NodeFlags.Const)\r\n            return VariableDeclarationKind_1.VariableDeclarationKind.Const;\r\n        else\r\n            return VariableDeclarationKind_1.VariableDeclarationKind.Var;\r\n    };\r\n    /**\r\n     * Gets the variable declaration kind keyword.\r\n     */\r\n    VariableDeclarationList.prototype.getDeclarationKindKeyword = function () {\r\n        var declarationKind = this.getDeclarationKind();\r\n        switch (declarationKind) {\r\n            case VariableDeclarationKind_1.VariableDeclarationKind.Const:\r\n                return this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.ConstKeyword);\r\n            case VariableDeclarationKind_1.VariableDeclarationKind.Let:\r\n                return this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.LetKeyword);\r\n            case VariableDeclarationKind_1.VariableDeclarationKind.Var:\r\n                return this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.VarKeyword);\r\n            default:\r\n                throw errors.getNotImplementedForNeverValueError(declarationKind);\r\n        }\r\n    };\r\n    /**\r\n     * Sets the variable declaration kind.\r\n     * @param type - Type to set.\r\n     */\r\n    VariableDeclarationList.prototype.setDeclarationKind = function (type) {\r\n        if (this.getDeclarationKind() === type)\r\n            return this;\r\n        var keyword = this.getDeclarationKindKeyword();\r\n        manipulation_1.insertIntoParentTextRange({\r\n            insertPos: keyword.getStart(),\r\n            newText: type,\r\n            parent: this,\r\n            replacing: {\r\n                textLength: keyword.getWidth()\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Add a variable declaration to the statement.\r\n     * @param structure - Structure representing the variable declaration to add.\r\n     */\r\n    VariableDeclarationList.prototype.addDeclaration = function (structure) {\r\n        return this.addDeclarations([structure])[0];\r\n    };\r\n    /**\r\n     * Adds variable declarations to the statement.\r\n     * @param structures - Structures representing the variable declarations to add.\r\n     */\r\n    VariableDeclarationList.prototype.addDeclarations = function (structures) {\r\n        return this.insertDeclarations(this.getDeclarations().length, structures);\r\n    };\r\n    /**\r\n     * Inserts a variable declaration at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structure - Structure representing the variable declaration to insert.\r\n     */\r\n    VariableDeclarationList.prototype.insertDeclaration = function (index, structure) {\r\n        return this.insertDeclarations(index, [structure])[0];\r\n    };\r\n    /**\r\n     * Inserts variable declarations at the specified index within the statement.\r\n     * @param index - Child index to insert at.\r\n     * @param structures - Structures representing the variable declarations to insert.\r\n     */\r\n    VariableDeclarationList.prototype.insertDeclarations = function (index, structures) {\r\n        var writer = this.getWriterWithQueuedChildIndentation();\r\n        var structurePrinter = new structurePrinters_1.CommaSeparatedStructuresPrinter(this.context.structurePrinterFactory.forVariableDeclaration());\r\n        structurePrinter.printText(writer, structures);\r\n        manipulation_1.insertIntoCommaSeparatedNodes({\r\n            parent: this.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.SyntaxList),\r\n            currentNodes: this.getDeclarations(),\r\n            insertIndex: index,\r\n            newText: writer.toString()\r\n        });\r\n        return manipulation_1.getNodesToReturn(this.getDeclarations(), index, structures.length);\r\n    };\r\n    /**\r\n     * Fills the node from a structure.\r\n     * @param structure - Structure to fill.\r\n     */\r\n    VariableDeclarationList.prototype.fill = function (structure) {\r\n        callBaseFill_1.callBaseFill(exports.VariableDeclarationListBase.prototype, this, structure);\r\n        if (structure.declarationKind != null)\r\n            this.setDeclarationKind(structure.declarationKind);\r\n        if (structure.declarations != null)\r\n            this.addDeclarations(structure.declarations);\r\n        return this;\r\n    };\r\n    return VariableDeclarationList;\r\n}(exports.VariableDeclarationListBase));\r\nexports.VariableDeclarationList = VariableDeclarationList;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationList.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/compiler/variable/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/compiler/variable/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VariableDeclaration */ \"./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclaration.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VariableDeclarationKind */ \"./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationKind.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VariableDeclarationList */ \"./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationList.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/compiler/variable/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/constants.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Chars = {\r\n    BOM: \"\\uFEFF\"\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/constants.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BaseError_1 = __webpack_require__(/*! ./BaseError */ \"./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js\");\r\nvar ArgumentError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArgumentError, _super);\r\n    /** @internal */\r\n    function ArgumentError(argName, message, prototype) {\r\n        if (prototype === void 0) { prototype = ArgumentError.prototype; }\r\n        var _this = _super.call(this, \"Argument Error (\" + argName + \"): \" + message, prototype) || this;\r\n        _this.argName = argName;\r\n        return _this;\r\n    }\r\n    return ArgumentError;\r\n}(BaseError_1.BaseError));\r\nexports.ArgumentError = ArgumentError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/ArgumentNullOrWhitespaceError.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/ArgumentNullOrWhitespaceError.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar ArgumentError_1 = __webpack_require__(/*! ./ArgumentError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js\");\r\nvar ArgumentNullOrWhitespaceError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArgumentNullOrWhitespaceError, _super);\r\n    /** @internal */\r\n    function ArgumentNullOrWhitespaceError(argName) {\r\n        return _super.call(this, argName, \"Cannot be null or whitespace.\", ArgumentNullOrWhitespaceError.prototype) || this;\r\n    }\r\n    return ArgumentNullOrWhitespaceError;\r\n}(ArgumentError_1.ArgumentError));\r\nexports.ArgumentNullOrWhitespaceError = ArgumentNullOrWhitespaceError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/ArgumentNullOrWhitespaceError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/ArgumentOutOfRangeError.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/ArgumentOutOfRangeError.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar ArgumentError_1 = __webpack_require__(/*! ./ArgumentError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js\");\r\nvar ArgumentOutOfRangeError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArgumentOutOfRangeError, _super);\r\n    /** @internal */\r\n    function ArgumentOutOfRangeError(argName, value, range) {\r\n        return _super.call(this, argName, \"Range is \" + range[0] + \" to \" + range[1] + \", but \" + value + \" was provided.\", ArgumentOutOfRangeError.prototype) || this;\r\n    }\r\n    return ArgumentOutOfRangeError;\r\n}(ArgumentError_1.ArgumentError));\r\nexports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/ArgumentOutOfRangeError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/ArgumentTypeError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/ArgumentTypeError.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar ArgumentError_1 = __webpack_require__(/*! ./ArgumentError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js\");\r\nvar ArgumentTypeError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ArgumentTypeError, _super);\r\n    /** @internal */\r\n    function ArgumentTypeError(argName, expectedType, actualType) {\r\n        var _this = _super.call(this, argName, \"Expected type '\" + expectedType + \"', but was '\" + actualType + \"'.\", ArgumentTypeError.prototype) || this;\r\n        _this.expectedType = expectedType;\r\n        _this.actualType = actualType;\r\n        return _this;\r\n    }\r\n    return ArgumentTypeError;\r\n}(ArgumentError_1.ArgumentError));\r\nexports.ArgumentTypeError = ArgumentTypeError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/ArgumentTypeError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BaseError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BaseError, _super);\r\n    /** @internal */\r\n    function BaseError(message, prototype) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.message = message;\r\n        _this.message = message;\r\n        // workaround for extending error to work in ES5 :(\r\n        Object.setPrototypeOf(_this, prototype);\r\n        return _this;\r\n    }\r\n    return BaseError;\r\n}(Error));\r\nexports.BaseError = BaseError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/DirectoryNotFoundError.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/DirectoryNotFoundError.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar PathNotFoundError_1 = __webpack_require__(/*! ./PathNotFoundError */ \"./node_modules/ts-simple-ast/dist/errors/classes/PathNotFoundError.js\");\r\nvar DirectoryNotFoundError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DirectoryNotFoundError, _super);\r\n    /** @internal */\r\n    function DirectoryNotFoundError(dirPath) {\r\n        var _this = _super.call(this, dirPath, \"Directory\", DirectoryNotFoundError.prototype) || this;\r\n        _this.dirPath = dirPath;\r\n        return _this;\r\n    }\r\n    return DirectoryNotFoundError;\r\n}(PathNotFoundError_1.PathNotFoundError));\r\nexports.DirectoryNotFoundError = DirectoryNotFoundError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/DirectoryNotFoundError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/FileNotFoundError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/FileNotFoundError.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar PathNotFoundError_1 = __webpack_require__(/*! ./PathNotFoundError */ \"./node_modules/ts-simple-ast/dist/errors/classes/PathNotFoundError.js\");\r\nvar FileNotFoundError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FileNotFoundError, _super);\r\n    /** @internal */\r\n    function FileNotFoundError(filePath) {\r\n        var _this = _super.call(this, filePath, \"File\", FileNotFoundError.prototype) || this;\r\n        _this.filePath = filePath;\r\n        return _this;\r\n    }\r\n    return FileNotFoundError;\r\n}(PathNotFoundError_1.PathNotFoundError));\r\nexports.FileNotFoundError = FileNotFoundError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/FileNotFoundError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/InvalidOperationError.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/InvalidOperationError.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BaseError_1 = __webpack_require__(/*! ./BaseError */ \"./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js\");\r\nvar InvalidOperationError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(InvalidOperationError, _super);\r\n    /** @internal */\r\n    function InvalidOperationError(message) {\r\n        return _super.call(this, message, InvalidOperationError.prototype) || this;\r\n    }\r\n    return InvalidOperationError;\r\n}(BaseError_1.BaseError));\r\nexports.InvalidOperationError = InvalidOperationError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/InvalidOperationError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/NotImplementedError.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/NotImplementedError.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BaseError_1 = __webpack_require__(/*! ./BaseError */ \"./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js\");\r\nvar NotImplementedError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NotImplementedError, _super);\r\n    /** @internal */\r\n    function NotImplementedError(message) {\r\n        if (message === void 0) { message = \"Not implemented.\"; }\r\n        return _super.call(this, message, NotImplementedError.prototype) || this;\r\n    }\r\n    return NotImplementedError;\r\n}(BaseError_1.BaseError));\r\nexports.NotImplementedError = NotImplementedError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/NotImplementedError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/NotSupportedError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/NotSupportedError.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BaseError_1 = __webpack_require__(/*! ./BaseError */ \"./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js\");\r\nvar NotSupportedError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NotSupportedError, _super);\r\n    /** @internal */\r\n    function NotSupportedError(message) {\r\n        return _super.call(this, message, NotSupportedError.prototype) || this;\r\n    }\r\n    return NotSupportedError;\r\n}(BaseError_1.BaseError));\r\nexports.NotSupportedError = NotSupportedError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/NotSupportedError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/PathNotFoundError.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/PathNotFoundError.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar BaseError_1 = __webpack_require__(/*! ./BaseError */ \"./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js\");\r\nvar PathNotFoundError = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PathNotFoundError, _super);\r\n    /** @internal */\r\n    function PathNotFoundError(path, prefix, prototype) {\r\n        if (prefix === void 0) { prefix = \"Path\"; }\r\n        if (prototype === void 0) { prototype = PathNotFoundError.prototype; }\r\n        var _this = _super.call(this, prefix + \" not found: \" + path, prototype) || this;\r\n        _this.path = path;\r\n        _this.code = \"ENOENT\";\r\n        return _this;\r\n    }\r\n    return PathNotFoundError;\r\n}(BaseError_1.BaseError));\r\nexports.PathNotFoundError = PathNotFoundError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/PathNotFoundError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/classes/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/classes/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArgumentError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArgumentNullOrWhitespaceError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentNullOrWhitespaceError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArgumentOutOfRangeError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentOutOfRangeError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArgumentTypeError */ \"./node_modules/ts-simple-ast/dist/errors/classes/ArgumentTypeError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BaseError */ \"./node_modules/ts-simple-ast/dist/errors/classes/BaseError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DirectoryNotFoundError */ \"./node_modules/ts-simple-ast/dist/errors/classes/DirectoryNotFoundError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FileNotFoundError */ \"./node_modules/ts-simple-ast/dist/errors/classes/FileNotFoundError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InvalidOperationError */ \"./node_modules/ts-simple-ast/dist/errors/classes/InvalidOperationError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NotImplementedError */ \"./node_modules/ts-simple-ast/dist/errors/classes/NotImplementedError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NotSupportedError */ \"./node_modules/ts-simple-ast/dist/errors/classes/NotSupportedError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PathNotFoundError */ \"./node_modules/ts-simple-ast/dist/errors/classes/PathNotFoundError.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/classes/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/helpers.js":
/*!***********************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/helpers.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar getSyntaxKindName_1 = __webpack_require__(/*! ../utils/compiler/getSyntaxKindName */ \"./node_modules/ts-simple-ast/dist/utils/compiler/getSyntaxKindName.js\");\r\nvar classes_1 = __webpack_require__(/*! ./classes */ \"./node_modules/ts-simple-ast/dist/errors/classes/index.js\");\r\n/**\r\n * Thows if not a type.\r\n * @param value - Value to check the type of.\r\n * @param expectedType - Expected type.\r\n * @param argName - Argument name.\r\n */\r\nfunction throwIfNotType(value, expectedType, argName) {\r\n    if (typeof value !== expectedType)\r\n        throw new classes_1.ArgumentTypeError(argName, expectedType, typeof value);\r\n}\r\nexports.throwIfNotType = throwIfNotType;\r\n/**\r\n * Throws if the value is not a string.\r\n * @param value - Value to check.\r\n * @param argName - Arg name.\r\n */\r\nfunction throwIfNotString(value, argName) {\r\n    if (typeof value !== \"string\")\r\n        throw new classes_1.ArgumentTypeError(argName, \"string\", typeof value);\r\n}\r\nexports.throwIfNotString = throwIfNotString;\r\n/**\r\n * Throws if the value is not a string or is whitespace.\r\n * @param value - Value to check.\r\n * @param argName - Arg name.\r\n */\r\nfunction throwIfNotStringOrWhitespace(value, argName) {\r\n    throwIfNotString(value, argName);\r\n    if (value.trim().length === 0)\r\n        throw new classes_1.ArgumentNullOrWhitespaceError(argName);\r\n}\r\nexports.throwIfNotStringOrWhitespace = throwIfNotStringOrWhitespace;\r\n/**\r\n * Throws a NotImplementedError if a node doesn't match the expected syntax kind.\r\n * @param node - Node.\r\n * @param kind - Syntax kind that's expected.\r\n * @param message - Optional message to throw.\r\n */\r\nfunction throwIfNotSyntaxKind(node, kind, message) {\r\n    if (node.getKind() !== kind)\r\n        throw new classes_1.NotImplementedError(message || \"Expected node to be syntax kind \" + getSyntaxKindName_1.getSyntaxKindName(kind) + \", but was \" + node.getKindName() + \".\");\r\n}\r\nexports.throwIfNotSyntaxKind = throwIfNotSyntaxKind;\r\n/**\r\n * Throws an ArgumentOutOfRangeError if an argument's value is out of an inclusive range.\r\n * @param value - Value.\r\n * @param range - Range.\r\n * @param argName - Argument name.\r\n */\r\nfunction throwIfOutOfRange(value, range, argName) {\r\n    if (value < range[0] || value > range[1])\r\n        throw new classes_1.ArgumentOutOfRangeError(argName, value, range);\r\n}\r\nexports.throwIfOutOfRange = throwIfOutOfRange;\r\n/**\r\n * Throws an ArgumentOutOfRangeError if an argument's range value is out of an inclusive range.\r\n *\r\n * Also throws when the start of the range is greater than the end.\r\n * @param actualRange - Range to check.\r\n * @param range - Range to check against.\r\n * @param argName - Argument name.\r\n */\r\nfunction throwIfRangeOutOfRange(actualRange, range, argName) {\r\n    if (actualRange[0] > actualRange[1])\r\n        throw new classes_1.ArgumentError(argName, \"The start of a range must not be greater than the end: [\" + actualRange[0] + \", \" + actualRange[1] + \"]\");\r\n    throwIfOutOfRange(actualRange[0], range, argName);\r\n    throwIfOutOfRange(actualRange[1], range, argName);\r\n}\r\nexports.throwIfRangeOutOfRange = throwIfRangeOutOfRange;\r\n/**\r\n * Gets an error saying that a feature is not implemented for a certain syntax kind.\r\n * @param kind - Syntax kind that isn't implemented.\r\n */\r\nfunction getNotImplementedForSyntaxKindError(kind) {\r\n    return new classes_1.NotImplementedError(\"Not implemented feature for syntax kind '\" + getSyntaxKindName_1.getSyntaxKindName(kind) + \"'.\");\r\n}\r\nexports.getNotImplementedForSyntaxKindError = getNotImplementedForSyntaxKindError;\r\n/**\r\n * Throws an Argument\r\n * @param value\r\n * @param argName\r\n */\r\nfunction throwIfNegative(value, argName) {\r\n    if (value < 0)\r\n        throw new classes_1.ArgumentError(argName, \"Expected a non-negative value.\");\r\n}\r\nexports.throwIfNegative = throwIfNegative;\r\n/**\r\n * Throws when the value is null or undefined.\r\n * @param value - Value to check.\r\n * @param errorMessage - Error message to throw when not defined.\r\n */\r\nfunction throwIfNullOrUndefined(value, errorMessage) {\r\n    if (value == null)\r\n        throw new classes_1.InvalidOperationError(typeof errorMessage === \"string\" ? errorMessage : errorMessage());\r\n    return value;\r\n}\r\nexports.throwIfNullOrUndefined = throwIfNullOrUndefined;\r\n/**\r\n * Throw if the value should have been the never type.\r\n * @param value - Value to check.\r\n */\r\nfunction getNotImplementedForNeverValueError(value) {\r\n    return new classes_1.NotImplementedError(\"Not implemented value: \" + JSON.stringify(value));\r\n}\r\nexports.getNotImplementedForNeverValueError = getNotImplementedForNeverValueError;\r\n/**\r\n * Throws an error if the actual value does not equal the expected value.\r\n * @param actual - Actual value.\r\n * @param expected - Expected value.\r\n * @param description - Message to show in the error. Should be a full sentence that doesn't include the actual and expected values.\r\n */\r\nfunction throwIfNotEqual(actual, expected, description) {\r\n    if (actual !== expected)\r\n        throw new classes_1.InvalidOperationError(\"Expected \" + actual + \" to equal \" + expected + \". \" + description);\r\n}\r\nexports.throwIfNotEqual = throwIfNotEqual;\r\n/**\r\n * Throws if true.\r\n * @param value - Value to check.\r\n * @param errorMessage - Error message to throw when true.\r\n */\r\nfunction throwIfTrue(value, errorMessage) {\r\n    if (value === true)\r\n        throw new classes_1.InvalidOperationError(errorMessage);\r\n}\r\nexports.throwIfTrue = throwIfTrue;\r\n/**\r\n * Throws if the file does not exist.\r\n * @param fileSystem - File system host.\r\n * @param filePath - File path.\r\n */\r\nfunction throwIfFileNotExists(fileSystemWrapper, filePath) {\r\n    if (!fileSystemWrapper.fileExistsSync(filePath))\r\n        throw new classes_1.FileNotFoundError(filePath);\r\n}\r\nexports.throwIfFileNotExists = throwIfFileNotExists;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/helpers.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/errors/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/errors/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./classes */ \"./node_modules/ts-simple-ast/dist/errors/classes/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./helpers */ \"./node_modules/ts-simple-ast/dist/errors/helpers.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/errors/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/CompilerFactory.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/CompilerFactory.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar compiler_1 = __webpack_require__(/*! ../compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar manipulation_1 = __webpack_require__(/*! ../manipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar DirectoryCache_1 = __webpack_require__(/*! ./DirectoryCache */ \"./node_modules/ts-simple-ast/dist/factories/DirectoryCache.js\");\r\nvar ForgetfulNodeCache_1 = __webpack_require__(/*! ./ForgetfulNodeCache */ \"./node_modules/ts-simple-ast/dist/factories/ForgetfulNodeCache.js\");\r\nvar kindToWrapperMappings_1 = __webpack_require__(/*! ./kindToWrapperMappings */ \"./node_modules/ts-simple-ast/dist/factories/kindToWrapperMappings.js\");\r\nvar DocumentRegistry_1 = __webpack_require__(/*! ./DocumentRegistry */ \"./node_modules/ts-simple-ast/dist/factories/DocumentRegistry.js\");\r\n/**\r\n * Factory for creating compiler wrappers.\r\n * @internal\r\n */\r\nvar CompilerFactory = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance of CompilerFactory.\r\n     * @param context - Project context.\r\n     */\r\n    function CompilerFactory(context) {\r\n        var _this = this;\r\n        this.context = context;\r\n        this.sourceFileCacheByFilePath = new utils_1.KeyValueCache();\r\n        this.diagnosticCache = new utils_1.WeakCache();\r\n        this.definitionInfoCache = new utils_1.WeakCache();\r\n        this.documentSpanCache = new utils_1.WeakCache();\r\n        this.diagnosticMessageChainCache = new utils_1.WeakCache();\r\n        this.jsDocTagInfoCache = new utils_1.WeakCache();\r\n        this.signatureCache = new utils_1.WeakCache();\r\n        this.symbolCache = new utils_1.WeakCache();\r\n        this.symbolDisplayPartCache = new utils_1.WeakCache();\r\n        this.referenceEntryCache = new utils_1.WeakCache();\r\n        this.referencedSymbolCache = new utils_1.WeakCache();\r\n        this.referencedSymbolDefinitionInfoCache = new utils_1.WeakCache();\r\n        this.typeCache = new utils_1.WeakCache();\r\n        this.typeParameterCache = new utils_1.WeakCache();\r\n        this.nodeCache = new ForgetfulNodeCache_1.ForgetfulNodeCache();\r\n        this.sourceFileAddedEventContainer = new utils_1.EventContainer();\r\n        this.sourceFileMovedEventContainer = new utils_1.EventContainer();\r\n        this.sourceFileRemovedEventContainer = new utils_1.EventContainer();\r\n        this.documentRegistry = new DocumentRegistry_1.DocumentRegistry(context.fileSystemWrapper);\r\n        this.directoryCache = new DirectoryCache_1.DirectoryCache(context);\r\n        // prevent memory leaks when the document registry key changes by just reseting it\r\n        this.context.compilerOptions.onModified(function () {\r\n            var e_1, _a;\r\n            // repopulate the cache\r\n            var currentSourceFiles = _this.sourceFileCacheByFilePath.getValuesAsArray();\r\n            try {\r\n                for (var currentSourceFiles_1 = tslib_1.__values(currentSourceFiles), currentSourceFiles_1_1 = currentSourceFiles_1.next(); !currentSourceFiles_1_1.done; currentSourceFiles_1_1 = currentSourceFiles_1.next()) {\r\n                    var sourceFile = currentSourceFiles_1_1.value;\r\n                    // reparse the source files in the new document registry, then populate the cache with the new nodes\r\n                    manipulation_1.replaceSourceFileForCacheUpdate(sourceFile);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (currentSourceFiles_1_1 && !currentSourceFiles_1_1.done && (_a = currentSourceFiles_1.return)) _a.call(currentSourceFiles_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Gets all the source files sorted by their directory depth.\r\n     */\r\n    CompilerFactory.prototype.getSourceFilesByDirectoryDepth = function () {\r\n        var e_2, _a, _b, _c, dir, e_2_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(this.getDirectoriesByDepth()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    dir = _c.value;\r\n                    return [5 /*yield**/, tslib_1.__values(dir.getSourceFiles())];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_2_1 = _d.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the source file paths from the internal cache.\r\n     */\r\n    CompilerFactory.prototype.getSourceFilePaths = function () {\r\n        return utils_1.ArrayUtils.from(this.sourceFileCacheByFilePath.getKeys());\r\n    };\r\n    /**\r\n     * Gets the child directories of a directory.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    CompilerFactory.prototype.getChildDirectoriesOfDirectory = function (dirPath) {\r\n        return this.directoryCache.getChildDirectoriesOfDirectory(dirPath);\r\n    };\r\n    /**\r\n     * Gets the child source files of a directory.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    CompilerFactory.prototype.getChildSourceFilesOfDirectory = function (dirPath) {\r\n        return this.directoryCache.getChildSourceFilesOfDirectory(dirPath);\r\n    };\r\n    /**\r\n     * Occurs when a source file is added to the cache.\r\n     * @param subscription - Subscripton.\r\n     * @param subscribe - Whether to subscribe or unsubscribe (default to true).\r\n     */\r\n    CompilerFactory.prototype.onSourceFileAdded = function (subscription, subscribe) {\r\n        if (subscribe === void 0) { subscribe = true; }\r\n        if (subscribe)\r\n            this.sourceFileAddedEventContainer.subscribe(subscription);\r\n        else\r\n            this.sourceFileAddedEventContainer.unsubscribe(subscription);\r\n    };\r\n    /**\r\n     * Occurs when a source file is removed from the cache.\r\n     * @param subscription - Subscripton.\r\n     */\r\n    CompilerFactory.prototype.onSourceFileRemoved = function (subscription) {\r\n        this.sourceFileRemovedEventContainer.subscribe(subscription);\r\n    };\r\n    /**\r\n     * Adds a source file by structure or text.\r\n     * @param filePath - File path.\r\n     * @param structureOrText - Structure or text.\r\n     * @param options - Options.\r\n     */\r\n    CompilerFactory.prototype.createSourceFile = function (filePath, structureOrText, options) {\r\n        if (structureOrText == null || typeof structureOrText === \"string\")\r\n            return this.createSourceFileFromText(filePath, structureOrText || \"\", options);\r\n        var writer = this.context.createWriter();\r\n        var structurePrinter = this.context.structurePrinterFactory.forSourceFile({\r\n            isAmbient: utils_1.FileUtils.getExtension(filePath) === \".d.ts\"\r\n        });\r\n        structurePrinter.printText(writer, structureOrText);\r\n        return this.createSourceFileFromText(filePath, writer.toString(), options);\r\n    };\r\n    /**\r\n     * Creates a source file from a file path and text.\r\n     * Adds it to the cache.\r\n     * @param filePath - File path for the source file.\r\n     * @param sourceText - Text to create the source file with.\r\n     * @param options - Options.\r\n     * @throws InvalidOperationError if the file exists.\r\n     */\r\n    CompilerFactory.prototype.createSourceFileFromText = function (filePath, sourceText, options) {\r\n        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);\r\n        if (options != null && options.overwrite === true)\r\n            return this.createOrOverwriteSourceFileFromText(filePath, sourceText);\r\n        this.throwIfFileExists(filePath);\r\n        return this.createSourceFileFromTextInternal(filePath, sourceText);\r\n    };\r\n    /**\r\n     * Throws an error if the file exists in the cache or file system.\r\n     * @param filePath - File path.\r\n     * @param prefixMessage - Message to attach on as a prefix.\r\n     */\r\n    CompilerFactory.prototype.throwIfFileExists = function (filePath, prefixMessage) {\r\n        if (!this.containsSourceFileAtPath(filePath) && !this.context.fileSystemWrapper.fileExistsSync(filePath))\r\n            return;\r\n        prefixMessage = prefixMessage == null ? \"\" : prefixMessage + \" \";\r\n        throw new errors.InvalidOperationError(prefixMessage + \"A source file already exists at the provided file path: \" + filePath);\r\n    };\r\n    CompilerFactory.prototype.createOrOverwriteSourceFileFromText = function (filePath, sourceText) {\r\n        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);\r\n        var existingSourceFile = this.addOrGetSourceFileFromFilePath(filePath);\r\n        if (existingSourceFile != null) {\r\n            existingSourceFile.getChildren().forEach(function (c) { return c.forget(); });\r\n            this.replaceCompilerNode(existingSourceFile, this.createCompilerSourceFileFromText(filePath, sourceText));\r\n            return existingSourceFile;\r\n        }\r\n        return this.createSourceFileFromTextInternal(filePath, sourceText);\r\n    };\r\n    /**\r\n     * Gets the source file from the cache by a file path.\r\n     * @param filePath - File path.\r\n     */\r\n    CompilerFactory.prototype.getSourceFileFromCacheFromFilePath = function (filePath) {\r\n        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);\r\n        return this.sourceFileCacheByFilePath.get(filePath);\r\n    };\r\n    /**\r\n     * Gets a source file from a file path. Will use the file path cache if the file exists.\r\n     * @param filePath - File path to get the file from.\r\n     */\r\n    CompilerFactory.prototype.addOrGetSourceFileFromFilePath = function (filePath) {\r\n        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);\r\n        var sourceFile = this.sourceFileCacheByFilePath.get(filePath);\r\n        if (sourceFile == null) {\r\n            if (this.context.fileSystemWrapper.fileExistsSync(filePath)) {\r\n                this.context.logger.log(\"Loading file: \" + filePath);\r\n                sourceFile = this.createSourceFileFromTextInternal(filePath, this.context.fileSystemWrapper.readFileSync(filePath, this.context.getEncoding()));\r\n                sourceFile.setIsSaved(true); // source files loaded from the disk are saved to start with\r\n            }\r\n            if (sourceFile != null) {\r\n                // ensure these are added to the ast\r\n                sourceFile.getReferencedFiles();\r\n                sourceFile.getTypeReferenceDirectives();\r\n            }\r\n        }\r\n        return sourceFile;\r\n    };\r\n    /**\r\n     * Gets if the internal cache contains a source file at a specific file path.\r\n     * @param filePath - File path to check.\r\n     */\r\n    CompilerFactory.prototype.containsSourceFileAtPath = function (filePath) {\r\n        var absoluteFilePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);\r\n        return this.sourceFileCacheByFilePath.has(absoluteFilePath);\r\n    };\r\n    /**\r\n     * Gets if the internal cache contains a source file with the specified directory path.\r\n     * @param dirPath - Directory path to check.\r\n     */\r\n    CompilerFactory.prototype.containsDirectoryAtPath = function (dirPath) {\r\n        var normalizedDirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);\r\n        return this.directoryCache.has(normalizedDirPath);\r\n    };\r\n    /**\r\n     * Gets the source file for a node.\r\n     * @param compilerNode - Compiler node to get the source file of.\r\n     */\r\n    CompilerFactory.prototype.getSourceFileForNode = function (compilerNode) {\r\n        var currentNode = compilerNode;\r\n        while (currentNode.kind !== typescript_1.SyntaxKind.SourceFile) {\r\n            if (currentNode.parent == null)\r\n                throw new errors.NotImplementedError(\"Could not find node source file.\");\r\n            currentNode = currentNode.parent;\r\n        }\r\n        return this.getSourceFile(currentNode);\r\n    };\r\n    /**\r\n     * Gets if the factory contains the compiler node in its internal cache.\r\n     * @param compilerNode - Compiler node.\r\n     */\r\n    CompilerFactory.prototype.hasCompilerNode = function (compilerNode) {\r\n        return this.nodeCache.has(compilerNode);\r\n    };\r\n    /**\r\n     * Gets an existing node from the cache.\r\n     * @param compilerNode - Compiler node.\r\n     */\r\n    CompilerFactory.prototype.getExistingCompilerNode = function (compilerNode) {\r\n        return this.nodeCache.get(compilerNode);\r\n    };\r\n    /**\r\n     * Gets a wrapped compiler type based on the node's kind.\r\n     * @param node - Node to get the wrapped object from.\r\n     */\r\n    CompilerFactory.prototype.getNodeFromCompilerNode = function (compilerNode, sourceFile) {\r\n        var _this = this;\r\n        if (compilerNode.kind === typescript_1.SyntaxKind.SourceFile)\r\n            return this.getSourceFile(compilerNode);\r\n        var createNode = function (ctor) {\r\n            // ensure the parent is created\r\n            if (compilerNode.parent != null && !_this.nodeCache.has(compilerNode.parent))\r\n                _this.getNodeFromCompilerNode(compilerNode.parent, sourceFile);\r\n            return new ctor(_this.context, compilerNode, sourceFile);\r\n        };\r\n        if (kindToWrapperMappings_1.kindToWrapperMappings[compilerNode.kind] != null)\r\n            return this.nodeCache.getOrCreate(compilerNode, function () { return createNode(kindToWrapperMappings_1.kindToWrapperMappings[compilerNode.kind]); });\r\n        else\r\n            return this.nodeCache.getOrCreate(compilerNode, function () { return createNode(compiler_1.Node); });\r\n    };\r\n    CompilerFactory.prototype.createSourceFileFromTextInternal = function (filePath, text) {\r\n        return this.getSourceFile(this.createCompilerSourceFileFromText(filePath, text));\r\n    };\r\n    CompilerFactory.prototype.createCompilerSourceFileFromText = function (filePath, text) {\r\n        return this.documentRegistry.createOrUpdateSourceFile(filePath, this.context.compilerOptions.get(), typescript_1.ts.ScriptSnapshot.fromString(text));\r\n    };\r\n    /**\r\n     * Gets a wrapped source file from a compiler source file.\r\n     * @param sourceFile - Compiler source file.\r\n     */\r\n    CompilerFactory.prototype.getSourceFile = function (compilerSourceFile) {\r\n        var _this = this;\r\n        var wasAdded = false;\r\n        var sourceFile = this.nodeCache.getOrCreate(compilerSourceFile, function () {\r\n            var createdSourceFile = new compiler_1.SourceFile(_this.context, compilerSourceFile);\r\n            _this.addSourceFileToCache(createdSourceFile);\r\n            wasAdded = true;\r\n            return createdSourceFile;\r\n        });\r\n        if (wasAdded)\r\n            this.sourceFileAddedEventContainer.fire(sourceFile);\r\n        return sourceFile;\r\n    };\r\n    CompilerFactory.prototype.addSourceFileToCache = function (sourceFile) {\r\n        this.sourceFileCacheByFilePath.set(sourceFile.getFilePath(), sourceFile);\r\n        this.context.fileSystemWrapper.removeFileDelete(sourceFile.getFilePath());\r\n        this.directoryCache.addSourceFile(sourceFile);\r\n    };\r\n    /**\r\n     * Gets a directory from a path.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    CompilerFactory.prototype.getDirectoryFromPath = function (dirPath) {\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);\r\n        var directory = this.directoryCache.get(dirPath);\r\n        if (directory == null && this.context.fileSystemWrapper.directoryExistsSync(dirPath))\r\n            directory = this.directoryCache.createOrAddIfExists(dirPath);\r\n        return directory;\r\n    };\r\n    /**\r\n     * Creates or adds a directory if it doesn't exist.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    CompilerFactory.prototype.createDirectoryOrAddIfExists = function (dirPath) {\r\n        return this.directoryCache.createOrAddIfExists(dirPath);\r\n    };\r\n    /**\r\n     * Gets a directory.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    CompilerFactory.prototype.getDirectoryFromCache = function (dirPath) {\r\n        return this.directoryCache.get(dirPath);\r\n    };\r\n    /**\r\n     * Gets all the directories iterated by depth.\r\n     */\r\n    CompilerFactory.prototype.getDirectoriesByDepth = function () {\r\n        return this.directoryCache.getAllByDepth();\r\n    };\r\n    /**\r\n     * Gets the directories without a parent.\r\n     */\r\n    CompilerFactory.prototype.getOrphanDirectories = function () {\r\n        return this.directoryCache.getOrphans();\r\n    };\r\n    /**\r\n     * Gets a warpped symbol display part form a compiler symbol display part.\r\n     * @param compilerObject - Compiler symbol display part.\r\n     */\r\n    CompilerFactory.prototype.getSymbolDisplayPart = function (compilerObject) {\r\n        return this.symbolDisplayPartCache.getOrCreate(compilerObject, function () { return new compiler_1.SymbolDisplayPart(compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a wrapped type from a compiler type.\r\n     * @param type - Compiler type.\r\n     */\r\n    CompilerFactory.prototype.getType = function (type) {\r\n        var _this = this;\r\n        if ((type.flags & typescript_1.TypeFlags.TypeParameter) === typescript_1.TypeFlags.TypeParameter)\r\n            return this.getTypeParameter(type);\r\n        return this.typeCache.getOrCreate(type, function () { return new compiler_1.Type(_this.context, type); });\r\n    };\r\n    /**\r\n     * Gets a wrapped type parameter from a compiler type parameter.\r\n     * @param typeParameter - Compiler type parameter\r\n     */\r\n    CompilerFactory.prototype.getTypeParameter = function (typeParameter) {\r\n        var _this = this;\r\n        return this.typeParameterCache.getOrCreate(typeParameter, function () { return new compiler_1.TypeParameter(_this.context, typeParameter); });\r\n    };\r\n    /**\r\n     * Gets a wrapped signature from a compiler signature.\r\n     * @param signature - Compiler signature.\r\n     */\r\n    CompilerFactory.prototype.getSignature = function (signature) {\r\n        var _this = this;\r\n        return this.signatureCache.getOrCreate(signature, function () { return new compiler_1.Signature(_this.context, signature); });\r\n    };\r\n    /**\r\n     * Gets a wrapped symbol from a compiler symbol.\r\n     * @param symbol - Compiler symbol.\r\n     */\r\n    CompilerFactory.prototype.getSymbol = function (symbol) {\r\n        var _this = this;\r\n        return this.symbolCache.getOrCreate(symbol, function () { return new compiler_1.Symbol(_this.context, symbol); });\r\n    };\r\n    /**\r\n     * Gets a wrapped definition info from a compiler object.\r\n     * @param compilerObject - Compiler definition info.\r\n     */\r\n    CompilerFactory.prototype.getDefinitionInfo = function (compilerObject) {\r\n        var _this = this;\r\n        return this.definitionInfoCache.getOrCreate(compilerObject, function () { return new compiler_1.DefinitionInfo(_this.context, compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a wrapped document span from a compiler object.\r\n     * @param compilerObject - Compiler document span.\r\n     */\r\n    CompilerFactory.prototype.getDocumentSpan = function (compilerObject) {\r\n        var _this = this;\r\n        return this.documentSpanCache.getOrCreate(compilerObject, function () { return new compiler_1.DocumentSpan(_this.context, compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a wrapped referenced entry from a compiler object.\r\n     * @param compilerObject - Compiler referenced entry.\r\n     */\r\n    CompilerFactory.prototype.getReferenceEntry = function (compilerObject) {\r\n        var _this = this;\r\n        return this.referenceEntryCache.getOrCreate(compilerObject, function () { return new compiler_1.ReferenceEntry(_this.context, compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a wrapped referenced symbol from a compiler object.\r\n     * @param compilerObject - Compiler referenced symbol.\r\n     */\r\n    CompilerFactory.prototype.getReferencedSymbol = function (compilerObject) {\r\n        var _this = this;\r\n        return this.referencedSymbolCache.getOrCreate(compilerObject, function () { return new compiler_1.ReferencedSymbol(_this.context, compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a wrapped referenced symbol definition info from a compiler object.\r\n     * @param compilerObject - Compiler referenced symbol definition info.\r\n     */\r\n    CompilerFactory.prototype.getReferencedSymbolDefinitionInfo = function (compilerObject) {\r\n        var _this = this;\r\n        return this.referencedSymbolDefinitionInfoCache.getOrCreate(compilerObject, function () { return new compiler_1.ReferencedSymbolDefinitionInfo(_this.context, compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a wrapped diagnostic from a compiler diagnostic.\r\n     * @param diagnostic - Compiler diagnostic.\r\n     */\r\n    CompilerFactory.prototype.getDiagnostic = function (diagnostic) {\r\n        var _this = this;\r\n        return this.diagnosticCache.getOrCreate(diagnostic, function () {\r\n            if (diagnostic.start != null)\r\n                return new compiler_1.DiagnosticWithLocation(_this.context, diagnostic);\r\n            return new compiler_1.Diagnostic(_this.context, diagnostic);\r\n        });\r\n    };\r\n    /**\r\n     * Gets a wrapped diagnostic with location from a compiler diagnostic.\r\n     * @param diagnostic - Compiler diagnostic.\r\n     */\r\n    CompilerFactory.prototype.getDiagnosticWithLocation = function (diagnostic) {\r\n        var _this = this;\r\n        return this.diagnosticCache.getOrCreate(diagnostic, function () { return new compiler_1.DiagnosticWithLocation(_this.context, diagnostic); });\r\n    };\r\n    /**\r\n     * Gets a wrapped diagnostic message chain from a compiler diagnostic message chain.\r\n     * @param diagnosticMessageChain - Compiler diagnostic message chain.\r\n     */\r\n    CompilerFactory.prototype.getDiagnosticMessageChain = function (compilerObject) {\r\n        return this.diagnosticMessageChainCache.getOrCreate(compilerObject, function () { return new compiler_1.DiagnosticMessageChain(compilerObject); });\r\n    };\r\n    /**\r\n     * Gets a warpped JS doc tag info from a compiler object.\r\n     * @param jsDocTagInfo - Compiler object.\r\n     */\r\n    CompilerFactory.prototype.getJSDocTagInfo = function (jsDocTagInfo) {\r\n        return this.jsDocTagInfoCache.getOrCreate(jsDocTagInfo, function () { return new compiler_1.JSDocTagInfo(jsDocTagInfo); });\r\n    };\r\n    /**\r\n     * Replaces a compiler node in the cache.\r\n     * @param oldNode - Old node to remove.\r\n     * @param newNode - New node to use.\r\n     */\r\n    CompilerFactory.prototype.replaceCompilerNode = function (oldNode, newNode) {\r\n        var nodeToReplace = oldNode instanceof compiler_1.Node ? oldNode.compilerNode : oldNode;\r\n        var node = oldNode instanceof compiler_1.Node ? oldNode : this.nodeCache.get(oldNode);\r\n        if (nodeToReplace.kind === typescript_1.SyntaxKind.SourceFile && nodeToReplace.fileName !== newNode.fileName) {\r\n            var oldFilePath = nodeToReplace.fileName;\r\n            var sourceFile = node;\r\n            this.removeCompilerNodeFromCache(nodeToReplace);\r\n            sourceFile.replaceCompilerNodeFromFactory(newNode);\r\n            this.nodeCache.set(newNode, sourceFile);\r\n            this.addSourceFileToCache(sourceFile);\r\n            this.sourceFileAddedEventContainer.fire(sourceFile);\r\n        }\r\n        else {\r\n            this.nodeCache.replaceKey(nodeToReplace, newNode);\r\n            if (node != null)\r\n                node.replaceCompilerNodeFromFactory(newNode);\r\n        }\r\n    };\r\n    /**\r\n     * Removes a node from the cache.\r\n     * @param node - Node to remove.\r\n     */\r\n    CompilerFactory.prototype.removeNodeFromCache = function (node) {\r\n        this.removeCompilerNodeFromCache(node.compilerNode);\r\n    };\r\n    /**\r\n     * Removes a compiler node from the cache.\r\n     * @param compilerNode - Compiler node to remove.\r\n     */\r\n    CompilerFactory.prototype.removeCompilerNodeFromCache = function (compilerNode) {\r\n        this.nodeCache.removeByKey(compilerNode);\r\n        if (compilerNode.kind === typescript_1.SyntaxKind.SourceFile) {\r\n            var sourceFile = compilerNode;\r\n            this.directoryCache.removeSourceFile(sourceFile.fileName);\r\n            var tsSourceFile = this.sourceFileCacheByFilePath.get(sourceFile.fileName);\r\n            this.sourceFileCacheByFilePath.removeByKey(sourceFile.fileName);\r\n            this.documentRegistry.removeSourceFile(sourceFile.fileName);\r\n            if (tsSourceFile != null)\r\n                this.sourceFileRemovedEventContainer.fire(tsSourceFile);\r\n        }\r\n    };\r\n    /**\r\n     * Adds the specified directory to the cache.\r\n     * @param directory - Directory\r\n     */\r\n    CompilerFactory.prototype.addDirectoryToCache = function (directory) {\r\n        this.directoryCache.addDirectory(directory);\r\n    };\r\n    /**\r\n     * Removes the directory from the cache.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    CompilerFactory.prototype.removeDirectoryFromCache = function (dirPath) {\r\n        this.directoryCache.remove(dirPath);\r\n    };\r\n    /**\r\n     * Forgets the nodes created in the block.\r\n     * @param block - Block of code to run.\r\n     */\r\n    CompilerFactory.prototype.forgetNodesCreatedInBlock = function (block) {\r\n        var _this = this;\r\n        // can't use the async keyword here because exceptions that happen when doing this synchronously need to be thrown\r\n        this.nodeCache.setForgetPoint();\r\n        var wasPromise = false;\r\n        try {\r\n            var result = block(function () {\r\n                var nodes = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    nodes[_i] = arguments[_i];\r\n                }\r\n                var e_3, _a;\r\n                try {\r\n                    for (var nodes_1 = tslib_1.__values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\r\n                        var node = nodes_1_1.value;\r\n                        _this.nodeCache.rememberNode(node);\r\n                    }\r\n                }\r\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                }\r\n            });\r\n            if (result != null && typeof result.then === \"function\") {\r\n                wasPromise = true;\r\n                return result.then(function () { return _this.nodeCache.forgetLastPoint(); });\r\n            }\r\n        }\r\n        finally {\r\n            if (!wasPromise)\r\n                this.nodeCache.forgetLastPoint();\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    return CompilerFactory;\r\n}());\r\nexports.CompilerFactory = CompilerFactory;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/CompilerFactory.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/DirectoryCache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/DirectoryCache.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Directory_1 = __webpack_require__(/*! ../fileSystem/Directory */ \"./node_modules/ts-simple-ast/dist/fileSystem/Directory.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Cache for the directories.\r\n * @internal\r\n */\r\nvar DirectoryCache = /** @class */ (function () {\r\n    function DirectoryCache(context) {\r\n        this.context = context;\r\n        this.directoriesByPath = new utils_1.KeyValueCache();\r\n        this.sourceFilesByDirPath = new utils_1.KeyValueCache();\r\n        this.directoriesByDirPath = new utils_1.KeyValueCache();\r\n        this.orphanDirs = new utils_1.KeyValueCache();\r\n    }\r\n    DirectoryCache.prototype.has = function (dirPath) {\r\n        return this.directoriesByPath.has(dirPath);\r\n    };\r\n    DirectoryCache.prototype.get = function (dirPath) {\r\n        var e_1, _a;\r\n        if (!this.directoriesByPath.has(dirPath)) {\r\n            try {\r\n                for (var _b = tslib_1.__values(this.orphanDirs.getValues()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var orphanDir = _c.value;\r\n                    if (utils_1.FileUtils.pathStartsWith(orphanDir.getPath(), dirPath))\r\n                        return this.createOrAddIfExists(dirPath);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return undefined;\r\n        }\r\n        return this.directoriesByPath.get(dirPath);\r\n    };\r\n    DirectoryCache.prototype.getOrphans = function () {\r\n        return this.orphanDirs.getValuesAsArray();\r\n    };\r\n    DirectoryCache.prototype.getAll = function () {\r\n        return this.directoriesByPath.getValuesAsArray();\r\n    };\r\n    DirectoryCache.prototype.getAllByDepth = function () {\r\n        function addToDirLevels(dir) {\r\n            var dirDepth = dir.getDepth();\r\n            /* istanbul ignore if */\r\n            if (depth > dirDepth)\r\n                throw new Error(\"For some reason a subdirectory had a lower depth than the parent directory: \" + dir.getPath());\r\n            var dirs = dirLevels.getOrCreate(dirDepth, function () { return []; });\r\n            dirs.push(dir);\r\n        }\r\n        var e_2, _a, dirLevels, depth, _b, _c, dir, e_2_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    dirLevels = new utils_1.KeyValueCache();\r\n                    depth = 0;\r\n                    this.getOrphans().forEach(addToDirLevels);\r\n                    depth = Math.min.apply(Math, tslib_1.__spread(utils_1.ArrayUtils.from(dirLevels.getKeys())));\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!(dirLevels.getSize() > 0)) return [3 /*break*/, 10];\r\n                    _d.label = 2;\r\n                case 2:\r\n                    _d.trys.push([2, 7, 8, 9]);\r\n                    _b = tslib_1.__values(dirLevels.get(depth) || []), _c = _b.next();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    if (!!_c.done) return [3 /*break*/, 6];\r\n                    dir = _c.value;\r\n                    return [4 /*yield*/, dir];\r\n                case 4:\r\n                    _d.sent();\r\n                    dir.getDirectories().forEach(addToDirLevels);\r\n                    _d.label = 5;\r\n                case 5:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 3];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_2_1 = _d.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9:\r\n                    dirLevels.removeByKey(depth);\r\n                    depth++;\r\n                    return [3 /*break*/, 1];\r\n                case 10: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    DirectoryCache.prototype.remove = function (dirPath) {\r\n        this.removeFromDirectoriesByDirPath(dirPath);\r\n        this.directoriesByPath.removeByKey(dirPath);\r\n        this.orphanDirs.removeByKey(dirPath);\r\n    };\r\n    DirectoryCache.prototype.getChildDirectoriesOfDirectory = function (dirPath) {\r\n        var directories = this.directoriesByDirPath.get(dirPath);\r\n        if (directories == null)\r\n            return [];\r\n        return directories.getArrayCopy();\r\n    };\r\n    DirectoryCache.prototype.getChildSourceFilesOfDirectory = function (dirPath) {\r\n        var sourceFiles = this.sourceFilesByDirPath.get(dirPath);\r\n        if (sourceFiles == null)\r\n            return [];\r\n        return sourceFiles.getArrayCopy();\r\n    };\r\n    DirectoryCache.prototype.addSourceFile = function (sourceFile) {\r\n        var dirPath = sourceFile.getDirectoryPath();\r\n        this.createOrAddIfExists(dirPath);\r\n        var sourceFiles = this.sourceFilesByDirPath.getOrCreate(dirPath, function () { return new utils_1.SortedKeyValueArray(function (item) { return item.getBaseName(); }, utils_1.LocaleStringComparer.instance); });\r\n        sourceFiles.set(sourceFile);\r\n    };\r\n    DirectoryCache.prototype.removeSourceFile = function (filePath) {\r\n        var dirPath = utils_1.FileUtils.getDirPath(filePath);\r\n        var sourceFiles = this.sourceFilesByDirPath.get(dirPath);\r\n        if (sourceFiles == null)\r\n            return;\r\n        sourceFiles.removeByKey(utils_1.FileUtils.getBaseName(filePath));\r\n        // clean up\r\n        if (!sourceFiles.hasItems())\r\n            this.sourceFilesByDirPath.removeByKey(dirPath);\r\n    };\r\n    DirectoryCache.prototype.createOrAddIfExists = function (dirPath) {\r\n        if (this.has(dirPath))\r\n            return this.get(dirPath);\r\n        this.fillParentsOfDirPath(dirPath);\r\n        return this.createDirectory(dirPath);\r\n    };\r\n    DirectoryCache.prototype.createDirectory = function (path) {\r\n        var newDirectory = new Directory_1.Directory(this.context, path);\r\n        this.addDirectory(newDirectory);\r\n        return newDirectory;\r\n    };\r\n    DirectoryCache.prototype.addDirectory = function (directory) {\r\n        var e_3, _a, e_4, _b;\r\n        var path = directory.getPath();\r\n        var parentDirPath = utils_1.FileUtils.getDirPath(path);\r\n        var isRootDir = parentDirPath === path;\r\n        try {\r\n            // remove any orphans that have a loaded parent\r\n            for (var _c = tslib_1.__values(this.orphanDirs.getValues()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var orphanDir = _d.value;\r\n                var orphanDirPath = orphanDir.getPath();\r\n                var orphanDirParentPath = utils_1.FileUtils.getDirPath(orphanDirPath);\r\n                var isOrphanRootDir = orphanDirParentPath === orphanDirPath;\r\n                if (!isOrphanRootDir && orphanDirParentPath === path)\r\n                    this.orphanDirs.removeByKey(orphanDirPath);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        if (!isRootDir)\r\n            this.addToDirectoriesByDirPath(directory);\r\n        if (!this.has(parentDirPath))\r\n            this.orphanDirs.set(path, directory);\r\n        this.directoriesByPath.set(path, directory);\r\n        if (!this.context.fileSystemWrapper.directoryExistsSync(path))\r\n            this.context.fileSystemWrapper.queueMkdir(path);\r\n        try {\r\n            for (var _e = tslib_1.__values(this.orphanDirs.getValues()), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                var orphanDir = _f.value;\r\n                if (directory.isAncestorOf(orphanDir))\r\n                    this.fillParentsOfDirPath(orphanDir.getPath());\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n    };\r\n    DirectoryCache.prototype.addToDirectoriesByDirPath = function (directory) {\r\n        if (utils_1.FileUtils.isRootDirPath(directory.getPath()))\r\n            return;\r\n        var parentDirPath = utils_1.FileUtils.getDirPath(directory.getPath());\r\n        var directories = this.directoriesByDirPath.getOrCreate(parentDirPath, function () { return new utils_1.SortedKeyValueArray(function (item) { return item.getBaseName(); }, utils_1.LocaleStringComparer.instance); });\r\n        directories.set(directory);\r\n    };\r\n    DirectoryCache.prototype.removeFromDirectoriesByDirPath = function (dirPath) {\r\n        if (utils_1.FileUtils.isRootDirPath(dirPath))\r\n            return;\r\n        var parentDirPath = utils_1.FileUtils.getDirPath(dirPath);\r\n        var directories = this.directoriesByDirPath.get(parentDirPath);\r\n        if (directories == null)\r\n            return;\r\n        directories.removeByKey(utils_1.FileUtils.getBaseName(dirPath));\r\n        // clean up\r\n        if (!directories.hasItems())\r\n            this.directoriesByDirPath.removeByKey(parentDirPath);\r\n    };\r\n    DirectoryCache.prototype.fillParentsOfDirPath = function (dirPath) {\r\n        var e_5, _a;\r\n        var passedDirPaths = [];\r\n        var dir = dirPath;\r\n        var parentDir = utils_1.FileUtils.getDirPath(dir);\r\n        while (dir !== parentDir) {\r\n            dir = parentDir;\r\n            parentDir = utils_1.FileUtils.getDirPath(dir);\r\n            if (this.directoriesByPath.has(dir)) {\r\n                try {\r\n                    for (var passedDirPaths_1 = tslib_1.__values(passedDirPaths), passedDirPaths_1_1 = passedDirPaths_1.next(); !passedDirPaths_1_1.done; passedDirPaths_1_1 = passedDirPaths_1.next()) {\r\n                        var currentDirPath = passedDirPaths_1_1.value;\r\n                        this.createDirectory(currentDirPath);\r\n                    }\r\n                }\r\n                catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (passedDirPaths_1_1 && !passedDirPaths_1_1.done && (_a = passedDirPaths_1.return)) _a.call(passedDirPaths_1);\r\n                    }\r\n                    finally { if (e_5) throw e_5.error; }\r\n                }\r\n                break;\r\n            }\r\n            passedDirPaths.unshift(dir);\r\n        }\r\n    };\r\n    return DirectoryCache;\r\n}());\r\nexports.DirectoryCache = DirectoryCache;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/DirectoryCache.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/DocumentRegistry.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/DocumentRegistry.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* barrel:ignore */\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar DocumentRegistry = /** @class */ (function () {\r\n    function DocumentRegistry(fileSystemWrapper) {\r\n        this.fileSystemWrapper = fileSystemWrapper;\r\n        this.sourceFileCacheByFilePath = new utils_1.KeyValueCache();\r\n    }\r\n    DocumentRegistry.prototype.removeSourceFile = function (fileName) {\r\n        this.sourceFileCacheByFilePath.removeByKey(fileName);\r\n    };\r\n    DocumentRegistry.prototype.createOrUpdateSourceFile = function (fileName, compilationSettings, scriptSnapshot) {\r\n        var sourceFile = this.sourceFileCacheByFilePath.get(fileName);\r\n        if (sourceFile == null)\r\n            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, DocumentRegistry.initialVersion);\r\n        else\r\n            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, this.getNextSourceFileVersion(sourceFile));\r\n        return sourceFile;\r\n    };\r\n    DocumentRegistry.prototype.acquireDocument = function (fileName, compilationSettings, scriptSnapshot, version, scriptKind) {\r\n        var sourceFile = this.sourceFileCacheByFilePath.get(fileName);\r\n        if (sourceFile == null || this.getSourceFileVersion(sourceFile) !== version)\r\n            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, version);\r\n        return sourceFile;\r\n    };\r\n    DocumentRegistry.prototype.acquireDocumentWithKey = function (fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {\r\n        // ignore the key because we only ever keep track of one key\r\n        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);\r\n    };\r\n    DocumentRegistry.prototype.updateDocument = function (fileName, compilationSettings, scriptSnapshot, version, scriptKind) {\r\n        // the compiler will call this even when it doesn't need to update for some reason\r\n        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);\r\n    };\r\n    DocumentRegistry.prototype.updateDocumentWithKey = function (fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {\r\n        // ignore the key because we only ever keep track of one key\r\n        return this.updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);\r\n    };\r\n    DocumentRegistry.prototype.getKeyForCompilationSettings = function (settings) {\r\n        return \"defaultKey\";\r\n    };\r\n    DocumentRegistry.prototype.releaseDocument = function (fileName, compilationSettings) {\r\n        // ignore, handled by removeSourceFile\r\n    };\r\n    DocumentRegistry.prototype.releaseDocumentWithKey = function (path, key) {\r\n        // ignore, handled by removeSourceFile\r\n    };\r\n    DocumentRegistry.prototype.reportStats = function () {\r\n        throw new errors.NotImplementedError();\r\n    };\r\n    DocumentRegistry.prototype.getSourceFileVersion = function (sourceFile) {\r\n        return sourceFile.version || \"0\";\r\n    };\r\n    DocumentRegistry.prototype.getNextSourceFileVersion = function (sourceFile) {\r\n        var currentVersion = parseInt(this.getSourceFileVersion(sourceFile), 10) || 0;\r\n        return (currentVersion + 1).toString();\r\n    };\r\n    DocumentRegistry.prototype.updateSourceFile = function (fileName, compilationSettings, scriptSnapshot, version) {\r\n        fileName = this.fileSystemWrapper.getStandardizedAbsolutePath(fileName);\r\n        var newSourceFile = this.createCompilerSourceFile(fileName, scriptSnapshot, compilationSettings, version);\r\n        this.sourceFileCacheByFilePath.set(fileName, newSourceFile);\r\n        return newSourceFile;\r\n    };\r\n    DocumentRegistry.prototype.createCompilerSourceFile = function (fileName, scriptSnapshot, compilationSettings, version) {\r\n        var scriptTarget = compilationSettings.target || typescript_1.ScriptTarget.Latest;\r\n        return typescript_1.ts.createLanguageServiceSourceFile(fileName, scriptSnapshot, scriptTarget, version, true, /* scriptKind */ undefined);\r\n    };\r\n    DocumentRegistry.initialVersion = \"0\";\r\n    return DocumentRegistry;\r\n}());\r\nexports.DocumentRegistry = DocumentRegistry;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/DocumentRegistry.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/ForgetfulNodeCache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/ForgetfulNodeCache.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Extension of KeyValueCache that allows for \"forget points.\"\r\n */\r\nvar ForgetfulNodeCache = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ForgetfulNodeCache, _super);\r\n    function ForgetfulNodeCache() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.forgetStack = [];\r\n        return _this;\r\n    }\r\n    ForgetfulNodeCache.prototype.getOrCreate = function (key, createFunc) {\r\n        var _this = this;\r\n        return _super.prototype.getOrCreate.call(this, key, function () {\r\n            var node = createFunc();\r\n            if (_this.forgetStack.length > 0)\r\n                _this.forgetStack[_this.forgetStack.length - 1].add(node);\r\n            return node;\r\n        });\r\n    };\r\n    ForgetfulNodeCache.prototype.setForgetPoint = function () {\r\n        this.forgetStack.push(utils_1.createHashSet());\r\n    };\r\n    ForgetfulNodeCache.prototype.forgetLastPoint = function () {\r\n        var nodes = this.forgetStack.pop();\r\n        if (nodes != null)\r\n            this.forgetNodes(nodes.values());\r\n    };\r\n    ForgetfulNodeCache.prototype.rememberNode = function (node) {\r\n        var e_1, _a;\r\n        if (node.wasForgotten())\r\n            throw new errors.InvalidOperationError(\"Cannot remember a node that was removed or forgotten.\");\r\n        var wasInForgetStack = false;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.forgetStack), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var stackItem = _c.value;\r\n                if (stackItem.delete(node)) {\r\n                    wasInForgetStack = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        if (wasInForgetStack)\r\n            this.rememberParentOfNode(node);\r\n        return wasInForgetStack;\r\n    };\r\n    ForgetfulNodeCache.prototype.rememberParentOfNode = function (node) {\r\n        var parent = node.getParentSyntaxList() || node.getParent();\r\n        if (parent != null)\r\n            this.rememberNode(parent);\r\n    };\r\n    ForgetfulNodeCache.prototype.forgetNodes = function (nodes) {\r\n        var e_2, _a;\r\n        try {\r\n            for (var nodes_1 = tslib_1.__values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\r\n                var node = nodes_1_1.value;\r\n                if (node.wasForgotten() || node.getKind() === typescript_1.SyntaxKind.SourceFile)\r\n                    continue;\r\n                node.forgetOnlyThis();\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    return ForgetfulNodeCache;\r\n}(utils_1.KeyValueCache));\r\nexports.ForgetfulNodeCache = ForgetfulNodeCache;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/ForgetfulNodeCache.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/StructurePrinterFactory.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/StructurePrinterFactory.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\n// DO NOT EDIT - Automatically maintained by createStructurePrinterFactory.ts\r\nvar structurePrinters = __webpack_require__(/*! ../structurePrinters */ \"./node_modules/ts-simple-ast/dist/structurePrinters/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Cached lazy factory for StructurePrinters.\r\n */\r\nvar StructurePrinterFactory = /** @class */ (function () {\r\n    function StructurePrinterFactory(_getFormatCodeSettings) {\r\n        this._getFormatCodeSettings = _getFormatCodeSettings;\r\n    }\r\n    StructurePrinterFactory.prototype.getFormatCodeSettings = function () {\r\n        return this._getFormatCodeSettings();\r\n    };\r\n    StructurePrinterFactory.prototype.forInitializerExpressionableNode = function () {\r\n        return new structurePrinters.InitializerExpressionableNodeStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forModifierableNode = function () {\r\n        return new structurePrinters.ModifierableNodeStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forReturnTypedNode = function (alwaysWrite) {\r\n        return new structurePrinters.ReturnTypedNodeStructurePrinter(this, alwaysWrite);\r\n    };\r\n    StructurePrinterFactory.prototype.forTypedNode = function (separator, alwaysWrite) {\r\n        return new structurePrinters.TypedNodeStructurePrinter(this, separator, alwaysWrite);\r\n    };\r\n    StructurePrinterFactory.prototype.forClassDeclaration = function (options) {\r\n        return new structurePrinters.ClassDeclarationStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forConstructorDeclaration = function (options) {\r\n        return new structurePrinters.ConstructorDeclarationStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forGetAccessorDeclaration = function (options) {\r\n        return new structurePrinters.GetAccessorDeclarationStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forMethodDeclaration = function (options) {\r\n        return new structurePrinters.MethodDeclarationStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forPropertyDeclaration = function () {\r\n        return new structurePrinters.PropertyDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forSetAccessorDeclaration = function (options) {\r\n        return new structurePrinters.SetAccessorDeclarationStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forPropertyAssignment = function () {\r\n        return new structurePrinters.PropertyAssignmentStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forShorthandPropertyAssignment = function () {\r\n        return new structurePrinters.ShorthandPropertyAssignmentStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forSpreadAssignment = function () {\r\n        return new structurePrinters.SpreadAssignmentStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forDecorator = function () {\r\n        return new structurePrinters.DecoratorStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forJSDoc = function () {\r\n        return new structurePrinters.JSDocStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forEnumDeclaration = function () {\r\n        return new structurePrinters.EnumDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forEnumMember = function () {\r\n        return new structurePrinters.EnumMemberStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forExportAssignment = function () {\r\n        return new structurePrinters.ExportAssignmentStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forExportDeclaration = function () {\r\n        return new structurePrinters.ExportDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forImportDeclaration = function () {\r\n        return new structurePrinters.ImportDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forNamedImportExportSpecifier = function () {\r\n        return new structurePrinters.NamedImportExportSpecifierStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forSourceFile = function (options) {\r\n        return new structurePrinters.SourceFileStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forFunctionDeclaration = function () {\r\n        return new structurePrinters.FunctionDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forParameterDeclaration = function () {\r\n        return new structurePrinters.ParameterDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forCallSignatureDeclaration = function () {\r\n        return new structurePrinters.CallSignatureDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forConstructSignatureDeclaration = function () {\r\n        return new structurePrinters.ConstructSignatureDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forIndexSignatureDeclaration = function () {\r\n        return new structurePrinters.IndexSignatureDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forInterfaceDeclaration = function () {\r\n        return new structurePrinters.InterfaceDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forMethodSignature = function () {\r\n        return new structurePrinters.MethodSignatureStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forPropertySignature = function () {\r\n        return new structurePrinters.PropertySignatureStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forTypeElementMemberedNode = function () {\r\n        return new structurePrinters.TypeElementMemberedNodeStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forJsxAttribute = function () {\r\n        return new structurePrinters.JsxAttributeStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forJsxElement = function () {\r\n        return new structurePrinters.JsxElementStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forNamespaceDeclaration = function (options) {\r\n        return new structurePrinters.NamespaceDeclarationStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forBodyText = function (options) {\r\n        return new structurePrinters.BodyTextStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forStatementedNode = function (options) {\r\n        return new structurePrinters.StatementedNodeStructurePrinter(this, options);\r\n    };\r\n    StructurePrinterFactory.prototype.forVariableStatement = function () {\r\n        return new structurePrinters.VariableStatementStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forVariableDeclaration = function () {\r\n        return new structurePrinters.VariableDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forTypeAliasDeclaration = function () {\r\n        return new structurePrinters.TypeAliasDeclarationStructurePrinter(this);\r\n    };\r\n    StructurePrinterFactory.prototype.forTypeParameterDeclaration = function () {\r\n        return new structurePrinters.TypeParameterDeclarationStructurePrinter(this);\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forInitializerExpressionableNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forModifierableNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forReturnTypedNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forTypedNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forClassDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forConstructorDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forGetAccessorDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forMethodDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forPropertyDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forSetAccessorDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forPropertyAssignment\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forShorthandPropertyAssignment\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forSpreadAssignment\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forDecorator\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forJSDoc\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forEnumDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forEnumMember\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forExportAssignment\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forExportDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forImportDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forNamedImportExportSpecifier\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forSourceFile\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forFunctionDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forParameterDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forCallSignatureDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forConstructSignatureDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forIndexSignatureDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forInterfaceDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forMethodSignature\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forPropertySignature\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forTypeElementMemberedNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forJsxAttribute\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forJsxElement\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forNamespaceDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forBodyText\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forStatementedNode\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forVariableStatement\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forVariableDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forTypeAliasDeclaration\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], StructurePrinterFactory.prototype, \"forTypeParameterDeclaration\", null);\r\n    return StructurePrinterFactory;\r\n}());\r\nexports.StructurePrinterFactory = StructurePrinterFactory;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/StructurePrinterFactory.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/index.js":
/*!************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CompilerFactory */ \"./node_modules/ts-simple-ast/dist/factories/CompilerFactory.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ForgetfulNodeCache */ \"./node_modules/ts-simple-ast/dist/factories/ForgetfulNodeCache.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./kindToWrapperMappings */ \"./node_modules/ts-simple-ast/dist/factories/kindToWrapperMappings.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StructurePrinterFactory */ \"./node_modules/ts-simple-ast/dist/factories/StructurePrinterFactory.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/factories/kindToWrapperMappings.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/factories/kindToWrapperMappings.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar _a;\r\nvar compiler = __webpack_require__(/*! ../compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\n// when changing this, make sure to run `npm run code-generate`.\r\n// that will automatically update all other parts of the application that need to be updated when this changes.\r\n// using an \"any\" type here because I couldn't figure out a way of getting the typescript compiler to understand this\r\nexports.kindToWrapperMappings = (_a = {},\r\n    _a[typescript_1.SyntaxKind.SourceFile] = compiler.SourceFile,\r\n    _a[typescript_1.SyntaxKind.ArrayBindingPattern] = compiler.ArrayBindingPattern,\r\n    _a[typescript_1.SyntaxKind.ArrayLiteralExpression] = compiler.ArrayLiteralExpression,\r\n    _a[typescript_1.SyntaxKind.ArrayType] = compiler.ArrayTypeNode,\r\n    _a[typescript_1.SyntaxKind.ArrowFunction] = compiler.ArrowFunction,\r\n    _a[typescript_1.SyntaxKind.AsExpression] = compiler.AsExpression,\r\n    _a[typescript_1.SyntaxKind.AwaitExpression] = compiler.AwaitExpression,\r\n    _a[typescript_1.SyntaxKind.BindingElement] = compiler.BindingElement,\r\n    _a[typescript_1.SyntaxKind.BinaryExpression] = compiler.BinaryExpression,\r\n    _a[typescript_1.SyntaxKind.Block] = compiler.Block,\r\n    _a[typescript_1.SyntaxKind.BreakStatement] = compiler.BreakStatement,\r\n    _a[typescript_1.SyntaxKind.CallExpression] = compiler.CallExpression,\r\n    _a[typescript_1.SyntaxKind.CallSignature] = compiler.CallSignatureDeclaration,\r\n    _a[typescript_1.SyntaxKind.CaseBlock] = compiler.CaseBlock,\r\n    _a[typescript_1.SyntaxKind.CaseClause] = compiler.CaseClause,\r\n    _a[typescript_1.SyntaxKind.CatchClause] = compiler.CatchClause,\r\n    _a[typescript_1.SyntaxKind.ClassDeclaration] = compiler.ClassDeclaration,\r\n    _a[typescript_1.SyntaxKind.Constructor] = compiler.ConstructorDeclaration,\r\n    _a[typescript_1.SyntaxKind.ConstructorType] = compiler.ConstructorTypeNode,\r\n    _a[typescript_1.SyntaxKind.ConstructSignature] = compiler.ConstructSignatureDeclaration,\r\n    _a[typescript_1.SyntaxKind.ContinueStatement] = compiler.ContinueStatement,\r\n    _a[typescript_1.SyntaxKind.CommaListExpression] = compiler.CommaListExpression,\r\n    _a[typescript_1.SyntaxKind.ComputedPropertyName] = compiler.ComputedPropertyName,\r\n    _a[typescript_1.SyntaxKind.ConditionalExpression] = compiler.ConditionalExpression,\r\n    _a[typescript_1.SyntaxKind.DebuggerStatement] = compiler.DebuggerStatement,\r\n    _a[typescript_1.SyntaxKind.Decorator] = compiler.Decorator,\r\n    _a[typescript_1.SyntaxKind.DefaultClause] = compiler.DefaultClause,\r\n    _a[typescript_1.SyntaxKind.DeleteExpression] = compiler.DeleteExpression,\r\n    _a[typescript_1.SyntaxKind.DoStatement] = compiler.DoStatement,\r\n    _a[typescript_1.SyntaxKind.ElementAccessExpression] = compiler.ElementAccessExpression,\r\n    _a[typescript_1.SyntaxKind.EmptyStatement] = compiler.EmptyStatement,\r\n    _a[typescript_1.SyntaxKind.EnumDeclaration] = compiler.EnumDeclaration,\r\n    _a[typescript_1.SyntaxKind.EnumMember] = compiler.EnumMember,\r\n    _a[typescript_1.SyntaxKind.ExportAssignment] = compiler.ExportAssignment,\r\n    _a[typescript_1.SyntaxKind.ExportDeclaration] = compiler.ExportDeclaration,\r\n    _a[typescript_1.SyntaxKind.ExportSpecifier] = compiler.ExportSpecifier,\r\n    _a[typescript_1.SyntaxKind.ExpressionWithTypeArguments] = compiler.ExpressionWithTypeArguments,\r\n    _a[typescript_1.SyntaxKind.ExpressionStatement] = compiler.ExpressionStatement,\r\n    _a[typescript_1.SyntaxKind.ExternalModuleReference] = compiler.ExternalModuleReference,\r\n    _a[typescript_1.SyntaxKind.QualifiedName] = compiler.QualifiedName,\r\n    _a[typescript_1.SyntaxKind.ForInStatement] = compiler.ForInStatement,\r\n    _a[typescript_1.SyntaxKind.ForOfStatement] = compiler.ForOfStatement,\r\n    _a[typescript_1.SyntaxKind.ForStatement] = compiler.ForStatement,\r\n    _a[typescript_1.SyntaxKind.FunctionDeclaration] = compiler.FunctionDeclaration,\r\n    _a[typescript_1.SyntaxKind.FunctionExpression] = compiler.FunctionExpression,\r\n    _a[typescript_1.SyntaxKind.FunctionType] = compiler.FunctionTypeNode,\r\n    _a[typescript_1.SyntaxKind.GetAccessor] = compiler.GetAccessorDeclaration,\r\n    _a[typescript_1.SyntaxKind.HeritageClause] = compiler.HeritageClause,\r\n    _a[typescript_1.SyntaxKind.Identifier] = compiler.Identifier,\r\n    _a[typescript_1.SyntaxKind.IfStatement] = compiler.IfStatement,\r\n    _a[typescript_1.SyntaxKind.ImportDeclaration] = compiler.ImportDeclaration,\r\n    _a[typescript_1.SyntaxKind.ImportEqualsDeclaration] = compiler.ImportEqualsDeclaration,\r\n    _a[typescript_1.SyntaxKind.ImportSpecifier] = compiler.ImportSpecifier,\r\n    _a[typescript_1.SyntaxKind.ImportType] = compiler.ImportTypeNode,\r\n    _a[typescript_1.SyntaxKind.IndexSignature] = compiler.IndexSignatureDeclaration,\r\n    _a[typescript_1.SyntaxKind.InterfaceDeclaration] = compiler.InterfaceDeclaration,\r\n    _a[typescript_1.SyntaxKind.IntersectionType] = compiler.IntersectionTypeNode,\r\n    _a[typescript_1.SyntaxKind.JSDocTag] = compiler.JSDocUnknownTag,\r\n    _a[typescript_1.SyntaxKind.JSDocAugmentsTag] = compiler.JSDocAugmentsTag,\r\n    _a[typescript_1.SyntaxKind.JSDocClassTag] = compiler.JSDocClassTag,\r\n    _a[typescript_1.SyntaxKind.JSDocReturnTag] = compiler.JSDocReturnTag,\r\n    _a[typescript_1.SyntaxKind.JSDocTypeTag] = compiler.JSDocTypeTag,\r\n    _a[typescript_1.SyntaxKind.JSDocTypedefTag] = compiler.JSDocTypedefTag,\r\n    _a[typescript_1.SyntaxKind.JSDocParameterTag] = compiler.JSDocParameterTag,\r\n    _a[typescript_1.SyntaxKind.JSDocPropertyTag] = compiler.JSDocPropertyTag,\r\n    _a[typescript_1.SyntaxKind.JsxAttribute] = compiler.JsxAttribute,\r\n    _a[typescript_1.SyntaxKind.JsxClosingElement] = compiler.JsxClosingElement,\r\n    _a[typescript_1.SyntaxKind.JsxClosingFragment] = compiler.JsxClosingFragment,\r\n    _a[typescript_1.SyntaxKind.JsxElement] = compiler.JsxElement,\r\n    _a[typescript_1.SyntaxKind.JsxExpression] = compiler.JsxExpression,\r\n    _a[typescript_1.SyntaxKind.JsxFragment] = compiler.JsxFragment,\r\n    _a[typescript_1.SyntaxKind.JsxOpeningElement] = compiler.JsxOpeningElement,\r\n    _a[typescript_1.SyntaxKind.JsxOpeningFragment] = compiler.JsxOpeningFragment,\r\n    _a[typescript_1.SyntaxKind.JsxSelfClosingElement] = compiler.JsxSelfClosingElement,\r\n    _a[typescript_1.SyntaxKind.JsxSpreadAttribute] = compiler.JsxSpreadAttribute,\r\n    _a[typescript_1.SyntaxKind.JsxText] = compiler.JsxText,\r\n    _a[typescript_1.SyntaxKind.LabeledStatement] = compiler.LabeledStatement,\r\n    _a[typescript_1.SyntaxKind.LiteralType] = compiler.LiteralTypeNode,\r\n    _a[typescript_1.SyntaxKind.MetaProperty] = compiler.MetaProperty,\r\n    _a[typescript_1.SyntaxKind.MethodDeclaration] = compiler.MethodDeclaration,\r\n    _a[typescript_1.SyntaxKind.MethodSignature] = compiler.MethodSignature,\r\n    _a[typescript_1.SyntaxKind.ModuleDeclaration] = compiler.NamespaceDeclaration,\r\n    _a[typescript_1.SyntaxKind.NewExpression] = compiler.NewExpression,\r\n    _a[typescript_1.SyntaxKind.NonNullExpression] = compiler.NonNullExpression,\r\n    _a[typescript_1.SyntaxKind.NotEmittedStatement] = compiler.NotEmittedStatement,\r\n    _a[typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral] = compiler.NoSubstitutionTemplateLiteral,\r\n    _a[typescript_1.SyntaxKind.NumericLiteral] = compiler.NumericLiteral,\r\n    _a[typescript_1.SyntaxKind.ObjectBindingPattern] = compiler.ObjectBindingPattern,\r\n    _a[typescript_1.SyntaxKind.ObjectLiteralExpression] = compiler.ObjectLiteralExpression,\r\n    _a[typescript_1.SyntaxKind.OmittedExpression] = compiler.OmittedExpression,\r\n    _a[typescript_1.SyntaxKind.Parameter] = compiler.ParameterDeclaration,\r\n    _a[typescript_1.SyntaxKind.ParenthesizedExpression] = compiler.ParenthesizedExpression,\r\n    _a[typescript_1.SyntaxKind.ParenthesizedType] = compiler.ParenthesizedTypeNode,\r\n    _a[typescript_1.SyntaxKind.PartiallyEmittedExpression] = compiler.PartiallyEmittedExpression,\r\n    _a[typescript_1.SyntaxKind.PostfixUnaryExpression] = compiler.PostfixUnaryExpression,\r\n    _a[typescript_1.SyntaxKind.PrefixUnaryExpression] = compiler.PrefixUnaryExpression,\r\n    _a[typescript_1.SyntaxKind.PropertyAccessExpression] = compiler.PropertyAccessExpression,\r\n    _a[typescript_1.SyntaxKind.PropertyAssignment] = compiler.PropertyAssignment,\r\n    _a[typescript_1.SyntaxKind.PropertyDeclaration] = compiler.PropertyDeclaration,\r\n    _a[typescript_1.SyntaxKind.PropertySignature] = compiler.PropertySignature,\r\n    _a[typescript_1.SyntaxKind.RegularExpressionLiteral] = compiler.RegularExpressionLiteral,\r\n    _a[typescript_1.SyntaxKind.ReturnStatement] = compiler.ReturnStatement,\r\n    _a[typescript_1.SyntaxKind.SetAccessor] = compiler.SetAccessorDeclaration,\r\n    _a[typescript_1.SyntaxKind.ShorthandPropertyAssignment] = compiler.ShorthandPropertyAssignment,\r\n    _a[typescript_1.SyntaxKind.SpreadAssignment] = compiler.SpreadAssignment,\r\n    _a[typescript_1.SyntaxKind.SpreadElement] = compiler.SpreadElement,\r\n    _a[typescript_1.SyntaxKind.StringLiteral] = compiler.StringLiteral,\r\n    _a[typescript_1.SyntaxKind.SwitchStatement] = compiler.SwitchStatement,\r\n    _a[typescript_1.SyntaxKind.SyntaxList] = compiler.SyntaxList,\r\n    _a[typescript_1.SyntaxKind.TaggedTemplateExpression] = compiler.TaggedTemplateExpression,\r\n    _a[typescript_1.SyntaxKind.TemplateExpression] = compiler.TemplateExpression,\r\n    _a[typescript_1.SyntaxKind.TemplateHead] = compiler.TemplateHead,\r\n    _a[typescript_1.SyntaxKind.TemplateMiddle] = compiler.TemplateMiddle,\r\n    _a[typescript_1.SyntaxKind.TemplateSpan] = compiler.TemplateSpan,\r\n    _a[typescript_1.SyntaxKind.TemplateTail] = compiler.TemplateTail,\r\n    _a[typescript_1.SyntaxKind.ThrowStatement] = compiler.ThrowStatement,\r\n    _a[typescript_1.SyntaxKind.TryStatement] = compiler.TryStatement,\r\n    _a[typescript_1.SyntaxKind.TupleType] = compiler.TupleTypeNode,\r\n    _a[typescript_1.SyntaxKind.TypeAliasDeclaration] = compiler.TypeAliasDeclaration,\r\n    _a[typescript_1.SyntaxKind.TypeAssertionExpression] = compiler.TypeAssertion,\r\n    _a[typescript_1.SyntaxKind.TypeLiteral] = compiler.TypeLiteralNode,\r\n    _a[typescript_1.SyntaxKind.TypeParameter] = compiler.TypeParameterDeclaration,\r\n    _a[typescript_1.SyntaxKind.TypeReference] = compiler.TypeReferenceNode,\r\n    _a[typescript_1.SyntaxKind.UnionType] = compiler.UnionTypeNode,\r\n    _a[typescript_1.SyntaxKind.VariableDeclaration] = compiler.VariableDeclaration,\r\n    _a[typescript_1.SyntaxKind.VariableDeclarationList] = compiler.VariableDeclarationList,\r\n    _a[typescript_1.SyntaxKind.VariableStatement] = compiler.VariableStatement,\r\n    _a[typescript_1.SyntaxKind.JSDocComment] = compiler.JSDoc,\r\n    _a[typescript_1.SyntaxKind.TypePredicate] = compiler.TypeNode,\r\n    _a[typescript_1.SyntaxKind.SemicolonToken] = compiler.Node,\r\n    _a[typescript_1.SyntaxKind.TypeOfExpression] = compiler.TypeOfExpression,\r\n    _a[typescript_1.SyntaxKind.WhileStatement] = compiler.WhileStatement,\r\n    _a[typescript_1.SyntaxKind.WithStatement] = compiler.WithStatement,\r\n    _a[typescript_1.SyntaxKind.YieldExpression] = compiler.YieldExpression,\r\n    // keywords\r\n    _a[typescript_1.SyntaxKind.AnyKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.BooleanKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.FalseKeyword] = compiler.BooleanLiteral,\r\n    _a[typescript_1.SyntaxKind.ImportKeyword] = compiler.ImportExpression,\r\n    _a[typescript_1.SyntaxKind.NeverKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.NullKeyword] = compiler.NullLiteral,\r\n    _a[typescript_1.SyntaxKind.NumberKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.ObjectKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.StringKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.SymbolKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.SuperKeyword] = compiler.SuperExpression,\r\n    _a[typescript_1.SyntaxKind.ThisKeyword] = compiler.ThisExpression,\r\n    _a[typescript_1.SyntaxKind.TrueKeyword] = compiler.BooleanLiteral,\r\n    _a[typescript_1.SyntaxKind.UndefinedKeyword] = compiler.Expression,\r\n    _a[typescript_1.SyntaxKind.VoidKeyword] = compiler.VoidExpression,\r\n    _a);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/factories/kindToWrapperMappings.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/DefaultFileSystemHost.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/DefaultFileSystemHost.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar nodePath = __webpack_require__(/*! path */ \"path\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar DefaultFileSystemHost = /** @class */ (function () {\r\n    function DefaultFileSystemHost() {\r\n        // Prevent \"fs-extra\" and \"globby\" from being loaded in environments that don't support it (ex. browsers).\r\n        // This means if someone specifies to use a virtual file system then it won't load this.\r\n        this.fs = __webpack_require__(/*! fs-extra */ \"fs-extra\");\r\n        this.globby = __webpack_require__(/*! globby */ \"./node_modules/globby/index.js\");\r\n    }\r\n    DefaultFileSystemHost.prototype.delete = function (path) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.fs.unlink(path, function (err) {\r\n                if (err)\r\n                    reject(_this.getFileNotFoundErrorIfNecessary(err, path));\r\n                else\r\n                    resolve();\r\n            });\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.deleteSync = function (path) {\r\n        try {\r\n            this.fs.unlinkSync(path);\r\n        }\r\n        catch (err) {\r\n            throw this.getFileNotFoundErrorIfNecessary(err, path);\r\n        }\r\n    };\r\n    DefaultFileSystemHost.prototype.readDirSync = function (dirPath) {\r\n        try {\r\n            return this.fs.readdirSync(dirPath).map(function (name) { return utils_1.FileUtils.pathJoin(dirPath, name); });\r\n        }\r\n        catch (err) {\r\n            throw this.getDirectoryNotFoundErrorIfNecessary(err, dirPath);\r\n        }\r\n    };\r\n    DefaultFileSystemHost.prototype.readFile = function (filePath, encoding) {\r\n        var _this = this;\r\n        if (encoding === void 0) { encoding = \"utf-8\"; }\r\n        return new Promise(function (resolve, reject) {\r\n            _this.fs.readFile(filePath, encoding, function (err, data) {\r\n                if (err)\r\n                    reject(_this.getFileNotFoundErrorIfNecessary(err, filePath));\r\n                else\r\n                    resolve(data);\r\n            });\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.readFileSync = function (filePath, encoding) {\r\n        if (encoding === void 0) { encoding = \"utf-8\"; }\r\n        try {\r\n            return this.fs.readFileSync(filePath, encoding);\r\n        }\r\n        catch (err) {\r\n            throw this.getFileNotFoundErrorIfNecessary(err, filePath);\r\n        }\r\n    };\r\n    DefaultFileSystemHost.prototype.writeFile = function (filePath, fileText) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\r\n                            _this.fs.writeFile(filePath, fileText, function (err) {\r\n                                if (err)\r\n                                    reject(err);\r\n                                else\r\n                                    resolve();\r\n                            });\r\n                        })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.writeFileSync = function (filePath, fileText) {\r\n        this.fs.writeFileSync(filePath, fileText);\r\n    };\r\n    DefaultFileSystemHost.prototype.mkdir = function (dirPath) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.fs.mkdir(dirPath, function (err) {\r\n                if (err)\r\n                    reject(err);\r\n                else\r\n                    resolve();\r\n            });\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.mkdirSync = function (dirPath) {\r\n        this.fs.mkdirSync(dirPath);\r\n    };\r\n    DefaultFileSystemHost.prototype.move = function (srcPath, destPath) {\r\n        return this.fs.move(srcPath, destPath, { overwrite: true });\r\n    };\r\n    DefaultFileSystemHost.prototype.moveSync = function (srcPath, destPath) {\r\n        this.fs.moveSync(srcPath, destPath, { overwrite: true });\r\n    };\r\n    DefaultFileSystemHost.prototype.copy = function (srcPath, destPath) {\r\n        return this.fs.copy(srcPath, destPath, { overwrite: true });\r\n    };\r\n    DefaultFileSystemHost.prototype.copySync = function (srcPath, destPath) {\r\n        this.fs.copySync(srcPath, destPath, { overwrite: true });\r\n    };\r\n    DefaultFileSystemHost.prototype.fileExists = function (filePath) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.fs.stat(filePath, function (err, stat) {\r\n                if (err)\r\n                    resolve(false);\r\n                else\r\n                    resolve(stat.isFile());\r\n            });\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.fileExistsSync = function (filePath) {\r\n        try {\r\n            return this.fs.statSync(filePath).isFile();\r\n        }\r\n        catch (err) {\r\n            return false;\r\n        }\r\n    };\r\n    DefaultFileSystemHost.prototype.directoryExists = function (dirPath) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            _this.fs.stat(dirPath, function (err, stat) {\r\n                if (err)\r\n                    resolve(false);\r\n                else\r\n                    resolve(stat.isDirectory());\r\n            });\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.directoryExistsSync = function (dirPath) {\r\n        try {\r\n            return this.fs.statSync(dirPath).isDirectory();\r\n        }\r\n        catch (err) {\r\n            return false;\r\n        }\r\n    };\r\n    DefaultFileSystemHost.prototype.getCurrentDirectory = function () {\r\n        return utils_1.FileUtils.standardizeSlashes(nodePath.resolve());\r\n    };\r\n    DefaultFileSystemHost.prototype.glob = function (patterns) {\r\n        return this.globby.sync(patterns, {\r\n            cwd: this.getCurrentDirectory(),\r\n            absolute: true\r\n        });\r\n    };\r\n    DefaultFileSystemHost.prototype.getDirectoryNotFoundErrorIfNecessary = function (err, path) {\r\n        return utils_1.FileUtils.isNotExistsError(err) ? new errors.DirectoryNotFoundError(path) : err;\r\n    };\r\n    DefaultFileSystemHost.prototype.getFileNotFoundErrorIfNecessary = function (err, path) {\r\n        return utils_1.FileUtils.isNotExistsError(err) ? new errors.FileNotFoundError(path) : err;\r\n    };\r\n    return DefaultFileSystemHost;\r\n}());\r\nexports.DefaultFileSystemHost = DefaultFileSystemHost;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/DefaultFileSystemHost.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/Directory.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/Directory.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar compiler_1 = __webpack_require__(/*! ../compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar DirectoryEmitResult_1 = __webpack_require__(/*! ./DirectoryEmitResult */ \"./node_modules/ts-simple-ast/dist/fileSystem/DirectoryEmitResult.js\");\r\nvar Directory = /** @class */ (function () {\r\n    /** @internal */\r\n    function Directory(context, path) {\r\n        this._context = context;\r\n        this._setPathInternal(path);\r\n    }\r\n    /** @internal */\r\n    Directory.prototype._setPathInternal = function (path) {\r\n        this._path = path;\r\n        this._pathParts = path.split(\"/\").filter(function (p) { return p.length > 0; });\r\n    };\r\n    Object.defineProperty(Directory.prototype, \"context\", {\r\n        /** @internal */\r\n        get: function () {\r\n            this._throwIfDeletedOrRemoved();\r\n            return this._context;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Checks if this directory is an ancestor of the provided directory.\r\n     * @param possibleDescendant - Directory or source file that's a possible descendant.\r\n     */\r\n    Directory.prototype.isAncestorOf = function (possibleDescendant) {\r\n        return Directory.isAncestorOfDir(this, possibleDescendant);\r\n    };\r\n    /**\r\n     * Checks if this directory is a descendant of the provided directory.\r\n     * @param possibleAncestor - Directory or source file that's a possible ancestor.\r\n     */\r\n    Directory.prototype.isDescendantOf = function (possibleAncestor) {\r\n        return Directory.isAncestorOfDir(possibleAncestor, this);\r\n    };\r\n    /**\r\n     * Gets the directory depth.\r\n     * @internal\r\n     */\r\n    Directory.prototype.getDepth = function () {\r\n        return this._pathParts.length;\r\n    };\r\n    /**\r\n     * Gets the path to the directory.\r\n     */\r\n    Directory.prototype.getPath = function () {\r\n        this._throwIfDeletedOrRemoved();\r\n        return this._path;\r\n    };\r\n    /**\r\n     * Gets the directory path's base name.\r\n     */\r\n    Directory.prototype.getBaseName = function () {\r\n        return this._pathParts[this._pathParts.length - 1];\r\n    };\r\n    /**\r\n     * Gets the parent directory or throws if it doesn't exist or was never added to the AST.\r\n     */\r\n    Directory.prototype.getParentOrThrow = function () {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getParent(), function () { return \"Parent directory of \" + _this.getPath() + \" does not exist or was never added.\"; });\r\n    };\r\n    /**\r\n     * Gets the parent directory if it exists and was added to the AST.\r\n     */\r\n    Directory.prototype.getParent = function () {\r\n        if (utils_1.FileUtils.isRootDirPath(this.getPath()))\r\n            return undefined;\r\n        return this.addExistingDirectoryIfExists(utils_1.FileUtils.getDirPath(this.getPath()));\r\n    };\r\n    Directory.prototype.getDirectoryOrThrow = function (pathOrCondition) {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getDirectory(pathOrCondition), function () {\r\n            if (typeof pathOrCondition === \"string\")\r\n                return \"Could not find a directory at path '\" + _this.context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, _this.getPath()) + \"'.\";\r\n            return \"Could not find child directory that matched condition.\";\r\n        });\r\n    };\r\n    Directory.prototype.getDirectory = function (pathOrCondition) {\r\n        if (typeof pathOrCondition === \"string\") {\r\n            var path = this.context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());\r\n            return this.context.compilerFactory.getDirectoryFromCache(path);\r\n        }\r\n        return utils_1.ArrayUtils.find(this.getDirectories(), pathOrCondition);\r\n    };\r\n    Directory.prototype.getSourceFileOrThrow = function (pathOrCondition) {\r\n        var _this = this;\r\n        return errors.throwIfNullOrUndefined(this.getSourceFile(pathOrCondition), function () {\r\n            if (typeof pathOrCondition === \"string\")\r\n                return \"Could not find child source file at path '\" + _this.context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, _this.getPath()) + \"'.\";\r\n            return \"Could not find child source file that matched condition.\";\r\n        });\r\n    };\r\n    Directory.prototype.getSourceFile = function (pathOrCondition) {\r\n        if (typeof pathOrCondition === \"string\") {\r\n            var path = this.context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());\r\n            return this.context.compilerFactory.getSourceFileFromCacheFromFilePath(path);\r\n        }\r\n        return utils_1.ArrayUtils.find(this.getSourceFiles(), pathOrCondition);\r\n    };\r\n    /**\r\n     * Gets the child directories.\r\n     */\r\n    Directory.prototype.getDirectories = function () {\r\n        return this.context.compilerFactory.getChildDirectoriesOfDirectory(this.getPath());\r\n    };\r\n    /**\r\n     * Gets the source files within this directory.\r\n     */\r\n    Directory.prototype.getSourceFiles = function () {\r\n        return this.context.compilerFactory.getChildSourceFilesOfDirectory(this.getPath());\r\n    };\r\n    /**\r\n     * Gets the source files in the current directory and all the descendant directories.\r\n     */\r\n    Directory.prototype.getDescendantSourceFiles = function () {\r\n        return utils_1.ArrayUtils.from(this.getDescendantSourceFilesIterator());\r\n    };\r\n    /**\r\n     * Gets the source files in the current directory and all the descendant directories.\r\n     * @internal\r\n     */\r\n    Directory.prototype.getDescendantSourceFilesIterator = function () {\r\n        var e_1, _a, e_2, _b, _c, _d, sourceFile, e_1_1, _e, _f, directory, e_2_1;\r\n        return tslib_1.__generator(this, function (_g) {\r\n            switch (_g.label) {\r\n                case 0:\r\n                    _g.trys.push([0, 5, 6, 7]);\r\n                    _c = tslib_1.__values(this.getSourceFiles()), _d = _c.next();\r\n                    _g.label = 1;\r\n                case 1:\r\n                    if (!!_d.done) return [3 /*break*/, 4];\r\n                    sourceFile = _d.value;\r\n                    return [4 /*yield*/, sourceFile];\r\n                case 2:\r\n                    _g.sent();\r\n                    _g.label = 3;\r\n                case 3:\r\n                    _d = _c.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_1_1 = _g.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7:\r\n                    _g.trys.push([7, 12, 13, 14]);\r\n                    _e = tslib_1.__values(this.getDirectories()), _f = _e.next();\r\n                    _g.label = 8;\r\n                case 8:\r\n                    if (!!_f.done) return [3 /*break*/, 11];\r\n                    directory = _f.value;\r\n                    return [5 /*yield**/, tslib_1.__values(directory.getDescendantSourceFilesIterator())];\r\n                case 9:\r\n                    _g.sent();\r\n                    _g.label = 10;\r\n                case 10:\r\n                    _f = _e.next();\r\n                    return [3 /*break*/, 8];\r\n                case 11: return [3 /*break*/, 14];\r\n                case 12:\r\n                    e_2_1 = _g.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 14];\r\n                case 13:\r\n                    try {\r\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 14: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Gets the descendant directories.\r\n     */\r\n    Directory.prototype.getDescendantDirectories = function () {\r\n        return utils_1.ArrayUtils.from(this.getDescendantDirectoriesIterator());\r\n    };\r\n    /**\r\n     * Gets the descendant directories.\r\n     * @internal\r\n     */\r\n    Directory.prototype.getDescendantDirectoriesIterator = function () {\r\n        var e_3, _a, _b, _c, directory, e_3_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 6, 7, 8]);\r\n                    _b = tslib_1.__values(this.getDirectories()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 5];\r\n                    directory = _c.value;\r\n                    return [4 /*yield*/, directory];\r\n                case 2:\r\n                    _d.sent();\r\n                    return [5 /*yield**/, tslib_1.__values(directory.getDescendantDirectoriesIterator())];\r\n                case 3:\r\n                    _d.sent();\r\n                    _d.label = 4;\r\n                case 4:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 5: return [3 /*break*/, 8];\r\n                case 6:\r\n                    e_3_1 = _d.sent();\r\n                    e_3 = { error: e_3_1 };\r\n                    return [3 /*break*/, 8];\r\n                case 7:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 8: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Add source files based on file globs.\r\n     * @param fileGlobs - File glob or globs to add files based on.\r\n     * @returns The matched source files.\r\n     */\r\n    Directory.prototype.addExistingSourceFiles = function (fileGlobs) {\r\n        var _this = this;\r\n        fileGlobs = typeof fileGlobs === \"string\" ? [fileGlobs] : fileGlobs;\r\n        fileGlobs = fileGlobs.map(function (g) {\r\n            if (utils_1.FileUtils.pathIsAbsolute(g))\r\n                return g;\r\n            return utils_1.FileUtils.pathJoin(_this.getPath(), g);\r\n        });\r\n        return this.context.directoryCoordinator.addExistingSourceFiles(fileGlobs);\r\n    };\r\n    /**\r\n     * Adds an existing directory to the AST from the relative path or directory name, or returns undefined if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Directory name or path to the directory that should be added.\r\n     * @param options - Options.\r\n     * @skipOrThrowCheck\r\n     */\r\n    Directory.prototype.addExistingDirectoryIfExists = function (dirPath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath, this.getPath());\r\n        return this.context.directoryCoordinator.addExistingDirectoryIfExists(dirPath, options);\r\n    };\r\n    /**\r\n     * Adds an existing directory to the AST from the relative path or directory name, or throws if it doesn't exist.\r\n     *\r\n     * Will return the directory if it was already added.\r\n     * @param dirPath - Directory name or path to the directory that should be added.\r\n     * @throws DirectoryNotFoundError if the directory does not exist.\r\n     */\r\n    Directory.prototype.addExistingDirectory = function (dirPath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath, this.getPath());\r\n        return this.context.directoryCoordinator.addExistingDirectory(dirPath, options);\r\n    };\r\n    /**\r\n     * Creates a directory if it doesn't exist.\r\n     * @param dirPath - Relative or absolute path to the directory that should be created.\r\n     */\r\n    Directory.prototype.createDirectory = function (dirPath) {\r\n        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath, this.getPath());\r\n        return this.context.directoryCoordinator.createDirectoryOrAddIfExists(dirPath);\r\n    };\r\n    Directory.prototype.createSourceFile = function (relativeFilePath, structureOrText, options) {\r\n        var filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());\r\n        return this.context.compilerFactory.createSourceFile(filePath, structureOrText || \"\", options || {});\r\n    };\r\n    /**\r\n     * Adds an existing source file to the AST, relative to this directory, or returns undefined.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param relativeFilePath - Relative file path to add.\r\n     * @skipOrThrowCheck\r\n     */\r\n    Directory.prototype.addExistingSourceFileIfExists = function (relativeFilePath) {\r\n        var filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());\r\n        return this.context.directoryCoordinator.addExistingSourceFileIfExists(filePath);\r\n    };\r\n    /**\r\n     * Adds an existing source file to the AST, relative to this directory, or throws if it doesn't exist.\r\n     *\r\n     * Will return the source file if it was already added.\r\n     * @param relativeFilePath - Relative file path to add.\r\n     * @throws FileNotFoundError when the file doesn't exist.\r\n     */\r\n    Directory.prototype.addExistingSourceFile = function (relativeFilePath) {\r\n        var filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());\r\n        return this.context.directoryCoordinator.addExistingSourceFile(filePath);\r\n    };\r\n    /**\r\n     * Emits the files in the directory.\r\n     * @param options - Options for emitting.\r\n     */\r\n    Directory.prototype.emit = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var e_4, _a, fileSystemWrapper, writeTasks, outputFilePaths, _b, _c, emitResult, e_4_1;\r\n            return tslib_1.__generator(this, function (_d) {\r\n                switch (_d.label) {\r\n                    case 0:\r\n                        fileSystemWrapper = this.context.fileSystemWrapper;\r\n                        writeTasks = [];\r\n                        outputFilePaths = [];\r\n                        _d.label = 1;\r\n                    case 1:\r\n                        _d.trys.push([1, 7, 8, 9]);\r\n                        _b = tslib_1.__values(this._emitInternal(options)), _c = _b.next();\r\n                        _d.label = 2;\r\n                    case 2:\r\n                        if (!!_c.done) return [3 /*break*/, 6];\r\n                        emitResult = _c.value;\r\n                        if (!(emitResult === false)) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, Promise.all(writeTasks)];\r\n                    case 3:\r\n                        _d.sent();\r\n                        return [2 /*return*/, new DirectoryEmitResult_1.DirectoryEmitResult(true, outputFilePaths)];\r\n                    case 4:\r\n                        writeTasks.push(fileSystemWrapper.writeFile(emitResult.filePath, emitResult.fileText));\r\n                        outputFilePaths.push(emitResult.filePath);\r\n                        _d.label = 5;\r\n                    case 5:\r\n                        _c = _b.next();\r\n                        return [3 /*break*/, 2];\r\n                    case 6: return [3 /*break*/, 9];\r\n                    case 7:\r\n                        e_4_1 = _d.sent();\r\n                        e_4 = { error: e_4_1 };\r\n                        return [3 /*break*/, 9];\r\n                    case 8:\r\n                        try {\r\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                        }\r\n                        finally { if (e_4) throw e_4.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 9: return [4 /*yield*/, Promise.all(writeTasks)];\r\n                    case 10:\r\n                        _d.sent();\r\n                        return [2 /*return*/, new DirectoryEmitResult_1.DirectoryEmitResult(false, outputFilePaths)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Emits the files in the directory synchronously.\r\n     *\r\n     * Remarks: This might be very slow compared to the asynchronous version if there are a lot of files.\r\n     * @param options - Options for emitting.\r\n     */\r\n    Directory.prototype.emitSync = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        var e_5, _a;\r\n        var fileSystemWrapper = this.context.fileSystemWrapper;\r\n        var outputFilePaths = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(this._emitInternal(options)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var emitResult = _c.value;\r\n                if (emitResult === false)\r\n                    return new DirectoryEmitResult_1.DirectoryEmitResult(true, outputFilePaths);\r\n                fileSystemWrapper.writeFileSync(emitResult.filePath, emitResult.fileText);\r\n                outputFilePaths.push(emitResult.filePath);\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n        return new DirectoryEmitResult_1.DirectoryEmitResult(false, outputFilePaths);\r\n    };\r\n    Directory.prototype._emitInternal = function (options) {\r\n        var _this = this;\r\n        if (options === void 0) { options = {}; }\r\n        var _a = options.emitOnlyDtsFiles, emitOnlyDtsFiles = _a === void 0 ? false : _a;\r\n        var isJsFile = options.outDir == null ? undefined : /\\.js$/i;\r\n        var isMapFile = options.outDir == null ? undefined : /\\.js\\.map$/i;\r\n        var isDtsFile = options.declarationDir == null && options.outDir == null ? undefined : /\\.d\\.ts$/i;\r\n        var getStandardizedPath = function (path) { return path == null ? undefined : _this.context.fileSystemWrapper.getStandardizedAbsolutePath(path, _this.getPath()); };\r\n        var getSubDirPath = function (path, dir) { return path == null ? undefined : utils_1.FileUtils.pathJoin(path, dir.getBaseName()); };\r\n        var hasDeclarationDir = this.context.compilerOptions.get().declarationDir != null || options.declarationDir != null;\r\n        return emitDirectory(this, getStandardizedPath(options.outDir), getStandardizedPath(options.declarationDir));\r\n        function emitDirectory(directory, outDir, declarationDir) {\r\n            var e_6, _a, e_7, _b, e_8, _c, _d, _e, sourceFile, output, _f, _g, outputFile, filePath, fileText, e_7_1, e_6_1, _h, _j, dir, e_8_1;\r\n            return tslib_1.__generator(this, function (_k) {\r\n                switch (_k.label) {\r\n                    case 0:\r\n                        _k.trys.push([0, 12, 13, 14]);\r\n                        _d = tslib_1.__values(directory.getSourceFiles()), _e = _d.next();\r\n                        _k.label = 1;\r\n                    case 1:\r\n                        if (!!_e.done) return [3 /*break*/, 11];\r\n                        sourceFile = _e.value;\r\n                        output = sourceFile.getEmitOutput({ emitOnlyDtsFiles: emitOnlyDtsFiles });\r\n                        if (!output.getEmitSkipped()) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, false];\r\n                    case 2:\r\n                        _k.sent();\r\n                        return [2 /*return*/];\r\n                    case 3:\r\n                        _k.trys.push([3, 8, 9, 10]);\r\n                        _f = tslib_1.__values(output.getOutputFiles()), _g = _f.next();\r\n                        _k.label = 4;\r\n                    case 4:\r\n                        if (!!_g.done) return [3 /*break*/, 7];\r\n                        outputFile = _g.value;\r\n                        filePath = outputFile.getFilePath();\r\n                        fileText = outputFile.getWriteByteOrderMark() ? utils_1.FileUtils.getTextWithByteOrderMark(outputFile.getText()) : outputFile.getText();\r\n                        if (outDir != null && (isJsFile.test(filePath) || isMapFile.test(filePath) || (!hasDeclarationDir && isDtsFile.test(filePath))))\r\n                            filePath = utils_1.FileUtils.pathJoin(outDir, utils_1.FileUtils.getBaseName(filePath));\r\n                        else if (declarationDir != null && isDtsFile.test(filePath))\r\n                            filePath = utils_1.FileUtils.pathJoin(declarationDir, utils_1.FileUtils.getBaseName(filePath));\r\n                        return [4 /*yield*/, { filePath: filePath, fileText: fileText }];\r\n                    case 5:\r\n                        _k.sent();\r\n                        _k.label = 6;\r\n                    case 6:\r\n                        _g = _f.next();\r\n                        return [3 /*break*/, 4];\r\n                    case 7: return [3 /*break*/, 10];\r\n                    case 8:\r\n                        e_7_1 = _k.sent();\r\n                        e_7 = { error: e_7_1 };\r\n                        return [3 /*break*/, 10];\r\n                    case 9:\r\n                        try {\r\n                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\r\n                        }\r\n                        finally { if (e_7) throw e_7.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 10:\r\n                        _e = _d.next();\r\n                        return [3 /*break*/, 1];\r\n                    case 11: return [3 /*break*/, 14];\r\n                    case 12:\r\n                        e_6_1 = _k.sent();\r\n                        e_6 = { error: e_6_1 };\r\n                        return [3 /*break*/, 14];\r\n                    case 13:\r\n                        try {\r\n                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\r\n                        }\r\n                        finally { if (e_6) throw e_6.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 14:\r\n                        _k.trys.push([14, 19, 20, 21]);\r\n                        _h = tslib_1.__values(directory.getDirectories()), _j = _h.next();\r\n                        _k.label = 15;\r\n                    case 15:\r\n                        if (!!_j.done) return [3 /*break*/, 18];\r\n                        dir = _j.value;\r\n                        return [5 /*yield**/, tslib_1.__values(emitDirectory(dir, getSubDirPath(outDir, dir), getSubDirPath(declarationDir, dir)))];\r\n                    case 16:\r\n                        _k.sent();\r\n                        _k.label = 17;\r\n                    case 17:\r\n                        _j = _h.next();\r\n                        return [3 /*break*/, 15];\r\n                    case 18: return [3 /*break*/, 21];\r\n                    case 19:\r\n                        e_8_1 = _k.sent();\r\n                        e_8 = { error: e_8_1 };\r\n                        return [3 /*break*/, 21];\r\n                    case 20:\r\n                        try {\r\n                            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\r\n                        }\r\n                        finally { if (e_8) throw e_8.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 21: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Copies a directory to a new directory.\r\n     * @param relativeOrAbsolutePath - The relative or absolute path to the new directory.\r\n     * @param options - Options.\r\n     * @returns The directory the copy was made to.\r\n     */\r\n    Directory.prototype.copy = function (relativeOrAbsolutePath, options) {\r\n        var originalPath = this.getPath();\r\n        var fileSystem = this.context.fileSystemWrapper;\r\n        var newPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(relativeOrAbsolutePath, this.getPath());\r\n        if (originalPath === newPath)\r\n            return this;\r\n        options = getDirectoryCopyOptions(options);\r\n        if (options.includeUntrackedFiles)\r\n            fileSystem.queueCopyDirectory(originalPath, newPath);\r\n        return this._copyInternal(newPath, options);\r\n    };\r\n    /**\r\n     * Immediately copies the directory to the specified path asynchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.\r\n     */\r\n    Directory.prototype.copyImmediately = function (relativeOrAbsolutePath, options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var fileSystem, originalPath, newPath, newDir;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        fileSystem = this.context.fileSystemWrapper;\r\n                        originalPath = this.getPath();\r\n                        newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);\r\n                        if (!(originalPath === newPath)) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.save()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this];\r\n                    case 2:\r\n                        options = getDirectoryCopyOptions(options);\r\n                        newDir = this._copyInternal(newPath, options);\r\n                        if (!options.includeUntrackedFiles) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, fileSystem.copyDirectoryImmediately(originalPath, newPath)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        _a.label = 4;\r\n                    case 4: return [4 /*yield*/, newDir.save()];\r\n                    case 5:\r\n                        _a.sent();\r\n                        return [2 /*return*/, newDir];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Immediately copies the directory to the specified path synchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     * @remarks If includeTrackedFiles is true, then it will execute the pending operations in the current directory.\r\n     */\r\n    Directory.prototype.copyImmediatelySync = function (relativeOrAbsolutePath, options) {\r\n        var fileSystem = this.context.fileSystemWrapper;\r\n        var originalPath = this.getPath();\r\n        var newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);\r\n        if (originalPath === newPath) {\r\n            this.saveSync();\r\n            return this;\r\n        }\r\n        options = getDirectoryCopyOptions(options);\r\n        var newDir = this._copyInternal(newPath, options);\r\n        if (options.includeUntrackedFiles)\r\n            fileSystem.copyDirectoryImmediatelySync(originalPath, newPath);\r\n        newDir.saveSync();\r\n        return newDir;\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._copyInternal = function (newPath, options) {\r\n        var _this = this;\r\n        var e_9, _a, e_10, _b, e_11, _c;\r\n        var originalPath = this.getPath();\r\n        if (originalPath === newPath)\r\n            return this;\r\n        var fileSystem = this.context.fileSystemWrapper;\r\n        var copyingDirectories = tslib_1.__spread([this], this.getDescendantDirectories()).map(function (directory) { return ({\r\n            directory: directory,\r\n            oldPath: directory.getPath(),\r\n            newDirPath: directory === _this ? newPath : fileSystem.getStandardizedAbsolutePath(_this.getRelativePathTo(directory), newPath)\r\n        }); });\r\n        var copyingSourceFiles = this.getDescendantSourceFiles().map(function (sourceFile) { return ({\r\n            sourceFile: sourceFile,\r\n            newFilePath: fileSystem.getStandardizedAbsolutePath(_this.getRelativePathTo(sourceFile), newPath),\r\n            references: _this._getReferencesForCopy(sourceFile)\r\n        }); });\r\n        try {\r\n            // copy directories\r\n            for (var copyingDirectories_1 = tslib_1.__values(copyingDirectories), copyingDirectories_1_1 = copyingDirectories_1.next(); !copyingDirectories_1_1.done; copyingDirectories_1_1 = copyingDirectories_1.next()) {\r\n                var _d = copyingDirectories_1_1.value, directory = _d.directory, oldPath = _d.oldPath, newDirPath = _d.newDirPath;\r\n                this.context.compilerFactory.createDirectoryOrAddIfExists(newDirPath);\r\n            }\r\n        }\r\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\r\n        finally {\r\n            try {\r\n                if (copyingDirectories_1_1 && !copyingDirectories_1_1.done && (_a = copyingDirectories_1.return)) _a.call(copyingDirectories_1);\r\n            }\r\n            finally { if (e_9) throw e_9.error; }\r\n        }\r\n        try {\r\n            // copy source files\r\n            for (var copyingSourceFiles_1 = tslib_1.__values(copyingSourceFiles), copyingSourceFiles_1_1 = copyingSourceFiles_1.next(); !copyingSourceFiles_1_1.done; copyingSourceFiles_1_1 = copyingSourceFiles_1.next()) {\r\n                var _e = copyingSourceFiles_1_1.value, sourceFile = _e.sourceFile, newFilePath = _e.newFilePath;\r\n                sourceFile._copyInternal(newFilePath, options);\r\n            }\r\n        }\r\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\r\n        finally {\r\n            try {\r\n                if (copyingSourceFiles_1_1 && !copyingSourceFiles_1_1.done && (_b = copyingSourceFiles_1.return)) _b.call(copyingSourceFiles_1);\r\n            }\r\n            finally { if (e_10) throw e_10.error; }\r\n        }\r\n        try {\r\n            // update the references\r\n            for (var copyingSourceFiles_2 = tslib_1.__values(copyingSourceFiles), copyingSourceFiles_2_1 = copyingSourceFiles_2.next(); !copyingSourceFiles_2_1.done; copyingSourceFiles_2_1 = copyingSourceFiles_2.next()) {\r\n                var _f = copyingSourceFiles_2_1.value, references = _f.references, newFilePath = _f.newFilePath;\r\n                this.getSourceFileOrThrow(newFilePath)._updateReferencesForCopyInternal(references);\r\n            }\r\n        }\r\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\r\n        finally {\r\n            try {\r\n                if (copyingSourceFiles_2_1 && !copyingSourceFiles_2_1.done && (_c = copyingSourceFiles_2.return)) _c.call(copyingSourceFiles_2);\r\n            }\r\n            finally { if (e_11) throw e_11.error; }\r\n        }\r\n        return this.context.compilerFactory.getDirectoryFromCache(newPath);\r\n    };\r\n    /**\r\n     * Moves the directory to a new path.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     */\r\n    Directory.prototype.move = function (relativeOrAbsolutePath, options) {\r\n        var fileSystem = this.context.fileSystemWrapper;\r\n        var originalPath = this.getPath();\r\n        var newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);\r\n        if (originalPath === newPath)\r\n            return this;\r\n        fileSystem.queueMoveDirectory(originalPath, newPath);\r\n        return this._moveInternal(newPath, options);\r\n    };\r\n    /**\r\n     * Immediately moves the directory to a new path asynchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     */\r\n    Directory.prototype.moveImmediately = function (relativeOrAbsolutePath, options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var fileSystem, originalPath, newPath;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        fileSystem = this.context.fileSystemWrapper;\r\n                        originalPath = this.getPath();\r\n                        newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);\r\n                        if (!(originalPath === newPath)) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.save()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this];\r\n                    case 2:\r\n                        this._moveInternal(newPath, options);\r\n                        return [4 /*yield*/, fileSystem.moveDirectoryImmediately(originalPath, newPath)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.save()];\r\n                    case 4:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Immediately moves the directory to a new path synchronously.\r\n     * @param relativeOrAbsolutePath - Directory path as an absolute or relative path.\r\n     * @param options - Options for moving the directory.\r\n     */\r\n    Directory.prototype.moveImmediatelySync = function (relativeOrAbsolutePath, options) {\r\n        var fileSystem = this.context.fileSystemWrapper;\r\n        var originalPath = this.getPath();\r\n        var newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);\r\n        if (originalPath === newPath) {\r\n            this.saveSync();\r\n            return this;\r\n        }\r\n        this._moveInternal(newPath, options);\r\n        fileSystem.moveDirectoryImmediatelySync(originalPath, newPath);\r\n        this.saveSync();\r\n        return this;\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._moveInternal = function (newPath, options) {\r\n        var _this = this;\r\n        var e_12, _a, e_13, _b, e_14, _c;\r\n        var originalPath = this.getPath();\r\n        if (originalPath === newPath)\r\n            return this;\r\n        var fileSystem = this.context.fileSystemWrapper;\r\n        var compilerFactory = this.context.compilerFactory;\r\n        var movingDirectories = tslib_1.__spread([this], this.getDescendantDirectories()).map(function (directory) { return ({\r\n            directory: directory,\r\n            oldPath: directory.getPath(),\r\n            newDirPath: directory === _this ? newPath : fileSystem.getStandardizedAbsolutePath(_this.getRelativePathTo(directory), newPath)\r\n        }); });\r\n        var movingSourceFiles = this.getDescendantSourceFiles().map(function (sourceFile) { return ({\r\n            sourceFile: sourceFile,\r\n            newFilePath: fileSystem.getStandardizedAbsolutePath(_this.getRelativePathTo(sourceFile), newPath),\r\n            references: _this._getReferencesForMove(sourceFile)\r\n        }); });\r\n        try {\r\n            // update directories\r\n            for (var movingDirectories_1 = tslib_1.__values(movingDirectories), movingDirectories_1_1 = movingDirectories_1.next(); !movingDirectories_1_1.done; movingDirectories_1_1 = movingDirectories_1.next()) {\r\n                var _d = movingDirectories_1_1.value, directory = _d.directory, oldPath = _d.oldPath, newDirPath = _d.newDirPath;\r\n                compilerFactory.removeDirectoryFromCache(oldPath);\r\n                var dirToOverwrite = compilerFactory.getDirectoryFromCache(newDirPath);\r\n                if (dirToOverwrite != null)\r\n                    dirToOverwrite._forgetOnlyThis();\r\n                directory._setPathInternal(newDirPath);\r\n                compilerFactory.addDirectoryToCache(directory);\r\n            }\r\n        }\r\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\r\n        finally {\r\n            try {\r\n                if (movingDirectories_1_1 && !movingDirectories_1_1.done && (_a = movingDirectories_1.return)) _a.call(movingDirectories_1);\r\n            }\r\n            finally { if (e_12) throw e_12.error; }\r\n        }\r\n        try {\r\n            // update source files\r\n            for (var movingSourceFiles_1 = tslib_1.__values(movingSourceFiles), movingSourceFiles_1_1 = movingSourceFiles_1.next(); !movingSourceFiles_1_1.done; movingSourceFiles_1_1 = movingSourceFiles_1.next()) {\r\n                var _e = movingSourceFiles_1_1.value, sourceFile = _e.sourceFile, newFilePath = _e.newFilePath;\r\n                sourceFile._moveInternal(newFilePath, options);\r\n            }\r\n        }\r\n        catch (e_13_1) { e_13 = { error: e_13_1 }; }\r\n        finally {\r\n            try {\r\n                if (movingSourceFiles_1_1 && !movingSourceFiles_1_1.done && (_b = movingSourceFiles_1.return)) _b.call(movingSourceFiles_1);\r\n            }\r\n            finally { if (e_13) throw e_13.error; }\r\n        }\r\n        try {\r\n            // update the references\r\n            for (var movingSourceFiles_2 = tslib_1.__values(movingSourceFiles), movingSourceFiles_2_1 = movingSourceFiles_2.next(); !movingSourceFiles_2_1.done; movingSourceFiles_2_1 = movingSourceFiles_2.next()) {\r\n                var _f = movingSourceFiles_2_1.value, sourceFile = _f.sourceFile, references = _f.references;\r\n                sourceFile._updateReferencesForMoveInternal(references, originalPath);\r\n            }\r\n        }\r\n        catch (e_14_1) { e_14 = { error: e_14_1 }; }\r\n        finally {\r\n            try {\r\n                if (movingSourceFiles_2_1 && !movingSourceFiles_2_1.done && (_c = movingSourceFiles_2.return)) _c.call(movingSourceFiles_2);\r\n            }\r\n            finally { if (e_14) throw e_14.error; }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Queues a deletion of the directory to the file system.\r\n     *\r\n     * The directory will be deleted when calling ast.save(). If you wish to delete the file immediately, then use deleteImmediately().\r\n     */\r\n    Directory.prototype.delete = function () {\r\n        var e_15, _a, e_16, _b;\r\n        var fileSystemWrapper = this.context.fileSystemWrapper;\r\n        var path = this.getPath();\r\n        try {\r\n            for (var _c = tslib_1.__values(this.getSourceFiles()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var sourceFile = _d.value;\r\n                sourceFile.delete();\r\n            }\r\n        }\r\n        catch (e_15_1) { e_15 = { error: e_15_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_15) throw e_15.error; }\r\n        }\r\n        try {\r\n            for (var _e = tslib_1.__values(this.getDirectories()), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                var dir = _f.value;\r\n                dir.delete();\r\n            }\r\n        }\r\n        catch (e_16_1) { e_16 = { error: e_16_1 }; }\r\n        finally {\r\n            try {\r\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n            }\r\n            finally { if (e_16) throw e_16.error; }\r\n        }\r\n        fileSystemWrapper.queueDirectoryDelete(path);\r\n        this.forget();\r\n    };\r\n    /**\r\n     * Asyncronously deletes the directory and all its descendants from the file system.\r\n     */\r\n    Directory.prototype.deleteImmediately = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var fileSystemWrapper, path;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        fileSystemWrapper = this.context.fileSystemWrapper;\r\n                        path = this.getPath();\r\n                        this.forget();\r\n                        return [4 /*yield*/, fileSystemWrapper.deleteDirectoryImmediately(path)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronously deletes the directory and all its descendants from the file system.\r\n     */\r\n    Directory.prototype.deleteImmediatelySync = function () {\r\n        var fileSystemWrapper = this.context.fileSystemWrapper;\r\n        var path = this.getPath();\r\n        this.forget();\r\n        fileSystemWrapper.deleteDirectoryImmediatelySync(path);\r\n    };\r\n    /**\r\n     * Forgets the directory and all its descendants from the Project.\r\n     *\r\n     * Note: Does not delete the directory from the file system.\r\n     */\r\n    Directory.prototype.forget = function () {\r\n        var e_17, _a, e_18, _b;\r\n        if (this.wasForgotten())\r\n            return;\r\n        try {\r\n            for (var _c = tslib_1.__values(this.getSourceFiles()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var sourceFile = _d.value;\r\n                sourceFile.forget();\r\n            }\r\n        }\r\n        catch (e_17_1) { e_17 = { error: e_17_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_17) throw e_17.error; }\r\n        }\r\n        try {\r\n            for (var _e = tslib_1.__values(this.getDirectories()), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                var dir = _f.value;\r\n                dir.forget();\r\n            }\r\n        }\r\n        catch (e_18_1) { e_18 = { error: e_18_1 }; }\r\n        finally {\r\n            try {\r\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n            }\r\n            finally { if (e_18) throw e_18.error; }\r\n        }\r\n        this._forgetOnlyThis();\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._forgetOnlyThis = function () {\r\n        if (this.wasForgotten())\r\n            return;\r\n        this.context.compilerFactory.removeDirectoryFromCache(this.getPath());\r\n        this._context = undefined;\r\n    };\r\n    /**\r\n     * Asynchronously saves the directory and all the unsaved source files to the disk.\r\n     */\r\n    Directory.prototype.save = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var unsavedSourceFiles;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.context.fileSystemWrapper.saveForDirectory(this.getPath())];\r\n                    case 1:\r\n                        _a.sent();\r\n                        unsavedSourceFiles = this.getDescendantSourceFiles().filter(function (s) { return !s.isSaved(); });\r\n                        return [4 /*yield*/, Promise.all(unsavedSourceFiles.map(function (s) { return s.save(); }))];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Synchronously saves the directory and all the unsaved source files to the disk.\r\n     */\r\n    Directory.prototype.saveSync = function () {\r\n        this.context.fileSystemWrapper.saveForDirectorySync(this.getPath());\r\n        var unsavedSourceFiles = this.getDescendantSourceFiles().filter(function (s) { return !s.isSaved(); });\r\n        unsavedSourceFiles.forEach(function (s) { return s.saveSync(); });\r\n    };\r\n    Directory.prototype.getRelativePathTo = function (sourceFileOrDir) {\r\n        return utils_1.FileUtils.getRelativePathTo(this.getPath(), getPath());\r\n        function getPath() {\r\n            return sourceFileOrDir instanceof compiler_1.SourceFile ? sourceFileOrDir.getFilePath() : sourceFileOrDir.getPath();\r\n        }\r\n    };\r\n    Directory.prototype.getRelativePathAsModuleSpecifierTo = function (sourceFileOrDir) {\r\n        var moduleResolution = this.context.program.getEmitModuleResolutionKind();\r\n        var thisDirectory = this;\r\n        var moduleSpecifier = utils_1.FileUtils.getRelativePathTo(this.getPath(), getPath()).replace(/((\\.d\\.ts$)|(\\.[^/.]+$))/i, \"\");\r\n        return utils_1.StringUtils.startsWith(moduleSpecifier, \"../\") ? moduleSpecifier : \"./\" + moduleSpecifier;\r\n        function getPath() {\r\n            return sourceFileOrDir instanceof compiler_1.SourceFile ? getPathForSourceFile(sourceFileOrDir) : getPathForDirectory(sourceFileOrDir);\r\n            function getPathForSourceFile(sourceFile) {\r\n                switch (moduleResolution) {\r\n                    case typescript_1.ModuleResolutionKind.NodeJs:\r\n                        var filePath = sourceFile.getFilePath();\r\n                        if (sourceFile.getDirectory() === thisDirectory)\r\n                            return filePath;\r\n                        return filePath.replace(/\\/index?(\\.d\\.ts|\\.ts|\\.js)$/i, \"\");\r\n                    case typescript_1.ModuleResolutionKind.Classic:\r\n                        return sourceFile.getFilePath();\r\n                    default:\r\n                        throw errors.getNotImplementedForNeverValueError(moduleResolution);\r\n                }\r\n            }\r\n            function getPathForDirectory(dir) {\r\n                switch (moduleResolution) {\r\n                    case typescript_1.ModuleResolutionKind.NodeJs:\r\n                        if (dir === thisDirectory)\r\n                            return utils_1.FileUtils.pathJoin(dir.getPath(), \"index.ts\");\r\n                        return dir.getPath();\r\n                    case typescript_1.ModuleResolutionKind.Classic:\r\n                        return utils_1.FileUtils.pathJoin(dir.getPath(), \"index.ts\");\r\n                    default:\r\n                        throw errors.getNotImplementedForNeverValueError(moduleResolution);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the directory was forgotten.\r\n     */\r\n    Directory.prototype.wasForgotten = function () {\r\n        return this._context == null;\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._hasLoadedParent = function () {\r\n        return this.context.compilerFactory.containsDirectoryAtPath(utils_1.FileUtils.getDirPath(this.getPath()));\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._throwIfDeletedOrRemoved = function () {\r\n        if (this.wasForgotten())\r\n            throw new errors.InvalidOperationError(\"Cannot use a directory that was deleted, removed, or overwritten.\");\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._getReferencesForCopy = function (sourceFile) {\r\n        var _this = this;\r\n        var literalReferences = sourceFile._getReferencesForCopyInternal();\r\n        return literalReferences.filter(function (r) { return !_this.isAncestorOf(r[1]); });\r\n    };\r\n    /** @internal */\r\n    Directory.prototype._getReferencesForMove = function (sourceFile) {\r\n        var _this = this;\r\n        var _a = sourceFile._getReferencesForMoveInternal(), literalReferences = _a.literalReferences, referencingLiterals = _a.referencingLiterals;\r\n        return {\r\n            literalReferences: literalReferences.filter(function (r) { return !_this.isAncestorOf(r[1]); }),\r\n            referencingLiterals: referencingLiterals.filter(function (l) { return !_this.isAncestorOf(l.sourceFile); })\r\n        };\r\n    };\r\n    /** @internal */\r\n    Directory.isAncestorOfDir = function (ancestor, descendant) {\r\n        if (descendant instanceof compiler_1.SourceFile) {\r\n            descendant = descendant.getDirectory();\r\n            if (ancestor === descendant)\r\n                return true;\r\n        }\r\n        if (ancestor._pathParts.length >= descendant._pathParts.length)\r\n            return false;\r\n        // more likely to be a mistake at the end, so search backwards\r\n        for (var i = ancestor._pathParts.length - 1; i >= 0; i--) {\r\n            if (ancestor._pathParts[i] !== descendant._pathParts[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    return Directory;\r\n}());\r\nexports.Directory = Directory;\r\nfunction getDirectoryCopyOptions(options) {\r\n    options = utils_1.ObjectUtils.clone(options || {});\r\n    utils_1.setValueIfUndefined(options, \"includeUntrackedFiles\", true);\r\n    return options;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/Directory.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/DirectoryCoordinator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/DirectoryCoordinator.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Contains common methods between Project and Directory.\r\n *\r\n * I'll definitely need to refactor this in the future... just putting these methods in a common place for now.\r\n */\r\nvar DirectoryCoordinator = /** @class */ (function () {\r\n    function DirectoryCoordinator(compilerFactory, fileSystemWrapper) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.fileSystemWrapper = fileSystemWrapper;\r\n    }\r\n    DirectoryCoordinator.prototype.addExistingDirectoryIfExists = function (dirPath, options) {\r\n        var e_1, _a;\r\n        var directory = this.compilerFactory.getDirectoryFromPath(dirPath);\r\n        if (directory == null)\r\n            return undefined;\r\n        if (options.recursive) {\r\n            try {\r\n                for (var _b = tslib_1.__values(utils_1.FileUtils.getDescendantDirectories(this.fileSystemWrapper, dirPath)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var descendantDirPath = _c.value;\r\n                    this.compilerFactory.createDirectoryOrAddIfExists(descendantDirPath);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n        return directory;\r\n    };\r\n    DirectoryCoordinator.prototype.addExistingDirectory = function (dirPath, options) {\r\n        var directory = this.addExistingDirectoryIfExists(dirPath, options);\r\n        if (directory == null)\r\n            throw new errors.DirectoryNotFoundError(dirPath);\r\n        return directory;\r\n    };\r\n    DirectoryCoordinator.prototype.createDirectoryOrAddIfExists = function (dirPath) {\r\n        return this.compilerFactory.createDirectoryOrAddIfExists(dirPath);\r\n    };\r\n    DirectoryCoordinator.prototype.addExistingSourceFileIfExists = function (filePath) {\r\n        return this.compilerFactory.addOrGetSourceFileFromFilePath(filePath);\r\n    };\r\n    DirectoryCoordinator.prototype.addExistingSourceFile = function (filePath) {\r\n        var sourceFile = this.addExistingSourceFileIfExists(filePath);\r\n        if (sourceFile == null)\r\n            throw new errors.FileNotFoundError(this.fileSystemWrapper.getStandardizedAbsolutePath(filePath));\r\n        return sourceFile;\r\n    };\r\n    DirectoryCoordinator.prototype.addExistingSourceFiles = function (fileGlobs) {\r\n        var e_2, _a, e_3, _b;\r\n        if (typeof fileGlobs === \"string\")\r\n            fileGlobs = [fileGlobs];\r\n        var sourceFiles = [];\r\n        var globbedDirectories = utils_1.FileUtils.getParentMostPaths(fileGlobs.filter(function (g) { return !utils_1.FileUtils.isNegatedGlob(g); }).map(function (g) { return utils_1.FileUtils.getGlobDir(g); }));\r\n        try {\r\n            for (var _c = tslib_1.__values(this.fileSystemWrapper.glob(fileGlobs)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var filePath = _d.value;\r\n                var sourceFile = this.addExistingSourceFileIfExists(filePath);\r\n                if (sourceFile != null)\r\n                    sourceFiles.push(sourceFile);\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        try {\r\n            for (var globbedDirectories_1 = tslib_1.__values(globbedDirectories), globbedDirectories_1_1 = globbedDirectories_1.next(); !globbedDirectories_1_1.done; globbedDirectories_1_1 = globbedDirectories_1.next()) {\r\n                var dirPath = globbedDirectories_1_1.value;\r\n                this.addExistingDirectoryIfExists(dirPath, { recursive: true });\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (globbedDirectories_1_1 && !globbedDirectories_1_1.done && (_b = globbedDirectories_1.return)) _b.call(globbedDirectories_1);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return sourceFiles;\r\n    };\r\n    return DirectoryCoordinator;\r\n}());\r\nexports.DirectoryCoordinator = DirectoryCoordinator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/DirectoryCoordinator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/DirectoryEmitResult.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/DirectoryEmitResult.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DirectoryEmitResult = /** @class */ (function () {\r\n    /** @internal */\r\n    function DirectoryEmitResult(_emitSkipped, _outputFilePaths) {\r\n        this._emitSkipped = _emitSkipped;\r\n        this._outputFilePaths = _outputFilePaths;\r\n    }\r\n    /**\r\n     * Gets if the emit was skipped.\r\n     */\r\n    DirectoryEmitResult.prototype.getEmitSkipped = function () {\r\n        return this._emitSkipped;\r\n    };\r\n    /**\r\n     * Gets the output file paths.\r\n     */\r\n    DirectoryEmitResult.prototype.getOutputFilePaths = function () {\r\n        return this._outputFilePaths;\r\n    };\r\n    return DirectoryEmitResult;\r\n}());\r\nexports.DirectoryEmitResult = DirectoryEmitResult;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/DirectoryEmitResult.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/FileSystemWrapper.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/FileSystemWrapper.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar Directory = /** @class */ (function () {\r\n    function Directory(path) {\r\n        this.path = path;\r\n        this.operations = [];\r\n        this.inboundOperations = [];\r\n        this.isDeleted = false;\r\n        this.wasEverDeleted = false;\r\n        this.childDirs = new utils_1.SortedKeyValueArray(function (item) { return item.path; }, utils_1.LocaleStringComparer.instance);\r\n    }\r\n    Directory.prototype.getExternalOperations = function () {\r\n        var _this = this;\r\n        return tslib_1.__spread(utils_1.ArrayUtils.flatten(this.getAncestors().map(function (a) { return getMoveCopyOrDeleteOperations(a); })).filter(function (o) { return isAncestorAffectedOperation(_this, o); }), utils_1.ArrayUtils.flatten(tslib_1.__spread([this], this.getDescendants()).map(function (d) { return getMoveOrCopyOperations(d); })).filter(function (o) { return !isInternalOperation(_this, o); }));\r\n        function isInternalOperation(thisDir, operation) {\r\n            return operation.oldDir.isDescendantOrEqual(thisDir) && operation.newDir.isDescendantOrEqual(thisDir);\r\n        }\r\n        function isAncestorAffectedOperation(thisDir, operation) {\r\n            switch (operation.kind) {\r\n                case \"move\":\r\n                case \"copy\":\r\n                    return thisDir.isDescendantOrEqual(operation.oldDir) || thisDir.isDescendantOrEqual(operation.newDir);\r\n                case \"deleteDir\":\r\n                    return thisDir.isDescendantOrEqual(operation.dir);\r\n                default:\r\n                    throw errors.getNotImplementedForNeverValueError(operation);\r\n            }\r\n        }\r\n        function getMoveOrCopyOperations(dir) {\r\n            return dir.operations.filter(function (o) { return o.kind === \"move\" || o.kind === \"copy\"; });\r\n        }\r\n        function getMoveCopyOrDeleteOperations(dir) {\r\n            return dir.operations.filter(function (o) { return o.kind === \"move\" || o.kind === \"deleteDir\" || o.kind === \"copy\"; });\r\n        }\r\n    };\r\n    Directory.prototype.isDescendantOrEqual = function (directory) {\r\n        return this.isDescendant(directory) || this === directory;\r\n    };\r\n    Directory.prototype.isDescendant = function (directory) {\r\n        return utils_1.FileUtils.pathStartsWith(this.path, directory.path);\r\n    };\r\n    Directory.prototype.getIsDeleted = function () {\r\n        return this.isDeleted;\r\n    };\r\n    Directory.prototype.getWasEverDeleted = function () {\r\n        var e_1, _a;\r\n        if (this.wasEverDeleted)\r\n            return true;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getAncestorsIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var ancestor = _c.value;\r\n                if (ancestor.wasEverDeleted)\r\n                    return true;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return false;\r\n    };\r\n    Directory.prototype.setIsDeleted = function (isDeleted) {\r\n        var e_2, _a;\r\n        if (this.isDeleted === isDeleted)\r\n            return;\r\n        if (isDeleted) {\r\n            this.wasEverDeleted = true;\r\n            try {\r\n                for (var _b = tslib_1.__values(this.childDirs.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var child = _c.value;\r\n                    child.setIsDeleted(true);\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        }\r\n        else {\r\n            if (this.parent != null)\r\n                this.parent.setIsDeleted(false);\r\n        }\r\n        this.isDeleted = isDeleted;\r\n    };\r\n    Directory.prototype.getParent = function () {\r\n        return this.parent;\r\n    };\r\n    Directory.prototype.setParent = function (parent) {\r\n        if (this.parent != null)\r\n            throw new errors.InvalidOperationError(\"For some reason, a parent was being set when the directory already had a parent. Please open an issue.\");\r\n        this.parent = parent;\r\n        parent.childDirs.set(this);\r\n        if (parent.isDeleted && !this.isDeleted)\r\n            parent.setIsDeleted(false);\r\n    };\r\n    Directory.prototype.removeParent = function () {\r\n        var parent = this.parent;\r\n        if (parent == null)\r\n            return;\r\n        parent.childDirs.removeByValue(this);\r\n        this.parent = undefined;\r\n    };\r\n    Directory.prototype.getAncestors = function () {\r\n        return utils_1.ArrayUtils.from(this.getAncestorsIterator());\r\n    };\r\n    Directory.prototype.getAncestorsIterator = function () {\r\n        var parent;\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    parent = this.parent;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(parent != null)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, parent];\r\n                case 2:\r\n                    _a.sent();\r\n                    parent = parent.parent;\r\n                    return [3 /*break*/, 1];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Directory.prototype.getDescendants = function () {\r\n        var e_3, _a;\r\n        var descendants = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(this.childDirs.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                descendants.push(child);\r\n                descendants.push.apply(descendants, tslib_1.__spread(child.getDescendants()));\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return descendants;\r\n    };\r\n    Directory.prototype.isFileQueuedForDelete = function (filePath) {\r\n        return this.hasOperation(function (operation) { return operation.kind === \"deleteFile\" && operation.filePath === filePath; });\r\n    };\r\n    Directory.prototype.hasOperation = function (operationMatches) {\r\n        var e_4, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.operations), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var operation = _c.value;\r\n                if (operationMatches(operation))\r\n                    return true;\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        return false;\r\n    };\r\n    Directory.prototype.dequeueFileDelete = function (filePath) {\r\n        this.removeMatchingOperations(function (operation) { return operation.kind === \"deleteFile\" && operation.filePath === filePath; });\r\n    };\r\n    Directory.prototype.dequeueDirDelete = function (dirPath) {\r\n        this.removeMatchingOperations(function (operation) { return operation.kind === \"deleteDir\" && operation.dir.path === dirPath; });\r\n    };\r\n    Directory.prototype.isRootDir = function () {\r\n        return utils_1.FileUtils.isRootDirPath(this.path);\r\n    };\r\n    Directory.prototype.removeMatchingOperations = function (operationMatches) {\r\n        utils_1.ArrayUtils.removeAll(this.operations, operationMatches);\r\n    };\r\n    return Directory;\r\n}());\r\n/**\r\n * File system host wrapper that allows queuing deletions to the file system.\r\n */\r\nvar FileSystemWrapper = /** @class */ (function () {\r\n    function FileSystemWrapper(fileSystem) {\r\n        this.fileSystem = fileSystem;\r\n        this.directories = new utils_1.KeyValueCache();\r\n        this.operationIndex = 0;\r\n    }\r\n    FileSystemWrapper.prototype.queueFileDelete = function (filePath) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        var parentDir = this.getOrCreateParentDirectory(filePath);\r\n        parentDir.operations.push({\r\n            kind: \"deleteFile\",\r\n            index: this.getNextOperationIndex(),\r\n            filePath: filePath\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.removeFileDelete = function (filePath) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        this.getOrCreateParentDirectory(filePath).dequeueFileDelete(filePath);\r\n    };\r\n    FileSystemWrapper.prototype.queueMkdir = function (dirPath) {\r\n        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n        var dir = this.getOrCreateDirectory(dirPath);\r\n        dir.setIsDeleted(false);\r\n        var parentDir = this.getOrCreateParentDirectory(dirPath);\r\n        parentDir.operations.push({\r\n            kind: \"mkdir\",\r\n            index: this.getNextOperationIndex(),\r\n            dir: dir\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.queueDirectoryDelete = function (dirPath) {\r\n        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n        var dir = this.getOrCreateDirectory(dirPath);\r\n        dir.setIsDeleted(true);\r\n        var parentDir = this.getOrCreateParentDirectory(dirPath);\r\n        parentDir.operations.push({\r\n            kind: \"deleteDir\",\r\n            index: this.getNextOperationIndex(),\r\n            dir: dir\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.queueMoveDirectory = function (srcPath, destPath) {\r\n        // todo: tests for the root directory\r\n        srcPath = this.getStandardizedAbsolutePath(srcPath);\r\n        destPath = this.getStandardizedAbsolutePath(destPath);\r\n        var parentDir = this.getOrCreateParentDirectory(srcPath);\r\n        var moveDir = this.getOrCreateDirectory(srcPath);\r\n        var destinationDir = this.getOrCreateDirectory(destPath);\r\n        var moveOperation = {\r\n            kind: \"move\",\r\n            index: this.getNextOperationIndex(),\r\n            oldDir: moveDir,\r\n            newDir: destinationDir\r\n        };\r\n        parentDir.operations.push(moveOperation);\r\n        (destinationDir.getParent() || destinationDir).inboundOperations.push(moveOperation);\r\n        moveDir.setIsDeleted(true);\r\n    };\r\n    FileSystemWrapper.prototype.queueCopyDirectory = function (srcPath, destPath) {\r\n        srcPath = this.getStandardizedAbsolutePath(srcPath);\r\n        destPath = this.getStandardizedAbsolutePath(destPath);\r\n        var parentDir = this.getOrCreateParentDirectory(srcPath);\r\n        var copyDir = this.getOrCreateDirectory(srcPath);\r\n        var destinationDir = this.getOrCreateDirectory(destPath);\r\n        var copyOperation = {\r\n            kind: \"copy\",\r\n            index: this.getNextOperationIndex(),\r\n            oldDir: copyDir,\r\n            newDir: destinationDir\r\n        };\r\n        parentDir.operations.push(copyOperation);\r\n        (destinationDir.getParent() || destinationDir).inboundOperations.push(copyOperation);\r\n    };\r\n    FileSystemWrapper.prototype.flush = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var e_5, _a, operations, operations_1, operations_1_1, operation, e_5_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        operations = this.getAndClearOperations();\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 6, 7, 8]);\r\n                        operations_1 = tslib_1.__values(operations), operations_1_1 = operations_1.next();\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        if (!!operations_1_1.done) return [3 /*break*/, 5];\r\n                        operation = operations_1_1.value;\r\n                        return [4 /*yield*/, this.executeOperation(operation)];\r\n                    case 3:\r\n                        _b.sent();\r\n                        _b.label = 4;\r\n                    case 4:\r\n                        operations_1_1 = operations_1.next();\r\n                        return [3 /*break*/, 2];\r\n                    case 5: return [3 /*break*/, 8];\r\n                    case 6:\r\n                        e_5_1 = _b.sent();\r\n                        e_5 = { error: e_5_1 };\r\n                        return [3 /*break*/, 8];\r\n                    case 7:\r\n                        try {\r\n                            if (operations_1_1 && !operations_1_1.done && (_a = operations_1.return)) _a.call(operations_1);\r\n                        }\r\n                        finally { if (e_5) throw e_5.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.flushSync = function () {\r\n        var e_6, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getAndClearOperations()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var operation = _c.value;\r\n                this.executeOperationSync(operation);\r\n            }\r\n        }\r\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_6) throw e_6.error; }\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.saveForDirectory = function (dirPath) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var e_7, _a, dir, operations, operations_2, operations_2_1, operation, e_7_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n                        dir = this.getOrCreateDirectory(dirPath);\r\n                        this.throwIfHasExternalOperations(dir, \"save directory\");\r\n                        operations = this.getAndClearOperationsForDir(dir);\r\n                        // await after the state is set\r\n                        return [4 /*yield*/, this.ensureDirectoryExists(dirPath)];\r\n                    case 1:\r\n                        // await after the state is set\r\n                        _b.sent();\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        _b.trys.push([2, 7, 8, 9]);\r\n                        operations_2 = tslib_1.__values(operations), operations_2_1 = operations_2.next();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        if (!!operations_2_1.done) return [3 /*break*/, 6];\r\n                        operation = operations_2_1.value;\r\n                        return [4 /*yield*/, this.executeOperation(operation)];\r\n                    case 4:\r\n                        _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        operations_2_1 = operations_2.next();\r\n                        return [3 /*break*/, 3];\r\n                    case 6: return [3 /*break*/, 9];\r\n                    case 7:\r\n                        e_7_1 = _b.sent();\r\n                        e_7 = { error: e_7_1 };\r\n                        return [3 /*break*/, 9];\r\n                    case 8:\r\n                        try {\r\n                            if (operations_2_1 && !operations_2_1.done && (_a = operations_2.return)) _a.call(operations_2);\r\n                        }\r\n                        finally { if (e_7) throw e_7.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 9: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.saveForDirectorySync = function (dirPath) {\r\n        var e_8, _a;\r\n        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n        var dir = this.getOrCreateDirectory(dirPath);\r\n        this.throwIfHasExternalOperations(dir, \"save directory\");\r\n        this.ensureDirectoryExistsSync(dirPath);\r\n        try {\r\n            for (var _b = tslib_1.__values(this.getAndClearOperationsForDir(dir)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var operation = _c.value;\r\n                this.executeOperationSync(operation);\r\n            }\r\n        }\r\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_8) throw e_8.error; }\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.getAndClearOperationsForDir = function (dir) {\r\n        var e_9, _a;\r\n        var operations = getAndClearParentMkDirOperations(dir.getParent(), dir);\r\n        try {\r\n            for (var _b = tslib_1.__values(tslib_1.__spread([dir], dir.getDescendants())), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var currentDir = _c.value;\r\n                operations.push.apply(operations, tslib_1.__spread(currentDir.operations));\r\n            }\r\n        }\r\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_9) throw e_9.error; }\r\n        }\r\n        utils_1.ArrayUtils.sortByProperty(operations, function (item) { return item.index; });\r\n        this.removeDirAndSubDirs(dir);\r\n        return operations;\r\n        function getAndClearParentMkDirOperations(parentDir, childDir) {\r\n            if (parentDir == null)\r\n                return [];\r\n            var parentOperations = utils_1.ArrayUtils.removeAll(parentDir.operations, function (operation) { return operation.kind === \"mkdir\" && operation.dir === childDir; });\r\n            return tslib_1.__spread(parentOperations, getAndClearParentMkDirOperations(parentDir.getParent(), parentDir));\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.executeOperation = function (operation) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = operation.kind;\r\n                        switch (_a) {\r\n                            case \"deleteDir\": return [3 /*break*/, 1];\r\n                            case \"deleteFile\": return [3 /*break*/, 3];\r\n                            case \"move\": return [3 /*break*/, 5];\r\n                            case \"copy\": return [3 /*break*/, 7];\r\n                            case \"mkdir\": return [3 /*break*/, 9];\r\n                        }\r\n                        return [3 /*break*/, 11];\r\n                    case 1: return [4 /*yield*/, this.deleteSuppressNotFound(operation.dir.path)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 12];\r\n                    case 3: return [4 /*yield*/, this.deleteSuppressNotFound(operation.filePath)];\r\n                    case 4:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 12];\r\n                    case 5: return [4 /*yield*/, this.fileSystem.move(operation.oldDir.path, operation.newDir.path)];\r\n                    case 6:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 12];\r\n                    case 7: return [4 /*yield*/, this.fileSystem.copy(operation.oldDir.path, operation.newDir.path)];\r\n                    case 8:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 12];\r\n                    case 9: return [4 /*yield*/, this.fileSystem.mkdir(operation.dir.path)];\r\n                    case 10:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 12];\r\n                    case 11: throw errors.getNotImplementedForNeverValueError(operation);\r\n                    case 12: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.executeOperationSync = function (operation) {\r\n        switch (operation.kind) {\r\n            case \"deleteDir\":\r\n                this.deleteSuppressNotFoundSync(operation.dir.path);\r\n                break;\r\n            case \"deleteFile\":\r\n                this.deleteSuppressNotFoundSync(operation.filePath);\r\n                break;\r\n            case \"move\":\r\n                this.fileSystem.moveSync(operation.oldDir.path, operation.newDir.path);\r\n                break;\r\n            case \"copy\":\r\n                this.fileSystem.copySync(operation.oldDir.path, operation.newDir.path);\r\n                break;\r\n            case \"mkdir\":\r\n                this.fileSystem.mkdirSync(operation.dir.path);\r\n                break;\r\n            default:\r\n                throw errors.getNotImplementedForNeverValueError(operation);\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.getAndClearOperations = function () {\r\n        var e_10, _a;\r\n        var operations = [];\r\n        try {\r\n            for (var _b = tslib_1.__values(this.directories.getValues()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var dir = _c.value;\r\n                operations.push.apply(operations, tslib_1.__spread(dir.operations));\r\n            }\r\n        }\r\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_10) throw e_10.error; }\r\n        }\r\n        utils_1.ArrayUtils.sortByProperty(operations, function (item) { return item.index; });\r\n        this.directories.clear();\r\n        return operations;\r\n    };\r\n    FileSystemWrapper.prototype.moveFileImmediately = function (oldFilePath, newFilePath, fileText) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        oldFilePath = this.getStandardizedAbsolutePath(oldFilePath);\r\n                        newFilePath = this.getStandardizedAbsolutePath(newFilePath);\r\n                        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(oldFilePath), \"move file\");\r\n                        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(newFilePath), \"move file\");\r\n                        return [4 /*yield*/, this.deleteFileImmediately(oldFilePath)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.writeFile(newFilePath, fileText)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.moveFileImmediatelySync = function (oldFilePath, newFilePath, fileText) {\r\n        oldFilePath = this.getStandardizedAbsolutePath(oldFilePath);\r\n        newFilePath = this.getStandardizedAbsolutePath(newFilePath);\r\n        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(oldFilePath), \"move file\");\r\n        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(newFilePath), \"move file\");\r\n        this.deleteFileImmediatelySync(oldFilePath);\r\n        this.writeFileSync(newFilePath, fileText);\r\n    };\r\n    FileSystemWrapper.prototype.deleteFileImmediately = function (filePath) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var dir, err_1;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        filePath = this.getStandardizedAbsolutePath(filePath);\r\n                        dir = this.getOrCreateParentDirectory(filePath);\r\n                        this.throwIfHasExternalOperations(dir, \"delete file\");\r\n                        dir.dequeueFileDelete(filePath);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.deleteSuppressNotFound(filePath)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_1 = _a.sent();\r\n                        this.queueFileDelete(filePath);\r\n                        throw err_1;\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.deleteFileImmediatelySync = function (filePath) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        var dir = this.getOrCreateParentDirectory(filePath);\r\n        this.throwIfHasExternalOperations(dir, \"delete file\");\r\n        dir.dequeueFileDelete(filePath);\r\n        try {\r\n            this.deleteSuppressNotFoundSync(filePath);\r\n        }\r\n        catch (err) {\r\n            this.queueFileDelete(filePath);\r\n            throw err;\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.copyDirectoryImmediately = function (srcDirPath, destDirPath) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var srcDir, destDir, saveTask;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);\r\n                        destDirPath = this.getStandardizedAbsolutePath(destDirPath);\r\n                        srcDir = this.getOrCreateDirectory(srcDirPath);\r\n                        destDir = this.getOrCreateDirectory(destDirPath);\r\n                        this.throwIfHasExternalOperations(srcDir, \"copy directory\");\r\n                        this.throwIfHasExternalOperations(destDir, \"copy directory\");\r\n                        saveTask = Promise.all([this.saveForDirectory(srcDirPath), this.saveForDirectory(destDirPath)]);\r\n                        this.removeDirAndSubDirs(srcDir);\r\n                        // await after the state is set\r\n                        return [4 /*yield*/, saveTask];\r\n                    case 1:\r\n                        // await after the state is set\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.fileSystem.copy(srcDirPath, destDirPath)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.copyDirectoryImmediatelySync = function (srcDirPath, destDirPath) {\r\n        srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);\r\n        destDirPath = this.getStandardizedAbsolutePath(destDirPath);\r\n        var srcDir = this.getOrCreateDirectory(srcDirPath);\r\n        var destDir = this.getOrCreateDirectory(destDirPath);\r\n        this.throwIfHasExternalOperations(srcDir, \"copy directory\");\r\n        this.throwIfHasExternalOperations(destDir, \"copy directory\");\r\n        this.saveForDirectorySync(srcDirPath);\r\n        this.saveForDirectorySync(destDirPath);\r\n        this.removeDirAndSubDirs(srcDir);\r\n        this.fileSystem.copySync(srcDirPath, destDirPath);\r\n    };\r\n    FileSystemWrapper.prototype.moveDirectoryImmediately = function (srcDirPath, destDirPath) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var srcDir, destDir, saveTask;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);\r\n                        destDirPath = this.getStandardizedAbsolutePath(destDirPath);\r\n                        srcDir = this.getOrCreateDirectory(srcDirPath);\r\n                        destDir = this.getOrCreateDirectory(destDirPath);\r\n                        this.throwIfHasExternalOperations(srcDir, \"move directory\");\r\n                        this.throwIfHasExternalOperations(destDir, \"move directory\");\r\n                        saveTask = Promise.all([this.saveForDirectory(srcDirPath), this.saveForDirectory(destDirPath)]);\r\n                        this.removeDirAndSubDirs(srcDir);\r\n                        // await after the state is set\r\n                        return [4 /*yield*/, saveTask];\r\n                    case 1:\r\n                        // await after the state is set\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.fileSystem.move(srcDirPath, destDirPath)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.moveDirectoryImmediatelySync = function (srcDirPath, destDirPath) {\r\n        srcDirPath = this.getStandardizedAbsolutePath(srcDirPath);\r\n        destDirPath = this.getStandardizedAbsolutePath(destDirPath);\r\n        var srcDir = this.getOrCreateDirectory(srcDirPath);\r\n        var destDir = this.getOrCreateDirectory(destDirPath);\r\n        this.throwIfHasExternalOperations(srcDir, \"move directory\");\r\n        this.throwIfHasExternalOperations(destDir, \"move directory\");\r\n        this.saveForDirectorySync(srcDirPath);\r\n        this.saveForDirectorySync(destDirPath);\r\n        this.removeDirAndSubDirs(srcDir);\r\n        this.fileSystem.moveSync(srcDirPath, destDirPath);\r\n    };\r\n    FileSystemWrapper.prototype.deleteDirectoryImmediately = function (dirPath) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var dir, err_2;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n                        dir = this.getOrCreateDirectory(dirPath);\r\n                        this.throwIfHasExternalOperations(dir, \"delete\");\r\n                        this.removeDirAndSubDirs(dir);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.deleteSuppressNotFound(dirPath)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_2 = _a.sent();\r\n                        this.addBackDirAndSubDirs(dir);\r\n                        this.queueDirectoryDelete(dirPath);\r\n                        return [3 /*break*/, 4];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.deleteDirectoryImmediatelySync = function (dirPath) {\r\n        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n        var dir = this.getOrCreateDirectory(dirPath);\r\n        this.throwIfHasExternalOperations(dir, \"delete\");\r\n        this.removeDirAndSubDirs(dir);\r\n        try {\r\n            this.deleteSuppressNotFoundSync(dirPath);\r\n        }\r\n        catch (err) {\r\n            this.addBackDirAndSubDirs(dir);\r\n            this.queueDirectoryDelete(dirPath);\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.deleteSuppressNotFound = function (path) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var err_3;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4 /*yield*/, this.fileSystem.delete(path)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        err_3 = _a.sent();\r\n                        if (!utils_1.FileUtils.isNotExistsError(err_3))\r\n                            throw err_3;\r\n                        return [3 /*break*/, 3];\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.deleteSuppressNotFoundSync = function (path) {\r\n        try {\r\n            this.fileSystem.deleteSync(path);\r\n        }\r\n        catch (err) {\r\n            if (!utils_1.FileUtils.isNotExistsError(err))\r\n                throw err;\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.fileExistsSync = function (filePath) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        if (this.isPathQueuedForDeletion(filePath))\r\n            return false;\r\n        var parentDir = this.getParentDirectoryIfExists(filePath);\r\n        if (parentDir != null && parentDir.getWasEverDeleted())\r\n            return false;\r\n        return this.fileSystem.fileExistsSync(filePath);\r\n    };\r\n    FileSystemWrapper.prototype.directoryExistsSync = function (dirPath) {\r\n        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n        if (this.isPathQueuedForDeletion(dirPath))\r\n            return false;\r\n        if (this.isPathDirectoryInQueueThatExists(dirPath))\r\n            return true;\r\n        var dir = this.getDirectoryIfExists(dirPath);\r\n        if (dir != null && dir.getWasEverDeleted())\r\n            return false;\r\n        return this.fileSystem.directoryExistsSync(dirPath);\r\n    };\r\n    FileSystemWrapper.prototype.readFileSync = function (filePath, encoding) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        if (this.isPathQueuedForDeletion(filePath))\r\n            throw new errors.InvalidOperationError(\"Cannot read file at \" + filePath + \" when it is queued for deletion.\");\r\n        if (this.getOrCreateParentDirectory(filePath).getWasEverDeleted())\r\n            throw new errors.InvalidOperationError(\"Cannot read file at \" + filePath + \" because one of its ancestor directories was once deleted or moved.\");\r\n        return this.fileSystem.readFileSync(filePath, encoding);\r\n    };\r\n    FileSystemWrapper.prototype.readDirSync = function (dirPath) {\r\n        var _this = this;\r\n        dirPath = this.getStandardizedAbsolutePath(dirPath);\r\n        var dir = this.getOrCreateDirectory(dirPath);\r\n        if (dir.getIsDeleted())\r\n            throw new errors.InvalidOperationError(\"Cannot read directory at \" + dirPath + \" when it is queued for deletion.\");\r\n        if (dir.getWasEverDeleted())\r\n            throw new errors.InvalidOperationError(\"Cannot read directory at \" + dirPath + \" because one of its ancestor directories was once deleted or moved.\");\r\n        return this.fileSystem.readDirSync(dirPath).filter(function (path) { return !_this.isPathQueuedForDeletion(path) && !_this.isPathQueuedForDeletion(path); });\r\n    };\r\n    FileSystemWrapper.prototype.glob = function (patterns) {\r\n        var _this = this;\r\n        return this.fileSystem.glob(patterns).filter(function (path) { return !_this.isPathQueuedForDeletion(path); });\r\n    };\r\n    FileSystemWrapper.prototype.getFileSystem = function () {\r\n        return this.fileSystem;\r\n    };\r\n    FileSystemWrapper.prototype.getCurrentDirectory = function () {\r\n        return this.fileSystem.getCurrentDirectory();\r\n    };\r\n    FileSystemWrapper.prototype.getDirectories = function (dirPath) {\r\n        var _this = this;\r\n        return this.readDirSync(dirPath).filter(function (path) { return _this.directoryExistsSync(path); });\r\n    };\r\n    FileSystemWrapper.prototype.getStandardizedAbsolutePath = function (fileOrDirPath, relativeBase) {\r\n        return utils_1.FileUtils.getStandardizedAbsolutePath(this.fileSystem, fileOrDirPath, relativeBase);\r\n    };\r\n    FileSystemWrapper.prototype.readFileOrNotExists = function (filePath, encoding) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        if (this.isPathQueuedForDeletion(filePath))\r\n            return false;\r\n        return utils_1.FileUtils.readFileOrNotExists(this.fileSystem, filePath, encoding);\r\n    };\r\n    FileSystemWrapper.prototype.readFileOrNotExistsSync = function (filePath, encoding) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        if (this.isPathQueuedForDeletion(filePath))\r\n            return false;\r\n        return utils_1.FileUtils.readFileOrNotExistsSync(this.fileSystem, filePath, encoding);\r\n    };\r\n    FileSystemWrapper.prototype.writeFile = function (filePath, fileText) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var parentDir;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        filePath = this.getStandardizedAbsolutePath(filePath);\r\n                        parentDir = this.getOrCreateParentDirectory(filePath);\r\n                        this.throwIfHasExternalOperations(parentDir, \"write file\");\r\n                        parentDir.dequeueFileDelete(filePath);\r\n                        return [4 /*yield*/, this.ensureDirectoryExists(parentDir.path)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [4 /*yield*/, this.fileSystem.writeFile(filePath, fileText)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.writeFileSync = function (filePath, fileText) {\r\n        filePath = this.getStandardizedAbsolutePath(filePath);\r\n        var parentDir = this.getOrCreateParentDirectory(filePath);\r\n        this.throwIfHasExternalOperations(parentDir, \"write file\");\r\n        parentDir.dequeueFileDelete(filePath);\r\n        this.ensureDirectoryExistsSync(parentDir.path);\r\n        this.fileSystem.writeFileSync(filePath, fileText);\r\n    };\r\n    FileSystemWrapper.prototype.isPathDirectoryInQueueThatExists = function (path) {\r\n        var pathDir = this.getDirectoryIfExists(path);\r\n        return pathDir == null ? false : !pathDir.getIsDeleted();\r\n    };\r\n    FileSystemWrapper.prototype.isPathQueuedForDeletion = function (path) {\r\n        // check if the provided path is a dir and if it's deleted\r\n        var pathDir = this.getDirectoryIfExists(path);\r\n        if (pathDir != null)\r\n            return pathDir.getIsDeleted();\r\n        // check if the provided path is a file or if it or its parent is deleted\r\n        var parentDir = this.getOrCreateParentDirectory(path);\r\n        return parentDir.isFileQueuedForDelete(path) || parentDir.getIsDeleted();\r\n    };\r\n    FileSystemWrapper.prototype.removeDirAndSubDirs = function (dir) {\r\n        var e_11, _a;\r\n        var originalParent = dir.getParent();\r\n        dir.removeParent();\r\n        try {\r\n            for (var _b = tslib_1.__values(tslib_1.__spread([dir], dir.getDescendants())), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var dirToRemove = _c.value;\r\n                this.directories.removeByKey(dirToRemove.path);\r\n            }\r\n        }\r\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_11) throw e_11.error; }\r\n        }\r\n        if (originalParent != null)\r\n            originalParent.dequeueDirDelete(dir.path);\r\n    };\r\n    FileSystemWrapper.prototype.addBackDirAndSubDirs = function (dir) {\r\n        var e_12, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(tslib_1.__spread([dir], dir.getDescendants())), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var dirToAdd = _c.value;\r\n                this.directories.set(dirToAdd.path, dirToAdd);\r\n            }\r\n        }\r\n        catch (e_12_1) { e_12 = { error: e_12_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_12) throw e_12.error; }\r\n        }\r\n        if (!dir.isRootDir())\r\n            dir.setParent(this.getOrCreateParentDirectory(dir.path));\r\n    };\r\n    FileSystemWrapper.prototype.getNextOperationIndex = function () {\r\n        return this.operationIndex++;\r\n    };\r\n    FileSystemWrapper.prototype.getParentDirectoryIfExists = function (filePath) {\r\n        return this.getDirectoryIfExists(utils_1.FileUtils.getDirPath(filePath));\r\n    };\r\n    FileSystemWrapper.prototype.getOrCreateParentDirectory = function (filePath) {\r\n        return this.getOrCreateDirectory(utils_1.FileUtils.getDirPath(filePath));\r\n    };\r\n    FileSystemWrapper.prototype.getDirectoryIfExists = function (dirPath) {\r\n        return this.directories.get(dirPath);\r\n    };\r\n    FileSystemWrapper.prototype.getOrCreateDirectory = function (dirPath) {\r\n        var _this = this;\r\n        var dir = this.directories.get(dirPath);\r\n        if (dir != null)\r\n            return dir;\r\n        var getOrCreateDir = function (creatingDirPath) { return _this.directories.getOrCreate(creatingDirPath, function () { return new Directory(creatingDirPath); }); };\r\n        dir = getOrCreateDir(dirPath);\r\n        var currentDirPath = dirPath;\r\n        var currentDir = dir;\r\n        while (!utils_1.FileUtils.isRootDirPath(currentDirPath)) {\r\n            var nextDirPath = utils_1.FileUtils.getDirPath(currentDirPath);\r\n            var hadNextDir = this.directories.has(nextDirPath);\r\n            var nextDir = getOrCreateDir(nextDirPath);\r\n            currentDir.setParent(nextDir);\r\n            if (hadNextDir)\r\n                return dir;\r\n            currentDir = nextDir;\r\n            currentDirPath = nextDirPath;\r\n        }\r\n        return dir;\r\n    };\r\n    FileSystemWrapper.prototype.throwIfHasExternalOperations = function (dir, commandName) {\r\n        var operations = dir.getExternalOperations();\r\n        if (operations.length === 0)\r\n            return;\r\n        throw new errors.InvalidOperationError(getErrorText());\r\n        function getErrorText() {\r\n            var e_13, _a;\r\n            var hasCopy = false;\r\n            var errorText = \"Cannot execute immediate operation '\" + commandName + \"' because of the following external operations:\\n\";\r\n            try {\r\n                for (var operations_3 = tslib_1.__values(operations), operations_3_1 = operations_3.next(); !operations_3_1.done; operations_3_1 = operations_3.next()) {\r\n                    var operation = operations_3_1.value;\r\n                    if (operation.kind === \"move\")\r\n                        errorText += \"\\n* Move: \" + operation.oldDir.path + \" --> \" + operation.newDir.path;\r\n                    else if (operation.kind === \"copy\") {\r\n                        errorText += \"\\n* Copy: \" + operation.oldDir.path + \" --> \" + operation.newDir.path;\r\n                        hasCopy = true;\r\n                    }\r\n                    else if (operation.kind === \"deleteDir\")\r\n                        errorText += \"\\n* Delete: \" + operation.dir.path;\r\n                    else {\r\n                        var expectNever = operation;\r\n                        errorText += \"\\n* Unknown operation: Please report this as a bug.\";\r\n                    }\r\n                }\r\n            }\r\n            catch (e_13_1) { e_13 = { error: e_13_1 }; }\r\n            finally {\r\n                try {\r\n                    if (operations_3_1 && !operations_3_1.done && (_a = operations_3.return)) _a.call(operations_3);\r\n                }\r\n                finally { if (e_13) throw e_13.error; }\r\n            }\r\n            if (hasCopy)\r\n                errorText += \"\\n\\nNote: Copy operations can be removed from external operations by setting `includeUntrackedFiles` to `false` when copying.\";\r\n            return errorText;\r\n        }\r\n    };\r\n    FileSystemWrapper.prototype.ensureDirectoryExists = function (dirPath) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var parentDirPath;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.fileSystem.directoryExists(dirPath)];\r\n                    case 1:\r\n                        if (_a.sent())\r\n                            return [2 /*return*/];\r\n                        parentDirPath = utils_1.FileUtils.getDirPath(dirPath);\r\n                        if (!(parentDirPath !== dirPath && !utils_1.FileUtils.isRootDirPath(parentDirPath))) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, this.ensureDirectoryExists(parentDirPath)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        // make this directory\r\n                        this.removeMkDirOperationsForDir(dirPath);\r\n                        return [4 /*yield*/, this.fileSystem.mkdir(dirPath)];\r\n                    case 4:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FileSystemWrapper.prototype.ensureDirectoryExistsSync = function (dirPath) {\r\n        if (this.fileSystem.directoryExistsSync(dirPath))\r\n            return;\r\n        // ensure the parent exists and is not the root\r\n        var parentDirPath = utils_1.FileUtils.getDirPath(dirPath);\r\n        if (parentDirPath !== dirPath && !utils_1.FileUtils.isRootDirPath(parentDirPath))\r\n            this.ensureDirectoryExistsSync(parentDirPath);\r\n        // make this directory\r\n        this.removeMkDirOperationsForDir(dirPath);\r\n        this.fileSystem.mkdirSync(dirPath);\r\n    };\r\n    FileSystemWrapper.prototype.removeMkDirOperationsForDir = function (dirPath) {\r\n        var dir = this.getOrCreateDirectory(dirPath);\r\n        var parentDir = this.getOrCreateParentDirectory(dirPath);\r\n        utils_1.ArrayUtils.removeAll(parentDir.operations, function (operation) { return operation.kind === \"mkdir\" && operation.dir === dir; });\r\n    };\r\n    return FileSystemWrapper;\r\n}());\r\nexports.FileSystemWrapper = FileSystemWrapper;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/FileSystemWrapper.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/VirtualFileSystemHost.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/VirtualFileSystemHost.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar VirtualFileSystemHost = /** @class */ (function () {\r\n    function VirtualFileSystemHost() {\r\n        this.directories = new utils_1.KeyValueCache();\r\n        this.getOrCreateDir(\"/\");\r\n    }\r\n    VirtualFileSystemHost.prototype.delete = function (path) {\r\n        try {\r\n            this.deleteSync(path);\r\n            return Promise.resolve();\r\n        }\r\n        catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    };\r\n    VirtualFileSystemHost.prototype.deleteSync = function (path) {\r\n        var e_1, _a;\r\n        path = utils_1.FileUtils.getStandardizedAbsolutePath(this, path);\r\n        if (this.directories.has(path)) {\r\n            try {\r\n                // remove descendant dirs\r\n                for (var _b = tslib_1.__values(getDescendantDirectories(this.directories.getKeys(), path)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var descendantDirPath = _c.value;\r\n                    this.directories.removeByKey(descendantDirPath);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            // remove this dir\r\n            this.directories.removeByKey(path);\r\n            return;\r\n        }\r\n        var parentDir = this.directories.get(utils_1.FileUtils.getDirPath(path));\r\n        if (parentDir == null || !parentDir.files.has(path))\r\n            throw new errors.FileNotFoundError(path);\r\n        parentDir.files.removeByKey(path);\r\n    };\r\n    VirtualFileSystemHost.prototype.readDirSync = function (dirPath) {\r\n        dirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, dirPath);\r\n        var dir = this.directories.get(dirPath);\r\n        if (dir == null)\r\n            throw new errors.DirectoryNotFoundError(dirPath);\r\n        return tslib_1.__spread(getDirectories(this.directories.getKeys()), dir.files.getKeys());\r\n        function getDirectories(dirPaths) {\r\n            var e_2, _a, dirPaths_1, dirPaths_1_1, path, parentDir, e_2_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _b.trys.push([0, 5, 6, 7]);\r\n                        dirPaths_1 = tslib_1.__values(dirPaths), dirPaths_1_1 = dirPaths_1.next();\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!!dirPaths_1_1.done) return [3 /*break*/, 4];\r\n                        path = dirPaths_1_1.value;\r\n                        parentDir = utils_1.FileUtils.getDirPath(path);\r\n                        if (!(parentDir === dirPath && parentDir !== path)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, path];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        dirPaths_1_1 = dirPaths_1.next();\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [3 /*break*/, 7];\r\n                    case 5:\r\n                        e_2_1 = _b.sent();\r\n                        e_2 = { error: e_2_1 };\r\n                        return [3 /*break*/, 7];\r\n                    case 6:\r\n                        try {\r\n                            if (dirPaths_1_1 && !dirPaths_1_1.done && (_a = dirPaths_1.return)) _a.call(dirPaths_1);\r\n                        }\r\n                        finally { if (e_2) throw e_2.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    VirtualFileSystemHost.prototype.readFile = function (filePath, encoding) {\r\n        if (encoding === void 0) { encoding = \"utf-8\"; }\r\n        try {\r\n            return Promise.resolve(this.readFileSync(filePath, encoding));\r\n        }\r\n        catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    };\r\n    VirtualFileSystemHost.prototype.readFileSync = function (filePath, encoding) {\r\n        if (encoding === void 0) { encoding = \"utf-8\"; }\r\n        filePath = utils_1.FileUtils.getStandardizedAbsolutePath(this, filePath);\r\n        var parentDir = this.directories.get(utils_1.FileUtils.getDirPath(filePath));\r\n        if (parentDir == null)\r\n            throw new errors.FileNotFoundError(filePath);\r\n        var fileText = parentDir.files.get(filePath);\r\n        if (fileText === undefined)\r\n            throw new errors.FileNotFoundError(filePath);\r\n        return fileText;\r\n    };\r\n    VirtualFileSystemHost.prototype.writeFile = function (filePath, fileText) {\r\n        this.writeFileSync(filePath, fileText);\r\n        return Promise.resolve();\r\n    };\r\n    VirtualFileSystemHost.prototype.writeFileSync = function (filePath, fileText) {\r\n        filePath = utils_1.FileUtils.getStandardizedAbsolutePath(this, filePath);\r\n        var dirPath = utils_1.FileUtils.getDirPath(filePath);\r\n        this.getOrCreateDir(dirPath).files.set(filePath, fileText);\r\n    };\r\n    VirtualFileSystemHost.prototype.mkdir = function (dirPath) {\r\n        this.mkdirSync(dirPath);\r\n        return Promise.resolve();\r\n    };\r\n    VirtualFileSystemHost.prototype.mkdirSync = function (dirPath) {\r\n        dirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, dirPath);\r\n        this.getOrCreateDir(dirPath);\r\n    };\r\n    VirtualFileSystemHost.prototype.move = function (srcPath, destPath) {\r\n        this.moveSync(srcPath, destPath);\r\n        return Promise.resolve();\r\n    };\r\n    VirtualFileSystemHost.prototype.moveSync = function (srcPath, destPath) {\r\n        var _this = this;\r\n        var e_3, _a;\r\n        srcPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, srcPath);\r\n        destPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, destPath);\r\n        if (this.fileExistsSync(srcPath)) {\r\n            var fileText = this.readFileSync(srcPath);\r\n            this.deleteSync(srcPath);\r\n            this.writeFileSync(destPath, fileText);\r\n        }\r\n        else if (this.directories.has(srcPath)) {\r\n            var moveDirectory = function (from, to) {\r\n                _this._copyDirInternal(from, to);\r\n                _this.directories.removeByKey(from);\r\n            };\r\n            moveDirectory(srcPath, destPath);\r\n            try {\r\n                // move descendant dirs\r\n                for (var _b = tslib_1.__values(getDescendantDirectories(this.directories.getKeys(), srcPath)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var descendantDirPath = _c.value;\r\n                    var relativePath = utils_1.FileUtils.getRelativePathTo(srcPath, descendantDirPath);\r\n                    moveDirectory(descendantDirPath, utils_1.FileUtils.pathJoin(destPath, relativePath));\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        }\r\n        else\r\n            throw new errors.PathNotFoundError(srcPath);\r\n    };\r\n    VirtualFileSystemHost.prototype.copy = function (srcPath, destPath) {\r\n        this.copySync(srcPath, destPath);\r\n        return Promise.resolve();\r\n    };\r\n    VirtualFileSystemHost.prototype.copySync = function (srcPath, destPath) {\r\n        var e_4, _a;\r\n        srcPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, srcPath);\r\n        destPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, destPath);\r\n        if (this.fileExistsSync(srcPath))\r\n            this.writeFileSync(destPath, this.readFileSync(srcPath));\r\n        else if (this.directories.has(srcPath)) {\r\n            this._copyDirInternal(srcPath, destPath);\r\n            try {\r\n                // copy descendant dirs\r\n                for (var _b = tslib_1.__values(getDescendantDirectories(this.directories.getKeys(), srcPath)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var descendantDirPath = _c.value;\r\n                    var relativePath = utils_1.FileUtils.getRelativePathTo(srcPath, descendantDirPath);\r\n                    this._copyDirInternal(descendantDirPath, utils_1.FileUtils.pathJoin(destPath, relativePath));\r\n                }\r\n            }\r\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_4) throw e_4.error; }\r\n            }\r\n        }\r\n        else\r\n            throw new errors.PathNotFoundError(srcPath);\r\n    };\r\n    VirtualFileSystemHost.prototype._copyDirInternal = function (from, to) {\r\n        var e_5, _a;\r\n        var dir = this.directories.get(from);\r\n        var newDir = this.getOrCreateDir(to);\r\n        try {\r\n            for (var _b = tslib_1.__values(dir.files.getEntries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var fileEntry = _c.value;\r\n                newDir.files.set(utils_1.FileUtils.pathJoin(to, utils_1.FileUtils.getBaseName(fileEntry[0])), fileEntry[1]);\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n    };\r\n    VirtualFileSystemHost.prototype.fileExists = function (filePath) {\r\n        return Promise.resolve(this.fileExistsSync(filePath));\r\n    };\r\n    VirtualFileSystemHost.prototype.fileExistsSync = function (filePath) {\r\n        filePath = utils_1.FileUtils.getStandardizedAbsolutePath(this, filePath);\r\n        var dirPath = utils_1.FileUtils.getDirPath(filePath);\r\n        var dir = this.directories.get(dirPath);\r\n        if (dir == null)\r\n            return false;\r\n        return dir.files.has(filePath);\r\n    };\r\n    VirtualFileSystemHost.prototype.directoryExists = function (dirPath) {\r\n        return Promise.resolve(this.directoryExistsSync(dirPath));\r\n    };\r\n    VirtualFileSystemHost.prototype.directoryExistsSync = function (dirPath) {\r\n        dirPath = utils_1.FileUtils.getStandardizedAbsolutePath(this, dirPath);\r\n        return this.directories.has(dirPath);\r\n    };\r\n    VirtualFileSystemHost.prototype.getCurrentDirectory = function () {\r\n        return \"/\";\r\n    };\r\n    VirtualFileSystemHost.prototype.glob = function (patterns) {\r\n        var filePaths = [];\r\n        var allFilePaths = utils_1.ArrayUtils.from(getAllFilePaths(this.directories.getValues()));\r\n        return utils_1.matchGlobs(allFilePaths, patterns, this.getCurrentDirectory());\r\n        function getAllFilePaths(directories) {\r\n            var e_6, _a, directories_1, directories_1_1, dir, e_6_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _b.trys.push([0, 5, 6, 7]);\r\n                        directories_1 = tslib_1.__values(directories), directories_1_1 = directories_1.next();\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        if (!!directories_1_1.done) return [3 /*break*/, 4];\r\n                        dir = directories_1_1.value;\r\n                        return [5 /*yield**/, tslib_1.__values(dir.files.getKeys())];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        directories_1_1 = directories_1.next();\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [3 /*break*/, 7];\r\n                    case 5:\r\n                        e_6_1 = _b.sent();\r\n                        e_6 = { error: e_6_1 };\r\n                        return [3 /*break*/, 7];\r\n                    case 6:\r\n                        try {\r\n                            if (directories_1_1 && !directories_1_1.done && (_a = directories_1.return)) _a.call(directories_1);\r\n                        }\r\n                        finally { if (e_6) throw e_6.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    VirtualFileSystemHost.prototype.getOrCreateDir = function (dirPath) {\r\n        var dir = this.directories.get(dirPath);\r\n        if (dir == null) {\r\n            dir = { path: dirPath, files: new utils_1.KeyValueCache() };\r\n            this.directories.set(dirPath, dir);\r\n            var parentDirPath = utils_1.FileUtils.getDirPath(dirPath);\r\n            if (parentDirPath !== dirPath)\r\n                this.getOrCreateDir(parentDirPath);\r\n        }\r\n        return dir;\r\n    };\r\n    return VirtualFileSystemHost;\r\n}());\r\nexports.VirtualFileSystemHost = VirtualFileSystemHost;\r\nfunction getDescendantDirectories(directoryPaths, dirPath) {\r\n    var e_7, _a, directoryPaths_1, directoryPaths_1_1, path, e_7_1;\r\n    return tslib_1.__generator(this, function (_b) {\r\n        switch (_b.label) {\r\n            case 0:\r\n                _b.trys.push([0, 5, 6, 7]);\r\n                directoryPaths_1 = tslib_1.__values(directoryPaths), directoryPaths_1_1 = directoryPaths_1.next();\r\n                _b.label = 1;\r\n            case 1:\r\n                if (!!directoryPaths_1_1.done) return [3 /*break*/, 4];\r\n                path = directoryPaths_1_1.value;\r\n                if (!utils_1.FileUtils.pathStartsWith(path, dirPath)) return [3 /*break*/, 3];\r\n                return [4 /*yield*/, path];\r\n            case 2:\r\n                _b.sent();\r\n                _b.label = 3;\r\n            case 3:\r\n                directoryPaths_1_1 = directoryPaths_1.next();\r\n                return [3 /*break*/, 1];\r\n            case 4: return [3 /*break*/, 7];\r\n            case 5:\r\n                e_7_1 = _b.sent();\r\n                e_7 = { error: e_7_1 };\r\n                return [3 /*break*/, 7];\r\n            case 6:\r\n                try {\r\n                    if (directoryPaths_1_1 && !directoryPaths_1_1.done && (_a = directoryPaths_1.return)) _a.call(directoryPaths_1);\r\n                }\r\n                finally { if (e_7) throw e_7.error; }\r\n                return [7 /*endfinally*/];\r\n            case 7: return [2 /*return*/];\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/VirtualFileSystemHost.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/fileSystem/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/fileSystem/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DefaultFileSystemHost */ \"./node_modules/ts-simple-ast/dist/fileSystem/DefaultFileSystemHost.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Directory */ \"./node_modules/ts-simple-ast/dist/fileSystem/Directory.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DirectoryCoordinator */ \"./node_modules/ts-simple-ast/dist/fileSystem/DirectoryCoordinator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DirectoryEmitResult */ \"./node_modules/ts-simple-ast/dist/fileSystem/DirectoryEmitResult.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FileSystemWrapper */ \"./node_modules/ts-simple-ast/dist/fileSystem/FileSystemWrapper.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VirtualFileSystemHost */ \"./node_modules/ts-simple-ast/dist/fileSystem/VirtualFileSystemHost.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/fileSystem/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/main.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\n/// <reference path=\"typings/index.d.ts\" />\r\ntslib_1.__exportStar(__webpack_require__(/*! ./codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./errors/classes */ \"./node_modules/ts-simple-ast/dist/errors/classes/index.js\"), exports);\r\nvar fileSystem_1 = __webpack_require__(/*! ./fileSystem */ \"./node_modules/ts-simple-ast/dist/fileSystem/index.js\");\r\nexports.Directory = fileSystem_1.Directory;\r\nexports.DirectoryEmitResult = fileSystem_1.DirectoryEmitResult;\r\ntslib_1.__exportStar(__webpack_require__(/*! ./options */ \"./node_modules/ts-simple-ast/dist/options/index.js\"), exports);\r\nvar Project_1 = __webpack_require__(/*! ./Project */ \"./node_modules/ts-simple-ast/dist/Project.js\");\r\nexports.default = Project_1.Project;\r\ntslib_1.__exportStar(__webpack_require__(/*! ./typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\"), exports);\r\nvar createWrappedNode_1 = __webpack_require__(/*! ./utils/compiler/createWrappedNode */ \"./node_modules/ts-simple-ast/dist/utils/compiler/createWrappedNode.js\");\r\nexports.createWrappedNode = createWrappedNode_1.createWrappedNode;\r\nvar printNode_1 = __webpack_require__(/*! ./utils/compiler/printNode */ \"./node_modules/ts-simple-ast/dist/utils/compiler/printNode.js\");\r\nexports.printNode = printNode_1.printNode;\r\nvar getCompilerOptionsFromTsConfig_1 = __webpack_require__(/*! ./utils/tsconfig/getCompilerOptionsFromTsConfig */ \"./node_modules/ts-simple-ast/dist/utils/tsconfig/getCompilerOptionsFromTsConfig.js\");\r\nexports.getCompilerOptionsFromTsConfig = getCompilerOptionsFromTsConfig_1.getCompilerOptionsFromTsConfig;\r\nvar TypeGuards_1 = __webpack_require__(/*! ./utils/TypeGuards */ \"./node_modules/ts-simple-ast/dist/utils/TypeGuards.js\");\r\nexports.TypeGuards = TypeGuards_1.TypeGuards;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/main.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/code/getNewInsertCode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/code/getNewInsertCode.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js\");\r\n// todo: seems like this should be renamed or removed?\r\nfunction getNewInsertCode(opts) {\r\n    var structures = opts.structures, newCodes = opts.newCodes, parent = opts.parent, getSeparator = opts.getSeparator, previousFormattingKind = opts.previousFormattingKind, nextFormattingKind = opts.nextFormattingKind;\r\n    var indentationText = opts.indentationText == null ? parent.getChildIndentationText() : opts.indentationText;\r\n    var newLineKind = parent.context.manipulationSettings.getNewLineKindAsString();\r\n    return getFormattingKindTextWithIndent(previousFormattingKind) + getChildCode() + getFormattingKindTextWithIndent(nextFormattingKind);\r\n    function getChildCode() {\r\n        var code = newCodes[0];\r\n        for (var i = 1; i < newCodes.length; i++) {\r\n            var formattingKind = getSeparator(structures[i - 1], structures[i]);\r\n            code += getFormattingKindTextWithIndent(formattingKind);\r\n            code += newCodes[i];\r\n        }\r\n        return code;\r\n    }\r\n    function getFormattingKindTextWithIndent(formattingKind) {\r\n        var code = formatting_1.getFormattingKindText(formattingKind, { newLineKind: newLineKind });\r\n        if (formattingKind === formatting_1.FormattingKind.Newline || formattingKind === formatting_1.FormattingKind.Blankline)\r\n            code += indentationText;\r\n        return code;\r\n    }\r\n}\r\nexports.getNewInsertCode = getNewInsertCode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/code/getNewInsertCode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/code/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/code/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getNewInsertCode */ \"./node_modules/ts-simple-ast/dist/manipulation/code/getNewInsertCode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/code/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FormattingKind;\r\n(function (FormattingKind) {\r\n    FormattingKind[FormattingKind[\"Newline\"] = 0] = \"Newline\";\r\n    FormattingKind[FormattingKind[\"Blankline\"] = 1] = \"Blankline\";\r\n    FormattingKind[FormattingKind[\"Space\"] = 2] = \"Space\";\r\n    FormattingKind[FormattingKind[\"None\"] = 3] = \"None\";\r\n})(FormattingKind = exports.FormattingKind || (exports.FormattingKind = {}));\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/getClassMemberFormatting.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/getClassMemberFormatting.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FormattingKind_1 = __webpack_require__(/*! ./FormattingKind */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js\");\r\nfunction getClassMemberFormatting(parent, member) {\r\n    if (parent.isAmbient())\r\n        return FormattingKind_1.FormattingKind.Newline;\r\n    if (hasBody(member))\r\n        return FormattingKind_1.FormattingKind.Blankline;\r\n    return FormattingKind_1.FormattingKind.Newline;\r\n}\r\nexports.getClassMemberFormatting = getClassMemberFormatting;\r\nfunction hasBody(node) {\r\n    if (utils_1.TypeGuards.isBodyableNode(node) && node.getBody() != null)\r\n        return true;\r\n    if (utils_1.TypeGuards.isBodiedNode(node))\r\n        return true;\r\n    return false;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/getClassMemberFormatting.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/getFormattingKindText.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/getFormattingKindText.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar FormattingKind_1 = __webpack_require__(/*! ./FormattingKind */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js\");\r\nfunction getFormattingKindText(formattingKind, opts) {\r\n    switch (formattingKind) {\r\n        case FormattingKind_1.FormattingKind.Space:\r\n            return \" \";\r\n        case FormattingKind_1.FormattingKind.Newline:\r\n            return opts.newLineKind;\r\n        case FormattingKind_1.FormattingKind.Blankline:\r\n            return opts.newLineKind + opts.newLineKind;\r\n        case FormattingKind_1.FormattingKind.None:\r\n            return \"\";\r\n        default:\r\n            throw new errors.NotImplementedError(\"Not implemented formatting kind: \" + formattingKind);\r\n    }\r\n}\r\nexports.getFormattingKindText = getFormattingKindText;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/getFormattingKindText.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/getGeneralFormatting.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/getGeneralFormatting.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar getClassMemberFormatting_1 = __webpack_require__(/*! ./getClassMemberFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getClassMemberFormatting.js\");\r\nvar getInterfaceMemberFormatting_1 = __webpack_require__(/*! ./getInterfaceMemberFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getInterfaceMemberFormatting.js\");\r\nvar getStatementedNodeChildFormatting_1 = __webpack_require__(/*! ./getStatementedNodeChildFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getStatementedNodeChildFormatting.js\");\r\nfunction getGeneralFormatting(parent, child) {\r\n    // todo: support more\r\n    if (utils_1.TypeGuards.isClassDeclaration(parent))\r\n        return getClassMemberFormatting_1.getClassMemberFormatting(parent, child);\r\n    if (utils_1.TypeGuards.isInterfaceDeclaration(parent))\r\n        return getInterfaceMemberFormatting_1.getInterfaceMemberFormatting(parent, child);\r\n    // todo: don't assume it's a statemented node here\r\n    return getStatementedNodeChildFormatting_1.getStatementedNodeChildFormatting(parent, child);\r\n}\r\nexports.getGeneralFormatting = getGeneralFormatting;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/getGeneralFormatting.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/getInterfaceMemberFormatting.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/getInterfaceMemberFormatting.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FormattingKind_1 = __webpack_require__(/*! ./FormattingKind */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js\");\r\nfunction getInterfaceMemberFormatting(parent, member) {\r\n    return FormattingKind_1.FormattingKind.Newline;\r\n}\r\nexports.getInterfaceMemberFormatting = getInterfaceMemberFormatting;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/getInterfaceMemberFormatting.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/getStatementedNodeChildFormatting.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/getStatementedNodeChildFormatting.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FormattingKind_1 = __webpack_require__(/*! ./FormattingKind */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js\");\r\nvar hasBody_1 = __webpack_require__(/*! ./hasBody */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/hasBody.js\");\r\nfunction getStatementedNodeChildFormatting(parent, member) {\r\n    if (hasBody_1.hasBody(member))\r\n        return FormattingKind_1.FormattingKind.Blankline;\r\n    return FormattingKind_1.FormattingKind.Newline;\r\n}\r\nexports.getStatementedNodeChildFormatting = getStatementedNodeChildFormatting;\r\nfunction getClausedNodeChildFormatting(parent, member) {\r\n    return FormattingKind_1.FormattingKind.Newline;\r\n}\r\nexports.getClausedNodeChildFormatting = getClausedNodeChildFormatting;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/getStatementedNodeChildFormatting.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/getTextFromFormattingEdits.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/getTextFromFormattingEdits.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction getTextFromFormattingEdits(sourceFile, formattingEdits) {\r\n    var e_1, _a;\r\n    // reverse the order\r\n    formattingEdits = tslib_1.__spread(formattingEdits).sort(function (a, b) { return b.getSpan().getStart() - a.getSpan().getStart(); });\r\n    var text = sourceFile.getFullText();\r\n    try {\r\n        for (var formattingEdits_1 = tslib_1.__values(formattingEdits), formattingEdits_1_1 = formattingEdits_1.next(); !formattingEdits_1_1.done; formattingEdits_1_1 = formattingEdits_1.next()) {\r\n            var textChange = formattingEdits_1_1.value;\r\n            var span = textChange.getSpan();\r\n            text = text.slice(0, span.getStart()) + textChange.getNewText() + text.slice(span.getEnd());\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (formattingEdits_1_1 && !formattingEdits_1_1.done && (_a = formattingEdits_1.return)) _a.call(formattingEdits_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return text;\r\n}\r\nexports.getTextFromFormattingEdits = getTextFromFormattingEdits;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/getTextFromFormattingEdits.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/hasBody.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/hasBody.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction hasBody(node) {\r\n    if (utils_1.TypeGuards.isBodyableNode(node) && node.hasBody())\r\n        return true;\r\n    if (utils_1.TypeGuards.isBodiedNode(node))\r\n        return true;\r\n    return utils_1.TypeGuards.isInterfaceDeclaration(node) || utils_1.TypeGuards.isClassDeclaration(node) || utils_1.TypeGuards.isEnumDeclaration(node);\r\n}\r\nexports.hasBody = hasBody;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/hasBody.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FormattingKind */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/FormattingKind.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getClassMemberFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getClassMemberFormatting.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getFormattingKindText */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getFormattingKindText.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getGeneralFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getGeneralFormatting.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getInterfaceMemberFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getInterfaceMemberFormatting.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getStatementedNodeChildFormatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getStatementedNodeChildFormatting.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getTextFromFormattingEdits */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/getTextFromFormattingEdits.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./hasBody */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/hasBody.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/getEndIndexFromArray.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/getEndIndexFromArray.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Gets the end index from a possibly undefined array.\r\n * @param array - Array that could possibly be undefined.\r\n */\r\nfunction getEndIndexFromArray(array) {\r\n    return array == null ? 0 : array.length;\r\n}\r\nexports.getEndIndexFromArray = getEndIndexFromArray;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/getEndIndexFromArray.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/getInsertPosFromIndex.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/getInsertPosFromIndex.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar constants_1 = __webpack_require__(/*! ../../constants */ \"./node_modules/ts-simple-ast/dist/constants.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar textSeek_1 = __webpack_require__(/*! ../textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\");\r\n/**\r\n * Gets the insert pos from an index.\r\n */\r\nfunction getInsertPosFromIndex(index, syntaxList, children) {\r\n    if (index === 0) {\r\n        var parent = syntaxList.getParentOrThrow();\r\n        if (utils_1.TypeGuards.isSourceFile(parent))\r\n            return parent.getFullText()[0] === constants_1.Chars.BOM ? 1 : 0;\r\n        else if (utils_1.TypeGuards.isCaseClause(parent) || utils_1.TypeGuards.isDefaultClause(parent)) {\r\n            var block = parent.getFirstChildIfKind(typescript_1.SyntaxKind.Block);\r\n            var colonToken = parent.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.ColonToken);\r\n            return colonToken.getEnd();\r\n        }\r\n        var isInline = syntaxList !== parent.getChildSyntaxList();\r\n        if (isInline)\r\n            return syntaxList.getStart();\r\n        var parentContainer = getParentContainer(parent);\r\n        var openBraceToken = parentContainer.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.OpenBraceToken);\r\n        return openBraceToken.getEnd();\r\n    }\r\n    else\r\n        return children[index - 1].getEnd();\r\n}\r\nexports.getInsertPosFromIndex = getInsertPosFromIndex;\r\nfunction getEndPosFromIndex(index, parent, children, fullText) {\r\n    var endPos;\r\n    if (index === children.length) {\r\n        if (utils_1.TypeGuards.isSourceFile(parent))\r\n            endPos = parent.getEnd();\r\n        else if (utils_1.TypeGuards.isCaseClause(parent) || utils_1.TypeGuards.isDefaultClause(parent))\r\n            endPos = parent.getEnd();\r\n        else {\r\n            var parentContainer = getParentContainer(parent);\r\n            var closeBraceToken = parentContainer.getLastChildByKind(typescript_1.SyntaxKind.CloseBraceToken);\r\n            if (closeBraceToken == null)\r\n                endPos = parent.getEnd();\r\n            else\r\n                endPos = closeBraceToken.getNonWhitespaceStart();\r\n        }\r\n    }\r\n    else\r\n        endPos = children[index].getNonWhitespaceStart();\r\n    // use the start of the current line instead of the end of the previous line so that\r\n    // this works the same for code at the start of the file\r\n    return textSeek_1.getPosAtStartOfLineOrNonWhitespace(fullText, endPos);\r\n}\r\nexports.getEndPosFromIndex = getEndPosFromIndex;\r\nfunction getParentContainer(parent) {\r\n    if (utils_1.TypeGuards.isBodiedNode(parent))\r\n        return parent.getBody();\r\n    if (utils_1.TypeGuards.isBodyableNode(parent))\r\n        return parent.getBodyOrThrow();\r\n    else\r\n        return parent;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/getInsertPosFromIndex.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/getMixinStructureFunctions.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/getMixinStructureFunctions.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction fromAbstractableNode(node) {\r\n    return {\r\n        isAbstract: node.isAbstract()\r\n    };\r\n}\r\nexports.fromAbstractableNode = fromAbstractableNode;\r\nfunction fromAmbientableNode(node) {\r\n    return {\r\n        hasDeclareKeyword: node.hasDeclareKeyword()\r\n    };\r\n}\r\nexports.fromAmbientableNode = fromAmbientableNode;\r\nfunction fromAsyncableNode(node) {\r\n    return {\r\n        isAsync: node.isAsync()\r\n    };\r\n}\r\nexports.fromAsyncableNode = fromAsyncableNode;\r\nfunction fromAwaitableNode(node) {\r\n    return {\r\n        isAwaited: node.isAwaited()\r\n    };\r\n}\r\nexports.fromAwaitableNode = fromAwaitableNode;\r\nfunction fromExportableNode(node) {\r\n    return {\r\n        isDefaultExport: node.hasDefaultKeyword(),\r\n        isExported: node.hasExportKeyword()\r\n    };\r\n}\r\nexports.fromExportableNode = fromExportableNode;\r\nfunction fromGeneratorableNode(node) {\r\n    return {\r\n        isGenerator: node.isGenerator()\r\n    };\r\n}\r\nexports.fromGeneratorableNode = fromGeneratorableNode;\r\nfunction fromReturnTypedNode(node) {\r\n    var returnTypeNode = node.getReturnTypeNode();\r\n    return {\r\n        returnType: returnTypeNode == null ? undefined : returnTypeNode.getText()\r\n    };\r\n}\r\nexports.fromReturnTypedNode = fromReturnTypedNode;\r\nfunction fromStaticableNode(node) {\r\n    return {\r\n        isStatic: node.isStatic()\r\n    };\r\n}\r\nexports.fromStaticableNode = fromStaticableNode;\r\nfunction fromScopeableNode(node) {\r\n    return {\r\n        scope: node.getScope()\r\n    };\r\n}\r\nexports.fromScopeableNode = fromScopeableNode;\r\nfunction fromScopedNode(node) {\r\n    return {\r\n        scope: node.hasScopeKeyword() ? node.getScope() : undefined\r\n    };\r\n}\r\nexports.fromScopedNode = fromScopedNode;\r\nfunction fromExtendsClauseableNode(node) {\r\n    var exts = node.getExtends();\r\n    return {\r\n        extends: exts.length === 0 ? undefined : exts.map(function (e) { return e.getText(); })\r\n    };\r\n}\r\nexports.fromExtendsClauseableNode = fromExtendsClauseableNode;\r\nfunction fromImplementsClauseableNode(node) {\r\n    var implementsNodes = node.getImplements();\r\n    return {\r\n        implements: implementsNodes.length === 0 ? undefined : implementsNodes.map(function (e) { return e.getText(); })\r\n    };\r\n}\r\nexports.fromImplementsClauseableNode = fromImplementsClauseableNode;\r\nfunction fromQuestionTokenableNode(node) {\r\n    return {\r\n        hasQuestionToken: node.hasQuestionToken()\r\n    };\r\n}\r\nexports.fromQuestionTokenableNode = fromQuestionTokenableNode;\r\nfunction fromReadonlyableNode(node) {\r\n    return {\r\n        isReadonly: node.isReadonly()\r\n    };\r\n}\r\nexports.fromReadonlyableNode = fromReadonlyableNode;\r\nfunction fromTypedNode(node) {\r\n    var typeNode = node.getTypeNode();\r\n    return {\r\n        type: typeNode == null ? undefined : typeNode.getText()\r\n    };\r\n}\r\nexports.fromTypedNode = fromTypedNode;\r\nfunction fromInitializerExpressionableNode(node) {\r\n    var initializer = node.getInitializer();\r\n    return {\r\n        initializer: initializer == null ? undefined : initializer.getText()\r\n    };\r\n}\r\nexports.fromInitializerExpressionableNode = fromInitializerExpressionableNode;\r\nfunction fromNamedNode(node) {\r\n    return {\r\n        name: node.getName()\r\n    };\r\n}\r\nexports.fromNamedNode = fromNamedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/getMixinStructureFunctions.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/getNodeOrNodesToReturn.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/getNodeOrNodesToReturn.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getNodeOrNodesToReturn(nodes, index, length) {\r\n    return length > 0 ? getNodesToReturn(nodes, index, length) : nodes[index];\r\n}\r\nexports.getNodeOrNodesToReturn = getNodeOrNodesToReturn;\r\nfunction getNodesToReturn(nodes, index, length) {\r\n    return nodes.slice(index, index + length);\r\n}\r\nexports.getNodesToReturn = getNodesToReturn;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/getNodeOrNodesToReturn.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/getRangeFromArray.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/getRangeFromArray.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction getRangeFromArray(array, index, length, expectedKind) {\r\n    var e_1, _a;\r\n    var children = array.slice(index, index + length);\r\n    if (children.length !== length)\r\n        throw new errors.NotImplementedError(\"Unexpected! Inserted \" + length + \" child/children, but \" + children.length + \" were inserted.\");\r\n    try {\r\n        for (var children_1 = tslib_1.__values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\r\n            var child = children_1_1.value;\r\n            if (child.getKind() !== expectedKind)\r\n                throw new errors.NotImplementedError(\"Unexpected! Inserting syntax kind of \" + utils_1.getSyntaxKindName(expectedKind) +\r\n                    (\", but \" + child.getKindName() + \" was inserted.\"));\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return children;\r\n}\r\nexports.getRangeFromArray = getRangeFromArray;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/getRangeFromArray.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n/* tslint:disable */\r\n// DO NOT MANUALLY EDIT!! File generated via: npm run code-generate\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar objectAssign = __webpack_require__(/*! object-assign */ \"object-assign\");\r\nvar getMixinStructureFuncs = __webpack_require__(/*! ./getMixinStructureFunctions */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getMixinStructureFunctions.js\");\r\nfunction fromConstructorDeclarationOverload(node) {\r\n    var structure = {};\r\n    objectAssign(structure, getMixinStructureFuncs.fromScopedNode(node));\r\n    return structure;\r\n}\r\nexports.fromConstructorDeclarationOverload = fromConstructorDeclarationOverload;\r\nfunction fromMethodDeclarationOverload(node) {\r\n    var structure = {};\r\n    objectAssign(structure, getMixinStructureFuncs.fromStaticableNode(node));\r\n    objectAssign(structure, getMixinStructureFuncs.fromAbstractableNode(node));\r\n    objectAssign(structure, getMixinStructureFuncs.fromScopedNode(node));\r\n    return structure;\r\n}\r\nexports.fromMethodDeclarationOverload = fromMethodDeclarationOverload;\r\nfunction fromFunctionDeclarationOverload(node) {\r\n    var structure = {};\r\n    objectAssign(structure, getMixinStructureFuncs.fromAmbientableNode(node));\r\n    objectAssign(structure, getMixinStructureFuncs.fromExportableNode(node));\r\n    return structure;\r\n}\r\nexports.fromFunctionDeclarationOverload = fromFunctionDeclarationOverload;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getEndIndexFromArray */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getEndIndexFromArray.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getInsertPosFromIndex */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getInsertPosFromIndex.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getMixinStructureFunctions */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getMixinStructureFunctions.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getNodeOrNodesToReturn */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getNodeOrNodesToReturn.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getRangeFromArray */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getRangeFromArray.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getStructureFunctions */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/getStructureFunctions.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./verifyAndGetIndex */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/verifyAndGetIndex.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/helpers/verifyAndGetIndex.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/helpers/verifyAndGetIndex.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\n/**\r\n * Verifies to see if an index or negative index exists within a specified length.\r\n * @param index - Index.\r\n * @param length - Length index could be in.\r\n */\r\nfunction verifyAndGetIndex(index, length) {\r\n    var newIndex = index < 0 ? length + index : index;\r\n    if (newIndex < 0)\r\n        throw new errors.InvalidOperationError(\"Invalid index: The max negative index is \" + length * -1 + \", but \" + index + \" was specified.\");\r\n    if (index > length)\r\n        throw new errors.InvalidOperationError(\"Invalid index: The max index is \" + length + \", but \" + index + \" was specified.\");\r\n    return newIndex;\r\n}\r\nexports.verifyAndGetIndex = verifyAndGetIndex;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/helpers/verifyAndGetIndex.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./code */ \"./node_modules/ts-simple-ast/dist/manipulation/code/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./formatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./helpers */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./manipulations */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./nodeHandlers */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./textChecks */ \"./node_modules/ts-simple-ast/dist/manipulation/textChecks/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./textManipulators */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nfunction doManipulation(sourceFile, textManipulator, nodeHandler) {\r\n    var newFileText = textManipulator.getNewText(sourceFile.getFullText());\r\n    try {\r\n        var replacementSourceFile = sourceFile.context.compilerFactory.createCompilerSourceFileFromText(sourceFile.getFilePath(), newFileText);\r\n        nodeHandler.handleNode(sourceFile, replacementSourceFile, replacementSourceFile);\r\n    }\r\n    catch (err) {\r\n        throw new errors.InvalidOperationError(err.message + \"\\n\" +\r\n            \"-- Details --\\n\" +\r\n            (\"Path: \" + sourceFile.getFilePath() + \"\\n\") +\r\n            (\"Text: \" + JSON.stringify(textManipulator.getTextForError(newFileText))));\r\n    }\r\n}\r\nexports.doManipulation = doManipulation;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/manipulations/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/manipulations/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./insertion */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/insertion.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./move */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/move.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./removal */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/removal.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./replaction */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/replaction.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/manipulations/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/manipulations/insertion.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/manipulations/insertion.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar constants_1 = __webpack_require__(/*! ../../constants */ \"./node_modules/ts-simple-ast/dist/constants.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar helpers_1 = __webpack_require__(/*! ../helpers */ \"./node_modules/ts-simple-ast/dist/manipulation/helpers/index.js\");\r\nvar nodeHandlers_1 = __webpack_require__(/*! ../nodeHandlers */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js\");\r\nvar textManipulators_1 = __webpack_require__(/*! ../textManipulators */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js\");\r\nvar doManipulation_1 = __webpack_require__(/*! ./doManipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js\");\r\n/**\r\n * Inserts a text range into a parent.\r\n */\r\nfunction insertIntoParentTextRange(opts) {\r\n    var insertPos = opts.insertPos, newText = opts.newText, parent = opts.parent;\r\n    // todo: this should only forget the existing node if the kind changes\r\n    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.InsertionTextManipulator({\r\n        insertPos: insertPos,\r\n        newText: newText,\r\n        replacingLength: opts.replacing == null ? undefined : opts.replacing.textLength\r\n    }), new nodeHandlers_1.NodeHandlerFactory().getForRange({\r\n        parent: parent,\r\n        start: insertPos,\r\n        end: insertPos + newText.length,\r\n        replacingLength: opts.replacing == null ? undefined : opts.replacing.textLength,\r\n        replacingNodes: opts.replacing == null ? undefined : opts.replacing.nodes,\r\n        customMappings: opts.customMappings\r\n    }));\r\n}\r\nexports.insertIntoParentTextRange = insertIntoParentTextRange;\r\nfunction insertIntoCommaSeparatedNodes(opts) {\r\n    // todo: this needs to be fixed/cleaned up in the future, but this is good enough for now\r\n    var currentNodes = opts.currentNodes, insertIndex = opts.insertIndex, parent = opts.parent;\r\n    var nextNode = currentNodes[insertIndex];\r\n    var previousNode = currentNodes[insertIndex - 1];\r\n    var separator = opts.useNewLines ? parent.context.manipulationSettings.getNewLineKindAsString() : \" \";\r\n    var childIndentationText = parent.getParentOrThrow().getChildIndentationText();\r\n    var parentNextSibling = parent.getNextSibling();\r\n    var isContained = parentNextSibling != null && (parentNextSibling.getKind() === typescript_1.SyntaxKind.CloseBraceToken || parentNextSibling.getKind() === typescript_1.SyntaxKind.CloseBracketToken);\r\n    var newText = opts.newText;\r\n    if (previousNode != null) {\r\n        var nextEndStart = nextNode == null ? (isContained ? parentNextSibling.getStart(true) : parent.getEnd()) : nextNode.getStart(true);\r\n        var insertPos = previousNode.getEnd();\r\n        newText = \",\" + separator + newText;\r\n        if (nextNode != null) {\r\n            newText += \",\" + separator;\r\n            if (opts.useNewLines)\r\n                newText += childIndentationText;\r\n        }\r\n        else if (opts.useNewLines)\r\n            newText += separator + parent.getParentOrThrow().getIndentationText();\r\n        else if (opts.surroundWithSpaces)\r\n            newText += \" \";\r\n        insertIntoParentTextRange({\r\n            insertPos: insertPos,\r\n            newText: newText,\r\n            parent: parent,\r\n            replacing: { textLength: nextEndStart - insertPos }\r\n        });\r\n    }\r\n    else if (nextNode != null) {\r\n        if (opts.useNewLines)\r\n            newText = separator + newText;\r\n        else if (opts.surroundWithSpaces)\r\n            newText = \" \" + newText;\r\n        newText += \",\" + separator;\r\n        if (opts.useNewLines)\r\n            newText += childIndentationText;\r\n        var insertPos = isContained ? parent.getPos() : parent.getStart(true);\r\n        insertIntoParentTextRange({\r\n            insertPos: insertPos,\r\n            newText: newText,\r\n            parent: parent,\r\n            replacing: { textLength: nextNode.getStart(true) - insertPos }\r\n        });\r\n    }\r\n    else {\r\n        if (opts.useNewLines)\r\n            newText = separator + newText + parent.context.manipulationSettings.getNewLineKindAsString() + parent.getParentOrThrow().getIndentationText();\r\n        else if (opts.surroundWithSpaces)\r\n            newText = \" \" + newText + \" \";\r\n        insertIntoParentTextRange({\r\n            insertPos: parent.getPos(),\r\n            newText: newText,\r\n            parent: parent,\r\n            replacing: { textLength: parent.getNextSiblingOrThrow().getStart() - parent.getPos() }\r\n        });\r\n    }\r\n}\r\nexports.insertIntoCommaSeparatedNodes = insertIntoCommaSeparatedNodes;\r\n/**\r\n * Used to insert non-comma separated nodes into braces or a source file.\r\n */\r\nfunction insertIntoBracesOrSourceFile(opts) {\r\n    var parent = opts.parent, index = opts.index, children = opts.children;\r\n    var fullText = parent.sourceFile.getFullText();\r\n    var insertPos = helpers_1.getInsertPosFromIndex(index, parent.getChildSyntaxListOrThrow(), children);\r\n    var endPos = helpers_1.getEndPosFromIndex(index, parent, children, fullText);\r\n    var replacingLength = endPos - insertPos;\r\n    var newText = getNewText();\r\n    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.InsertionTextManipulator({ insertPos: insertPos, replacingLength: replacingLength, newText: newText }), new nodeHandlers_1.NodeHandlerFactory().getForRange({\r\n        parent: parent.getChildSyntaxListOrThrow(),\r\n        start: insertPos,\r\n        end: insertPos + newText.length,\r\n        replacingLength: replacingLength\r\n    }));\r\n    function getNewText() {\r\n        // todo: make this configurable\r\n        var writer = parent.getWriterWithChildIndentation();\r\n        opts.write(writer, {\r\n            previousMember: getChild(children[index - 1]),\r\n            nextMember: getChild(children[index]),\r\n            isStartOfFile: insertPos === 0 || insertPos === 1 && fullText[0] === constants_1.Chars.BOM\r\n        });\r\n        return writer.toString();\r\n        function getChild(child) {\r\n            // ensure it passes the implementation\r\n            if (child == null)\r\n                return child;\r\n            else if (utils_1.TypeGuards.isOverloadableNode(child))\r\n                return child.getImplementation() || child;\r\n            else\r\n                return child;\r\n        }\r\n    }\r\n}\r\nexports.insertIntoBracesOrSourceFile = insertIntoBracesOrSourceFile;\r\n/**\r\n * Glues together insertIntoBracesOrSourceFile and getRangeFromArray.\r\n * @param opts - Options to do this operation.\r\n */\r\nfunction insertIntoBracesOrSourceFileWithGetChildren(opts) {\r\n    if (opts.structures.length === 0)\r\n        return [];\r\n    var startChildren = opts.getIndexedChildren();\r\n    var parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();\r\n    var index = helpers_1.verifyAndGetIndex(opts.index, startChildren.length);\r\n    var childIndex = getChildIndex();\r\n    insertIntoBracesOrSourceFile({\r\n        parent: opts.parent,\r\n        index: getChildIndex(),\r\n        children: parentSyntaxList.getChildren(),\r\n        write: opts.write\r\n    });\r\n    return helpers_1.getRangeFromArray(opts.getIndexedChildren(), opts.index, opts.structures.length, opts.expectedKind);\r\n    function getChildIndex() {\r\n        if (index === 0)\r\n            return 0;\r\n        // get the previous member in order to get the implementation signature + 1\r\n        return startChildren[index - 1].getChildIndex() + 1;\r\n    }\r\n}\r\nexports.insertIntoBracesOrSourceFileWithGetChildren = insertIntoBracesOrSourceFileWithGetChildren;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/manipulations/insertion.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/manipulations/move.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/manipulations/move.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar nodeHandlers_1 = __webpack_require__(/*! ../nodeHandlers */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js\");\r\nvar textManipulators_1 = __webpack_require__(/*! ../textManipulators */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js\");\r\nvar doManipulation_1 = __webpack_require__(/*! ./doManipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js\");\r\n/**\r\n * Changes the child older of two nodes within a parent.\r\n * @param opts - Options.\r\n */\r\nfunction changeChildOrder(opts) {\r\n    var parent = opts.parent, getSiblingFormatting = opts.getSiblingFormatting, oldIndex = opts.oldIndex, newIndex = opts.newIndex;\r\n    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.ChangingChildOrderTextManipulator(opts), new nodeHandlers_1.NodeHandlerFactory().getForChangingChildOrder(opts));\r\n}\r\nexports.changeChildOrder = changeChildOrder;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/manipulations/move.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/manipulations/removal.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/manipulations/removal.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js\");\r\nvar nodeHandlers_1 = __webpack_require__(/*! ../nodeHandlers */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js\");\r\nvar textManipulators_1 = __webpack_require__(/*! ../textManipulators */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js\");\r\nvar doManipulation_1 = __webpack_require__(/*! ./doManipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js\");\r\nfunction removeChildren(opts) {\r\n    var children = opts.children;\r\n    if (children.length === 0)\r\n        return;\r\n    doManipulation_1.doManipulation(children[0].getSourceFile(), new textManipulators_1.RemoveChildrenTextManipulator(opts), new nodeHandlers_1.NodeHandlerFactory().getForChildIndex({\r\n        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),\r\n        childIndex: children[0].getChildIndex(),\r\n        childCount: -1 * children.length\r\n    }));\r\n}\r\nexports.removeChildren = removeChildren;\r\nfunction removeChildrenWithFormattingFromCollapsibleSyntaxList(opts) {\r\n    var children = opts.children;\r\n    if (children.length === 0)\r\n        return;\r\n    var syntaxList = children[0].getParentSyntaxListOrThrow();\r\n    if (syntaxList.getChildCount() === children.length) {\r\n        removeChildrenWithFormatting({\r\n            children: [syntaxList],\r\n            getSiblingFormatting: function () { return formatting_1.FormattingKind.None; }\r\n        });\r\n    }\r\n    else\r\n        removeChildrenWithFormatting(opts);\r\n}\r\nexports.removeChildrenWithFormattingFromCollapsibleSyntaxList = removeChildrenWithFormattingFromCollapsibleSyntaxList;\r\nfunction removeChildrenWithFormatting(opts) {\r\n    var children = opts.children, getSiblingFormatting = opts.getSiblingFormatting;\r\n    if (children.length === 0)\r\n        return;\r\n    doManipulation_1.doManipulation(children[0].sourceFile, new textManipulators_1.RemoveChildrenWithFormattingTextManipulator({\r\n        children: children,\r\n        getSiblingFormatting: getSiblingFormatting\r\n    }), new nodeHandlers_1.NodeHandlerFactory().getForChildIndex({\r\n        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),\r\n        childIndex: children[0].getChildIndex(),\r\n        childCount: -1 * children.length\r\n    }));\r\n}\r\nexports.removeChildrenWithFormatting = removeChildrenWithFormatting;\r\nfunction removeOverloadableClassMember(classMember) {\r\n    if (classMember.isOverload()) {\r\n        if (classMember.getParentOrThrow().isAmbient())\r\n            removeClassMember(classMember);\r\n        else\r\n            removeChildren({ children: [classMember], removeFollowingSpaces: true, removeFollowingNewLines: true });\r\n    }\r\n    else\r\n        removeClassMembers(tslib_1.__spread(classMember.getOverloads(), [classMember]));\r\n}\r\nexports.removeOverloadableClassMember = removeOverloadableClassMember;\r\nfunction removeClassMember(classMember) {\r\n    removeClassMembers([classMember]);\r\n}\r\nexports.removeClassMember = removeClassMember;\r\nfunction removeClassMembers(classMembers) {\r\n    removeChildrenWithFormatting({\r\n        getSiblingFormatting: formatting_1.getClassMemberFormatting,\r\n        children: classMembers\r\n    });\r\n}\r\nexports.removeClassMembers = removeClassMembers;\r\nfunction removeInterfaceMember(classMember) {\r\n    removeInterfaceMembers([classMember]);\r\n}\r\nexports.removeInterfaceMember = removeInterfaceMember;\r\nfunction removeInterfaceMembers(classMembers) {\r\n    removeChildrenWithFormatting({\r\n        getSiblingFormatting: formatting_1.getInterfaceMemberFormatting,\r\n        children: classMembers\r\n    });\r\n}\r\nexports.removeInterfaceMembers = removeInterfaceMembers;\r\nfunction removeCommaSeparatedChild(child) {\r\n    var childrenToRemove = [child];\r\n    var syntaxList = child.getParentSyntaxListOrThrow();\r\n    var isRemovingFirstChild = childrenToRemove[0] === syntaxList.getFirstChild();\r\n    addNextCommaIfAble();\r\n    addPreviousCommaIfAble();\r\n    removeChildren({\r\n        children: childrenToRemove,\r\n        removePrecedingSpaces: !isRemovingFirstChild,\r\n        removeFollowingSpaces: isRemovingFirstChild,\r\n        removePrecedingNewLines: !isRemovingFirstChild,\r\n        removeFollowingNewLines: isRemovingFirstChild\r\n    });\r\n    function addNextCommaIfAble() {\r\n        var commaToken = child.getNextSiblingIfKind(typescript_1.SyntaxKind.CommaToken);\r\n        if (commaToken != null)\r\n            childrenToRemove.push(commaToken);\r\n    }\r\n    function addPreviousCommaIfAble() {\r\n        if (syntaxList.getLastChild() !== childrenToRemove[childrenToRemove.length - 1])\r\n            return;\r\n        var precedingComma = child.getPreviousSiblingIfKind(typescript_1.SyntaxKind.CommaToken);\r\n        if (precedingComma != null)\r\n            childrenToRemove.unshift(precedingComma);\r\n    }\r\n}\r\nexports.removeCommaSeparatedChild = removeCommaSeparatedChild;\r\nfunction removeOverloadableStatementedNodeChild(node) {\r\n    if (node.isOverload())\r\n        removeChildren({ children: [node], removeFollowingSpaces: true, removeFollowingNewLines: true });\r\n    else\r\n        removeStatementedNodeChildren(tslib_1.__spread(node.getOverloads(), [node]));\r\n}\r\nexports.removeOverloadableStatementedNodeChild = removeOverloadableStatementedNodeChild;\r\nfunction removeStatementedNodeChild(node) {\r\n    removeStatementedNodeChildren([node]);\r\n}\r\nexports.removeStatementedNodeChild = removeStatementedNodeChild;\r\nfunction removeStatementedNodeChildren(nodes) {\r\n    removeChildrenWithFormatting({\r\n        getSiblingFormatting: formatting_1.getStatementedNodeChildFormatting,\r\n        children: nodes\r\n    });\r\n}\r\nexports.removeStatementedNodeChildren = removeStatementedNodeChildren;\r\nfunction removeClausedNodeChild(node) {\r\n    removeClausedNodeChildren([node]);\r\n}\r\nexports.removeClausedNodeChild = removeClausedNodeChild;\r\nfunction removeClausedNodeChildren(nodes) {\r\n    removeChildrenWithFormatting({\r\n        getSiblingFormatting: formatting_1.getClausedNodeChildFormatting,\r\n        children: nodes\r\n    });\r\n}\r\nexports.removeClausedNodeChildren = removeClausedNodeChildren;\r\nfunction unwrapNode(node) {\r\n    doManipulation_1.doManipulation(node.sourceFile, new textManipulators_1.UnwrapTextManipulator(node), new nodeHandlers_1.NodeHandlerFactory().getForUnwrappingNode(node));\r\n}\r\nexports.unwrapNode = unwrapNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/manipulations/removal.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/manipulations/replaction.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/manipulations/replaction.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar nodeHandlers_1 = __webpack_require__(/*! ../nodeHandlers */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js\");\r\nvar textManipulators_1 = __webpack_require__(/*! ../textManipulators */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js\");\r\nvar doManipulation_1 = __webpack_require__(/*! ./doManipulation */ \"./node_modules/ts-simple-ast/dist/manipulation/manipulations/doManipulation.js\");\r\n/**\r\n * Replaces text in a source file. Will forget any changed nodes.\r\n */\r\nfunction replaceNodeText(opts) {\r\n    doManipulation_1.doManipulation(opts.sourceFile, new textManipulators_1.InsertionTextManipulator({\r\n        insertPos: opts.start,\r\n        newText: opts.newText,\r\n        replacingLength: opts.replacingLength\r\n    }), new nodeHandlers_1.NodeHandlerFactory().getForForgetChanged(opts.sourceFile.context.compilerFactory));\r\n}\r\nexports.replaceNodeText = replaceNodeText;\r\n/**\r\n * Replaces the text in a source file and assumes only the nodes will shift (no tree structure should change).\r\n *\r\n * This is very useful when making formatting changes that won't change the AST structure.\r\n */\r\nfunction replaceSourceFileTextForFormatting(opts) {\r\n    var sourceFile = opts.sourceFile, newText = opts.newText;\r\n    doManipulation_1.doManipulation(sourceFile, new textManipulators_1.FullReplacementTextManipulator(newText), new nodeHandlers_1.NodeHandlerFactory().getForStraightReplacement(sourceFile.context.compilerFactory));\r\n}\r\nexports.replaceSourceFileTextForFormatting = replaceSourceFileTextForFormatting;\r\n/**\r\n * Replaces the text in a source file based on rename locations.\r\n */\r\nfunction replaceSourceFileTextForRename(opts) {\r\n    var sourceFile = opts.sourceFile, renameLocations = opts.renameLocations, newName = opts.newName;\r\n    var nodeHandlerFactory = new nodeHandlers_1.NodeHandlerFactory();\r\n    doManipulation_1.doManipulation(sourceFile, new textManipulators_1.RenameLocationTextManipulator(renameLocations, newName), nodeHandlerFactory.getForTryOrForget(nodeHandlerFactory.getForForgetChanged(sourceFile.context.compilerFactory)));\r\n}\r\nexports.replaceSourceFileTextForRename = replaceSourceFileTextForRename;\r\n/**\r\n * Replaces a node text while possibly creating new child nodes.\r\n */\r\nfunction replaceTextPossiblyCreatingChildNodes(opts) {\r\n    var replacePos = opts.replacePos, replacingLength = opts.replacingLength, newText = opts.newText, parent = opts.parent;\r\n    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.InsertionTextManipulator({\r\n        insertPos: replacePos,\r\n        replacingLength: replacingLength,\r\n        newText: newText\r\n    }), new nodeHandlers_1.NodeHandlerFactory().getForRange({\r\n        parent: parent,\r\n        start: replacePos,\r\n        end: replacePos + newText.length\r\n    }));\r\n}\r\nexports.replaceTextPossiblyCreatingChildNodes = replaceTextPossiblyCreatingChildNodes;\r\n/**\r\n * Replaces a source file for a file path move.\r\n */\r\nfunction replaceSourceFileForFilePathMove(opts) {\r\n    var sourceFile = opts.sourceFile, newFilePath = opts.newFilePath;\r\n    var replacementSourceFile = sourceFile.context.compilerFactory.createCompilerSourceFileFromText(newFilePath, sourceFile.getFullText());\r\n    new nodeHandlers_1.NodeHandlerFactory().getForStraightReplacement(sourceFile.context.compilerFactory)\r\n        .handleNode(sourceFile, replacementSourceFile, replacementSourceFile);\r\n}\r\nexports.replaceSourceFileForFilePathMove = replaceSourceFileForFilePathMove;\r\n/**\r\n * Replaces the source file and all its descendant nodes in the cache.\r\n * @param sourceFile - Source file.\r\n */\r\nfunction replaceSourceFileForCacheUpdate(sourceFile) {\r\n    replaceSourceFileForFilePathMove({ sourceFile: sourceFile, newFilePath: sourceFile.getFilePath() });\r\n}\r\nexports.replaceSourceFileForCacheUpdate = replaceSourceFileForCacheUpdate;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/manipulations/replaction.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ChangeChildOrderParentHandler.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ChangeChildOrderParentHandler.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar NodeHandlerHelper_1 = __webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\");\r\nvar StraightReplacementNodeHandler_1 = __webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\");\r\n/**\r\n * Node handler for dealing with a parent who has a child that will change order.\r\n */\r\nvar ChangeChildOrderParentHandler = /** @class */ (function () {\r\n    function ChangeChildOrderParentHandler(compilerFactory, opts) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);\r\n        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);\r\n        this.oldIndex = opts.oldIndex;\r\n        this.newIndex = opts.newIndex;\r\n    }\r\n    ChangeChildOrderParentHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        var currentNodeChildren = this.getChildrenInNewOrder(currentNode.getCompilerChildren());\r\n        var newNodeChildren = newNode.getChildren(newSourceFile);\r\n        errors.throwIfNotEqual(newNodeChildren.length, currentNodeChildren.length, \"New children length should match the old children length.\");\r\n        for (var i = 0; i < newNodeChildren.length; i++)\r\n            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren[i], newNodeChildren[i], newSourceFile);\r\n        this.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n    };\r\n    ChangeChildOrderParentHandler.prototype.getChildrenInNewOrder = function (children) {\r\n        var result = tslib_1.__spread(children);\r\n        var movingNode = result.splice(this.oldIndex, 1)[0];\r\n        result.splice(this.newIndex, 0, movingNode);\r\n        return result;\r\n    };\r\n    return ChangeChildOrderParentHandler;\r\n}());\r\nexports.ChangeChildOrderParentHandler = ChangeChildOrderParentHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ChangeChildOrderParentHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/DefaultParentHandler.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/DefaultParentHandler.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar NodeHandlerHelper_1 = __webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\");\r\nvar StraightReplacementNodeHandler_1 = __webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\");\r\n/**\r\n * Handler for deailing with a parent that is going to have a child replaced.\r\n */\r\nvar DefaultParentHandler = /** @class */ (function () {\r\n    function DefaultParentHandler(compilerFactory, opts) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);\r\n        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);\r\n        this.childCount = opts.childCount;\r\n        this.isFirstChild = opts.isFirstChild;\r\n        this.replacingNodes = opts.replacingNodes == null ? undefined : opts.replacingNodes.map(function (n) { return n.compilerNode; });\r\n        this.customMappings = opts.customMappings;\r\n    }\r\n    DefaultParentHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        var currentNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(currentNode.getCompilerChildren()));\r\n        var newNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(newNode.getChildren(newSourceFile)));\r\n        var count = this.childCount;\r\n        // handle any custom mappings\r\n        this.handleCustomMappings(newNode);\r\n        // get the first child\r\n        while (!currentNodeChildren.done && !newNodeChildren.done && !this.isFirstChild(currentNodeChildren.peek, newNodeChildren.peek))\r\n            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);\r\n        // try replacing any nodes\r\n        while (!currentNodeChildren.done && this.tryReplaceNode(currentNodeChildren.peek))\r\n            currentNodeChildren.next();\r\n        // add or remove the items\r\n        if (count > 0) {\r\n            while (count > 0) {\r\n                newNodeChildren.next();\r\n                count--;\r\n            }\r\n        }\r\n        else if (count < 0) {\r\n            while (count < 0) {\r\n                this.helper.forgetNodeIfNecessary(currentNodeChildren.next());\r\n                count++;\r\n            }\r\n        }\r\n        // handle the rest\r\n        while (!currentNodeChildren.done)\r\n            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);\r\n        // ensure the new children iterator is done too\r\n        if (!newNodeChildren.done)\r\n            throw new Error(\"Error replacing tree: Should not have children left over.\");\r\n        this.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n    };\r\n    DefaultParentHandler.prototype.handleCustomMappings = function (newParentNode) {\r\n        var e_1, _a;\r\n        if (this.customMappings == null)\r\n            return;\r\n        var customMappings = this.customMappings(newParentNode);\r\n        try {\r\n            for (var customMappings_1 = tslib_1.__values(customMappings), customMappings_1_1 = customMappings_1.next(); !customMappings_1_1.done; customMappings_1_1 = customMappings_1.next()) {\r\n                var mapping = customMappings_1_1.value;\r\n                mapping.currentNode.context.compilerFactory.replaceCompilerNode(mapping.currentNode, mapping.newNode);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (customMappings_1_1 && !customMappings_1_1.done && (_a = customMappings_1.return)) _a.call(customMappings_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    DefaultParentHandler.prototype.tryReplaceNode = function (currentCompilerNode) {\r\n        if (this.replacingNodes == null || this.replacingNodes.length === 0)\r\n            return false;\r\n        var index = this.replacingNodes.indexOf(currentCompilerNode);\r\n        if (index === -1)\r\n            return false;\r\n        this.replacingNodes.splice(index, 1);\r\n        this.helper.forgetNodeIfNecessary(currentCompilerNode);\r\n        return true;\r\n    };\r\n    return DefaultParentHandler;\r\n}());\r\nexports.DefaultParentHandler = DefaultParentHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/DefaultParentHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ForgetChangedNodeHandler.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ForgetChangedNodeHandler.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar NodeHandlerHelper_1 = __webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\");\r\n/**\r\n * Replacement handler that goes through the tree and forgets any nodes that have changed kind.\r\n */\r\nvar ForgetChangedNodeHandler = /** @class */ (function () {\r\n    function ForgetChangedNodeHandler(compilerFactory) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);\r\n    }\r\n    ForgetChangedNodeHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        var e_1, _a;\r\n        if (currentNode.getKind() !== newNode.kind) {\r\n            currentNode.forget();\r\n            return;\r\n        }\r\n        var _b = tslib_1.__read(this.helper.getChildrenFast(currentNode, newNode, newSourceFile), 2), currentNodeChildren = _b[0], newNodeChildrenArray = _b[1];\r\n        var newNodeChildren = utils_1.ArrayUtils.toIterator(newNodeChildrenArray);\r\n        try {\r\n            for (var currentNodeChildren_1 = tslib_1.__values(currentNodeChildren), currentNodeChildren_1_1 = currentNodeChildren_1.next(); !currentNodeChildren_1_1.done; currentNodeChildren_1_1 = currentNodeChildren_1.next()) {\r\n                var currentNodeChild = currentNodeChildren_1_1.value;\r\n                this.helper.handleForValues(this, currentNodeChild, newNodeChildren.next().value, newSourceFile);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (currentNodeChildren_1_1 && !currentNodeChildren_1_1.done && (_a = currentNodeChildren_1.return)) _a.call(currentNodeChildren_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        this.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n    };\r\n    return ForgetChangedNodeHandler;\r\n}());\r\nexports.ForgetChangedNodeHandler = ForgetChangedNodeHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ForgetChangedNodeHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerFactory.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerFactory.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar ChangeChildOrderParentHandler_1 = __webpack_require__(/*! ./ChangeChildOrderParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ChangeChildOrderParentHandler.js\");\r\nvar DefaultParentHandler_1 = __webpack_require__(/*! ./DefaultParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/DefaultParentHandler.js\");\r\nvar ForgetChangedNodeHandler_1 = __webpack_require__(/*! ./ForgetChangedNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ForgetChangedNodeHandler.js\");\r\nvar ParentFinderReplacementNodeHandler_1 = __webpack_require__(/*! ./ParentFinderReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ParentFinderReplacementNodeHandler.js\");\r\nvar RangeParentHandler_1 = __webpack_require__(/*! ./RangeParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/RangeParentHandler.js\");\r\nvar StraightReplacementNodeHandler_1 = __webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\");\r\nvar TryOrForgetNodeHandler_1 = __webpack_require__(/*! ./TryOrForgetNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/TryOrForgetNodeHandler.js\");\r\nvar UnwrapParentHandler_1 = __webpack_require__(/*! ./UnwrapParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/UnwrapParentHandler.js\");\r\nvar NodeHandlerFactory = /** @class */ (function () {\r\n    function NodeHandlerFactory() {\r\n    }\r\n    NodeHandlerFactory.prototype.getDefault = function (opts) {\r\n        var changingParent = opts.parent, isFirstChild = opts.isFirstChild, childCount = opts.childCount, customMappings = opts.customMappings;\r\n        var sourceFile = changingParent.getSourceFile();\r\n        var compilerFactory = sourceFile.context.compilerFactory;\r\n        var replacingNodes = opts.replacingNodes == null ? undefined : tslib_1.__spread(opts.replacingNodes);\r\n        var parentHandler = new DefaultParentHandler_1.DefaultParentHandler(compilerFactory, { childCount: childCount, isFirstChild: isFirstChild, replacingNodes: replacingNodes, customMappings: customMappings });\r\n        if (changingParent === sourceFile)\r\n            return parentHandler;\r\n        else\r\n            return new ParentFinderReplacementNodeHandler_1.ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);\r\n    };\r\n    NodeHandlerFactory.prototype.getForCreatingSyntaxList = function (opts) {\r\n        var parent = opts.parent, insertPos = opts.insertPos;\r\n        return this.getDefault({\r\n            parent: parent,\r\n            childCount: 1,\r\n            isFirstChild: function (currentNode, newNode) { return newNode.kind === typescript_1.SyntaxKind.SyntaxList && insertPos <= newNode.getStart(); }\r\n        });\r\n    };\r\n    NodeHandlerFactory.prototype.getForRange = function (opts) {\r\n        var changingParent = opts.parent, start = opts.start, end = opts.end, replacingLength = opts.replacingLength, replacingNodes = opts.replacingNodes, customMappings = opts.customMappings;\r\n        var sourceFile = changingParent.getSourceFile();\r\n        var compilerFactory = sourceFile.context.compilerFactory;\r\n        var parentHandler = new RangeParentHandler_1.RangeParentHandler(compilerFactory, { start: start, end: end, replacingLength: replacingLength, replacingNodes: replacingNodes, customMappings: customMappings });\r\n        if (changingParent === sourceFile)\r\n            return parentHandler;\r\n        else\r\n            return new ParentFinderReplacementNodeHandler_1.ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);\r\n    };\r\n    NodeHandlerFactory.prototype.getForChildIndex = function (opts) {\r\n        var parent = opts.parent, childIndex = opts.childIndex, childCount = opts.childCount, replacingNodes = opts.replacingNodes, customMappings = opts.customMappings;\r\n        var parentChildren = parent.getChildren();\r\n        errors.throwIfOutOfRange(childIndex, [0, parentChildren.length], \"opts.childIndex\");\r\n        if (childCount < 0)\r\n            errors.throwIfOutOfRange(childCount, [childIndex - parentChildren.length, 0], \"opts.childCount\");\r\n        var i = 0;\r\n        var isFirstChild = function () { return i++ === childIndex; };\r\n        return this.getDefault({\r\n            parent: parent,\r\n            isFirstChild: isFirstChild,\r\n            childCount: childCount,\r\n            replacingNodes: replacingNodes,\r\n            customMappings: customMappings\r\n        });\r\n    };\r\n    NodeHandlerFactory.prototype.getForStraightReplacement = function (compilerFactory) {\r\n        return new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);\r\n    };\r\n    NodeHandlerFactory.prototype.getForForgetChanged = function (compilerFactory) {\r\n        return new ForgetChangedNodeHandler_1.ForgetChangedNodeHandler(compilerFactory);\r\n    };\r\n    NodeHandlerFactory.prototype.getForTryOrForget = function (handler) {\r\n        return new TryOrForgetNodeHandler_1.TryOrForgetNodeHandler(handler);\r\n    };\r\n    NodeHandlerFactory.prototype.getForChangingChildOrder = function (opts) {\r\n        var changingParent = opts.parent, oldIndex = opts.oldIndex, newIndex = opts.newIndex;\r\n        var sourceFile = changingParent.getSourceFile();\r\n        var compilerFactory = sourceFile.context.compilerFactory;\r\n        var changeChildOrderParentHandler = new ChangeChildOrderParentHandler_1.ChangeChildOrderParentHandler(compilerFactory, { oldIndex: oldIndex, newIndex: newIndex });\r\n        if (changingParent === sourceFile)\r\n            return changeChildOrderParentHandler;\r\n        else\r\n            return new ParentFinderReplacementNodeHandler_1.ParentFinderReplacementNodeHandler(compilerFactory, changeChildOrderParentHandler, changingParent);\r\n    };\r\n    NodeHandlerFactory.prototype.getForUnwrappingNode = function (unwrappingNode) {\r\n        var changingParent = unwrappingNode.getParentSyntaxList() || unwrappingNode.getParentOrThrow();\r\n        var childIndex = unwrappingNode.getChildIndex();\r\n        var sourceFile = changingParent.getSourceFile();\r\n        var compilerFactory = sourceFile.context.compilerFactory;\r\n        var unwrapParentHandler = new UnwrapParentHandler_1.UnwrapParentHandler(compilerFactory, childIndex);\r\n        if (changingParent === sourceFile)\r\n            return unwrapParentHandler;\r\n        else\r\n            return new ParentFinderReplacementNodeHandler_1.ParentFinderReplacementNodeHandler(compilerFactory, unwrapParentHandler, changingParent);\r\n    };\r\n    return NodeHandlerFactory;\r\n}());\r\nexports.NodeHandlerFactory = NodeHandlerFactory;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerFactory.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar NodeHandlerHelper = /** @class */ (function () {\r\n    function NodeHandlerHelper(compilerFactory) {\r\n        this.compilerFactory = compilerFactory;\r\n    }\r\n    NodeHandlerHelper.prototype.handleForValues = function (handler, currentNode, newNode, newSourceFile) {\r\n        if (this.compilerFactory.hasCompilerNode(currentNode))\r\n            handler.handleNode(this.compilerFactory.getExistingCompilerNode(currentNode), newNode, newSourceFile);\r\n        else if (currentNode.kind === typescript_1.SyntaxKind.SyntaxList) {\r\n            // always handle syntax lists because their children might be in the cache\r\n            // todo: pass this in for performance reasons\r\n            var sourceFile = this.compilerFactory.getExistingCompilerNode(currentNode.getSourceFile());\r\n            handler.handleNode(this.compilerFactory.getNodeFromCompilerNode(currentNode, sourceFile), newNode, newSourceFile);\r\n        }\r\n    };\r\n    NodeHandlerHelper.prototype.forgetNodeIfNecessary = function (currentNode) {\r\n        if (this.compilerFactory.hasCompilerNode(currentNode))\r\n            this.compilerFactory.getExistingCompilerNode(currentNode).forget();\r\n    };\r\n    /**\r\n     * Gets the children of the node according to whether the tokens have previously been parsed.\r\n     */\r\n    NodeHandlerHelper.prototype.getChildrenFast = function (currentNode, newNode, newSourceFile) {\r\n        // if this is true, it means the compiler has previously parsed the tokens\r\n        var hasChildren = currentNode.compilerNode._children != null;\r\n        if (hasChildren)\r\n            return [currentNode.getCompilerChildren(), newNode.getChildren(newSourceFile)];\r\n        // great, we don't have to parse the tokens and we can instead just use ts.forEachChild (faster)\r\n        return [getForEachChildren(currentNode.compilerNode), getForEachChildren(newNode)];\r\n        function getForEachChildren(node) {\r\n            var nodes = [];\r\n            typescript_1.ts.forEachChild(node, function (childNode) {\r\n                nodes.push(childNode);\r\n            });\r\n            return nodes;\r\n        }\r\n    };\r\n    return NodeHandlerHelper;\r\n}());\r\nexports.NodeHandlerHelper = NodeHandlerHelper;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ParentFinderReplacementNodeHandler.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ParentFinderReplacementNodeHandler.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar StraightReplacementNodeHandler_1 = __webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\");\r\n/**\r\n * Replacement handler that tries to find the parents.\r\n */\r\nvar ParentFinderReplacementNodeHandler = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParentFinderReplacementNodeHandler, _super);\r\n    function ParentFinderReplacementNodeHandler(compilerFactory, parentNodeHandler, changingParent) {\r\n        var _this = _super.call(this, compilerFactory) || this;\r\n        _this.parentNodeHandler = parentNodeHandler;\r\n        _this.changingParent = changingParent;\r\n        _this.foundParent = false;\r\n        _this.changingParentParent = _this.changingParent.getParentSyntaxList() || _this.changingParent.getParent();\r\n        _this.parentsAtSamePos = _this.changingParentParent != null && _this.changingParentParent.getPos() === _this.changingParent.getPos();\r\n        return _this;\r\n    }\r\n    ParentFinderReplacementNodeHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        if (!this.foundParent && this.isParentNode(currentNode, newNode)) {\r\n            this.foundParent = true; // don't bother checking for the parent once it's found\r\n            this.parentNodeHandler.handleNode(currentNode, newNode, newSourceFile);\r\n        }\r\n        else\r\n            _super.prototype.handleNode.call(this, currentNode, newNode, newSourceFile);\r\n    };\r\n    ParentFinderReplacementNodeHandler.prototype.isParentNode = function (currentNode, newNode) {\r\n        var positionsAndKindsEqual = areNodesEqual(newNode, this.changingParent)\r\n            && areNodesEqual(utils_1.getParentSyntaxList(newNode) || newNode.parent, this.changingParentParent);\r\n        if (!positionsAndKindsEqual)\r\n            return false;\r\n        if (!this.parentsAtSamePos)\r\n            return true;\r\n        // Need to do some additional checks if the parents are in the same position.\r\n        // For example, some nodes like `this` in `this.is.nested.deep;`... in this case, just check the depths are equal\r\n        return getAncestorLength(this.changingParent.compilerNode) === getAncestorLength(newNode);\r\n        function getAncestorLength(nodeToCheck) {\r\n            var node = nodeToCheck;\r\n            var count = 0;\r\n            while (node.parent != null) {\r\n                count++;\r\n                node = node.parent;\r\n            }\r\n            return count;\r\n        }\r\n    };\r\n    return ParentFinderReplacementNodeHandler;\r\n}(StraightReplacementNodeHandler_1.StraightReplacementNodeHandler));\r\nexports.ParentFinderReplacementNodeHandler = ParentFinderReplacementNodeHandler;\r\nfunction areNodesEqual(a, b) {\r\n    if (a == null && b == null)\r\n        return true;\r\n    if (a == null || b == null)\r\n        return false;\r\n    if (a.pos === b.getPos() && a.kind === b.getKind())\r\n        return true;\r\n    return false;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ParentFinderReplacementNodeHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/RangeParentHandler.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/RangeParentHandler.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar NodeHandlerHelper_1 = __webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\");\r\nvar StraightReplacementNodeHandler_1 = __webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\");\r\n/**\r\n * Handler for deailing with a parent that is going to have a child replaced based on the range.\r\n */\r\nvar RangeParentHandler = /** @class */ (function () {\r\n    function RangeParentHandler(compilerFactory, opts) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);\r\n        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);\r\n        this.start = opts.start;\r\n        this.end = opts.end;\r\n        this.replacingLength = opts.replacingLength;\r\n        this.replacingNodes = opts.replacingNodes == null ? undefined : opts.replacingNodes.map(function (n) { return n.compilerNode; });\r\n        this.customMappings = opts.customMappings;\r\n    }\r\n    RangeParentHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        var currentNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(currentNode.getCompilerChildren()));\r\n        var newNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(newNode.getChildren(newSourceFile)));\r\n        // handle any custom mappings\r\n        this.handleCustomMappings(newNode);\r\n        // get the first child\r\n        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getStart() < this.start)\r\n            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);\r\n        // handle the new nodes\r\n        while (!newNodeChildren.done && newNodeChildren.peek.getStart() >= this.start && newNodeChildren.peek.getEnd() <= this.end)\r\n            newNodeChildren.next();\r\n        // handle the nodes being replaced\r\n        if (this.replacingLength != null) {\r\n            var replacingEnd = this.start + this.replacingLength;\r\n            while (!currentNodeChildren.done && (currentNodeChildren.peek.end <= replacingEnd || currentNodeChildren.peek.getStart() < replacingEnd))\r\n                this.helper.forgetNodeIfNecessary(currentNodeChildren.next());\r\n        }\r\n        // handle the rest\r\n        while (!currentNodeChildren.done)\r\n            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);\r\n        // ensure the new children iterator is done too\r\n        if (!newNodeChildren.done)\r\n            throw new Error(\"Error replacing tree: Should not have children left over.\");\r\n        this.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n    };\r\n    RangeParentHandler.prototype.handleCustomMappings = function (newParentNode) {\r\n        var e_1, _a;\r\n        if (this.customMappings == null)\r\n            return;\r\n        var customMappings = this.customMappings(newParentNode);\r\n        try {\r\n            for (var customMappings_1 = tslib_1.__values(customMappings), customMappings_1_1 = customMappings_1.next(); !customMappings_1_1.done; customMappings_1_1 = customMappings_1.next()) {\r\n                var mapping = customMappings_1_1.value;\r\n                mapping.currentNode.context.compilerFactory.replaceCompilerNode(mapping.currentNode, mapping.newNode);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (customMappings_1_1 && !customMappings_1_1.done && (_a = customMappings_1.return)) _a.call(customMappings_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    RangeParentHandler.prototype.straightReplace = function (currentNode, nextNode, newSourceFile) {\r\n        if (!this.tryReplaceNode(currentNode))\r\n            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);\r\n    };\r\n    RangeParentHandler.prototype.tryReplaceNode = function (currentCompilerNode) {\r\n        if (this.replacingNodes == null || this.replacingNodes.length === 0)\r\n            return false;\r\n        var index = this.replacingNodes.indexOf(currentCompilerNode);\r\n        if (index === -1)\r\n            return false;\r\n        this.replacingNodes.splice(index, 1);\r\n        this.helper.forgetNodeIfNecessary(currentCompilerNode);\r\n        return true;\r\n    };\r\n    return RangeParentHandler;\r\n}());\r\nexports.RangeParentHandler = RangeParentHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/RangeParentHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar NodeHandlerHelper_1 = __webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\");\r\n/**\r\n * Replacement handler for replacing parts of the tree that should be equal.\r\n */\r\nvar StraightReplacementNodeHandler = /** @class */ (function () {\r\n    function StraightReplacementNodeHandler(compilerFactory) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);\r\n    }\r\n    StraightReplacementNodeHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        var e_1, _a;\r\n        /* istanbul ignore if */\r\n        if (currentNode.getKind() !== newNode.kind)\r\n            throw new errors.InvalidOperationError(\"Error replacing tree! Perhaps a syntax error was inserted \" +\r\n                (\"(Current: \" + currentNode.getKindName() + \" -- New: \" + utils_1.getSyntaxKindName(newNode.kind) + \").\"));\r\n        var _b = tslib_1.__read(this.helper.getChildrenFast(currentNode, newNode, newSourceFile), 2), currentNodeChildren = _b[0], newNodeChildrenArray = _b[1];\r\n        var newNodeChildren = utils_1.ArrayUtils.toIterator(newNodeChildrenArray);\r\n        try {\r\n            for (var currentNodeChildren_1 = tslib_1.__values(currentNodeChildren), currentNodeChildren_1_1 = currentNodeChildren_1.next(); !currentNodeChildren_1_1.done; currentNodeChildren_1_1 = currentNodeChildren_1.next()) {\r\n                var currentNodeChild = currentNodeChildren_1_1.value;\r\n                this.helper.handleForValues(this, currentNodeChild, newNodeChildren.next().value, newSourceFile);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (currentNodeChildren_1_1 && !currentNodeChildren_1_1.done && (_a = currentNodeChildren_1.return)) _a.call(currentNodeChildren_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        /* istanbul ignore if */\r\n        if (!newNodeChildren.next().done)\r\n            throw new Error(\"Error replacing tree: Should not have new children left over.\");\r\n        this.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n    };\r\n    return StraightReplacementNodeHandler;\r\n}());\r\nexports.StraightReplacementNodeHandler = StraightReplacementNodeHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/TryOrForgetNodeHandler.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/TryOrForgetNodeHandler.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\n/**\r\n * Attempts to use a node handler, but if it fails it will forget all the nodes' children.\r\n */\r\nvar TryOrForgetNodeHandler = /** @class */ (function () {\r\n    function TryOrForgetNodeHandler(handler) {\r\n        this.handler = handler;\r\n    }\r\n    TryOrForgetNodeHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        /* istanbul ignore next */\r\n        if (!utils_1.TypeGuards.isSourceFile(currentNode))\r\n            throw new errors.InvalidOperationError(\"Can only use a \" + \"TryOrForgetNodeHandler\" + \" with a source file.\");\r\n        try {\r\n            this.handler.handleNode(currentNode, newNode, newSourceFile);\r\n        }\r\n        catch (ex) {\r\n            currentNode.context.logger.warn(\"Could not replace tree, so forgetting all nodes instead. Message: \" + ex);\r\n            // forget all the source file's nodes\r\n            currentNode.getChildSyntaxListOrThrow().forget();\r\n            // replace the source file with the temporary source file\r\n            currentNode.context.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n        }\r\n    };\r\n    return TryOrForgetNodeHandler;\r\n}());\r\nexports.TryOrForgetNodeHandler = TryOrForgetNodeHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/TryOrForgetNodeHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/UnwrapParentHandler.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/UnwrapParentHandler.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar NodeHandlerHelper_1 = __webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\");\r\nvar StraightReplacementNodeHandler_1 = __webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\");\r\n/**\r\n * Parent handler used to unwrap a node.\r\n */\r\nvar UnwrapParentHandler = /** @class */ (function () {\r\n    function UnwrapParentHandler(compilerFactory, childIndex) {\r\n        this.compilerFactory = compilerFactory;\r\n        this.childIndex = childIndex;\r\n        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler_1.StraightReplacementNodeHandler(compilerFactory);\r\n        this.helper = new NodeHandlerHelper_1.NodeHandlerHelper(compilerFactory);\r\n    }\r\n    UnwrapParentHandler.prototype.handleNode = function (currentNode, newNode, newSourceFile) {\r\n        var e_1, _a;\r\n        var helper = this.helper;\r\n        var currentNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(currentNode.getCompilerChildren()));\r\n        var newNodeChildren = new utils_1.AdvancedIterator(utils_1.ArrayUtils.toIterator(newNode.getChildren(newSourceFile)));\r\n        var index = 0;\r\n        // replace normally until reaching the first child\r\n        while (!currentNodeChildren.done && !newNodeChildren.done && index++ < this.childIndex)\r\n            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);\r\n        // the child syntax list's children should map to the newNodes next children\r\n        var currentChild = this.compilerFactory.getExistingCompilerNode(currentNodeChildren.next());\r\n        var childSyntaxList = currentChild.getChildSyntaxListOrThrow();\r\n        try {\r\n            for (var _b = tslib_1.__values(childSyntaxList.getCompilerChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var child = _c.value;\r\n                this.helper.handleForValues(this.straightReplacementNodeHandler, child, newNodeChildren.next(), newSourceFile);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        // destroy all the current child's children except for the children of its child syntax list\r\n        forgetNodes(currentChild);\r\n        function forgetNodes(node) {\r\n            var e_2, _a;\r\n            if (node === childSyntaxList) {\r\n                node.forgetOnlyThis();\r\n                return;\r\n            }\r\n            try {\r\n                for (var _b = tslib_1.__values(node.getChildrenInCacheIterator()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var child = _c.value;\r\n                    forgetNodes(child);\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n            node.forgetOnlyThis();\r\n        }\r\n        // handle the rest\r\n        while (!currentNodeChildren.done)\r\n            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);\r\n        // ensure the new children iterator is done too\r\n        if (!newNodeChildren.done)\r\n            throw new Error(\"Error replacing tree: Should not have children left over.\");\r\n        this.compilerFactory.replaceCompilerNode(currentNode, newNode);\r\n    };\r\n    return UnwrapParentHandler;\r\n}());\r\nexports.UnwrapParentHandler = UnwrapParentHandler;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/UnwrapParentHandler.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ChangeChildOrderParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ChangeChildOrderParentHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DefaultParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/DefaultParentHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ForgetChangedNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ForgetChangedNodeHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NodeHandlerFactory */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerFactory.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NodeHandlerHelper */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/NodeHandlerHelper.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ParentFinderReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/ParentFinderReplacementNodeHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RangeParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/RangeParentHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StraightReplacementNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/StraightReplacementNodeHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TryOrForgetNodeHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/TryOrForgetNodeHandler.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UnwrapParentHandler */ \"./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/UnwrapParentHandler.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/nodeHandlers/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textChecks/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textChecks/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./isBlankLineAtPos */ \"./node_modules/ts-simple-ast/dist/manipulation/textChecks/isBlankLineAtPos.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./isNewLineAtPos */ \"./node_modules/ts-simple-ast/dist/manipulation/textChecks/isNewLineAtPos.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textChecks/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textChecks/isBlankLineAtPos.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textChecks/isBlankLineAtPos.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isBlankLineAtPos(sourceFile, pos) {\r\n    var fullText = sourceFile.getFullText();\r\n    var foundBlankLine = false;\r\n    for (var i = pos; i < fullText.length; i++) {\r\n        var char = fullText[i];\r\n        if (char === \" \" || char === \"\\t\")\r\n            continue;\r\n        if (char === \"\\r\" && fullText[i + 1] === \"\\n\" || char === \"\\n\") {\r\n            if (foundBlankLine)\r\n                return true;\r\n            foundBlankLine = true;\r\n            if (char === \"\\r\")\r\n                i++;\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return false;\r\n}\r\nexports.isBlankLineAtPos = isBlankLineAtPos;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textChecks/isBlankLineAtPos.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textChecks/isNewLineAtPos.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textChecks/isNewLineAtPos.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction isNewLineAtPos(fullText, pos) {\r\n    return fullText[pos] === \"\\n\" || (fullText[pos] === \"\\r\" && fullText[pos + 1] === \"\\n\");\r\n}\r\nexports.isNewLineAtPos = isNewLineAtPos;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textChecks/isNewLineAtPos.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/ChangingChildOrderTextManipulator.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/ChangingChildOrderTextManipulator.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar textSeek_1 = __webpack_require__(/*! ../textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\");\r\nvar getSpacingBetweenNodes_1 = __webpack_require__(/*! ./getSpacingBetweenNodes */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getSpacingBetweenNodes.js\");\r\nvar ChangingChildOrderTextManipulator = /** @class */ (function () {\r\n    function ChangingChildOrderTextManipulator(opts) {\r\n        this.opts = opts;\r\n    }\r\n    ChangingChildOrderTextManipulator.prototype.getNewText = function (inputText) {\r\n        var _a = this.opts, parent = _a.parent, oldIndex = _a.oldIndex, newIndex = _a.newIndex, getSiblingFormatting = _a.getSiblingFormatting;\r\n        var children = parent.getChildren();\r\n        var newLineKind = parent.context.manipulationSettings.getNewLineKindAsString();\r\n        var movingNode = children[oldIndex];\r\n        var fullText = parent.sourceFile.getFullText();\r\n        var movingNodeStart = textSeek_1.getPosAtNextNonBlankLine(fullText, movingNode.getPos());\r\n        var movingNodeText = fullText.substring(movingNodeStart, movingNode.getEnd());\r\n        var lowerIndex = Math.min(newIndex, oldIndex);\r\n        var upperIndex = Math.max(newIndex, oldIndex);\r\n        var childrenInNewOrder = getChildrenInNewOrder();\r\n        var isParentSourceFile = utils_1.TypeGuards.isSourceFile(parent.getParentOrThrow());\r\n        var finalText = \"\";\r\n        fillPrefixText();\r\n        fillTextForIndex(lowerIndex);\r\n        fillMiddleText();\r\n        fillTextForIndex(upperIndex);\r\n        fillSuffixText();\r\n        return finalText;\r\n        function getChildrenInNewOrder() {\r\n            var result = tslib_1.__spread(children);\r\n            result.splice(oldIndex, 1);\r\n            result.splice(newIndex, 0, movingNode);\r\n            return result;\r\n        }\r\n        function fillPrefixText() {\r\n            finalText += fullText.substring(0, children[lowerIndex].getPos());\r\n            if (lowerIndex === 0 && !isParentSourceFile)\r\n                finalText += newLineKind;\r\n        }\r\n        function fillMiddleText() {\r\n            var startPos;\r\n            var endPos;\r\n            if (lowerIndex === oldIndex) {\r\n                startPos = textSeek_1.getPosAtNextNonBlankLine(fullText, children[lowerIndex].getEnd());\r\n                endPos = children[upperIndex].getEnd();\r\n            }\r\n            else {\r\n                startPos = textSeek_1.getPosAtNextNonBlankLine(fullText, children[lowerIndex].getPos());\r\n                endPos = children[upperIndex].getPos();\r\n            }\r\n            finalText += fullText.substring(startPos, endPos);\r\n        }\r\n        function fillSuffixText() {\r\n            if (children.length - 1 === upperIndex && !isParentSourceFile)\r\n                finalText += newLineKind;\r\n            finalText += fullText.substring(textSeek_1.getPosAtNextNonBlankLine(fullText, children[upperIndex].getEnd()));\r\n        }\r\n        function fillTextForIndex(index) {\r\n            if (index === oldIndex)\r\n                fillSpacingForRemoval();\r\n            else {\r\n                fillSpacingBeforeInsertion();\r\n                finalText += movingNodeText;\r\n                fillSpacingAfterInsertion();\r\n            }\r\n        }\r\n        function fillSpacingForRemoval() {\r\n            if (oldIndex === 0 || oldIndex === children.length - 1)\r\n                return;\r\n            fillSpacingCommon({\r\n                previousSibling: childrenInNewOrder[oldIndex - 1],\r\n                nextSibling: childrenInNewOrder[oldIndex]\r\n            });\r\n        }\r\n        function fillSpacingBeforeInsertion() {\r\n            if (newIndex === 0)\r\n                return;\r\n            fillSpacingCommon({\r\n                previousSibling: childrenInNewOrder[newIndex - 1],\r\n                nextSibling: childrenInNewOrder[newIndex]\r\n            });\r\n        }\r\n        function fillSpacingAfterInsertion() {\r\n            fillSpacingCommon({\r\n                previousSibling: childrenInNewOrder[newIndex],\r\n                nextSibling: childrenInNewOrder[newIndex + 1]\r\n            });\r\n        }\r\n        function fillSpacingCommon(spacingOpts) {\r\n            var spacing = getSpacingBetweenNodes_1.getSpacingBetweenNodes({\r\n                parent: parent,\r\n                getSiblingFormatting: getSiblingFormatting,\r\n                newLineKind: newLineKind,\r\n                previousSibling: spacingOpts.previousSibling,\r\n                nextSibling: spacingOpts.nextSibling\r\n            });\r\n            var twoNewLines = newLineKind + newLineKind;\r\n            if (spacing === twoNewLines) {\r\n                if (utils_1.StringUtils.endsWith(finalText, twoNewLines))\r\n                    return;\r\n                else if (utils_1.StringUtils.endsWith(finalText, newLineKind))\r\n                    finalText += newLineKind;\r\n                else\r\n                    finalText += twoNewLines;\r\n            }\r\n            else if (spacing === newLineKind) {\r\n                if (utils_1.StringUtils.endsWith(finalText, newLineKind))\r\n                    return;\r\n                else\r\n                    finalText += newLineKind;\r\n            }\r\n            else if (spacing === \" \") {\r\n                if (utils_1.StringUtils.endsWith(finalText, \" \"))\r\n                    return;\r\n                else\r\n                    finalText += \" \";\r\n            }\r\n            else\r\n                finalText += spacing;\r\n        }\r\n    };\r\n    ChangingChildOrderTextManipulator.prototype.getTextForError = function (newText) {\r\n        return newText;\r\n    };\r\n    return ChangingChildOrderTextManipulator;\r\n}());\r\nexports.ChangingChildOrderTextManipulator = ChangingChildOrderTextManipulator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/ChangingChildOrderTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/FullReplacementTextManipulator.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/FullReplacementTextManipulator.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar FullReplacementTextManipulator = /** @class */ (function () {\r\n    function FullReplacementTextManipulator(newText) {\r\n        this.newText = newText;\r\n    }\r\n    FullReplacementTextManipulator.prototype.getNewText = function (inputText) {\r\n        return this.newText;\r\n    };\r\n    FullReplacementTextManipulator.prototype.getTextForError = function (newText) {\r\n        return newText;\r\n    };\r\n    return FullReplacementTextManipulator;\r\n}());\r\nexports.FullReplacementTextManipulator = FullReplacementTextManipulator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/FullReplacementTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/InsertionTextManipulator.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/InsertionTextManipulator.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar getTextForError_1 = __webpack_require__(/*! ./getTextForError */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js\");\r\nvar InsertionTextManipulator = /** @class */ (function () {\r\n    function InsertionTextManipulator(opts) {\r\n        this.opts = opts;\r\n    }\r\n    InsertionTextManipulator.prototype.getNewText = function (inputText) {\r\n        var _a = this.opts, insertPos = _a.insertPos, newText = _a.newText, _b = _a.replacingLength, replacingLength = _b === void 0 ? 0 : _b;\r\n        return inputText.substring(0, insertPos) + newText + inputText.substring(insertPos + replacingLength);\r\n    };\r\n    InsertionTextManipulator.prototype.getTextForError = function (newText) {\r\n        return getTextForError_1.getTextForError(newText, this.opts.insertPos, this.opts.newText.length);\r\n    };\r\n    return InsertionTextManipulator;\r\n}());\r\nexports.InsertionTextManipulator = InsertionTextManipulator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/InsertionTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenTextManipulator.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenTextManipulator.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar textSeek_1 = __webpack_require__(/*! ../textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\");\r\nvar getTextForError_1 = __webpack_require__(/*! ./getTextForError */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js\");\r\nvar RemoveChildrenTextManipulator = /** @class */ (function () {\r\n    function RemoveChildrenTextManipulator(opts) {\r\n        this.opts = opts;\r\n    }\r\n    RemoveChildrenTextManipulator.prototype.getNewText = function (inputText) {\r\n        var _a = this.opts, children = _a.children, _b = _a.removePrecedingSpaces, removePrecedingSpaces = _b === void 0 ? false : _b, _c = _a.removeFollowingSpaces, removeFollowingSpaces = _c === void 0 ? false : _c, _d = _a.removePrecedingNewLines, removePrecedingNewLines = _d === void 0 ? false : _d, _e = _a.removeFollowingNewLines, removeFollowingNewLines = _e === void 0 ? false : _e;\r\n        var sourceFile = children[0].getSourceFile();\r\n        var fullText = sourceFile.getFullText();\r\n        var removalPos = getRemovalPos();\r\n        this.removalPos = removalPos;\r\n        return getPrefix() + getSuffix();\r\n        function getPrefix() {\r\n            return fullText.substring(0, removalPos);\r\n        }\r\n        function getSuffix() {\r\n            return fullText.substring(getRemovalEnd());\r\n        }\r\n        function getRemovalPos() {\r\n            var pos = children[0].getNonWhitespaceStart();\r\n            if (removePrecedingSpaces || removePrecedingNewLines)\r\n                return textSeek_1.getPreviousMatchingPos(fullText, pos, getCharRemovalFunction(removePrecedingSpaces, removePrecedingNewLines));\r\n            return pos;\r\n        }\r\n        function getRemovalEnd() {\r\n            var end = children[children.length - 1].getEnd();\r\n            if (removeFollowingSpaces || removeFollowingNewLines)\r\n                return textSeek_1.getNextMatchingPos(fullText, end, getCharRemovalFunction(removeFollowingSpaces, removeFollowingNewLines));\r\n            return end;\r\n        }\r\n        function getCharRemovalFunction(removeSpaces, removeNewLines) {\r\n            return function (char) {\r\n                if (removeNewLines && (char === \"\\r\" || char === \"\\n\"))\r\n                    return false;\r\n                if (removeSpaces && !charNotSpaceOrTab(char))\r\n                    return false;\r\n                return true;\r\n            };\r\n        }\r\n        function charNotSpaceOrTab(char) {\r\n            return char !== \" \" && char !== \"\\t\";\r\n        }\r\n    };\r\n    RemoveChildrenTextManipulator.prototype.getTextForError = function (newText) {\r\n        return getTextForError_1.getTextForError(newText, this.removalPos);\r\n    };\r\n    return RemoveChildrenTextManipulator;\r\n}());\r\nexports.RemoveChildrenTextManipulator = RemoveChildrenTextManipulator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenWithFormattingTextManipulator.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenWithFormattingTextManipulator.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js\");\r\nvar textChecks_1 = __webpack_require__(/*! ../textChecks */ \"./node_modules/ts-simple-ast/dist/manipulation/textChecks/index.js\");\r\nvar textSeek_1 = __webpack_require__(/*! ../textSeek */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js\");\r\nvar getSpacingBetweenNodes_1 = __webpack_require__(/*! ./getSpacingBetweenNodes */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getSpacingBetweenNodes.js\");\r\nvar getTextForError_1 = __webpack_require__(/*! ./getTextForError */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js\");\r\nvar RemoveChildrenWithFormattingTextManipulator = /** @class */ (function () {\r\n    function RemoveChildrenWithFormattingTextManipulator(opts) {\r\n        this.opts = opts;\r\n    }\r\n    RemoveChildrenWithFormattingTextManipulator.prototype.getNewText = function (inputText) {\r\n        var _a = this.opts, children = _a.children, getSiblingFormatting = _a.getSiblingFormatting;\r\n        var parent = children[0].getParentOrThrow();\r\n        var sourceFile = parent.getSourceFile();\r\n        var fullText = sourceFile.getFullText();\r\n        var newLineKind = sourceFile.context.manipulationSettings.getNewLineKindAsString();\r\n        var previousSibling = children[0].getPreviousSibling();\r\n        var nextSibling = children[children.length - 1].getNextSibling();\r\n        var removalPos = getRemovalPos();\r\n        this.removalPos = removalPos;\r\n        // console.log(JSON.stringify(fullText.substring(0, removalPos)));\r\n        // console.log(JSON.stringify(fullText.substring(getRemovalEnd())));\r\n        return getPrefix() + getSpacing() + getSuffix();\r\n        function getPrefix() {\r\n            return fullText.substring(0, removalPos);\r\n        }\r\n        function getSpacing() {\r\n            return getSpacingBetweenNodes_1.getSpacingBetweenNodes({\r\n                parent: parent,\r\n                previousSibling: previousSibling,\r\n                nextSibling: nextSibling,\r\n                newLineKind: newLineKind,\r\n                getSiblingFormatting: getSiblingFormatting\r\n            });\r\n        }\r\n        function getSuffix() {\r\n            return fullText.substring(getRemovalEnd());\r\n        }\r\n        function getRemovalPos() {\r\n            if (previousSibling != null) {\r\n                var trailingEnd = previousSibling.getTrailingTriviaEnd();\r\n                return textChecks_1.isNewLineAtPos(fullText, trailingEnd) ? trailingEnd : previousSibling.getEnd();\r\n            }\r\n            if (parent.getPos() === children[0].getPos())\r\n                return children[0].getNonWhitespaceStart(); // do not shift the parent\r\n            return children[0].isFirstNodeOnLine() ? children[0].getPos() : children[0].getNonWhitespaceStart();\r\n        }\r\n        function getRemovalEnd() {\r\n            if (previousSibling != null && nextSibling != null) {\r\n                var nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);\r\n                if (nextSiblingFormatting === formatting_1.FormattingKind.Blankline || nextSiblingFormatting === formatting_1.FormattingKind.Newline)\r\n                    return textSeek_1.getPosAtStartOfLineOrNonWhitespace(fullText, nextSibling.getNonWhitespaceStart());\r\n                return nextSibling.getNonWhitespaceStart();\r\n            }\r\n            if (parent.getEnd() === children[children.length - 1].getEnd())\r\n                return children[children.length - 1].getEnd(); // do not shift the parent\r\n            var triviaEnd = children[children.length - 1].getTrailingTriviaEnd();\r\n            if (textChecks_1.isNewLineAtPos(fullText, triviaEnd)) {\r\n                if (previousSibling == null && children[0].getPos() === 0)\r\n                    return textSeek_1.getPosAtNextNonBlankLine(fullText, triviaEnd);\r\n                return textSeek_1.getPosAtEndOfPreviousLine(fullText, textSeek_1.getPosAtNextNonBlankLine(fullText, triviaEnd));\r\n            }\r\n            if (previousSibling == null)\r\n                return triviaEnd;\r\n            else\r\n                return children[children.length - 1].getEnd();\r\n        }\r\n    };\r\n    RemoveChildrenWithFormattingTextManipulator.prototype.getTextForError = function (newText) {\r\n        return getTextForError_1.getTextForError(newText, this.removalPos);\r\n    };\r\n    return RemoveChildrenWithFormattingTextManipulator;\r\n}());\r\nexports.RemoveChildrenWithFormattingTextManipulator = RemoveChildrenWithFormattingTextManipulator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenWithFormattingTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RenameLocationTextManipulator.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RenameLocationTextManipulator.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar RenameLocationTextManipulator = /** @class */ (function () {\r\n    function RenameLocationTextManipulator(renameLocations, newName) {\r\n        this.renameLocations = renameLocations;\r\n        this.newName = newName;\r\n    }\r\n    RenameLocationTextManipulator.prototype.getNewText = function (inputText) {\r\n        var e_1, _a;\r\n        // todo: go in reverse so that the difference doesn't need to be kept track of\r\n        var newFileText = inputText;\r\n        var difference = 0;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.renameLocations.map(function (l) { return l.getTextSpan(); })), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var textSpan = _c.value;\r\n                var start = textSpan.getStart();\r\n                var end = start + textSpan.getLength();\r\n                start -= difference;\r\n                end -= difference;\r\n                newFileText = newFileText.substring(0, start) + this.newName + newFileText.substring(end);\r\n                difference += textSpan.getLength() - this.newName.length;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return newFileText;\r\n    };\r\n    RenameLocationTextManipulator.prototype.getTextForError = function (newText) {\r\n        if (this.renameLocations.length === 0)\r\n            return newText;\r\n        return \"...\" + newText.substring(this.renameLocations[0].getTextSpan().getStart());\r\n    };\r\n    return RenameLocationTextManipulator;\r\n}());\r\nexports.RenameLocationTextManipulator = RenameLocationTextManipulator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RenameLocationTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/UnwrapTextManipulator.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/UnwrapTextManipulator.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar InsertionTextManipulator_1 = __webpack_require__(/*! ./InsertionTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/InsertionTextManipulator.js\");\r\nvar UnwrapTextManipulator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(UnwrapTextManipulator, _super);\r\n    function UnwrapTextManipulator(node) {\r\n        return _super.call(this, {\r\n            insertPos: node.getPos(),\r\n            newText: getReplacementText(node),\r\n            replacingLength: node.getFullWidth()\r\n        }) || this;\r\n    }\r\n    return UnwrapTextManipulator;\r\n}(InsertionTextManipulator_1.InsertionTextManipulator));\r\nexports.UnwrapTextManipulator = UnwrapTextManipulator;\r\nfunction getReplacementText(node) {\r\n    var e_1, _a;\r\n    var childSyntaxList = node.getChildSyntaxListOrThrow();\r\n    var indentationText = node.getIndentationText();\r\n    var childIndentationText = node.getChildIndentationText();\r\n    var indentationDifference = childIndentationText.replace(indentationText, \"\");\r\n    var replaceRegex = new RegExp(\"^\" + indentationDifference);\r\n    var originalText = childSyntaxList.getFullText();\r\n    var sourceFile = node.sourceFile;\r\n    var lines = originalText.split(\"\\n\");\r\n    var pos = childSyntaxList.getPos();\r\n    var newLines = [];\r\n    try {\r\n        for (var lines_1 = tslib_1.__values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {\r\n            var line = lines_1_1.value;\r\n            if (sourceFile.isInStringAtPos(pos))\r\n                newLines.push(line);\r\n            else\r\n                newLines.push(line.replace(replaceRegex, \"\"));\r\n            pos += line.length + 1;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return newLines.join(\"\\n\").replace(/^\\r?\\n/, \"\");\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/UnwrapTextManipulator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getSpacingBetweenNodes.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getSpacingBetweenNodes.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/manipulation/formatting/index.js\");\r\nfunction getSpacingBetweenNodes(opts) {\r\n    var parent = opts.parent, previousSibling = opts.previousSibling, nextSibling = opts.nextSibling, newLineKind = opts.newLineKind, getSiblingFormatting = opts.getSiblingFormatting;\r\n    if (previousSibling == null || nextSibling == null)\r\n        return \"\";\r\n    var previousSiblingFormatting = getSiblingFormatting(parent, previousSibling);\r\n    var nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);\r\n    if (previousSiblingFormatting === formatting_1.FormattingKind.Blankline || nextSiblingFormatting === formatting_1.FormattingKind.Blankline)\r\n        return newLineKind + newLineKind;\r\n    else if (previousSiblingFormatting === formatting_1.FormattingKind.Newline || nextSiblingFormatting === formatting_1.FormattingKind.Newline)\r\n        return newLineKind;\r\n    else if (previousSiblingFormatting === formatting_1.FormattingKind.Space || nextSiblingFormatting === formatting_1.FormattingKind.Space)\r\n        return \" \";\r\n    else\r\n        return \"\";\r\n}\r\nexports.getSpacingBetweenNodes = getSpacingBetweenNodes;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getSpacingBetweenNodes.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getTextForError(newText, pos, length) {\r\n    if (length === void 0) { length = 0; }\r\n    var startPos = Math.max(0, newText.lastIndexOf(\"\\n\", pos) - 100);\r\n    var endPos = Math.min(newText.length, newText.indexOf(\"\\n\", pos + length));\r\n    endPos = endPos === -1 ? newText.length : Math.min(newText.length, endPos + 100);\r\n    var text = \"\";\r\n    text += newText.substring(startPos, endPos);\r\n    if (startPos !== 0)\r\n        text = \"...\" + text;\r\n    if (endPos !== newText.length)\r\n        text += \"...\";\r\n    return text;\r\n}\r\nexports.getTextForError = getTextForError;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ChangingChildOrderTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/ChangingChildOrderTextManipulator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FullReplacementTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/FullReplacementTextManipulator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getSpacingBetweenNodes */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getSpacingBetweenNodes.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getTextForError */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/getTextForError.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InsertionTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/InsertionTextManipulator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RemoveChildrenTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenTextManipulator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RemoveChildrenWithFormattingTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RemoveChildrenWithFormattingTextManipulator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./RenameLocationTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/RenameLocationTextManipulator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./UnwrapTextManipulator */ \"./node_modules/ts-simple-ast/dist/manipulation/textManipulators/UnwrapTextManipulator.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textManipulators/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextMatchingPos.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextMatchingPos.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// todo: tests\r\nfunction getNextMatchingPos(text, pos, condition) {\r\n    while (pos < text.length) {\r\n        var char = text[pos];\r\n        if (!condition(char))\r\n            pos++;\r\n        else\r\n            break;\r\n    }\r\n    return pos;\r\n}\r\nexports.getNextMatchingPos = getNextMatchingPos;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextMatchingPos.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextNonWhitespacePos.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextNonWhitespacePos.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar getNextMatchingPos_1 = __webpack_require__(/*! ./getNextMatchingPos */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextMatchingPos.js\");\r\nfunction getNextNonWhitespacePos(text, pos) {\r\n    return getNextMatchingPos_1.getNextMatchingPos(text, pos, function (char) { return char !== \" \" && char !== \"\\t\" && char !== \"\\r\" && char !== \"\\n\"; });\r\n}\r\nexports.getNextNonWhitespacePos = getNextNonWhitespacePos;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextNonWhitespacePos.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterNewLine.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterNewLine.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getPosAfterNewLine(text, pos) {\r\n    while (pos < text.length) {\r\n        if (text[pos] === \"\\n\")\r\n            return pos + 1;\r\n        pos++;\r\n    }\r\n    return pos;\r\n}\r\nexports.getPosAfterNewLine = getPosAfterNewLine;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterNewLine.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterPreviousNonBlankLine.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterPreviousNonBlankLine.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getPosAfterPreviousNonBlankLine(text, pos) {\r\n    var newPos = pos;\r\n    for (var i = pos - 1; i >= 0; i--) {\r\n        if (text[i] === \" \" || text[i] === \"\\t\")\r\n            continue;\r\n        if (text[i] === \"\\n\") {\r\n            newPos = i + 1;\r\n            if (text[i - 1] === \"\\r\")\r\n                i--;\r\n            continue;\r\n        }\r\n        return newPos;\r\n    }\r\n    return 0;\r\n}\r\nexports.getPosAfterPreviousNonBlankLine = getPosAfterPreviousNonBlankLine;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterPreviousNonBlankLine.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLine.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLine.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getPosAtEndOfPreviousLine(fullText, pos) {\r\n    while (pos > 0) {\r\n        pos--;\r\n        if (fullText[pos] === \"\\n\") {\r\n            if (fullText[pos - 1] === \"\\r\")\r\n                return pos - 1;\r\n            return pos;\r\n        }\r\n    }\r\n    return pos;\r\n}\r\nexports.getPosAtEndOfPreviousLine = getPosAtEndOfPreviousLine;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLine.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLineOrNonWhitespace.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLineOrNonWhitespace.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getPosAtEndOfPreviousLineOrNonWhitespace(fullText, pos) {\r\n    while (pos > 0) {\r\n        pos--;\r\n        var currentChar = fullText[pos];\r\n        if (currentChar === \"\\n\") {\r\n            if (fullText[pos - 1] === \"\\r\")\r\n                return pos - 1;\r\n            return pos;\r\n        }\r\n        else if (currentChar !== \" \" && currentChar !== \"\\t\")\r\n            return pos + 1;\r\n    }\r\n    return pos;\r\n}\r\nexports.getPosAtEndOfPreviousLineOrNonWhitespace = getPosAtEndOfPreviousLineOrNonWhitespace;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLineOrNonWhitespace.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtNextNonBlankLine.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtNextNonBlankLine.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getPosAtNextNonBlankLine(text, pos) {\r\n    var newPos = pos;\r\n    for (var i = pos; i < text.length; i++) {\r\n        if (text[i] === \" \" || text[i] === \"\\t\")\r\n            continue;\r\n        if (text[i] === \"\\r\" && text[i + 1] === \"\\n\" || text[i] === \"\\n\") {\r\n            newPos = i + 1;\r\n            if (text[i] === \"\\r\") {\r\n                i++;\r\n                newPos++;\r\n            }\r\n            continue;\r\n        }\r\n        return newPos;\r\n    }\r\n    return newPos;\r\n}\r\nexports.getPosAtNextNonBlankLine = getPosAtNextNonBlankLine;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtNextNonBlankLine.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtStartOfLineOrNonWhitespace.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtStartOfLineOrNonWhitespace.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getPosAtStartOfLineOrNonWhitespace(fullText, pos) {\r\n    while (pos > 0) {\r\n        pos--;\r\n        var currentChar = fullText[pos];\r\n        if (currentChar === \"\\n\")\r\n            return pos + 1;\r\n        else if (currentChar !== \" \" && currentChar !== \"\\t\")\r\n            return pos + 1;\r\n    }\r\n    return pos;\r\n}\r\nexports.getPosAtStartOfLineOrNonWhitespace = getPosAtStartOfLineOrNonWhitespace;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtStartOfLineOrNonWhitespace.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPreviousMatchingPos.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPreviousMatchingPos.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// todo: tests\r\nfunction getPreviousMatchingPos(text, pos, condition) {\r\n    while (pos > 0) {\r\n        var char = text[pos - 1];\r\n        if (!condition(char))\r\n            pos--;\r\n        else\r\n            break;\r\n    }\r\n    return pos;\r\n}\r\nexports.getPreviousMatchingPos = getPreviousMatchingPos;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPreviousMatchingPos.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getNextMatchingPos */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextMatchingPos.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getNextNonWhitespacePos */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getNextNonWhitespacePos.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPosAfterNewLine */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterNewLine.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPosAfterPreviousNonBlankLine */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAfterPreviousNonBlankLine.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPosAtEndOfPreviousLine */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLine.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPosAtEndOfPreviousLineOrNonWhitespace */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtEndOfPreviousLineOrNonWhitespace.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPosAtNextNonBlankLine */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtNextNonBlankLine.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPosAtStartOfLineOrNonWhitespace */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPosAtStartOfLineOrNonWhitespace.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getPreviousMatchingPos */ \"./node_modules/ts-simple-ast/dist/manipulation/textSeek/getPreviousMatchingPos.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/manipulation/textSeek/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/options/CompilerOptionsContainer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/options/CompilerOptionsContainer.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar SettingsContainer_1 = __webpack_require__(/*! ./SettingsContainer */ \"./node_modules/ts-simple-ast/dist/options/SettingsContainer.js\");\r\n/**\r\n * Holds the compiler options.\r\n */\r\nvar CompilerOptionsContainer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CompilerOptionsContainer, _super);\r\n    function CompilerOptionsContainer() {\r\n        return _super.call(this, {}) || this;\r\n    }\r\n    /**\r\n     * Sets one or all of the compiler options.\r\n     *\r\n     * WARNING: Setting the compiler options will cause a complete reparse of all the source files.\r\n     * @param settings - Compiler options to set.\r\n     */\r\n    CompilerOptionsContainer.prototype.set = function (settings) {\r\n        _super.prototype.set.call(this, settings);\r\n    };\r\n    return CompilerOptionsContainer;\r\n}(SettingsContainer_1.SettingsContainer));\r\nexports.CompilerOptionsContainer = CompilerOptionsContainer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/options/CompilerOptionsContainer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/options/ManipulationSettingsContainer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/options/ManipulationSettingsContainer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar compiler_1 = __webpack_require__(/*! ../compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar SettingsContainer_1 = __webpack_require__(/*! ./SettingsContainer */ \"./node_modules/ts-simple-ast/dist/options/SettingsContainer.js\");\r\n/** Kinds of indentation */\r\nvar IndentationText;\r\n(function (IndentationText) {\r\n    /** Two spaces */\r\n    IndentationText[\"TwoSpaces\"] = \"  \";\r\n    /** Four spaces */\r\n    IndentationText[\"FourSpaces\"] = \"    \";\r\n    /** Eight spaces */\r\n    IndentationText[\"EightSpaces\"] = \"        \";\r\n    /** Tab */\r\n    IndentationText[\"Tab\"] = \"\\t\";\r\n})(IndentationText = exports.IndentationText || (exports.IndentationText = {}));\r\n/**\r\n * Holds the manipulation settings.\r\n */\r\nvar ManipulationSettingsContainer = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ManipulationSettingsContainer, _super);\r\n    function ManipulationSettingsContainer() {\r\n        return _super.call(this, {\r\n            indentationText: IndentationText.FourSpaces,\r\n            newLineKind: typescript_1.NewLineKind.LineFeed,\r\n            quoteKind: compiler_1.QuoteKind.Double,\r\n            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true\r\n        }) || this;\r\n    }\r\n    /**\r\n     * Gets the editor settings based on the current manipulation settings.\r\n     */\r\n    ManipulationSettingsContainer.prototype.getEditorSettings = function () {\r\n        if (this.editorSettings == null) {\r\n            this.editorSettings = {};\r\n            utils_1.fillDefaultEditorSettings(this.editorSettings, this);\r\n        }\r\n        return tslib_1.__assign({}, this.editorSettings);\r\n    };\r\n    /**\r\n     * Gets the format code settings.\r\n     */\r\n    ManipulationSettingsContainer.prototype.getFormatCodeSettings = function () {\r\n        if (this.formatCodeSettings == null) {\r\n            this.formatCodeSettings = tslib_1.__assign({}, this.getEditorSettings(), { insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: this.settings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces });\r\n        }\r\n        return tslib_1.__assign({}, this.formatCodeSettings);\r\n    };\r\n    /**\r\n     * Gets the user preferences.\r\n     */\r\n    ManipulationSettingsContainer.prototype.getUserPreferences = function () {\r\n        if (this.userPreferences == null) {\r\n            this.userPreferences = {\r\n                quotePreference: this.getQuoteKind() === compiler_1.QuoteKind.Double ? \"double\" : \"single\"\r\n            };\r\n        }\r\n        return tslib_1.__assign({}, this.userPreferences);\r\n    };\r\n    /**\r\n     * Gets the quote kind used for string literals.\r\n     */\r\n    ManipulationSettingsContainer.prototype.getQuoteKind = function () {\r\n        return this.settings.quoteKind;\r\n    };\r\n    /**\r\n     * Gets the new line kind.\r\n     */\r\n    ManipulationSettingsContainer.prototype.getNewLineKind = function () {\r\n        return this.settings.newLineKind;\r\n    };\r\n    /**\r\n     * Gets the new line kind as a string.\r\n     */\r\n    ManipulationSettingsContainer.prototype.getNewLineKindAsString = function () {\r\n        return utils_1.newLineKindToString(this.getNewLineKind());\r\n    };\r\n    /**\r\n     * Gets the indentation text;\r\n     */\r\n    ManipulationSettingsContainer.prototype.getIndentationText = function () {\r\n        return this.settings.indentationText;\r\n    };\r\n    /**\r\n     * Sets one or all of the settings.\r\n     * @param settings - Settings to set.\r\n     */\r\n    ManipulationSettingsContainer.prototype.set = function (settings) {\r\n        _super.prototype.set.call(this, settings);\r\n        this.editorSettings = undefined;\r\n        this.formatCodeSettings = undefined;\r\n        this.userPreferences = undefined;\r\n    };\r\n    return ManipulationSettingsContainer;\r\n}(SettingsContainer_1.SettingsContainer));\r\nexports.ManipulationSettingsContainer = ManipulationSettingsContainer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/options/ManipulationSettingsContainer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/options/SettingsContainer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/options/SettingsContainer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar objectAssign = __webpack_require__(/*! object-assign */ \"object-assign\");\r\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar SettingsContainer = /** @class */ (function () {\r\n    /** @internal */\r\n    function SettingsContainer(defaultSettings) {\r\n        this.defaultSettings = objectAssign({}, defaultSettings);\r\n        this.settings = defaultSettings;\r\n    }\r\n    /**\r\n     * Resets the settings to the default.\r\n     */\r\n    SettingsContainer.prototype.reset = function () {\r\n        this.settings = objectAssign({}, this.defaultSettings);\r\n        this.fireModified();\r\n    };\r\n    /**\r\n     * Gets a copy of the settings as an object.\r\n     */\r\n    SettingsContainer.prototype.get = function () {\r\n        return objectAssign({}, this.settings);\r\n    };\r\n    /**\r\n     * Sets one or all of the settings.\r\n     * @param settings - Settings to set.\r\n     */\r\n    SettingsContainer.prototype.set = function (settings) {\r\n        objectAssign(this.settings, settings);\r\n        this.fireModified();\r\n    };\r\n    /**\r\n     * Subscribe to modifications in the settings container.\r\n     * @param action - Action to execute when the settings change.\r\n     * @internal\r\n     */\r\n    SettingsContainer.prototype.onModified = function (action) {\r\n        if (this._modifiedEventContainer == null)\r\n            this._modifiedEventContainer = new utils_1.EventContainer();\r\n        this._modifiedEventContainer.subscribe(action);\r\n    };\r\n    /** @internal */\r\n    SettingsContainer.prototype.fireModified = function () {\r\n        if (this._modifiedEventContainer != null)\r\n            this._modifiedEventContainer.fire(undefined);\r\n    };\r\n    return SettingsContainer;\r\n}());\r\nexports.SettingsContainer = SettingsContainer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/options/SettingsContainer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/options/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/options/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CompilerOptionsContainer */ \"./node_modules/ts-simple-ast/dist/options/CompilerOptionsContainer.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ManipulationSettingsContainer */ \"./node_modules/ts-simple-ast/dist/options/ManipulationSettingsContainer.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SettingsContainer */ \"./node_modules/ts-simple-ast/dist/options/SettingsContainer.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/options/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ./StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar FactoryStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FactoryStructurePrinter, _super);\r\n    function FactoryStructurePrinter(factory) {\r\n        var _this = _super.call(this) || this;\r\n        _this.factory = factory;\r\n        return _this;\r\n    }\r\n    return FactoryStructurePrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.FactoryStructurePrinter = FactoryStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar StructurePrinter = /** @class */ (function () {\r\n    function StructurePrinter() {\r\n    }\r\n    // todo: this should not be a method on the base\r\n    StructurePrinter.prototype.printTextOrWriterFunc = function (writer, textOrWriterFunc) {\r\n        if (typeof textOrWriterFunc === \"string\")\r\n            writer.write(textOrWriterFunc);\r\n        else if (textOrWriterFunc != null)\r\n            textOrWriterFunc(writer);\r\n    };\r\n    return StructurePrinter;\r\n}());\r\nexports.StructurePrinter = StructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/base/InitializerExpressionableNodeStructurePrinter.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/base/InitializerExpressionableNodeStructurePrinter.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar codeBlockWriter_1 = __webpack_require__(/*! ../../codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar InitializerExpressionableNodeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(InitializerExpressionableNodeStructurePrinter, _super);\r\n    function InitializerExpressionableNodeStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    InitializerExpressionableNodeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var initializer = structure.initializer;\r\n        if (initializer == null)\r\n            return;\r\n        // todo: hacky, will need to change this in the future...\r\n        var initializerText = typeof initializer === \"string\" ? initializer : getTextForWriterFunc(initializer);\r\n        if (!utils_1.StringUtils.isNullOrWhitespace(initializerText))\r\n            writer.write(\" = \" + initializerText);\r\n        function getTextForWriterFunc(writerFunc) {\r\n            var newWriter = new codeBlockWriter_1.CodeBlockWriter(writer.getOptions());\r\n            writerFunc(newWriter);\r\n            return newWriter.toString();\r\n        }\r\n    };\r\n    return InitializerExpressionableNodeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.InitializerExpressionableNodeStructurePrinter = InitializerExpressionableNodeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/base/InitializerExpressionableNodeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/base/ModifierableNodeStructurePrinter.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/base/ModifierableNodeStructurePrinter.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar ModifierableNodeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ModifierableNodeStructurePrinter, _super);\r\n    function ModifierableNodeStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ModifierableNodeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var scope = structure.scope;\r\n        if (structure.isDefaultExport)\r\n            writer.write(\"export default \");\r\n        else if (structure.isExported)\r\n            writer.write(\"export \");\r\n        if (structure.hasDeclareKeyword)\r\n            writer.write(\"declare \");\r\n        if (structure.isAbstract)\r\n            writer.write(\"abstract \");\r\n        if (scope != null)\r\n            writer.write(scope + \" \");\r\n        if (structure.isStatic)\r\n            writer.write(\"static \");\r\n        if (structure.isAsync)\r\n            writer.write(\"async \");\r\n        if (structure.isReadonly)\r\n            writer.write(\"readonly \");\r\n    };\r\n    return ModifierableNodeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ModifierableNodeStructurePrinter = ModifierableNodeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/base/ModifierableNodeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/base/ReturnTypedNodeStructurePrinter.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/base/ReturnTypedNodeStructurePrinter.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar codeBlockWriter_1 = __webpack_require__(/*! ../../codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar ReturnTypedNodeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ReturnTypedNodeStructurePrinter, _super);\r\n    function ReturnTypedNodeStructurePrinter(factory, alwaysWrite) {\r\n        if (alwaysWrite === void 0) { alwaysWrite = false; }\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.alwaysWrite = alwaysWrite;\r\n        return _this;\r\n    }\r\n    ReturnTypedNodeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var returnType = structure.returnType;\r\n        if (returnType == null && this.alwaysWrite === false)\r\n            return;\r\n        returnType = returnType || \"void\";\r\n        // todo: hacky, will need to change this in the future...\r\n        var initializerText = typeof returnType === \"string\" ? returnType : getTextForWriterFunc(returnType);\r\n        if (!utils_1.StringUtils.isNullOrWhitespace(initializerText))\r\n            writer.write(\": \" + initializerText);\r\n        function getTextForWriterFunc(writerFunc) {\r\n            var newWriter = new codeBlockWriter_1.CodeBlockWriter(writer.getOptions());\r\n            writerFunc(newWriter);\r\n            return newWriter.toString();\r\n        }\r\n    };\r\n    return ReturnTypedNodeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ReturnTypedNodeStructurePrinter = ReturnTypedNodeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/base/ReturnTypedNodeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/base/TypedNodeStructurePrinter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/base/TypedNodeStructurePrinter.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar codeBlockWriter_1 = __webpack_require__(/*! ../../codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar TypedNodeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypedNodeStructurePrinter, _super);\r\n    function TypedNodeStructurePrinter(factory, separator, alwaysWrite) {\r\n        if (alwaysWrite === void 0) { alwaysWrite = false; }\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.separator = separator;\r\n        _this.alwaysWrite = alwaysWrite;\r\n        return _this;\r\n    }\r\n    TypedNodeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var type = structure.type;\r\n        if (type == null && this.alwaysWrite === false)\r\n            return;\r\n        type = type || \"any\";\r\n        // todo: hacky, will need to change this in the future...\r\n        var initializerText = typeof type === \"string\" ? type : getTextForWriterFunc(type);\r\n        if (!utils_1.StringUtils.isNullOrWhitespace(initializerText))\r\n            writer.write(this.separator + \" \" + initializerText);\r\n        function getTextForWriterFunc(writerFunc) {\r\n            var newWriter = new codeBlockWriter_1.CodeBlockWriter(writer.getOptions());\r\n            writerFunc(newWriter);\r\n            return newWriter.toString();\r\n        }\r\n    };\r\n    return TypedNodeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.TypedNodeStructurePrinter = TypedNodeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/base/TypedNodeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/base/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/base/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InitializerExpressionableNodeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/base/InitializerExpressionableNodeStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ModifierableNodeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/base/ModifierableNodeStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ReturnTypedNodeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/base/ReturnTypedNodeStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypedNodeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/base/TypedNodeStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/base/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/ClassDeclarationStructurePrinter.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/ClassDeclarationStructurePrinter.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar ClassDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ClassDeclarationStructurePrinter, _super);\r\n    function ClassDeclarationStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        _this.multipleWriter = new formatting_1.BlankLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    ClassDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    ClassDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        var isAmbient = structure.hasDeclareKeyword || this.options.isAmbient;\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forDecorator().printTexts(writer, structure.decorators);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"class\");\r\n        // can be null, ex. `export default class { ... }`\r\n        if (!utils_1.StringUtils.isNullOrWhitespace(structure.name))\r\n            writer.space().write(structure.name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.space();\r\n        if (!utils_1.StringUtils.isNullOrWhitespace(structure.extends))\r\n            writer.write(\"extends \" + structure.extends + \" \");\r\n        if (!utils_1.ArrayUtils.isNullOrEmpty(structure.implements))\r\n            writer.write(\"implements \" + structure.implements.join(\", \") + \" \");\r\n        writer.inlineBlock(function () {\r\n            _this.factory.forPropertyDeclaration().printTexts(writer, structure.properties);\r\n            _this.printCtors(writer, structure, isAmbient);\r\n            _this.printGetAndSet(writer, structure, isAmbient);\r\n            if (!utils_1.ArrayUtils.isNullOrEmpty(structure.methods)) {\r\n                _this.conditionalSeparator(writer, isAmbient);\r\n                _this.factory.forMethodDeclaration({ isAmbient: isAmbient }).printTexts(writer, structure.methods);\r\n            }\r\n        });\r\n    };\r\n    ClassDeclarationStructurePrinter.prototype.printCtors = function (writer, structure, isAmbient) {\r\n        var e_1, _a;\r\n        if (utils_1.ArrayUtils.isNullOrEmpty(structure.ctors))\r\n            return;\r\n        try {\r\n            for (var _b = tslib_1.__values(structure.ctors), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var ctor = _c.value;\r\n                this.conditionalSeparator(writer, isAmbient);\r\n                this.factory.forConstructorDeclaration({ isAmbient: isAmbient }).printText(writer, ctor);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    ClassDeclarationStructurePrinter.prototype.printGetAndSet = function (writer, structure, isAmbient) {\r\n        var e_2, _a, e_3, _b;\r\n        var getAccessors = tslib_1.__spread(structure.getAccessors || []);\r\n        var setAccessors = tslib_1.__spread(structure.setAccessors || []);\r\n        var getAccessorWriter = this.factory.forGetAccessorDeclaration({ isAmbient: isAmbient });\r\n        var setAccessorWriter = this.factory.forSetAccessorDeclaration({ isAmbient: isAmbient });\r\n        var _loop_1 = function (getAccessor) {\r\n            this_1.conditionalSeparator(writer, isAmbient);\r\n            getAccessorWriter.printText(writer, getAccessor);\r\n            // write the corresponding set accessor beside the get accessor\r\n            var setAccessorIndex = utils_1.ArrayUtils.findIndex(setAccessors, function (item) { return item.name === getAccessor.name; });\r\n            if (setAccessorIndex >= 0) {\r\n                this_1.conditionalSeparator(writer, isAmbient);\r\n                setAccessorWriter.printText(writer, setAccessors[setAccessorIndex]);\r\n                setAccessors.splice(setAccessorIndex, 1);\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        try {\r\n            for (var getAccessors_1 = tslib_1.__values(getAccessors), getAccessors_1_1 = getAccessors_1.next(); !getAccessors_1_1.done; getAccessors_1_1 = getAccessors_1.next()) {\r\n                var getAccessor = getAccessors_1_1.value;\r\n                _loop_1(getAccessor);\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (getAccessors_1_1 && !getAccessors_1_1.done && (_a = getAccessors_1.return)) _a.call(getAccessors_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        try {\r\n            for (var setAccessors_1 = tslib_1.__values(setAccessors), setAccessors_1_1 = setAccessors_1.next(); !setAccessors_1_1.done; setAccessors_1_1 = setAccessors_1.next()) {\r\n                var setAccessor = setAccessors_1_1.value;\r\n                this.conditionalSeparator(writer, isAmbient);\r\n                setAccessorWriter.printText(writer, setAccessor);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (setAccessors_1_1 && !setAccessors_1_1.done && (_b = setAccessors_1.return)) _b.call(setAccessors_1);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    ClassDeclarationStructurePrinter.prototype.conditionalSeparator = function (writer, isAmbient) {\r\n        if (writer.isAtStartOfFirstLineOfBlock())\r\n            return;\r\n        if (isAmbient)\r\n            writer.newLine();\r\n        else\r\n            writer.blankLine();\r\n    };\r\n    return ClassDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ClassDeclarationStructurePrinter = ClassDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/ClassDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/ConstructorDeclarationStructurePrinter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/ConstructorDeclarationStructurePrinter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar ConstructorDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConstructorDeclarationStructurePrinter, _super);\r\n    function ConstructorDeclarationStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        return _this;\r\n    }\r\n    ConstructorDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        // todo: move this code to a common printer similar to blank line formatting structure printer\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            if (i > 0) {\r\n                if (this.options.isAmbient)\r\n                    writer.newLine();\r\n                else\r\n                    writer.blankLine();\r\n            }\r\n            this.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    ConstructorDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.printOverloads(writer, getOverloadStructures());\r\n        this.printBase(writer, structure);\r\n        if (this.options.isAmbient)\r\n            writer.write(\";\");\r\n        else\r\n            writer.space().inlineBlock(function () {\r\n                _this.factory.forBodyText(_this.options).printText(writer, structure);\r\n            });\r\n        function getOverloadStructures() {\r\n            var e_1, _a;\r\n            // all the overloads need to have the same scope as the implementation\r\n            var overloads = utils_1.ObjectUtils.clone(structure.overloads);\r\n            if (overloads == null || overloads.length === 0)\r\n                return;\r\n            try {\r\n                for (var overloads_1 = tslib_1.__values(overloads), overloads_1_1 = overloads_1.next(); !overloads_1_1.done; overloads_1_1 = overloads_1.next()) {\r\n                    var overload = overloads_1_1.value;\r\n                    utils_1.setValueIfUndefined(overload, \"scope\", structure.scope);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (overloads_1_1 && !overloads_1_1.done && (_a = overloads_1.return)) _a.call(overloads_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return overloads;\r\n        }\r\n    };\r\n    ConstructorDeclarationStructurePrinter.prototype.printOverloads = function (writer, structures) {\r\n        var e_2, _a;\r\n        if (structures == null || structures.length === 0)\r\n            return;\r\n        try {\r\n            for (var structures_1 = tslib_1.__values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {\r\n                var structure = structures_1_1.value;\r\n                this.printOverload(writer, structure);\r\n                writer.newLine();\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    ConstructorDeclarationStructurePrinter.prototype.printOverload = function (writer, structure) {\r\n        this.printBase(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    ConstructorDeclarationStructurePrinter.prototype.printBase = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"constructor\");\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n    };\r\n    return ConstructorDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ConstructorDeclarationStructurePrinter = ConstructorDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/ConstructorDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/GetAccessorDeclarationStructurePrinter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/GetAccessorDeclarationStructurePrinter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar GetAccessorDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(GetAccessorDeclarationStructurePrinter, _super);\r\n    function GetAccessorDeclarationStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        _this.blankLineWriter = new formatting_1.BlankLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    GetAccessorDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.blankLineWriter.printText(writer, structures);\r\n    };\r\n    GetAccessorDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forDecorator().printTexts(writer, structure.decorators);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"get \" + structure.name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode().printText(writer, structure);\r\n        writer.spaceIfLastNot().inlineBlock(function () {\r\n            _this.factory.forBodyText(_this.options).printText(writer, structure);\r\n        });\r\n    };\r\n    return GetAccessorDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.GetAccessorDeclarationStructurePrinter = GetAccessorDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/GetAccessorDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/MethodDeclarationStructurePrinter.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/MethodDeclarationStructurePrinter.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar MethodDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MethodDeclarationStructurePrinter, _super);\r\n    function MethodDeclarationStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        return _this;\r\n    }\r\n    MethodDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            if (i > 0) {\r\n                if (this.options.isAmbient)\r\n                    writer.newLine();\r\n                else\r\n                    writer.blankLine();\r\n            }\r\n            this.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    MethodDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.printOverloads(writer, structure.name, getOverloadStructures());\r\n        this.printBase(writer, structure.name, structure);\r\n        if (this.options.isAmbient || structure.isAbstract)\r\n            writer.write(\";\");\r\n        else\r\n            writer.spaceIfLastNot().inlineBlock(function () {\r\n                _this.factory.forBodyText(_this.options).printText(writer, structure);\r\n            });\r\n        function getOverloadStructures() {\r\n            var e_1, _a;\r\n            // all the overloads need to have the same scope as the implementation\r\n            var overloads = utils_1.ObjectUtils.clone(structure.overloads);\r\n            if (overloads == null || overloads.length === 0)\r\n                return;\r\n            try {\r\n                for (var overloads_1 = tslib_1.__values(overloads), overloads_1_1 = overloads_1.next(); !overloads_1_1.done; overloads_1_1 = overloads_1.next()) {\r\n                    var overload = overloads_1_1.value;\r\n                    utils_1.setValueIfUndefined(overload, \"scope\", structure.scope);\r\n                    utils_1.setValueIfUndefined(overload, \"isStatic\", structure.isStatic); // allow people to do stupid things\r\n                    utils_1.setValueIfUndefined(overload, \"isAbstract\", structure.isAbstract);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (overloads_1_1 && !overloads_1_1.done && (_a = overloads_1.return)) _a.call(overloads_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return overloads;\r\n        }\r\n    };\r\n    MethodDeclarationStructurePrinter.prototype.printOverloads = function (writer, name, structures) {\r\n        var e_2, _a;\r\n        if (structures == null || structures.length === 0)\r\n            return;\r\n        try {\r\n            for (var structures_1 = tslib_1.__values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {\r\n                var structure = structures_1_1.value;\r\n                this.printOverload(writer, name, structure);\r\n                writer.newLine();\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    MethodDeclarationStructurePrinter.prototype.printOverload = function (writer, name, structure) {\r\n        this.printBase(writer, name, structure);\r\n        writer.write(\";\");\r\n    };\r\n    MethodDeclarationStructurePrinter.prototype.printBase = function (writer, name, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forDecorator().printTexts(writer, structure.decorators);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode().printText(writer, structure);\r\n    };\r\n    return MethodDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.MethodDeclarationStructurePrinter = MethodDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/MethodDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/PropertyDeclarationStructurePrinter.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/PropertyDeclarationStructurePrinter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar PropertyDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertyDeclarationStructurePrinter, _super);\r\n    function PropertyDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    PropertyDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    PropertyDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forDecorator().printTexts(writer, structure.decorators);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(structure.name);\r\n        writer.conditionalWrite(structure.hasQuestionToken, \"?\");\r\n        writer.conditionalWrite(structure.hasExclamationToken && !structure.hasQuestionToken, \"!\");\r\n        this.factory.forTypedNode(\":\").printText(writer, structure);\r\n        this.factory.forInitializerExpressionableNode().printText(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    return PropertyDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.PropertyDeclarationStructurePrinter = PropertyDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/PropertyDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/SetAccessorDeclarationStructurePrinter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/SetAccessorDeclarationStructurePrinter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar SetAccessorDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SetAccessorDeclarationStructurePrinter, _super);\r\n    function SetAccessorDeclarationStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        _this.multipleWriter = new formatting_1.BlankLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    SetAccessorDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    SetAccessorDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forDecorator().printTexts(writer, structure.decorators);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"set \" + structure.name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode().printText(writer, structure);\r\n        writer.spaceIfLastNot().inlineBlock(function () {\r\n            _this.factory.forBodyText(_this.options).printText(writer, structure);\r\n        });\r\n    };\r\n    return SetAccessorDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.SetAccessorDeclarationStructurePrinter = SetAccessorDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/SetAccessorDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/class/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/class/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ClassDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/ClassDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConstructorDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/ConstructorDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./GetAccessorDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/GetAccessorDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./MethodDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/MethodDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/PropertyDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SetAccessorDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/SetAccessorDeclarationStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/class/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/common/StringStructurePrinter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/common/StringStructurePrinter.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ../StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar StringStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StringStructurePrinter, _super);\r\n    function StringStructurePrinter() {\r\n        return _super.call(this) || this;\r\n    }\r\n    StringStructurePrinter.prototype.printText = function (writer, textOrWriterFunc) {\r\n        if (typeof textOrWriterFunc === \"string\")\r\n            writer.write(textOrWriterFunc);\r\n        else\r\n            textOrWriterFunc(writer);\r\n    };\r\n    return StringStructurePrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.StringStructurePrinter = StringStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/common/StringStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/common/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/common/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./object */ \"./node_modules/ts-simple-ast/dist/structurePrinters/common/object/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StringStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/common/StringStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/common/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/common/object/PropertyAssignmentStructurePrinter.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/common/object/PropertyAssignmentStructurePrinter.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar PropertyAssignmentStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertyAssignmentStructurePrinter, _super);\r\n    function PropertyAssignmentStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PropertyAssignmentStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(structure.name + \": \");\r\n        utils_1.printTextFromStringOrWriter(writer, structure.initializer);\r\n    };\r\n    return PropertyAssignmentStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.PropertyAssignmentStructurePrinter = PropertyAssignmentStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/common/object/PropertyAssignmentStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/common/object/ShorthandPropertyAssignmentStructurePrinter.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/common/object/ShorthandPropertyAssignmentStructurePrinter.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar ShorthandPropertyAssignmentStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ShorthandPropertyAssignmentStructurePrinter, _super);\r\n    function ShorthandPropertyAssignmentStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ShorthandPropertyAssignmentStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(\"\" + structure.name);\r\n    };\r\n    return ShorthandPropertyAssignmentStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ShorthandPropertyAssignmentStructurePrinter = ShorthandPropertyAssignmentStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/common/object/ShorthandPropertyAssignmentStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/common/object/SpreadAssignmentStructurePrinter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/common/object/SpreadAssignmentStructurePrinter.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar SpreadAssignmentStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SpreadAssignmentStructurePrinter, _super);\r\n    function SpreadAssignmentStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    SpreadAssignmentStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(\"...\");\r\n        utils_1.printTextFromStringOrWriter(writer, structure.expression);\r\n    };\r\n    return SpreadAssignmentStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.SpreadAssignmentStructurePrinter = SpreadAssignmentStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/common/object/SpreadAssignmentStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/common/object/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/common/object/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyAssignmentStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/common/object/PropertyAssignmentStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ShorthandPropertyAssignmentStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/common/object/ShorthandPropertyAssignmentStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SpreadAssignmentStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/common/object/SpreadAssignmentStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/common/object/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/decorator/DecoratorStructurePrinter.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/decorator/DecoratorStructurePrinter.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar DecoratorStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DecoratorStructurePrinter, _super);\r\n    function DecoratorStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DecoratorStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.printMultiple(writer, structures, function () { return writer.newLine(); });\r\n    };\r\n    DecoratorStructurePrinter.prototype.printTextsInline = function (writer, structures) {\r\n        this.printMultiple(writer, structures, function () { return writer.space(); });\r\n    };\r\n    DecoratorStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(\"@\" + structure.name);\r\n        this.printArguments(writer, structure);\r\n    };\r\n    DecoratorStructurePrinter.prototype.printArguments = function (writer, structure) {\r\n        if (structure.arguments == null)\r\n            return;\r\n        writer.write(\"(\");\r\n        for (var i = 0; i < structure.arguments.length; i++) {\r\n            writer.conditionalWrite(i > 0, \", \");\r\n            utils_1.printTextFromStringOrWriter(writer, structure.arguments[i]);\r\n        }\r\n        writer.write(\")\");\r\n    };\r\n    DecoratorStructurePrinter.prototype.printMultiple = function (writer, structures, separator) {\r\n        var e_1, _a;\r\n        if (structures == null || structures.length === 0)\r\n            return;\r\n        try {\r\n            for (var structures_1 = tslib_1.__values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {\r\n                var structure = structures_1_1.value;\r\n                this.printText(writer, structure);\r\n                separator();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    return DecoratorStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.DecoratorStructurePrinter = DecoratorStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/decorator/DecoratorStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/decorator/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/decorator/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./DecoratorStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/decorator/DecoratorStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/decorator/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/doc/JSDocStructurePrinter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/doc/JSDocStructurePrinter.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar codeBlockWriter_1 = __webpack_require__(/*! ../../codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar JSDocStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JSDocStructurePrinter, _super);\r\n    function JSDocStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    JSDocStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var e_1, _a;\r\n        var lines = getText().split(/\\r?\\n/);\r\n        writer.writeLine(\"/**\");\r\n        try {\r\n            for (var lines_1 = tslib_1.__values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {\r\n                var line = lines_1_1.value;\r\n                writer.writeLine(\" * \" + line);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        writer.write(\" */\");\r\n        function getText() {\r\n            if (typeof structure === \"string\")\r\n                return structure;\r\n            var tempWriter = new codeBlockWriter_1.CodeBlockWriter(writer.getOptions());\r\n            if (typeof structure === \"function\") {\r\n                structure(tempWriter);\r\n                return tempWriter.toString();\r\n            }\r\n            return utils_1.getTextFromStringOrWriter(tempWriter, structure.description);\r\n        }\r\n    };\r\n    JSDocStructurePrinter.prototype.printDocs = function (writer, structures) {\r\n        var e_2, _a;\r\n        if (structures == null)\r\n            return;\r\n        try {\r\n            for (var structures_1 = tslib_1.__values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {\r\n                var structure = structures_1_1.value;\r\n                this.printText(writer, structure);\r\n                writer.newLine();\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    return JSDocStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.JSDocStructurePrinter = JSDocStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/doc/JSDocStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/doc/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/doc/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JSDocStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/doc/JSDocStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/doc/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumDeclarationStructurePrinter.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumDeclarationStructurePrinter.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar EnumDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EnumDeclarationStructurePrinter, _super);\r\n    function EnumDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.BlankLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    EnumDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    EnumDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.conditionalWrite(structure.isConst, \"const \");\r\n        writer.write(\"enum \" + structure.name + \" \").inlineBlock(function () {\r\n            _this.factory.forEnumMember().printTexts(writer, structure.members);\r\n        });\r\n    };\r\n    return EnumDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.EnumDeclarationStructurePrinter = EnumDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumMemberStructurePrinter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumMemberStructurePrinter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar EnumMemberStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(EnumMemberStructurePrinter, _super);\r\n    function EnumMemberStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.CommaNewLineSeparatedStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    EnumMemberStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    EnumMemberStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        writer.write(structure.name);\r\n        if (typeof structure.value === \"string\")\r\n            writer.write(\" = \").quote(structure.value);\r\n        else if (typeof structure.value === \"number\")\r\n            writer.write(\" = \" + structure.value);\r\n        else\r\n            this.factory.forInitializerExpressionableNode().printText(writer, structure);\r\n    };\r\n    return EnumMemberStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.EnumMemberStructurePrinter = EnumMemberStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumMemberStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/enum/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/enum/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EnumDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EnumMemberStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/enum/EnumMemberStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/enum/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportAssignmentStructurePrinter.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportAssignmentStructurePrinter.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar ExportAssignmentStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExportAssignmentStructurePrinter, _super);\r\n    function ExportAssignmentStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    ExportAssignmentStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    ExportAssignmentStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(\"export\");\r\n        if (structure.isExportEquals !== false)\r\n            writer.write(\" = \");\r\n        else\r\n            writer.write(\" default \");\r\n        this.printTextOrWriterFunc(writer, structure.expression);\r\n        writer.write(\";\");\r\n    };\r\n    return ExportAssignmentStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ExportAssignmentStructurePrinter = ExportAssignmentStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportAssignmentStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportDeclarationStructurePrinter.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportDeclarationStructurePrinter.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar ExportDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ExportDeclarationStructurePrinter, _super);\r\n    function ExportDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    ExportDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    ExportDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var hasModuleSpecifier = structure.moduleSpecifier != null && structure.moduleSpecifier.length > 0;\r\n        writer.write(\"export\");\r\n        if (structure.namedExports != null && structure.namedExports.length > 0) {\r\n            writer.space();\r\n            this.factory.forNamedImportExportSpecifier().printTextsWithBraces(writer, structure.namedExports);\r\n        }\r\n        else if (!hasModuleSpecifier)\r\n            writer.write(\" {\")\r\n                .conditionalWrite(this.factory.getFormatCodeSettings().insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces, \" \") // compiler does this\r\n                .write(\"}\");\r\n        else\r\n            writer.write(\" *\");\r\n        if (hasModuleSpecifier) {\r\n            writer.write(\" from \");\r\n            writer.quote(structure.moduleSpecifier);\r\n        }\r\n        writer.write(\";\");\r\n    };\r\n    return ExportDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ExportDeclarationStructurePrinter = ExportDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/file/ImportDeclarationStructurePrinter.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/file/ImportDeclarationStructurePrinter.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar ImportDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ImportDeclarationStructurePrinter, _super);\r\n    function ImportDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    ImportDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    ImportDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var hasNamedImport = structure.namedImports != null && structure.namedImports.length > 0;\r\n        // validation\r\n        if (hasNamedImport && structure.namespaceImport != null)\r\n            throw new errors.InvalidOperationError(\"An import declaration cannot have both a namespace import and a named import.\");\r\n        writer.write(\"import\");\r\n        // default import\r\n        if (structure.defaultImport != null) {\r\n            writer.write(\" \" + structure.defaultImport);\r\n            writer.conditionalWrite(hasNamedImport || structure.namespaceImport != null, \",\");\r\n        }\r\n        // namespace import\r\n        if (structure.namespaceImport != null)\r\n            writer.write(\" * as \" + structure.namespaceImport);\r\n        // named imports\r\n        if (structure.namedImports != null && structure.namedImports.length > 0) {\r\n            writer.space();\r\n            this.factory.forNamedImportExportSpecifier().printTextsWithBraces(writer, structure.namedImports);\r\n        }\r\n        // from keyword\r\n        writer.conditionalWrite(structure.defaultImport != null || hasNamedImport || structure.namespaceImport != null, \" from\");\r\n        writer.write(\" \");\r\n        writer.quote(structure.moduleSpecifier);\r\n        writer.write(\";\");\r\n    };\r\n    return ImportDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ImportDeclarationStructurePrinter = ImportDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/file/ImportDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/file/NamedImportExportSpecifierStructurePrinter.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/file/NamedImportExportSpecifierStructurePrinter.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar NamedImportExportSpecifierStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NamedImportExportSpecifierStructurePrinter, _super);\r\n    function NamedImportExportSpecifierStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.CommaSeparatedStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    NamedImportExportSpecifierStructurePrinter.prototype.printTextsWithBraces = function (writer, structures) {\r\n        var formatSettings = this.factory.getFormatCodeSettings();\r\n        writer.write(\"{\").conditionalWrite(formatSettings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces, \" \");\r\n        this.printTexts(writer, structures);\r\n        writer.conditionalWrite(formatSettings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces, \" \").write(\"}\");\r\n    };\r\n    NamedImportExportSpecifierStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    NamedImportExportSpecifierStructurePrinter.prototype.printText = function (writer, structure) {\r\n        if (typeof structure === \"string\")\r\n            writer.write(structure);\r\n        else {\r\n            writer.write(structure.name);\r\n            writer.conditionalWrite(structure.alias != null, \" as \" + structure.alias);\r\n        }\r\n    };\r\n    return NamedImportExportSpecifierStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.NamedImportExportSpecifierStructurePrinter = NamedImportExportSpecifierStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/file/NamedImportExportSpecifierStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/file/SourceFileStructurePrinter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/file/SourceFileStructurePrinter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar SourceFileStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SourceFileStructurePrinter, _super);\r\n    function SourceFileStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        return _this;\r\n    }\r\n    SourceFileStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forImportDeclaration().printTexts(writer, structure.imports);\r\n        this.factory.forBodyText(this.options).printText(writer, structure);\r\n        this.conditionalBlankLine(writer, structure.exports);\r\n        this.factory.forExportDeclaration().printTexts(writer, structure.exports);\r\n        writer.conditionalNewLine(!writer.isAtStartOfFirstLineOfBlock() && !writer.isLastNewLine());\r\n    };\r\n    SourceFileStructurePrinter.prototype.conditionalBlankLine = function (writer, structures) {\r\n        if (!utils_1.ArrayUtils.isNullOrEmpty(structures))\r\n            writer.conditionalBlankLine(!writer.isAtStartOfFirstLineOfBlock());\r\n    };\r\n    return SourceFileStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.SourceFileStructurePrinter = SourceFileStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/file/SourceFileStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/file/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/file/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExportAssignmentStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportAssignmentStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ExportDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/file/ExportDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ImportDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/file/ImportDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NamedImportExportSpecifierStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/file/NamedImportExportSpecifierStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SourceFileStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/file/SourceFileStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/file/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/formatting/BlankLineFormattingStructuresPrinter.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/formatting/BlankLineFormattingStructuresPrinter.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ../StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar BlankLineFormattingStructuresPrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BlankLineFormattingStructuresPrinter, _super);\r\n    function BlankLineFormattingStructuresPrinter(structurePrinter) {\r\n        var _this = _super.call(this) || this;\r\n        _this.structurePrinter = structurePrinter;\r\n        return _this;\r\n    }\r\n    BlankLineFormattingStructuresPrinter.prototype.printText = function (writer, structures) {\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            writer.conditionalBlankLine(i > 0);\r\n            this.structurePrinter.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    return BlankLineFormattingStructuresPrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.BlankLineFormattingStructuresPrinter = BlankLineFormattingStructuresPrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/formatting/BlankLineFormattingStructuresPrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaNewLineSeparatedStructuresPrinter.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaNewLineSeparatedStructuresPrinter.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ../StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar CommaNewLineSeparatedStructuresPrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CommaNewLineSeparatedStructuresPrinter, _super);\r\n    function CommaNewLineSeparatedStructuresPrinter(structurePrinter) {\r\n        var _this = _super.call(this) || this;\r\n        _this.structurePrinter = structurePrinter;\r\n        return _this;\r\n    }\r\n    CommaNewLineSeparatedStructuresPrinter.prototype.printText = function (writer, structures) {\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            if (i > 0)\r\n                writer.write(\",\").newLine();\r\n            this.structurePrinter.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    return CommaNewLineSeparatedStructuresPrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.CommaNewLineSeparatedStructuresPrinter = CommaNewLineSeparatedStructuresPrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaNewLineSeparatedStructuresPrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaSeparatedStructuresPrinter.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaSeparatedStructuresPrinter.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ../StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar CommaSeparatedStructuresPrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CommaSeparatedStructuresPrinter, _super);\r\n    function CommaSeparatedStructuresPrinter(structurePrinter) {\r\n        var _this = _super.call(this) || this;\r\n        _this.structurePrinter = structurePrinter;\r\n        return _this;\r\n    }\r\n    CommaSeparatedStructuresPrinter.prototype.printText = function (writer, structures) {\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            if (i > 0)\r\n                writer.write(\", \");\r\n            this.structurePrinter.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    return CommaSeparatedStructuresPrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.CommaSeparatedStructuresPrinter = CommaSeparatedStructuresPrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaSeparatedStructuresPrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/formatting/NewLineFormattingStructuresPrinter.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/formatting/NewLineFormattingStructuresPrinter.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ../StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar NewLineFormattingStructuresPrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NewLineFormattingStructuresPrinter, _super);\r\n    function NewLineFormattingStructuresPrinter(structurePrinter) {\r\n        var _this = _super.call(this) || this;\r\n        _this.structurePrinter = structurePrinter;\r\n        return _this;\r\n    }\r\n    NewLineFormattingStructuresPrinter.prototype.printText = function (writer, structures) {\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            writer.conditionalNewLine(i > 0);\r\n            this.structurePrinter.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    return NewLineFormattingStructuresPrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.NewLineFormattingStructuresPrinter = NewLineFormattingStructuresPrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/formatting/NewLineFormattingStructuresPrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/formatting/SpaceFormattingStructuresPrinter.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/formatting/SpaceFormattingStructuresPrinter.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar StructurePrinter_1 = __webpack_require__(/*! ../StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\");\r\nvar SpaceFormattingStructuresPrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(SpaceFormattingStructuresPrinter, _super);\r\n    function SpaceFormattingStructuresPrinter(structurePrinter) {\r\n        var _this = _super.call(this) || this;\r\n        _this.structurePrinter = structurePrinter;\r\n        return _this;\r\n    }\r\n    SpaceFormattingStructuresPrinter.prototype.printText = function (writer, structures) {\r\n        for (var i = 0; i < structures.length; i++) {\r\n            writer.conditionalWrite(i > 0, \" \");\r\n            this.structurePrinter.printText(writer, structures[i]);\r\n        }\r\n    };\r\n    return SpaceFormattingStructuresPrinter;\r\n}(StructurePrinter_1.StructurePrinter));\r\nexports.SpaceFormattingStructuresPrinter = SpaceFormattingStructuresPrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/formatting/SpaceFormattingStructuresPrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BlankLineFormattingStructuresPrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/BlankLineFormattingStructuresPrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CommaNewLineSeparatedStructuresPrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaNewLineSeparatedStructuresPrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CommaSeparatedStructuresPrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/CommaSeparatedStructuresPrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NewLineFormattingStructuresPrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/NewLineFormattingStructuresPrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SpaceFormattingStructuresPrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/SpaceFormattingStructuresPrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/function/FunctionDeclarationStructurePrinter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/function/FunctionDeclarationStructurePrinter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar FunctionDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FunctionDeclarationStructurePrinter, _super);\r\n    function FunctionDeclarationStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    FunctionDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        if (structures == null)\r\n            return;\r\n        for (var i = 0; i < structures.length; i++) {\r\n            var currentStructure = structures[i];\r\n            if (i > 0) {\r\n                var previousStructure = structures[i - 1];\r\n                if (previousStructure.hasDeclareKeyword && currentStructure.hasDeclareKeyword)\r\n                    writer.newLine();\r\n                else\r\n                    writer.blankLine();\r\n            }\r\n            this.printText(writer, currentStructure);\r\n        }\r\n    };\r\n    FunctionDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.printOverloads(writer, structure.name, getOverloadStructures());\r\n        this.printBase(writer, structure.name, structure);\r\n        if (structure.hasDeclareKeyword)\r\n            writer.write(\";\");\r\n        else\r\n            writer.space().inlineBlock(function () {\r\n                _this.factory.forBodyText({ isAmbient: false }).printText(writer, structure);\r\n            });\r\n        function getOverloadStructures() {\r\n            var e_1, _a;\r\n            // all the overloads need to have similar properties as the implementation\r\n            var overloads = utils_1.ObjectUtils.clone(structure.overloads);\r\n            if (overloads == null || overloads.length === 0)\r\n                return;\r\n            try {\r\n                for (var overloads_1 = tslib_1.__values(overloads), overloads_1_1 = overloads_1.next(); !overloads_1_1.done; overloads_1_1 = overloads_1.next()) {\r\n                    var overload = overloads_1_1.value;\r\n                    utils_1.setValueIfUndefined(overload, \"hasDeclareKeyword\", structure.hasDeclareKeyword);\r\n                    utils_1.setValueIfUndefined(overload, \"isExported\", structure.isExported);\r\n                    utils_1.setValueIfUndefined(overload, \"isDefaultExport\", structure.isDefaultExport);\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (overloads_1_1 && !overloads_1_1.done && (_a = overloads_1.return)) _a.call(overloads_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return overloads;\r\n        }\r\n    };\r\n    FunctionDeclarationStructurePrinter.prototype.printOverloads = function (writer, name, structures) {\r\n        var e_2, _a;\r\n        if (structures == null || structures.length === 0)\r\n            return;\r\n        try {\r\n            for (var structures_1 = tslib_1.__values(structures), structures_1_1 = structures_1.next(); !structures_1_1.done; structures_1_1 = structures_1.next()) {\r\n                var structure = structures_1_1.value;\r\n                this.printOverload(writer, name, structure);\r\n                writer.newLine();\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (structures_1_1 && !structures_1_1.done && (_a = structures_1.return)) _a.call(structures_1);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n    };\r\n    FunctionDeclarationStructurePrinter.prototype.printOverload = function (writer, name, structure) {\r\n        this.printBase(writer, name, structure);\r\n        writer.write(\";\");\r\n    };\r\n    FunctionDeclarationStructurePrinter.prototype.printBase = function (writer, name, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"function\");\r\n        writer.conditionalWrite(structure.isGenerator, \"*\");\r\n        if (!utils_1.StringUtils.isNullOrWhitespace(name))\r\n            writer.write(\" \" + name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        if (structure.parameters != null)\r\n            this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode().printText(writer, structure);\r\n    };\r\n    return FunctionDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.FunctionDeclarationStructurePrinter = FunctionDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/function/FunctionDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/function/ParameterDeclarationStructurePrinter.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/function/ParameterDeclarationStructurePrinter.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar ParameterDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ParameterDeclarationStructurePrinter, _super);\r\n    function ParameterDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.CommaSeparatedStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    ParameterDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        if (structures == null || structures.length === 0)\r\n            return;\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    ParameterDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forDecorator().printTextsInline(writer, structure.decorators);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.conditionalWrite(structure.isRestParameter, \"...\");\r\n        writer.write(structure.name);\r\n        writer.conditionalWrite(structure.hasQuestionToken, \"?\");\r\n        this.factory.forTypedNode(\":\", structure.hasQuestionToken).printText(writer, structure);\r\n        this.factory.forInitializerExpressionableNode().printText(writer, structure);\r\n    };\r\n    return ParameterDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ParameterDeclarationStructurePrinter = ParameterDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/function/ParameterDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/function/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/function/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FunctionDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/function/FunctionDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ParameterDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/function/ParameterDeclarationStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/function/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./base */ \"./node_modules/ts-simple-ast/dist/structurePrinters/base/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./class */ \"./node_modules/ts-simple-ast/dist/structurePrinters/class/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./common */ \"./node_modules/ts-simple-ast/dist/structurePrinters/common/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./decorator */ \"./node_modules/ts-simple-ast/dist/structurePrinters/decorator/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./doc */ \"./node_modules/ts-simple-ast/dist/structurePrinters/doc/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./enum */ \"./node_modules/ts-simple-ast/dist/structurePrinters/enum/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./file */ \"./node_modules/ts-simple-ast/dist/structurePrinters/file/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./function */ \"./node_modules/ts-simple-ast/dist/structurePrinters/function/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./interface */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./jsx */ \"./node_modules/ts-simple-ast/dist/structurePrinters/jsx/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./namespace */ \"./node_modules/ts-simple-ast/dist/structurePrinters/namespace/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./statement */ \"./node_modules/ts-simple-ast/dist/structurePrinters/statement/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/StructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./variable */ \"./node_modules/ts-simple-ast/dist/structurePrinters/variable/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/ts-simple-ast/dist/structurePrinters/types/index.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/CallSignatureDeclarationStructurePrinter.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/CallSignatureDeclarationStructurePrinter.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar CallSignatureDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(CallSignatureDeclarationStructurePrinter, _super);\r\n    function CallSignatureDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    CallSignatureDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    CallSignatureDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode(true).printText(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    return CallSignatureDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.CallSignatureDeclarationStructurePrinter = CallSignatureDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/CallSignatureDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/ConstructSignatureDeclarationStructurePrinter.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/ConstructSignatureDeclarationStructurePrinter.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar ConstructSignatureDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConstructSignatureDeclarationStructurePrinter, _super);\r\n    function ConstructSignatureDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    ConstructSignatureDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    ConstructSignatureDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        writer.write(\"new\");\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode().printText(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    return ConstructSignatureDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.ConstructSignatureDeclarationStructurePrinter = ConstructSignatureDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/ConstructSignatureDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/IndexSignatureDeclarationStructurePrinter.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/IndexSignatureDeclarationStructurePrinter.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar IndexSignatureDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(IndexSignatureDeclarationStructurePrinter, _super);\r\n    function IndexSignatureDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    IndexSignatureDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    IndexSignatureDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"[\" + (structure.keyName || \"key\") + \": \" + (structure.keyType || \"string\") + \"]: \");\r\n        utils_1.printTextFromStringOrWriter(writer, structure.returnType);\r\n        writer.write(\";\");\r\n    };\r\n    return IndexSignatureDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.IndexSignatureDeclarationStructurePrinter = IndexSignatureDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/IndexSignatureDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/InterfaceDeclarationStructurePrinter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/InterfaceDeclarationStructurePrinter.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar InterfaceDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(InterfaceDeclarationStructurePrinter, _super);\r\n    function InterfaceDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.BlankLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    InterfaceDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    InterfaceDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"interface \" + structure.name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.space();\r\n        if (!utils_1.ArrayUtils.isNullOrEmpty(structure.extends))\r\n            writer.write(\"extends \" + structure.extends.join(\", \") + \" \");\r\n        writer.inlineBlock(function () {\r\n            _this.factory.forTypeElementMemberedNode().printText(writer, structure);\r\n        });\r\n    };\r\n    return InterfaceDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.InterfaceDeclarationStructurePrinter = InterfaceDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/InterfaceDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/MethodSignatureStructurePrinter.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/MethodSignatureStructurePrinter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar MethodSignatureStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MethodSignatureStructurePrinter, _super);\r\n    function MethodSignatureStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    MethodSignatureStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    MethodSignatureStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        writer.write(structure.name);\r\n        writer.conditionalWrite(structure.hasQuestionToken, \"?\");\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        writer.write(\"(\");\r\n        this.factory.forParameterDeclaration().printTexts(writer, structure.parameters);\r\n        writer.write(\")\");\r\n        this.factory.forReturnTypedNode().printText(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    return MethodSignatureStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.MethodSignatureStructurePrinter = MethodSignatureStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/MethodSignatureStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/PropertySignatureStructurePrinter.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/PropertySignatureStructurePrinter.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar PropertySignatureStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PropertySignatureStructurePrinter, _super);\r\n    function PropertySignatureStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    PropertySignatureStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    PropertySignatureStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(structure.name);\r\n        writer.conditionalWrite(structure.hasQuestionToken, \"?\");\r\n        this.factory.forTypedNode(\":\").printText(writer, structure);\r\n        // why would someone write an initializer? I guess let them do it...\r\n        this.factory.forInitializerExpressionableNode().printText(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    return PropertySignatureStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.PropertySignatureStructurePrinter = PropertySignatureStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/PropertySignatureStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/TypeElementMemberedNodeStructurePrinter.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/TypeElementMemberedNodeStructurePrinter.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar TypeElementMemberedNodeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeElementMemberedNodeStructurePrinter, _super);\r\n    function TypeElementMemberedNodeStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    TypeElementMemberedNodeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forCallSignatureDeclaration().printTexts(writer, structure.callSignatures);\r\n        this.conditionalSeparator(writer, structure.constructSignatures);\r\n        this.factory.forConstructSignatureDeclaration().printTexts(writer, structure.constructSignatures);\r\n        this.conditionalSeparator(writer, structure.indexSignatures);\r\n        this.factory.forIndexSignatureDeclaration().printTexts(writer, structure.indexSignatures);\r\n        this.conditionalSeparator(writer, structure.properties);\r\n        this.factory.forPropertySignature().printTexts(writer, structure.properties);\r\n        this.conditionalSeparator(writer, structure.methods);\r\n        this.factory.forMethodSignature().printTexts(writer, structure.methods);\r\n    };\r\n    TypeElementMemberedNodeStructurePrinter.prototype.conditionalSeparator = function (writer, structures) {\r\n        if (!utils_1.ArrayUtils.isNullOrEmpty(structures) && !writer.isAtStartOfFirstLineOfBlock())\r\n            writer.newLine();\r\n    };\r\n    return TypeElementMemberedNodeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.TypeElementMemberedNodeStructurePrinter = TypeElementMemberedNodeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/TypeElementMemberedNodeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/interface/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/interface/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./CallSignatureDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/CallSignatureDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConstructSignatureDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/ConstructSignatureDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./IndexSignatureDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/IndexSignatureDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./InterfaceDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/InterfaceDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./MethodSignatureStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/MethodSignatureStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertySignatureStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/PropertySignatureStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeElementMemberedNodeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/interface/TypeElementMemberedNodeStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/interface/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxAttributeStructurePrinter.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxAttributeStructurePrinter.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar JsxAttributeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxAttributeStructurePrinter, _super);\r\n    function JsxAttributeStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    JsxAttributeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        if (structure.isSpreadAttribute)\r\n            writer.write(\"...\");\r\n        writer.write(structure.name);\r\n        if (structure.initializer != null)\r\n            writer.write(\"=\").write(structure.initializer);\r\n    };\r\n    return JsxAttributeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.JsxAttributeStructurePrinter = JsxAttributeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxAttributeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxElementStructurePrinter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxElementStructurePrinter.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar JsxElementStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(JsxElementStructurePrinter, _super);\r\n    function JsxElementStructurePrinter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    JsxElementStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(\"<\" + structure.name);\r\n        if (structure.attributes)\r\n            this.printAttributes(writer, structure.attributes);\r\n        if (this.isSelfClosing(structure)) {\r\n            writer.write(\" />\");\r\n            return;\r\n        }\r\n        writer.write(\">\");\r\n        if (structure.children != null)\r\n            this.printChildren(writer, structure.children);\r\n        writer.write(\"</\" + structure.name + \">\");\r\n    };\r\n    JsxElementStructurePrinter.prototype.isSelfClosing = function (structure) {\r\n        if (structure.isSelfClosing === true)\r\n            return true;\r\n        return structure.isSelfClosing == null && structure.children == null;\r\n    };\r\n    JsxElementStructurePrinter.prototype.printAttributes = function (writer, attributes) {\r\n        var e_1, _a;\r\n        var attributePrinter = this.factory.forJsxAttribute();\r\n        try {\r\n            for (var attributes_1 = tslib_1.__values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {\r\n                var attrib = attributes_1_1.value;\r\n                writer.space();\r\n                attributePrinter.printText(writer, attrib);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    JsxElementStructurePrinter.prototype.printChildren = function (writer, children) {\r\n        var _this = this;\r\n        writer.newLine();\r\n        writer.indentBlock(function () {\r\n            var e_2, _a;\r\n            try {\r\n                for (var children_1 = tslib_1.__values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\r\n                    var child = children_1_1.value;\r\n                    _this.printText(writer, child);\r\n                    writer.newLine();\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        });\r\n    };\r\n    return JsxElementStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.JsxElementStructurePrinter = JsxElementStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxElementStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/jsx/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/jsx/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxAttributeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxAttributeStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./JsxElementStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/jsx/JsxElementStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/jsx/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/namespace/NamespaceDeclarationStructurePrinter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/namespace/NamespaceDeclarationStructurePrinter.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar NamespaceDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(NamespaceDeclarationStructurePrinter, _super);\r\n    function NamespaceDeclarationStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        _this.blankLineFormattingWriter = new formatting_1.BlankLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    NamespaceDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.blankLineFormattingWriter.printText(writer, structures);\r\n    };\r\n    NamespaceDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        var _this = this;\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write((structure.hasModuleKeyword ? \"module\" : \"namespace\") + \" \" + structure.name + \" \").inlineBlock(function () {\r\n            _this.factory.forBodyText({\r\n                isAmbient: structure.hasDeclareKeyword || _this.options.isAmbient\r\n            }).printText(writer, structure);\r\n        });\r\n    };\r\n    return NamespaceDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.NamespaceDeclarationStructurePrinter = NamespaceDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/namespace/NamespaceDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/namespace/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/namespace/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./NamespaceDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/namespace/NamespaceDeclarationStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/namespace/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/statement/BodyTextStructurePrinter.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/statement/BodyTextStructurePrinter.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar codeBlockWriter_1 = __webpack_require__(/*! ../../codeBlockWriter */ \"./node_modules/ts-simple-ast/dist/codeBlockWriter/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar BodyTextStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(BodyTextStructurePrinter, _super);\r\n    function BodyTextStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        return _this;\r\n    }\r\n    BodyTextStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forStatementedNode(this.options).printText(writer, structure);\r\n        // todo: hacky, will need to change this in the future...\r\n        // basically, need a way to make this only do the blank line if the user does a write\r\n        var newWriter = new codeBlockWriter_1.CodeBlockWriter(writer.getOptions());\r\n        this.printTextOrWriterFunc(newWriter, structure.bodyText);\r\n        if (newWriter.getLength() > 0) {\r\n            if (!writer.isAtStartOfFirstLineOfBlock())\r\n                writer.blankLineIfLastNot();\r\n            writer.write(newWriter.toString());\r\n        }\r\n    };\r\n    return BodyTextStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.BodyTextStructurePrinter = BodyTextStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/statement/BodyTextStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/statement/StatementedNodeStructurePrinter.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/statement/StatementedNodeStructurePrinter.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar StatementedNodeStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(StatementedNodeStructurePrinter, _super);\r\n    function StatementedNodeStructurePrinter(factory, options) {\r\n        var _this = _super.call(this, factory) || this;\r\n        _this.options = options;\r\n        return _this;\r\n    }\r\n    StatementedNodeStructurePrinter.prototype.printText = function (writer, structure) {\r\n        conditionalBlankLine(structure.typeAliases);\r\n        this.factory.forTypeAliasDeclaration().printTexts(writer, structure.typeAliases);\r\n        conditionalBlankLine(structure.interfaces);\r\n        this.factory.forInterfaceDeclaration().printTexts(writer, structure.interfaces);\r\n        conditionalBlankLine(structure.enums);\r\n        this.factory.forEnumDeclaration().printTexts(writer, structure.enums);\r\n        conditionalBlankLine(structure.functions);\r\n        this.factory.forFunctionDeclaration().printTexts(writer, structure.functions);\r\n        conditionalBlankLine(structure.classes);\r\n        this.factory.forClassDeclaration(this.options).printTexts(writer, structure.classes);\r\n        conditionalBlankLine(structure.namespaces);\r\n        this.factory.forNamespaceDeclaration(this.options).printTexts(writer, structure.namespaces);\r\n        function conditionalBlankLine(structures) {\r\n            if (!writer.isAtStartOfFirstLineOfBlock() && !utils_1.ArrayUtils.isNullOrEmpty(structures))\r\n                writer.blankLine();\r\n        }\r\n    };\r\n    return StatementedNodeStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.StatementedNodeStructurePrinter = StatementedNodeStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/statement/StatementedNodeStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/statement/VariableStatementStructurePrinter.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/statement/VariableStatementStructurePrinter.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar VariableDeclarationKind_1 = __webpack_require__(/*! ../../compiler/variable/VariableDeclarationKind */ \"./node_modules/ts-simple-ast/dist/compiler/variable/VariableDeclarationKind.js\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar VariableStatementStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(VariableStatementStructurePrinter, _super);\r\n    function VariableStatementStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    VariableStatementStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    VariableStatementStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write((structure.declarationKind || VariableDeclarationKind_1.VariableDeclarationKind.Let) + \" \");\r\n        this.factory.forVariableDeclaration().printTexts(writer, structure.declarations);\r\n        writer.write(\";\");\r\n    };\r\n    return VariableStatementStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.VariableStatementStructurePrinter = VariableStatementStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/statement/VariableStatementStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/statement/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/statement/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./BodyTextStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/statement/BodyTextStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StatementedNodeStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/statement/StatementedNodeStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VariableStatementStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/statement/VariableStatementStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/statement/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeAliasDeclarationStructurePrinter.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeAliasDeclarationStructurePrinter.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar TypeAliasDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeAliasDeclarationStructurePrinter, _super);\r\n    function TypeAliasDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.NewLineFormattingStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    TypeAliasDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    TypeAliasDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        this.factory.forJSDoc().printDocs(writer, structure.docs);\r\n        this.factory.forModifierableNode().printText(writer, structure);\r\n        writer.write(\"type \" + structure.name);\r\n        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);\r\n        this.factory.forTypedNode(\" =\").printText(writer, structure);\r\n        writer.write(\";\");\r\n    };\r\n    return TypeAliasDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.TypeAliasDeclarationStructurePrinter = TypeAliasDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeAliasDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeParameterDeclarationStructurePrinter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeParameterDeclarationStructurePrinter.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar TypeParameterDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TypeParameterDeclarationStructurePrinter, _super);\r\n    function TypeParameterDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.CommaSeparatedStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    TypeParameterDeclarationStructurePrinter.prototype.printTextsWithBrackets = function (writer, structures) {\r\n        if (structures == null || structures.length === 0)\r\n            return;\r\n        writer.write(\"<\");\r\n        this.printTexts(writer, structures);\r\n        writer.write(\">\");\r\n    };\r\n    TypeParameterDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    TypeParameterDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(structure.name);\r\n        if (structure.constraint != null && structure.constraint.length > 0)\r\n            writer.write(\" extends \" + structure.constraint);\r\n        if (structure.default != null && structure.default.length > 0)\r\n            writer.write(\" = \" + structure.default);\r\n    };\r\n    return TypeParameterDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.TypeParameterDeclarationStructurePrinter = TypeParameterDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeParameterDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/types/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/types/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeAliasDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeAliasDeclarationStructurePrinter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeParameterDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/types/TypeParameterDeclarationStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/types/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/variable/VariableDeclarationStructurePrinter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/variable/VariableDeclarationStructurePrinter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar FactoryStructurePrinter_1 = __webpack_require__(/*! ../FactoryStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/FactoryStructurePrinter.js\");\r\nvar formatting_1 = __webpack_require__(/*! ../formatting */ \"./node_modules/ts-simple-ast/dist/structurePrinters/formatting/index.js\");\r\nvar VariableDeclarationStructurePrinter = /** @class */ (function (_super) {\r\n    tslib_1.__extends(VariableDeclarationStructurePrinter, _super);\r\n    function VariableDeclarationStructurePrinter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.multipleWriter = new formatting_1.CommaSeparatedStructuresPrinter(_this);\r\n        return _this;\r\n    }\r\n    VariableDeclarationStructurePrinter.prototype.printTexts = function (writer, structures) {\r\n        this.multipleWriter.printText(writer, structures);\r\n    };\r\n    VariableDeclarationStructurePrinter.prototype.printText = function (writer, structure) {\r\n        writer.write(structure.name);\r\n        writer.conditionalWrite(structure.hasExclamationToken, \"!\");\r\n        this.factory.forTypedNode(\":\").printText(writer, structure);\r\n        this.factory.forInitializerExpressionableNode().printText(writer, structure);\r\n    };\r\n    return VariableDeclarationStructurePrinter;\r\n}(FactoryStructurePrinter_1.FactoryStructurePrinter));\r\nexports.VariableDeclarationStructurePrinter = VariableDeclarationStructurePrinter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/variable/VariableDeclarationStructurePrinter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/structurePrinters/variable/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/structurePrinters/variable/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./VariableDeclarationStructurePrinter */ \"./node_modules/ts-simple-ast/dist/structurePrinters/variable/VariableDeclarationStructurePrinter.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/structurePrinters/variable/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/typescript/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/typescript/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./typescript */ \"./node_modules/ts-simple-ast/dist/typescript/typescript.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/typescript/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/typescript/tsInternal.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/typescript/tsInternal.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* barrel:ignore */\r\nvar typescript_1 = __webpack_require__(/*! ./typescript */ \"./node_modules/ts-simple-ast/dist/typescript/typescript.js\");\r\n/* tslint:disable:align */\r\nfunction matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getEntries) {\r\n    return typescript_1.ts.matchFiles.apply(this, arguments);\r\n}\r\nexports.matchFiles = matchFiles;\r\nfunction getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {\r\n    return typescript_1.ts.getFileMatcherPatterns.apply(this, arguments);\r\n}\r\nexports.getFileMatcherPatterns = getFileMatcherPatterns;\r\nfunction getEmitModuleResolutionKind(compilerOptions) {\r\n    return typescript_1.ts.getEmitModuleResolutionKind.apply(this, arguments);\r\n}\r\nexports.getEmitModuleResolutionKind = getEmitModuleResolutionKind;\r\n/* tslint:enable:align */\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/typescript/tsInternal.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/typescript/typescript.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/typescript/typescript.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* tslint:disable */\r\n/*\r\n * TypeScript Compiler Declaration File\r\n * ====================================\r\n * DO NOT EDIT - This file is automatically generated by createCompilerApiLayer.ts\r\n *\r\n * This file contains the TypeScript compiler declarations slightly modified.\r\n * Note: The TypeScript compiler is licensed under the Apache 2.0 license.\r\n */\r\nvar tsCompiler = __webpack_require__(/*! typescript */ \"typescript\");\r\nvar ObjectUtils_1 = __webpack_require__(/*! ../utils/ObjectUtils */ \"./node_modules/ts-simple-ast/dist/utils/ObjectUtils.js\");\r\nvar ts;\r\n(function (ts) {\r\n    var NodeFlags;\r\n    (function (NodeFlags) {\r\n        NodeFlags[NodeFlags[\"None\"] = 0] = \"None\";\r\n        NodeFlags[NodeFlags[\"Let\"] = 1] = \"Let\";\r\n        NodeFlags[NodeFlags[\"Const\"] = 2] = \"Const\";\r\n        NodeFlags[NodeFlags[\"NestedNamespace\"] = 4] = \"NestedNamespace\";\r\n        NodeFlags[NodeFlags[\"Synthesized\"] = 8] = \"Synthesized\";\r\n        NodeFlags[NodeFlags[\"Namespace\"] = 16] = \"Namespace\";\r\n        NodeFlags[NodeFlags[\"ExportContext\"] = 32] = \"ExportContext\";\r\n        NodeFlags[NodeFlags[\"ContainsThis\"] = 64] = \"ContainsThis\";\r\n        NodeFlags[NodeFlags[\"HasImplicitReturn\"] = 128] = \"HasImplicitReturn\";\r\n        NodeFlags[NodeFlags[\"HasExplicitReturn\"] = 256] = \"HasExplicitReturn\";\r\n        NodeFlags[NodeFlags[\"GlobalAugmentation\"] = 512] = \"GlobalAugmentation\";\r\n        NodeFlags[NodeFlags[\"HasAsyncFunctions\"] = 1024] = \"HasAsyncFunctions\";\r\n        NodeFlags[NodeFlags[\"DisallowInContext\"] = 2048] = \"DisallowInContext\";\r\n        NodeFlags[NodeFlags[\"YieldContext\"] = 4096] = \"YieldContext\";\r\n        NodeFlags[NodeFlags[\"DecoratorContext\"] = 8192] = \"DecoratorContext\";\r\n        NodeFlags[NodeFlags[\"AwaitContext\"] = 16384] = \"AwaitContext\";\r\n        NodeFlags[NodeFlags[\"ThisNodeHasError\"] = 32768] = \"ThisNodeHasError\";\r\n        NodeFlags[NodeFlags[\"JavaScriptFile\"] = 65536] = \"JavaScriptFile\";\r\n        NodeFlags[NodeFlags[\"ThisNodeOrAnySubNodesHasError\"] = 131072] = \"ThisNodeOrAnySubNodesHasError\";\r\n        NodeFlags[NodeFlags[\"HasAggregatedChildData\"] = 262144] = \"HasAggregatedChildData\";\r\n        NodeFlags[NodeFlags[\"JSDoc\"] = 2097152] = \"JSDoc\";\r\n        NodeFlags[NodeFlags[\"JsonFile\"] = 16777216] = \"JsonFile\";\r\n        NodeFlags[NodeFlags[\"BlockScoped\"] = 3] = \"BlockScoped\";\r\n        NodeFlags[NodeFlags[\"ReachabilityCheckFlags\"] = 384] = \"ReachabilityCheckFlags\";\r\n        NodeFlags[NodeFlags[\"ReachabilityAndEmitFlags\"] = 1408] = \"ReachabilityAndEmitFlags\";\r\n        NodeFlags[NodeFlags[\"ContextFlags\"] = 12679168] = \"ContextFlags\";\r\n        NodeFlags[NodeFlags[\"TypeExcludesFlags\"] = 20480] = \"TypeExcludesFlags\";\r\n    })(NodeFlags = ts.NodeFlags || (ts.NodeFlags = {}));\r\n    var ModifierFlags;\r\n    (function (ModifierFlags) {\r\n        ModifierFlags[ModifierFlags[\"None\"] = 0] = \"None\";\r\n        ModifierFlags[ModifierFlags[\"Export\"] = 1] = \"Export\";\r\n        ModifierFlags[ModifierFlags[\"Ambient\"] = 2] = \"Ambient\";\r\n        ModifierFlags[ModifierFlags[\"Public\"] = 4] = \"Public\";\r\n        ModifierFlags[ModifierFlags[\"Private\"] = 8] = \"Private\";\r\n        ModifierFlags[ModifierFlags[\"Protected\"] = 16] = \"Protected\";\r\n        ModifierFlags[ModifierFlags[\"Static\"] = 32] = \"Static\";\r\n        ModifierFlags[ModifierFlags[\"Readonly\"] = 64] = \"Readonly\";\r\n        ModifierFlags[ModifierFlags[\"Abstract\"] = 128] = \"Abstract\";\r\n        ModifierFlags[ModifierFlags[\"Async\"] = 256] = \"Async\";\r\n        ModifierFlags[ModifierFlags[\"Default\"] = 512] = \"Default\";\r\n        ModifierFlags[ModifierFlags[\"Const\"] = 2048] = \"Const\";\r\n        ModifierFlags[ModifierFlags[\"HasComputedFlags\"] = 536870912] = \"HasComputedFlags\";\r\n        ModifierFlags[ModifierFlags[\"AccessibilityModifier\"] = 28] = \"AccessibilityModifier\";\r\n        ModifierFlags[ModifierFlags[\"ParameterPropertyModifier\"] = 92] = \"ParameterPropertyModifier\";\r\n        ModifierFlags[ModifierFlags[\"NonPublicAccessibilityModifier\"] = 24] = \"NonPublicAccessibilityModifier\";\r\n        ModifierFlags[ModifierFlags[\"TypeScriptModifier\"] = 2270] = \"TypeScriptModifier\";\r\n        ModifierFlags[ModifierFlags[\"ExportDefault\"] = 513] = \"ExportDefault\";\r\n        ModifierFlags[ModifierFlags[\"All\"] = 3071] = \"All\";\r\n    })(ModifierFlags = ts.ModifierFlags || (ts.ModifierFlags = {}));\r\n    var JsxFlags;\r\n    (function (JsxFlags) {\r\n        JsxFlags[JsxFlags[\"None\"] = 0] = \"None\";\r\n        /**\r\n         * An element from a named property of the JSX.IntrinsicElements interface\r\n         */\r\n        JsxFlags[JsxFlags[\"IntrinsicNamedElement\"] = 1] = \"IntrinsicNamedElement\";\r\n        /**\r\n         * An element inferred from the string index signature of the JSX.IntrinsicElements interface\r\n         */\r\n        JsxFlags[JsxFlags[\"IntrinsicIndexedElement\"] = 2] = \"IntrinsicIndexedElement\";\r\n        JsxFlags[JsxFlags[\"IntrinsicElement\"] = 3] = \"IntrinsicElement\";\r\n    })(JsxFlags = ts.JsxFlags || (ts.JsxFlags = {}));\r\n    var FlowFlags;\r\n    (function (FlowFlags) {\r\n        FlowFlags[FlowFlags[\"Unreachable\"] = 1] = \"Unreachable\";\r\n        FlowFlags[FlowFlags[\"Start\"] = 2] = \"Start\";\r\n        FlowFlags[FlowFlags[\"BranchLabel\"] = 4] = \"BranchLabel\";\r\n        FlowFlags[FlowFlags[\"LoopLabel\"] = 8] = \"LoopLabel\";\r\n        FlowFlags[FlowFlags[\"Assignment\"] = 16] = \"Assignment\";\r\n        FlowFlags[FlowFlags[\"TrueCondition\"] = 32] = \"TrueCondition\";\r\n        FlowFlags[FlowFlags[\"FalseCondition\"] = 64] = \"FalseCondition\";\r\n        FlowFlags[FlowFlags[\"SwitchClause\"] = 128] = \"SwitchClause\";\r\n        FlowFlags[FlowFlags[\"ArrayMutation\"] = 256] = \"ArrayMutation\";\r\n        FlowFlags[FlowFlags[\"Referenced\"] = 512] = \"Referenced\";\r\n        FlowFlags[FlowFlags[\"Shared\"] = 1024] = \"Shared\";\r\n        FlowFlags[FlowFlags[\"PreFinally\"] = 2048] = \"PreFinally\";\r\n        FlowFlags[FlowFlags[\"AfterFinally\"] = 4096] = \"AfterFinally\";\r\n        FlowFlags[FlowFlags[\"Label\"] = 12] = \"Label\";\r\n        FlowFlags[FlowFlags[\"Condition\"] = 96] = \"Condition\";\r\n    })(FlowFlags = ts.FlowFlags || (ts.FlowFlags = {}));\r\n    var ExitStatus;\r\n    (function (ExitStatus) {\r\n        ExitStatus[ExitStatus[\"Success\"] = 0] = \"Success\";\r\n        ExitStatus[ExitStatus[\"DiagnosticsPresent_OutputsSkipped\"] = 1] = \"DiagnosticsPresent_OutputsSkipped\";\r\n        ExitStatus[ExitStatus[\"DiagnosticsPresent_OutputsGenerated\"] = 2] = \"DiagnosticsPresent_OutputsGenerated\";\r\n    })(ExitStatus = ts.ExitStatus || (ts.ExitStatus = {}));\r\n    var NodeBuilderFlags;\r\n    (function (NodeBuilderFlags) {\r\n        NodeBuilderFlags[NodeBuilderFlags[\"None\"] = 0] = \"None\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"NoTruncation\"] = 1] = \"NoTruncation\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"WriteArrayAsGenericType\"] = 2] = \"WriteArrayAsGenericType\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"GenerateNamesForShadowedTypeParams\"] = 4] = \"GenerateNamesForShadowedTypeParams\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"UseStructuralFallback\"] = 8] = \"UseStructuralFallback\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"ForbidIndexedAccessSymbolReferences\"] = 16] = \"ForbidIndexedAccessSymbolReferences\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"WriteTypeArgumentsOfSignature\"] = 32] = \"WriteTypeArgumentsOfSignature\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"UseFullyQualifiedType\"] = 64] = \"UseFullyQualifiedType\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"UseOnlyExternalAliasing\"] = 128] = \"UseOnlyExternalAliasing\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"SuppressAnyReturnType\"] = 256] = \"SuppressAnyReturnType\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"WriteTypeParametersInQualifiedName\"] = 512] = \"WriteTypeParametersInQualifiedName\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"MultilineObjectLiterals\"] = 1024] = \"MultilineObjectLiterals\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"WriteClassExpressionAsTypeLiteral\"] = 2048] = \"WriteClassExpressionAsTypeLiteral\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"UseTypeOfFunction\"] = 4096] = \"UseTypeOfFunction\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"OmitParameterModifiers\"] = 8192] = \"OmitParameterModifiers\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"UseAliasDefinedOutsideCurrentScope\"] = 16384] = \"UseAliasDefinedOutsideCurrentScope\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowThisInObjectLiteral\"] = 32768] = \"AllowThisInObjectLiteral\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowQualifedNameInPlaceOfIdentifier\"] = 65536] = \"AllowQualifedNameInPlaceOfIdentifier\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowAnonymousIdentifier\"] = 131072] = \"AllowAnonymousIdentifier\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowEmptyUnionOrIntersection\"] = 262144] = \"AllowEmptyUnionOrIntersection\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowEmptyTuple\"] = 524288] = \"AllowEmptyTuple\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowUniqueESSymbolType\"] = 1048576] = \"AllowUniqueESSymbolType\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"AllowEmptyIndexInfoType\"] = 2097152] = \"AllowEmptyIndexInfoType\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"IgnoreErrors\"] = 3112960] = \"IgnoreErrors\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"InObjectTypeLiteral\"] = 4194304] = \"InObjectTypeLiteral\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"InTypeAlias\"] = 8388608] = \"InTypeAlias\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"InInitialEntityName\"] = 16777216] = \"InInitialEntityName\";\r\n        NodeBuilderFlags[NodeBuilderFlags[\"InReverseMappedType\"] = 33554432] = \"InReverseMappedType\";\r\n    })(NodeBuilderFlags = ts.NodeBuilderFlags || (ts.NodeBuilderFlags = {}));\r\n    var SymbolFormatFlags;\r\n    (function (SymbolFormatFlags) {\r\n        SymbolFormatFlags[SymbolFormatFlags[\"None\"] = 0] = \"None\";\r\n        SymbolFormatFlags[SymbolFormatFlags[\"WriteTypeParametersOrArguments\"] = 1] = \"WriteTypeParametersOrArguments\";\r\n        SymbolFormatFlags[SymbolFormatFlags[\"UseOnlyExternalAliasing\"] = 2] = \"UseOnlyExternalAliasing\";\r\n        SymbolFormatFlags[SymbolFormatFlags[\"AllowAnyNodeKind\"] = 4] = \"AllowAnyNodeKind\";\r\n        SymbolFormatFlags[SymbolFormatFlags[\"UseAliasDefinedOutsideCurrentScope\"] = 8] = \"UseAliasDefinedOutsideCurrentScope\";\r\n    })(SymbolFormatFlags = ts.SymbolFormatFlags || (ts.SymbolFormatFlags = {}));\r\n    var TypePredicateKind;\r\n    (function (TypePredicateKind) {\r\n        TypePredicateKind[TypePredicateKind[\"This\"] = 0] = \"This\";\r\n        TypePredicateKind[TypePredicateKind[\"Identifier\"] = 1] = \"Identifier\";\r\n    })(TypePredicateKind = ts.TypePredicateKind || (ts.TypePredicateKind = {}));\r\n    var InternalSymbolName;\r\n    (function (InternalSymbolName) {\r\n        InternalSymbolName[\"Call\"] = \"__call\";\r\n        InternalSymbolName[\"Constructor\"] = \"__constructor\";\r\n        InternalSymbolName[\"New\"] = \"__new\";\r\n        InternalSymbolName[\"Index\"] = \"__index\";\r\n        InternalSymbolName[\"ExportStar\"] = \"__export\";\r\n        InternalSymbolName[\"Global\"] = \"__global\";\r\n        InternalSymbolName[\"Missing\"] = \"__missing\";\r\n        InternalSymbolName[\"Type\"] = \"__type\";\r\n        InternalSymbolName[\"Object\"] = \"__object\";\r\n        InternalSymbolName[\"JSXAttributes\"] = \"__jsxAttributes\";\r\n        InternalSymbolName[\"Class\"] = \"__class\";\r\n        InternalSymbolName[\"Function\"] = \"__function\";\r\n        InternalSymbolName[\"Computed\"] = \"__computed\";\r\n        InternalSymbolName[\"Resolving\"] = \"__resolving__\";\r\n        InternalSymbolName[\"ExportEquals\"] = \"export=\";\r\n        InternalSymbolName[\"Default\"] = \"default\";\r\n    })(InternalSymbolName = ts.InternalSymbolName || (ts.InternalSymbolName = {}));\r\n    var SignatureKind;\r\n    (function (SignatureKind) {\r\n        SignatureKind[SignatureKind[\"Call\"] = 0] = \"Call\";\r\n        SignatureKind[SignatureKind[\"Construct\"] = 1] = \"Construct\";\r\n    })(SignatureKind = ts.SignatureKind || (ts.SignatureKind = {}));\r\n    var IndexKind;\r\n    (function (IndexKind) {\r\n        IndexKind[IndexKind[\"String\"] = 0] = \"String\";\r\n        IndexKind[IndexKind[\"Number\"] = 1] = \"Number\";\r\n    })(IndexKind = ts.IndexKind || (ts.IndexKind = {}));\r\n    var InferencePriority;\r\n    (function (InferencePriority) {\r\n        InferencePriority[InferencePriority[\"NakedTypeVariable\"] = 1] = \"NakedTypeVariable\";\r\n        InferencePriority[InferencePriority[\"HomomorphicMappedType\"] = 2] = \"HomomorphicMappedType\";\r\n        InferencePriority[InferencePriority[\"MappedTypeConstraint\"] = 4] = \"MappedTypeConstraint\";\r\n        InferencePriority[InferencePriority[\"ReturnType\"] = 8] = \"ReturnType\";\r\n        InferencePriority[InferencePriority[\"LiteralKeyof\"] = 16] = \"LiteralKeyof\";\r\n        InferencePriority[InferencePriority[\"NoConstraints\"] = 32] = \"NoConstraints\";\r\n        InferencePriority[InferencePriority[\"AlwaysStrict\"] = 64] = \"AlwaysStrict\";\r\n        InferencePriority[InferencePriority[\"PriorityImpliesCombination\"] = 28] = \"PriorityImpliesCombination\";\r\n    })(InferencePriority = ts.InferencePriority || (ts.InferencePriority = {}));\r\n    var WatchDirectoryFlags;\r\n    (function (WatchDirectoryFlags) {\r\n        WatchDirectoryFlags[WatchDirectoryFlags[\"None\"] = 0] = \"None\";\r\n        WatchDirectoryFlags[WatchDirectoryFlags[\"Recursive\"] = 1] = \"Recursive\";\r\n    })(WatchDirectoryFlags = ts.WatchDirectoryFlags || (ts.WatchDirectoryFlags = {}));\r\n    var Extension;\r\n    (function (Extension) {\r\n        Extension[\"Ts\"] = \".ts\";\r\n        Extension[\"Tsx\"] = \".tsx\";\r\n        Extension[\"Dts\"] = \".d.ts\";\r\n        Extension[\"Js\"] = \".js\";\r\n        Extension[\"Jsx\"] = \".jsx\";\r\n        Extension[\"Json\"] = \".json\";\r\n    })(Extension = ts.Extension || (ts.Extension = {}));\r\n    var EmitFlags;\r\n    (function (EmitFlags) {\r\n        EmitFlags[EmitFlags[\"None\"] = 0] = \"None\";\r\n        EmitFlags[EmitFlags[\"SingleLine\"] = 1] = \"SingleLine\";\r\n        EmitFlags[EmitFlags[\"AdviseOnEmitNode\"] = 2] = \"AdviseOnEmitNode\";\r\n        EmitFlags[EmitFlags[\"NoSubstitution\"] = 4] = \"NoSubstitution\";\r\n        EmitFlags[EmitFlags[\"CapturesThis\"] = 8] = \"CapturesThis\";\r\n        EmitFlags[EmitFlags[\"NoLeadingSourceMap\"] = 16] = \"NoLeadingSourceMap\";\r\n        EmitFlags[EmitFlags[\"NoTrailingSourceMap\"] = 32] = \"NoTrailingSourceMap\";\r\n        EmitFlags[EmitFlags[\"NoSourceMap\"] = 48] = \"NoSourceMap\";\r\n        EmitFlags[EmitFlags[\"NoNestedSourceMaps\"] = 64] = \"NoNestedSourceMaps\";\r\n        EmitFlags[EmitFlags[\"NoTokenLeadingSourceMaps\"] = 128] = \"NoTokenLeadingSourceMaps\";\r\n        EmitFlags[EmitFlags[\"NoTokenTrailingSourceMaps\"] = 256] = \"NoTokenTrailingSourceMaps\";\r\n        EmitFlags[EmitFlags[\"NoTokenSourceMaps\"] = 384] = \"NoTokenSourceMaps\";\r\n        EmitFlags[EmitFlags[\"NoLeadingComments\"] = 512] = \"NoLeadingComments\";\r\n        EmitFlags[EmitFlags[\"NoTrailingComments\"] = 1024] = \"NoTrailingComments\";\r\n        EmitFlags[EmitFlags[\"NoComments\"] = 1536] = \"NoComments\";\r\n        EmitFlags[EmitFlags[\"NoNestedComments\"] = 2048] = \"NoNestedComments\";\r\n        EmitFlags[EmitFlags[\"HelperName\"] = 4096] = \"HelperName\";\r\n        EmitFlags[EmitFlags[\"ExportName\"] = 8192] = \"ExportName\";\r\n        EmitFlags[EmitFlags[\"LocalName\"] = 16384] = \"LocalName\";\r\n        EmitFlags[EmitFlags[\"InternalName\"] = 32768] = \"InternalName\";\r\n        EmitFlags[EmitFlags[\"Indented\"] = 65536] = \"Indented\";\r\n        EmitFlags[EmitFlags[\"NoIndentation\"] = 131072] = \"NoIndentation\";\r\n        EmitFlags[EmitFlags[\"AsyncFunctionBody\"] = 262144] = \"AsyncFunctionBody\";\r\n        EmitFlags[EmitFlags[\"ReuseTempVariableScope\"] = 524288] = \"ReuseTempVariableScope\";\r\n        EmitFlags[EmitFlags[\"CustomPrologue\"] = 1048576] = \"CustomPrologue\";\r\n        EmitFlags[EmitFlags[\"NoHoisting\"] = 2097152] = \"NoHoisting\";\r\n        EmitFlags[EmitFlags[\"HasEndOfDeclarationMarker\"] = 4194304] = \"HasEndOfDeclarationMarker\";\r\n        EmitFlags[EmitFlags[\"Iterator\"] = 8388608] = \"Iterator\";\r\n        EmitFlags[EmitFlags[\"NoAsciiEscaping\"] = 16777216] = \"NoAsciiEscaping\";\r\n    })(EmitFlags = ts.EmitFlags || (ts.EmitFlags = {}));\r\n    var ListFormat;\r\n    (function (ListFormat) {\r\n        ListFormat[ListFormat[\"None\"] = 0] = \"None\";\r\n        ListFormat[ListFormat[\"SingleLine\"] = 0] = \"SingleLine\";\r\n        ListFormat[ListFormat[\"MultiLine\"] = 1] = \"MultiLine\";\r\n        ListFormat[ListFormat[\"PreserveLines\"] = 2] = \"PreserveLines\";\r\n        ListFormat[ListFormat[\"LinesMask\"] = 3] = \"LinesMask\";\r\n        ListFormat[ListFormat[\"NotDelimited\"] = 0] = \"NotDelimited\";\r\n        ListFormat[ListFormat[\"BarDelimited\"] = 4] = \"BarDelimited\";\r\n        ListFormat[ListFormat[\"AmpersandDelimited\"] = 8] = \"AmpersandDelimited\";\r\n        ListFormat[ListFormat[\"CommaDelimited\"] = 16] = \"CommaDelimited\";\r\n        ListFormat[ListFormat[\"DelimitersMask\"] = 28] = \"DelimitersMask\";\r\n        ListFormat[ListFormat[\"AllowTrailingComma\"] = 32] = \"AllowTrailingComma\";\r\n        ListFormat[ListFormat[\"Indented\"] = 64] = \"Indented\";\r\n        ListFormat[ListFormat[\"SpaceBetweenBraces\"] = 128] = \"SpaceBetweenBraces\";\r\n        ListFormat[ListFormat[\"SpaceBetweenSiblings\"] = 256] = \"SpaceBetweenSiblings\";\r\n        ListFormat[ListFormat[\"Braces\"] = 512] = \"Braces\";\r\n        ListFormat[ListFormat[\"Parenthesis\"] = 1024] = \"Parenthesis\";\r\n        ListFormat[ListFormat[\"AngleBrackets\"] = 2048] = \"AngleBrackets\";\r\n        ListFormat[ListFormat[\"SquareBrackets\"] = 4096] = \"SquareBrackets\";\r\n        ListFormat[ListFormat[\"BracketsMask\"] = 7680] = \"BracketsMask\";\r\n        ListFormat[ListFormat[\"OptionalIfUndefined\"] = 8192] = \"OptionalIfUndefined\";\r\n        ListFormat[ListFormat[\"OptionalIfEmpty\"] = 16384] = \"OptionalIfEmpty\";\r\n        ListFormat[ListFormat[\"Optional\"] = 24576] = \"Optional\";\r\n        ListFormat[ListFormat[\"PreferNewLine\"] = 32768] = \"PreferNewLine\";\r\n        ListFormat[ListFormat[\"NoTrailingNewLine\"] = 65536] = \"NoTrailingNewLine\";\r\n        ListFormat[ListFormat[\"NoInterveningComments\"] = 131072] = \"NoInterveningComments\";\r\n        ListFormat[ListFormat[\"NoSpaceIfEmpty\"] = 262144] = \"NoSpaceIfEmpty\";\r\n        ListFormat[ListFormat[\"SingleElement\"] = 524288] = \"SingleElement\";\r\n        ListFormat[ListFormat[\"Modifiers\"] = 131328] = \"Modifiers\";\r\n        ListFormat[ListFormat[\"HeritageClauses\"] = 256] = \"HeritageClauses\";\r\n        ListFormat[ListFormat[\"SingleLineTypeLiteralMembers\"] = 384] = \"SingleLineTypeLiteralMembers\";\r\n        ListFormat[ListFormat[\"MultiLineTypeLiteralMembers\"] = 16449] = \"MultiLineTypeLiteralMembers\";\r\n        ListFormat[ListFormat[\"TupleTypeElements\"] = 272] = \"TupleTypeElements\";\r\n        ListFormat[ListFormat[\"UnionTypeConstituents\"] = 260] = \"UnionTypeConstituents\";\r\n        ListFormat[ListFormat[\"IntersectionTypeConstituents\"] = 264] = \"IntersectionTypeConstituents\";\r\n        ListFormat[ListFormat[\"ObjectBindingPatternElements\"] = 262576] = \"ObjectBindingPatternElements\";\r\n        ListFormat[ListFormat[\"ArrayBindingPatternElements\"] = 262448] = \"ArrayBindingPatternElements\";\r\n        ListFormat[ListFormat[\"ObjectLiteralExpressionProperties\"] = 263122] = \"ObjectLiteralExpressionProperties\";\r\n        ListFormat[ListFormat[\"ArrayLiteralExpressionElements\"] = 4466] = \"ArrayLiteralExpressionElements\";\r\n        ListFormat[ListFormat[\"CommaListElements\"] = 272] = \"CommaListElements\";\r\n        ListFormat[ListFormat[\"CallExpressionArguments\"] = 1296] = \"CallExpressionArguments\";\r\n        ListFormat[ListFormat[\"NewExpressionArguments\"] = 9488] = \"NewExpressionArguments\";\r\n        ListFormat[ListFormat[\"TemplateExpressionSpans\"] = 131072] = \"TemplateExpressionSpans\";\r\n        ListFormat[ListFormat[\"SingleLineBlockStatements\"] = 384] = \"SingleLineBlockStatements\";\r\n        ListFormat[ListFormat[\"MultiLineBlockStatements\"] = 65] = \"MultiLineBlockStatements\";\r\n        ListFormat[ListFormat[\"VariableDeclarationList\"] = 272] = \"VariableDeclarationList\";\r\n        ListFormat[ListFormat[\"SingleLineFunctionBodyStatements\"] = 384] = \"SingleLineFunctionBodyStatements\";\r\n        ListFormat[ListFormat[\"MultiLineFunctionBodyStatements\"] = 1] = \"MultiLineFunctionBodyStatements\";\r\n        ListFormat[ListFormat[\"ClassHeritageClauses\"] = 0] = \"ClassHeritageClauses\";\r\n        ListFormat[ListFormat[\"ClassMembers\"] = 65] = \"ClassMembers\";\r\n        ListFormat[ListFormat[\"InterfaceMembers\"] = 65] = \"InterfaceMembers\";\r\n        ListFormat[ListFormat[\"EnumMembers\"] = 81] = \"EnumMembers\";\r\n        ListFormat[ListFormat[\"CaseBlockClauses\"] = 65] = \"CaseBlockClauses\";\r\n        ListFormat[ListFormat[\"NamedImportsOrExportsElements\"] = 262576] = \"NamedImportsOrExportsElements\";\r\n        ListFormat[ListFormat[\"JsxElementOrFragmentChildren\"] = 131072] = \"JsxElementOrFragmentChildren\";\r\n        ListFormat[ListFormat[\"JsxElementAttributes\"] = 131328] = \"JsxElementAttributes\";\r\n        ListFormat[ListFormat[\"CaseOrDefaultClauseStatements\"] = 81985] = \"CaseOrDefaultClauseStatements\";\r\n        ListFormat[ListFormat[\"HeritageClauseTypes\"] = 272] = \"HeritageClauseTypes\";\r\n        ListFormat[ListFormat[\"SourceFileStatements\"] = 65537] = \"SourceFileStatements\";\r\n        ListFormat[ListFormat[\"Decorators\"] = 24577] = \"Decorators\";\r\n        ListFormat[ListFormat[\"TypeArguments\"] = 26896] = \"TypeArguments\";\r\n        ListFormat[ListFormat[\"TypeParameters\"] = 26896] = \"TypeParameters\";\r\n        ListFormat[ListFormat[\"Parameters\"] = 1296] = \"Parameters\";\r\n        ListFormat[ListFormat[\"IndexSignatureParameters\"] = 4432] = \"IndexSignatureParameters\";\r\n    })(ListFormat = ts.ListFormat || (ts.ListFormat = {}));\r\n    var FileWatcherEventKind;\r\n    (function (FileWatcherEventKind) {\r\n        FileWatcherEventKind[FileWatcherEventKind[\"Created\"] = 0] = \"Created\";\r\n        FileWatcherEventKind[FileWatcherEventKind[\"Changed\"] = 1] = \"Changed\";\r\n        FileWatcherEventKind[FileWatcherEventKind[\"Deleted\"] = 2] = \"Deleted\";\r\n    })(FileWatcherEventKind = ts.FileWatcherEventKind || (ts.FileWatcherEventKind = {}));\r\n    var UpToDateStatusType;\r\n    (function (UpToDateStatusType) {\r\n        UpToDateStatusType[UpToDateStatusType[\"Unbuildable\"] = 0] = \"Unbuildable\";\r\n        UpToDateStatusType[UpToDateStatusType[\"UpToDate\"] = 1] = \"UpToDate\";\r\n        /**\r\n         * The project appears out of date because its upstream inputs are newer than its outputs,\r\n         * but all of its outputs are actually newer than the previous identical outputs of its (.d.ts) inputs.\r\n         * This means we can Pseudo-build (just touch timestamps), as if we had actually built this project.\r\n         */\r\n        UpToDateStatusType[UpToDateStatusType[\"UpToDateWithUpstreamTypes\"] = 2] = \"UpToDateWithUpstreamTypes\";\r\n        UpToDateStatusType[UpToDateStatusType[\"OutputMissing\"] = 3] = \"OutputMissing\";\r\n        UpToDateStatusType[UpToDateStatusType[\"OutOfDateWithSelf\"] = 4] = \"OutOfDateWithSelf\";\r\n        UpToDateStatusType[UpToDateStatusType[\"OutOfDateWithUpstream\"] = 5] = \"OutOfDateWithUpstream\";\r\n        UpToDateStatusType[UpToDateStatusType[\"UpstreamOutOfDate\"] = 6] = \"UpstreamOutOfDate\";\r\n        UpToDateStatusType[UpToDateStatusType[\"UpstreamBlocked\"] = 7] = \"UpstreamBlocked\";\r\n        /**\r\n         * Projects with no outputs (i.e. \"solution\" files)\r\n         */\r\n        UpToDateStatusType[UpToDateStatusType[\"ContainerOnly\"] = 8] = \"ContainerOnly\";\r\n    })(UpToDateStatusType = ts.UpToDateStatusType || (ts.UpToDateStatusType = {}));\r\n    var HighlightSpanKind;\r\n    (function (HighlightSpanKind) {\r\n        HighlightSpanKind[\"none\"] = \"none\";\r\n        HighlightSpanKind[\"definition\"] = \"definition\";\r\n        HighlightSpanKind[\"reference\"] = \"reference\";\r\n        HighlightSpanKind[\"writtenReference\"] = \"writtenReference\";\r\n    })(HighlightSpanKind = ts.HighlightSpanKind || (ts.HighlightSpanKind = {}));\r\n    var SymbolDisplayPartKind;\r\n    (function (SymbolDisplayPartKind) {\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"aliasName\"] = 0] = \"aliasName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"className\"] = 1] = \"className\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"enumName\"] = 2] = \"enumName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"fieldName\"] = 3] = \"fieldName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"interfaceName\"] = 4] = \"interfaceName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"keyword\"] = 5] = \"keyword\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"lineBreak\"] = 6] = \"lineBreak\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"numericLiteral\"] = 7] = \"numericLiteral\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"stringLiteral\"] = 8] = \"stringLiteral\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"localName\"] = 9] = \"localName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"methodName\"] = 10] = \"methodName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"moduleName\"] = 11] = \"moduleName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"operator\"] = 12] = \"operator\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"parameterName\"] = 13] = \"parameterName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"propertyName\"] = 14] = \"propertyName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"punctuation\"] = 15] = \"punctuation\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"space\"] = 16] = \"space\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"text\"] = 17] = \"text\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"typeParameterName\"] = 18] = \"typeParameterName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"enumMemberName\"] = 19] = \"enumMemberName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"functionName\"] = 20] = \"functionName\";\r\n        SymbolDisplayPartKind[SymbolDisplayPartKind[\"regularExpressionLiteral\"] = 21] = \"regularExpressionLiteral\";\r\n    })(SymbolDisplayPartKind = ts.SymbolDisplayPartKind || (ts.SymbolDisplayPartKind = {}));\r\n    var OutliningSpanKind;\r\n    (function (OutliningSpanKind) {\r\n        /**\r\n         * Single or multi-line comments\r\n         */\r\n        OutliningSpanKind[\"Comment\"] = \"comment\";\r\n        /**\r\n         * Sections marked by '// #region' and '// #endregion' comments\r\n         */\r\n        OutliningSpanKind[\"Region\"] = \"region\";\r\n        /**\r\n         * Declarations and expressions\r\n         */\r\n        OutliningSpanKind[\"Code\"] = \"code\";\r\n        /**\r\n         * Contiguous blocks of import declarations\r\n         */\r\n        OutliningSpanKind[\"Imports\"] = \"imports\";\r\n    })(OutliningSpanKind = ts.OutliningSpanKind || (ts.OutliningSpanKind = {}));\r\n    var OutputFileType;\r\n    (function (OutputFileType) {\r\n        OutputFileType[OutputFileType[\"JavaScript\"] = 0] = \"JavaScript\";\r\n        OutputFileType[OutputFileType[\"SourceMap\"] = 1] = \"SourceMap\";\r\n        OutputFileType[OutputFileType[\"Declaration\"] = 2] = \"Declaration\";\r\n    })(OutputFileType = ts.OutputFileType || (ts.OutputFileType = {}));\r\n    var EndOfLineState;\r\n    (function (EndOfLineState) {\r\n        EndOfLineState[EndOfLineState[\"None\"] = 0] = \"None\";\r\n        EndOfLineState[EndOfLineState[\"InMultiLineCommentTrivia\"] = 1] = \"InMultiLineCommentTrivia\";\r\n        EndOfLineState[EndOfLineState[\"InSingleQuoteStringLiteral\"] = 2] = \"InSingleQuoteStringLiteral\";\r\n        EndOfLineState[EndOfLineState[\"InDoubleQuoteStringLiteral\"] = 3] = \"InDoubleQuoteStringLiteral\";\r\n        EndOfLineState[EndOfLineState[\"InTemplateHeadOrNoSubstitutionTemplate\"] = 4] = \"InTemplateHeadOrNoSubstitutionTemplate\";\r\n        EndOfLineState[EndOfLineState[\"InTemplateMiddleOrTail\"] = 5] = \"InTemplateMiddleOrTail\";\r\n        EndOfLineState[EndOfLineState[\"InTemplateSubstitutionPosition\"] = 6] = \"InTemplateSubstitutionPosition\";\r\n    })(EndOfLineState = ts.EndOfLineState || (ts.EndOfLineState = {}));\r\n    var TokenClass;\r\n    (function (TokenClass) {\r\n        TokenClass[TokenClass[\"Punctuation\"] = 0] = \"Punctuation\";\r\n        TokenClass[TokenClass[\"Keyword\"] = 1] = \"Keyword\";\r\n        TokenClass[TokenClass[\"Operator\"] = 2] = \"Operator\";\r\n        TokenClass[TokenClass[\"Comment\"] = 3] = \"Comment\";\r\n        TokenClass[TokenClass[\"Whitespace\"] = 4] = \"Whitespace\";\r\n        TokenClass[TokenClass[\"Identifier\"] = 5] = \"Identifier\";\r\n        TokenClass[TokenClass[\"NumberLiteral\"] = 6] = \"NumberLiteral\";\r\n        TokenClass[TokenClass[\"StringLiteral\"] = 7] = \"StringLiteral\";\r\n        TokenClass[TokenClass[\"RegExpLiteral\"] = 8] = \"RegExpLiteral\";\r\n    })(TokenClass = ts.TokenClass || (ts.TokenClass = {}));\r\n    var ScriptElementKind;\r\n    (function (ScriptElementKind) {\r\n        ScriptElementKind[\"unknown\"] = \"\";\r\n        ScriptElementKind[\"warning\"] = \"warning\";\r\n        /**\r\n         * predefined type (void) or keyword (class)\r\n         */\r\n        ScriptElementKind[\"keyword\"] = \"keyword\";\r\n        /**\r\n         * top level script node\r\n         */\r\n        ScriptElementKind[\"scriptElement\"] = \"script\";\r\n        /**\r\n         * module foo {}\r\n         */\r\n        ScriptElementKind[\"moduleElement\"] = \"module\";\r\n        /**\r\n         * class X {}\r\n         */\r\n        ScriptElementKind[\"classElement\"] = \"class\";\r\n        /**\r\n         * var x = class X {}\r\n         */\r\n        ScriptElementKind[\"localClassElement\"] = \"local class\";\r\n        /**\r\n         * interface Y {}\r\n         */\r\n        ScriptElementKind[\"interfaceElement\"] = \"interface\";\r\n        /**\r\n         * type T = ...\r\n         */\r\n        ScriptElementKind[\"typeElement\"] = \"type\";\r\n        /**\r\n         * enum E\r\n         */\r\n        ScriptElementKind[\"enumElement\"] = \"enum\";\r\n        ScriptElementKind[\"enumMemberElement\"] = \"enum member\";\r\n        /**\r\n         * Inside module and script only\r\n         * const v = ..\r\n         */\r\n        ScriptElementKind[\"variableElement\"] = \"var\";\r\n        /**\r\n         * Inside function\r\n         */\r\n        ScriptElementKind[\"localVariableElement\"] = \"local var\";\r\n        /**\r\n         * Inside module and script only\r\n         * function f() { }\r\n         */\r\n        ScriptElementKind[\"functionElement\"] = \"function\";\r\n        /**\r\n         * Inside function\r\n         */\r\n        ScriptElementKind[\"localFunctionElement\"] = \"local function\";\r\n        /**\r\n         * foo() {} }\r\n         */\r\n        ScriptElementKind[\"memberFunctionElement\"] = \"method\";\r\n        /**\r\n         * [get|set] foo:number; }\r\n         */\r\n        ScriptElementKind[\"memberGetAccessorElement\"] = \"getter\";\r\n        ScriptElementKind[\"memberSetAccessorElement\"] = \"setter\";\r\n        /**\r\n         * class X { [public|private]* foo:number; }\r\n         * interface Y { foo:number; }\r\n         */\r\n        ScriptElementKind[\"memberVariableElement\"] = \"property\";\r\n        /**\r\n         * class X { constructor() { } }\r\n         */\r\n        ScriptElementKind[\"constructorImplementationElement\"] = \"constructor\";\r\n        /**\r\n         * interface Y { ():number; }\r\n         */\r\n        ScriptElementKind[\"callSignatureElement\"] = \"call\";\r\n        /**\r\n         * interface Y { []:number; }\r\n         */\r\n        ScriptElementKind[\"indexSignatureElement\"] = \"index\";\r\n        /**\r\n         * interface Y { new():Y; }\r\n         */\r\n        ScriptElementKind[\"constructSignatureElement\"] = \"construct\";\r\n        /**\r\n         * Y*: string)\r\n         */\r\n        ScriptElementKind[\"parameterElement\"] = \"parameter\";\r\n        ScriptElementKind[\"typeParameterElement\"] = \"type parameter\";\r\n        ScriptElementKind[\"primitiveType\"] = \"primitive type\";\r\n        ScriptElementKind[\"label\"] = \"label\";\r\n        ScriptElementKind[\"alias\"] = \"alias\";\r\n        ScriptElementKind[\"constElement\"] = \"const\";\r\n        ScriptElementKind[\"letElement\"] = \"let\";\r\n        ScriptElementKind[\"directory\"] = \"directory\";\r\n        ScriptElementKind[\"externalModuleName\"] = \"external module name\";\r\n        /**\r\n         * <JsxTagName attribute1 attribute2={0} />\r\n         */\r\n        ScriptElementKind[\"jsxAttribute\"] = \"JSX attribute\";\r\n        /**\r\n         * String literal\r\n         */\r\n        ScriptElementKind[\"string\"] = \"string\";\r\n    })(ScriptElementKind = ts.ScriptElementKind || (ts.ScriptElementKind = {}));\r\n    var ScriptElementKindModifier;\r\n    (function (ScriptElementKindModifier) {\r\n        ScriptElementKindModifier[\"none\"] = \"\";\r\n        ScriptElementKindModifier[\"publicMemberModifier\"] = \"public\";\r\n        ScriptElementKindModifier[\"privateMemberModifier\"] = \"private\";\r\n        ScriptElementKindModifier[\"protectedMemberModifier\"] = \"protected\";\r\n        ScriptElementKindModifier[\"exportedModifier\"] = \"export\";\r\n        ScriptElementKindModifier[\"ambientModifier\"] = \"declare\";\r\n        ScriptElementKindModifier[\"staticModifier\"] = \"static\";\r\n        ScriptElementKindModifier[\"abstractModifier\"] = \"abstract\";\r\n        ScriptElementKindModifier[\"optionalModifier\"] = \"optional\";\r\n    })(ScriptElementKindModifier = ts.ScriptElementKindModifier || (ts.ScriptElementKindModifier = {}));\r\n    var ClassificationTypeNames;\r\n    (function (ClassificationTypeNames) {\r\n        ClassificationTypeNames[\"comment\"] = \"comment\";\r\n        ClassificationTypeNames[\"identifier\"] = \"identifier\";\r\n        ClassificationTypeNames[\"keyword\"] = \"keyword\";\r\n        ClassificationTypeNames[\"numericLiteral\"] = \"number\";\r\n        ClassificationTypeNames[\"operator\"] = \"operator\";\r\n        ClassificationTypeNames[\"stringLiteral\"] = \"string\";\r\n        ClassificationTypeNames[\"whiteSpace\"] = \"whitespace\";\r\n        ClassificationTypeNames[\"text\"] = \"text\";\r\n        ClassificationTypeNames[\"punctuation\"] = \"punctuation\";\r\n        ClassificationTypeNames[\"className\"] = \"class name\";\r\n        ClassificationTypeNames[\"enumName\"] = \"enum name\";\r\n        ClassificationTypeNames[\"interfaceName\"] = \"interface name\";\r\n        ClassificationTypeNames[\"moduleName\"] = \"module name\";\r\n        ClassificationTypeNames[\"typeParameterName\"] = \"type parameter name\";\r\n        ClassificationTypeNames[\"typeAliasName\"] = \"type alias name\";\r\n        ClassificationTypeNames[\"parameterName\"] = \"parameter name\";\r\n        ClassificationTypeNames[\"docCommentTagName\"] = \"doc comment tag name\";\r\n        ClassificationTypeNames[\"jsxOpenTagName\"] = \"jsx open tag name\";\r\n        ClassificationTypeNames[\"jsxCloseTagName\"] = \"jsx close tag name\";\r\n        ClassificationTypeNames[\"jsxSelfClosingTagName\"] = \"jsx self closing tag name\";\r\n        ClassificationTypeNames[\"jsxAttribute\"] = \"jsx attribute\";\r\n        ClassificationTypeNames[\"jsxText\"] = \"jsx text\";\r\n        ClassificationTypeNames[\"jsxAttributeStringLiteralValue\"] = \"jsx attribute string literal value\";\r\n    })(ClassificationTypeNames = ts.ClassificationTypeNames || (ts.ClassificationTypeNames = {}));\r\n    var ClassificationType;\r\n    (function (ClassificationType) {\r\n        ClassificationType[ClassificationType[\"comment\"] = 1] = \"comment\";\r\n        ClassificationType[ClassificationType[\"identifier\"] = 2] = \"identifier\";\r\n        ClassificationType[ClassificationType[\"keyword\"] = 3] = \"keyword\";\r\n        ClassificationType[ClassificationType[\"numericLiteral\"] = 4] = \"numericLiteral\";\r\n        ClassificationType[ClassificationType[\"operator\"] = 5] = \"operator\";\r\n        ClassificationType[ClassificationType[\"stringLiteral\"] = 6] = \"stringLiteral\";\r\n        ClassificationType[ClassificationType[\"regularExpressionLiteral\"] = 7] = \"regularExpressionLiteral\";\r\n        ClassificationType[ClassificationType[\"whiteSpace\"] = 8] = \"whiteSpace\";\r\n        ClassificationType[ClassificationType[\"text\"] = 9] = \"text\";\r\n        ClassificationType[ClassificationType[\"punctuation\"] = 10] = \"punctuation\";\r\n        ClassificationType[ClassificationType[\"className\"] = 11] = \"className\";\r\n        ClassificationType[ClassificationType[\"enumName\"] = 12] = \"enumName\";\r\n        ClassificationType[ClassificationType[\"interfaceName\"] = 13] = \"interfaceName\";\r\n        ClassificationType[ClassificationType[\"moduleName\"] = 14] = \"moduleName\";\r\n        ClassificationType[ClassificationType[\"typeParameterName\"] = 15] = \"typeParameterName\";\r\n        ClassificationType[ClassificationType[\"typeAliasName\"] = 16] = \"typeAliasName\";\r\n        ClassificationType[ClassificationType[\"parameterName\"] = 17] = \"parameterName\";\r\n        ClassificationType[ClassificationType[\"docCommentTagName\"] = 18] = \"docCommentTagName\";\r\n        ClassificationType[ClassificationType[\"jsxOpenTagName\"] = 19] = \"jsxOpenTagName\";\r\n        ClassificationType[ClassificationType[\"jsxCloseTagName\"] = 20] = \"jsxCloseTagName\";\r\n        ClassificationType[ClassificationType[\"jsxSelfClosingTagName\"] = 21] = \"jsxSelfClosingTagName\";\r\n        ClassificationType[ClassificationType[\"jsxAttribute\"] = 22] = \"jsxAttribute\";\r\n        ClassificationType[ClassificationType[\"jsxText\"] = 23] = \"jsxText\";\r\n        ClassificationType[ClassificationType[\"jsxAttributeStringLiteralValue\"] = 24] = \"jsxAttributeStringLiteralValue\";\r\n    })(ClassificationType = ts.ClassificationType || (ts.ClassificationType = {}));\r\n    // overwrite this namespace with the TypeScript compiler\r\n    ObjectUtils_1.ObjectUtils.assign(ts, tsCompiler);\r\n})(ts = exports.ts || (exports.ts = {}));\r\n// this is a trick to get the enums defined in the local scope by their name, but have the compiler\r\n// understand this as exporting the ambient declarations above (so it works at compile time and run time)\r\n// @ts-ignore: Implicit use of this.\r\nvar tempThis = this;\r\ntempThis[\"SyntaxKind\"] = tsCompiler.SyntaxKind;\r\ntempThis[\"TypeFormatFlags\"] = tsCompiler.TypeFormatFlags;\r\ntempThis[\"SymbolFlags\"] = tsCompiler.SymbolFlags;\r\ntempThis[\"TypeFlags\"] = tsCompiler.TypeFlags;\r\ntempThis[\"ObjectFlags\"] = tsCompiler.ObjectFlags;\r\ntempThis[\"DiagnosticCategory\"] = tsCompiler.DiagnosticCategory;\r\ntempThis[\"ModuleResolutionKind\"] = tsCompiler.ModuleResolutionKind;\r\ntempThis[\"ModuleKind\"] = tsCompiler.ModuleKind;\r\ntempThis[\"JsxEmit\"] = tsCompiler.JsxEmit;\r\ntempThis[\"NewLineKind\"] = tsCompiler.NewLineKind;\r\ntempThis[\"ScriptKind\"] = tsCompiler.ScriptKind;\r\ntempThis[\"ScriptTarget\"] = tsCompiler.ScriptTarget;\r\ntempThis[\"LanguageVariant\"] = tsCompiler.LanguageVariant;\r\ntempThis[\"EmitHint\"] = tsCompiler.EmitHint;\r\ntempThis[\"IndentStyle\"] = tsCompiler.IndentStyle;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/typescript/typescript.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/AdvancedIterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/AdvancedIterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar AdvancedIterator = /** @class */ (function () {\r\n    function AdvancedIterator(iterator) {\r\n        this.iterator = iterator;\r\n        this.buffer = [undefined, undefined, undefined]; // previous, current, next\r\n        this.bufferIndex = 0;\r\n        this.isDone = false;\r\n        this.nextCount = 0;\r\n        this.advance();\r\n    }\r\n    Object.defineProperty(AdvancedIterator.prototype, \"done\", {\r\n        get: function () {\r\n            return this.isDone;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AdvancedIterator.prototype, \"current\", {\r\n        get: function () {\r\n            if (this.nextCount === 0)\r\n                throw new errors.InvalidOperationError(\"Cannot get the current when the iterator has not been advanced.\");\r\n            return this.buffer[this.bufferIndex];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AdvancedIterator.prototype, \"previous\", {\r\n        get: function () {\r\n            if (this.nextCount <= 1)\r\n                throw new errors.InvalidOperationError(\"Cannot get the previous when the iterator has not advanced enough.\");\r\n            return this.buffer[(this.bufferIndex + this.buffer.length - 1) % this.buffer.length];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AdvancedIterator.prototype, \"peek\", {\r\n        get: function () {\r\n            if (this.isDone)\r\n                throw new errors.InvalidOperationError(\"Cannot peek at the end of the iterator.\");\r\n            return this.buffer[(this.bufferIndex + 1) % this.buffer.length];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AdvancedIterator.prototype.next = function () {\r\n        if (this.done)\r\n            throw new errors.InvalidOperationError(\"Cannot get the next when at the end of the iterator.\");\r\n        var next = this.buffer[this.getNextBufferIndex()];\r\n        this.advance();\r\n        this.nextCount++;\r\n        return next;\r\n    };\r\n    AdvancedIterator.prototype.rest = function () {\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!!this.done) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, this.next()];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [3 /*break*/, 0];\r\n                case 2: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    AdvancedIterator.prototype.advance = function () {\r\n        var next = this.iterator.next();\r\n        this.bufferIndex = this.getNextBufferIndex();\r\n        if (next.done) {\r\n            this.isDone = true;\r\n            return;\r\n        }\r\n        this.buffer[this.getNextBufferIndex()] = next.value;\r\n    };\r\n    AdvancedIterator.prototype.getNextBufferIndex = function () {\r\n        return (this.bufferIndex + 1) % this.buffer.length;\r\n    };\r\n    return AdvancedIterator;\r\n}());\r\nexports.AdvancedIterator = AdvancedIterator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/AdvancedIterator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js":
/*!*************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar ArrayUtils = /** @class */ (function () {\r\n    function ArrayUtils() {\r\n    }\r\n    ArrayUtils.isNullOrEmpty = function (a) {\r\n        return !(a instanceof Array) || a.length === 0;\r\n    };\r\n    ArrayUtils.getUniqueItems = function (a) {\r\n        return a.filter(function (item, index) { return a.indexOf(item) === index; });\r\n    };\r\n    ArrayUtils.removeFirst = function (a, item) {\r\n        var index = a.indexOf(item);\r\n        if (index === -1)\r\n            return false;\r\n        a.splice(index, 1);\r\n        return true;\r\n    };\r\n    ArrayUtils.removeAll = function (a, isMatch) {\r\n        var removedItems = [];\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (isMatch(a[i])) {\r\n                removedItems.push(a[i]);\r\n                a.splice(i, 1);\r\n            }\r\n        }\r\n        return removedItems;\r\n    };\r\n    // can't use ReadonlyArray here for some reason\r\n    ArrayUtils.flatten = function (items) {\r\n        return items.reduce(function (a, b) { return a.concat(b); }, []);\r\n    };\r\n    ArrayUtils.find = function (items, condition) {\r\n        var e_1, _a;\r\n        try {\r\n            for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\r\n                var item = items_1_1.value;\r\n                if (condition(item))\r\n                    return item;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return undefined;\r\n    };\r\n    ArrayUtils.findIndex = function (items, condition) {\r\n        for (var i = 0; i < items.length; i++) {\r\n            if (condition(items[i]))\r\n                return i;\r\n        }\r\n        return -1;\r\n    };\r\n    ArrayUtils.from = function (items) {\r\n        var e_2, _a;\r\n        var a = [];\r\n        try {\r\n            for (var items_2 = tslib_1.__values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {\r\n                var item = items_2_1.value;\r\n                a.push(item);\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (items_2_1 && !items_2_1.done && (_a = items_2.return)) _a.call(items_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return a;\r\n    };\r\n    ArrayUtils.toIterator = function (items) {\r\n        var e_3, _a, items_3, items_3_1, item, e_3_1;\r\n        return tslib_1.__generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    _b.trys.push([0, 5, 6, 7]);\r\n                    items_3 = tslib_1.__values(items), items_3_1 = items_3.next();\r\n                    _b.label = 1;\r\n                case 1:\r\n                    if (!!items_3_1.done) return [3 /*break*/, 4];\r\n                    item = items_3_1.value;\r\n                    return [4 /*yield*/, item];\r\n                case 2:\r\n                    _b.sent();\r\n                    _b.label = 3;\r\n                case 3:\r\n                    items_3_1 = items_3.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_3_1 = _b.sent();\r\n                    e_3 = { error: e_3_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (items_3_1 && !items_3_1.done && (_a = items_3.return)) _a.call(items_3);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    ArrayUtils.sortByProperty = function (items, getProp) {\r\n        items.sort(function (a, b) { return getProp(a) <= getProp(b) ? -1 : 1; });\r\n        return items;\r\n    };\r\n    ArrayUtils.binaryInsertWithOverwrite = function (items, newItem, comparer) {\r\n        var top = items.length - 1;\r\n        var bottom = 0;\r\n        while (bottom <= top) {\r\n            var mid = Math.floor((top + bottom) / 2);\r\n            if (comparer.compareTo(newItem, items[mid]) < 0)\r\n                top = mid - 1;\r\n            else\r\n                bottom = mid + 1;\r\n        }\r\n        // overwrite an existing item\r\n        if (items[top] != null && comparer.compareTo(newItem, items[top]) === 0)\r\n            items[top] = newItem;\r\n        else\r\n            items.splice(top + 1, 0, newItem);\r\n    };\r\n    ArrayUtils.binarySearch = function (items, storedComparer) {\r\n        var top = items.length - 1;\r\n        var bottom = 0;\r\n        while (bottom <= top) {\r\n            var mid = Math.floor((top + bottom) / 2);\r\n            var comparisonResult = storedComparer.compareTo(items[mid]);\r\n            if (comparisonResult === 0)\r\n                return mid;\r\n            else if (comparisonResult < 0)\r\n                top = mid - 1;\r\n            else\r\n                bottom = mid + 1;\r\n        }\r\n        return -1;\r\n    };\r\n    ArrayUtils.containsSubArray = function (items, subArray) {\r\n        var e_4, _a;\r\n        var findIndex = 0;\r\n        try {\r\n            for (var items_4 = tslib_1.__values(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {\r\n                var item = items_4_1.value;\r\n                if (subArray[findIndex] === item) {\r\n                    findIndex++;\r\n                    if (findIndex === subArray.length)\r\n                        return true;\r\n                }\r\n                else\r\n                    findIndex = 0;\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (items_4_1 && !items_4_1.done && (_a = items_4.return)) _a.call(items_4);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        return false;\r\n    };\r\n    return ArrayUtils;\r\n}());\r\nexports.ArrayUtils = ArrayUtils;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/Es5PropSaver.js":
/*!***************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/Es5PropSaver.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* barrel:ignore */\r\nvar Es5PropSaver = /** @class */ (function () {\r\n    function Es5PropSaver() {\r\n        this.propName = \"__key_\" + Es5PropSaver.instanceCount++;\r\n    }\r\n    Es5PropSaver.prototype.get = function (obj) {\r\n        return obj[this.propName];\r\n    };\r\n    Es5PropSaver.prototype.set = function (obj, value) {\r\n        Object.defineProperty(obj, this.propName, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            writable: false,\r\n            value: value\r\n        });\r\n    };\r\n    Es5PropSaver.prototype.remove = function (obj) {\r\n        delete obj[this.propName];\r\n    };\r\n    Es5PropSaver.instanceCount = 0;\r\n    return Es5PropSaver;\r\n}());\r\nexports.Es5PropSaver = Es5PropSaver;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/Es5PropSaver.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/EventContainer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/EventContainer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\n/**\r\n * Event container for event subscriptions.\r\n */\r\nvar EventContainer = /** @class */ (function () {\r\n    function EventContainer() {\r\n        this.subscriptions = [];\r\n    }\r\n    /**\r\n     * Subscribe to an event being fired.\r\n     * @param subscription - Subscription.\r\n     */\r\n    EventContainer.prototype.subscribe = function (subscription) {\r\n        var index = this.getIndex(subscription);\r\n        if (index === -1)\r\n            this.subscriptions.push(subscription);\r\n    };\r\n    /**\r\n     * Unsubscribe to an event being fired.\r\n     * @param subscription - Subscription.\r\n     */\r\n    EventContainer.prototype.unsubscribe = function (subscription) {\r\n        var index = this.getIndex(subscription);\r\n        if (index >= 0)\r\n            this.subscriptions.splice(index, 1);\r\n    };\r\n    /**\r\n     * Fire an event.\r\n     */\r\n    EventContainer.prototype.fire = function (arg) {\r\n        var e_1, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var subscription = _c.value;\r\n                subscription(arg);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    EventContainer.prototype.getIndex = function (subscription) {\r\n        return this.subscriptions.indexOf(subscription);\r\n    };\r\n    return EventContainer;\r\n}());\r\nexports.EventContainer = EventContainer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/EventContainer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/FileUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/FileUtils.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar toAbsoluteGlob = __webpack_require__(/*! @dsherret/to-absolute-glob */ \"./node_modules/@dsherret/to-absolute-glob/index.js\");\r\nvar path = __webpack_require__(/*! path */ \"path\");\r\nvar constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/ts-simple-ast/dist/constants.js\");\r\nvar ArrayUtils_1 = __webpack_require__(/*! ./ArrayUtils */ \"./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js\");\r\nvar StringUtils_1 = __webpack_require__(/*! ./StringUtils */ \"./node_modules/ts-simple-ast/dist/utils/StringUtils.js\");\r\nvar globParent = __webpack_require__(/*! glob-parent */ \"glob-parent\");\r\nvar isNegatedGlob = __webpack_require__(/*! is-negated-glob */ \"./node_modules/is-negated-glob/index.js\");\r\nvar FileUtils = /** @class */ (function () {\r\n    function FileUtils() {\r\n    }\r\n    /**\r\n     * Gets if the error is a file not found or directory not found error.\r\n     * @param err - Error to check.\r\n     */\r\n    FileUtils.isNotExistsError = function (err) {\r\n        return err.code === FileUtils.ENOENT;\r\n    };\r\n    /**\r\n     * Joins the paths.\r\n     * @param paths - Paths to join.\r\n     */\r\n    FileUtils.pathJoin = function () {\r\n        var paths = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            paths[_i] = arguments[_i];\r\n        }\r\n        return FileUtils.standardizeSlashes(path.join.apply(path, tslib_1.__spread(paths)));\r\n    };\r\n    /**\r\n     * Gets if the path is absolute.\r\n     * @param fileOrDirPath - File or directory path.\r\n     */\r\n    FileUtils.pathIsAbsolute = function (fileOrDirPath) {\r\n        return path.isAbsolute(fileOrDirPath);\r\n    };\r\n    /**\r\n     * Gets the standardized absolute path.\r\n     * @param fileSystem - File system.\r\n     * @param fileOrDirPath - Path to standardize.\r\n     * @param relativeBase - Base path to be relative from.\r\n     */\r\n    FileUtils.getStandardizedAbsolutePath = function (fileSystem, fileOrDirPath, relativeBase) {\r\n        return FileUtils.standardizeSlashes(path.normalize(getAbsolutePath()));\r\n        function getAbsolutePath() {\r\n            var isAbsolutePath = path.isAbsolute(fileOrDirPath);\r\n            if (isAbsolutePath)\r\n                return fileOrDirPath;\r\n            if (!StringUtils_1.StringUtils.startsWith(fileOrDirPath, \"./\") && relativeBase != null)\r\n                return path.join(relativeBase, fileOrDirPath);\r\n            return path.join(fileSystem.getCurrentDirectory(), fileOrDirPath);\r\n        }\r\n    };\r\n    /**\r\n     * Gets the directory path.\r\n     * @param fileOrDirPath - Path to get the directory name from.\r\n     */\r\n    FileUtils.getDirPath = function (fileOrDirPath) {\r\n        return FileUtils.standardizeSlashes(path.dirname(fileOrDirPath));\r\n    };\r\n    /**\r\n     * Gets the base name.\r\n     * @param fileOrDirPath - Path to get the base name from.\r\n     */\r\n    FileUtils.getBaseName = function (fileOrDirPath) {\r\n        return path.basename(fileOrDirPath);\r\n    };\r\n    /**\r\n     * Gets the extension of the file name.\r\n     * @param fileOrDirPath - Path to get the extension from.\r\n     */\r\n    FileUtils.getExtension = function (fileOrDirPath) {\r\n        var baseName = FileUtils.getBaseName(fileOrDirPath);\r\n        var lastDotIndex = baseName.lastIndexOf(\".\");\r\n        if (lastDotIndex <= 0) // for files like .gitignore, need to include 0\r\n            return \"\"; // same behaviour as node\r\n        var lastExt = baseName.substring(lastDotIndex);\r\n        var lastExtLowerCase = lastExt.toLowerCase();\r\n        if (lastExtLowerCase === \".ts\" && baseName.substring(lastDotIndex - 2, lastDotIndex).toLowerCase() === \".d\")\r\n            return baseName.substring(lastDotIndex - 2);\r\n        if (lastExtLowerCase === \".map\" && baseName.substring(lastDotIndex - 3, lastDotIndex).toLowerCase() === \".js\")\r\n            return baseName.substring(lastDotIndex - 3);\r\n        return lastExt;\r\n    };\r\n    /**\r\n     * Changes all back slashes to forward slashes.\r\n     * @param fileOrDirPath - Path.\r\n     */\r\n    FileUtils.standardizeSlashes = function (fileOrDirPath) {\r\n        return fileOrDirPath.replace(this.standardizeSlashesRegex, \"/\");\r\n    };\r\n    /**\r\n     * Checks if a path ends with a specified search path.\r\n     * @param fileOrDirPath - Path.\r\n     * @param endsWithPath - Ends with path.\r\n     */\r\n    FileUtils.pathEndsWith = function (fileOrDirPath, endsWithPath) {\r\n        var pathItems = FileUtils.splitPathBySlashes(fileOrDirPath);\r\n        var endsWithItems = FileUtils.splitPathBySlashes(endsWithPath);\r\n        if (endsWithItems.length > pathItems.length)\r\n            return false;\r\n        for (var i = 0; i < endsWithItems.length; i++) {\r\n            if (endsWithItems[endsWithItems.length - i - 1] !== pathItems[pathItems.length - i - 1])\r\n                return false;\r\n        }\r\n        return endsWithItems.length > 0;\r\n    };\r\n    /**\r\n     * Checks if a path starts with a specified search path.\r\n     * @param fileOrDirPath - Path.\r\n     * @param startsWithPath - Starts with path.\r\n     */\r\n    FileUtils.pathStartsWith = function (fileOrDirPath, startsWithPath) {\r\n        var isfileOrDirPathEmpty = StringUtils_1.StringUtils.isNullOrWhitespace(fileOrDirPath);\r\n        var isStartsWithPathEmpty = StringUtils_1.StringUtils.isNullOrWhitespace(startsWithPath);\r\n        var pathItems = FileUtils.splitPathBySlashes(fileOrDirPath);\r\n        var startsWithItems = FileUtils.splitPathBySlashes(startsWithPath);\r\n        if (isfileOrDirPathEmpty && isStartsWithPathEmpty)\r\n            return true;\r\n        if (isStartsWithPathEmpty || startsWithItems.length > pathItems.length)\r\n            return false;\r\n        // return true for the root directory\r\n        if (startsWithItems.length === 1 && startsWithItems[0].length === 0)\r\n            return true;\r\n        for (var i = 0; i < startsWithItems.length; i++) {\r\n            if (startsWithItems[i] !== pathItems[i])\r\n                return false;\r\n        }\r\n        return startsWithItems.length > 0;\r\n    };\r\n    FileUtils.splitPathBySlashes = function (fileOrDirPath) {\r\n        fileOrDirPath = (fileOrDirPath || \"\").replace(FileUtils.trimSlashStartRegex, \"\").replace(FileUtils.trimSlashEndRegex, \"\");\r\n        return FileUtils.standardizeSlashes(fileOrDirPath).replace(/^\\//, \"\").split(\"/\");\r\n    };\r\n    /**\r\n     * Gets the parent most paths out of the list of paths.\r\n     * @param paths - File or directory paths.\r\n     */\r\n    FileUtils.getParentMostPaths = function (paths) {\r\n        var e_1, _a;\r\n        var finalPaths = [];\r\n        var _loop_1 = function (fileOrDirPath) {\r\n            if (finalPaths.every(function (p) { return !FileUtils.pathStartsWith(fileOrDirPath, p); }))\r\n                finalPaths.push(fileOrDirPath);\r\n        };\r\n        try {\r\n            for (var _b = tslib_1.__values(ArrayUtils_1.ArrayUtils.sortByProperty(paths, function (p) { return p.length; })), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var fileOrDirPath = _c.value;\r\n                _loop_1(fileOrDirPath);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return finalPaths;\r\n    };\r\n    /**\r\n     * Reads a file or returns false if the file doesn't exist.\r\n     * @param fileSystem - File System.\r\n     * @param filePath - Path to file.\r\n     * @param encoding - File encoding.\r\n     */\r\n    FileUtils.readFileOrNotExists = function (fileSystem, filePath, encoding) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var err_1;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4 /*yield*/, fileSystem.readFile(filePath, encoding)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                    case 2:\r\n                        err_1 = _a.sent();\r\n                        if (!FileUtils.isNotExistsError(err_1))\r\n                            throw err_1;\r\n                        return [2 /*return*/, false];\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reads a file synchronously or returns false if the file doesn't exist.\r\n     * @param fileSystem - File System.\r\n     * @param filePath - Path to file.\r\n     * @param encoding - File encoding.\r\n     */\r\n    FileUtils.readFileOrNotExistsSync = function (fileSystem, filePath, encoding) {\r\n        try {\r\n            return fileSystem.readFileSync(filePath, encoding);\r\n        }\r\n        catch (err) {\r\n            if (!FileUtils.isNotExistsError(err))\r\n                throw err;\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets the text with a byte order mark.\r\n     * @param text - Text.\r\n     */\r\n    FileUtils.getTextWithByteOrderMark = function (text) {\r\n        if (text[0] === constants_1.Chars.BOM)\r\n            return text;\r\n        return constants_1.Chars.BOM + text;\r\n    };\r\n    /**\r\n     * Gets the relative path from one absolute path to another.\r\n     * @param absoluteDirPathFrom - Absolute directory path from.\r\n     * @param absolutePathTo - Absolute path to.\r\n     */\r\n    FileUtils.getRelativePathTo = function (absoluteDirPathFrom, absolutePathTo) {\r\n        var relativePath = path.relative(absoluteDirPathFrom, path.dirname(absolutePathTo));\r\n        return FileUtils.standardizeSlashes(path.join(relativePath, path.basename(absolutePathTo)));\r\n    };\r\n    /**\r\n     * Gets if the path is for the root directory.\r\n     * @param path - Path.\r\n     */\r\n    FileUtils.isRootDirPath = function (dirOrFilePath) {\r\n        return dirOrFilePath === FileUtils.getDirPath(dirOrFilePath);\r\n    };\r\n    /**\r\n     * Gets the descendant directories of the specified directory.\r\n     * @param dirPath - Directory path.\r\n     */\r\n    FileUtils.getDescendantDirectories = function (fileSystemWrapper, dirPath) {\r\n        // todo: unit tests...\r\n        return Array.from(getDescendantDirectories(dirPath));\r\n        function getDescendantDirectories(currentDirPath) {\r\n            var e_2, _a, subDirPaths, subDirPaths_1, subDirPaths_1_1, subDirPath, e_2_1;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        subDirPaths = fileSystemWrapper.readDirSync(currentDirPath).filter(function (d) { return fileSystemWrapper.directoryExistsSync(d); });\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 7, 8, 9]);\r\n                        subDirPaths_1 = tslib_1.__values(subDirPaths), subDirPaths_1_1 = subDirPaths_1.next();\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        if (!!subDirPaths_1_1.done) return [3 /*break*/, 6];\r\n                        subDirPath = subDirPaths_1_1.value;\r\n                        return [4 /*yield*/, subDirPath];\r\n                    case 3:\r\n                        _b.sent();\r\n                        return [5 /*yield**/, tslib_1.__values(getDescendantDirectories(subDirPath))];\r\n                    case 4:\r\n                        _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        subDirPaths_1_1 = subDirPaths_1.next();\r\n                        return [3 /*break*/, 2];\r\n                    case 6: return [3 /*break*/, 9];\r\n                    case 7:\r\n                        e_2_1 = _b.sent();\r\n                        e_2 = { error: e_2_1 };\r\n                        return [3 /*break*/, 9];\r\n                    case 8:\r\n                        try {\r\n                            if (subDirPaths_1_1 && !subDirPaths_1_1.done && (_a = subDirPaths_1.return)) _a.call(subDirPaths_1);\r\n                        }\r\n                        finally { if (e_2) throw e_2.error; }\r\n                        return [7 /*endfinally*/];\r\n                    case 9: return [2 /*return*/];\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Gets the glob as absolute.\r\n     * @param glob - Glob.\r\n     * @param cwd - Current working directory.\r\n     */\r\n    FileUtils.toAbsoluteGlob = function (glob, cwd) {\r\n        return toAbsoluteGlob(glob, { cwd: cwd });\r\n    };\r\n    /**\r\n     * Gets if the glob is a negated glob.\r\n     * @param glob - Glob.\r\n     */\r\n    FileUtils.isNegatedGlob = function (glob) {\r\n        return isNegatedGlob(glob).negated;\r\n    };\r\n    /**\r\n     * Gets the glob's directory.\r\n     * @param glob - Glob.\r\n     */\r\n    FileUtils.getGlobDir = function (glob) {\r\n        return globParent(glob);\r\n    };\r\n    FileUtils.standardizeSlashesRegex = /\\\\/g;\r\n    FileUtils.trimSlashStartRegex = /^\\//;\r\n    FileUtils.trimSlashEndRegex = /\\/$/;\r\n    FileUtils.ENOENT = \"ENOENT\";\r\n    return FileUtils;\r\n}());\r\nexports.FileUtils = FileUtils;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/FileUtils.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/ObjectUtils.js":
/*!**************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/ObjectUtils.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ObjectUtils = /** @class */ (function () {\r\n    function ObjectUtils() {\r\n    }\r\n    ObjectUtils.clone = function (obj) {\r\n        // todo: make this an actual deep clone... good enough for now...\r\n        if (obj == null)\r\n            return undefined;\r\n        if (obj instanceof Array)\r\n            return cloneArray(obj);\r\n        return ObjectUtils.assign({}, obj);\r\n        function cloneArray(a) {\r\n            return a.map(function (item) { return ObjectUtils.clone(item); });\r\n        }\r\n    };\r\n    ObjectUtils.assign = function (a, b, c) {\r\n        if (Object.assign != null) {\r\n            if (c == null)\r\n                return Object.assign(a, b);\r\n            else\r\n                return Object.assign(a, b, c);\r\n        }\r\n        if (c == null)\r\n            return this.es5Assign(a, b);\r\n        else\r\n            return this.es5Assign(a, b, c);\r\n    };\r\n    ObjectUtils.es5Assign = function (a, b, c) {\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill\r\n        var to = Object(a);\r\n        for (var index = 1; index < arguments.length; index++) {\r\n            var nextSource = arguments[index];\r\n            if (nextSource == null)\r\n                continue;\r\n            for (var nextKey in nextSource) {\r\n                // Avoid bugs when hasOwnProperty is shadowed\r\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey))\r\n                    to[nextKey] = nextSource[nextKey];\r\n            }\r\n        }\r\n        return to;\r\n    };\r\n    return ObjectUtils;\r\n}());\r\nexports.ObjectUtils = ObjectUtils;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/ObjectUtils.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/StringUtils.js":
/*!**************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/StringUtils.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar StringUtils = /** @class */ (function () {\r\n    function StringUtils() {\r\n    }\r\n    StringUtils.isNullOrWhitespace = function (str) {\r\n        return typeof str !== \"string\" || str.trim().length === 0;\r\n    };\r\n    StringUtils.repeat = function (str, times) {\r\n        var newStr = \"\";\r\n        for (var i = 0; i < times; i++)\r\n            newStr += str;\r\n        return newStr;\r\n    };\r\n    StringUtils.startsWith = function (str, startsWithString) {\r\n        if (typeof String.prototype.startsWith === \"function\")\r\n            return str.startsWith(startsWithString);\r\n        return Es5StringUtils.startsWith(str, startsWithString);\r\n    };\r\n    StringUtils.endsWith = function (str, endsWithString) {\r\n        if (typeof String.prototype.endsWith === \"function\")\r\n            return str.endsWith(endsWithString);\r\n        return Es5StringUtils.endsWith(str, endsWithString);\r\n    };\r\n    StringUtils.getLineNumberAtPos = function (str, pos) {\r\n        errors.throwIfOutOfRange(pos, [0, str.length + 1], \"pos\");\r\n        // do not allocate a string in this method\r\n        var count = 0;\r\n        for (var i = 0; i < pos; i++) {\r\n            if (str[i] === \"\\n\" || (str[i] === \"\\r\" && str[i + 1] !== \"\\n\"))\r\n                count++;\r\n        }\r\n        return count + 1; // convert count to line number\r\n    };\r\n    StringUtils.getLengthFromLineStartAtPos = function (str, pos) {\r\n        errors.throwIfOutOfRange(pos, [0, str.length + 1], \"pos\");\r\n        var startPos = pos;\r\n        while (pos > 0) {\r\n            var previousChar = str[pos - 1];\r\n            if (previousChar === \"\\n\" || previousChar === \"\\r\")\r\n                break;\r\n            pos--;\r\n        }\r\n        return startPos - pos;\r\n    };\r\n    StringUtils.escapeForWithinString = function (str, quoteKind) {\r\n        return StringUtils.escapeChar(str, quoteKind).replace(/(\\r?\\n)/g, \"\\\\$1\");\r\n    };\r\n    /**\r\n     * Escapes all the occurences of the char in the string.\r\n     */\r\n    StringUtils.escapeChar = function (str, char) {\r\n        if (char.length !== 1)\r\n            throw new errors.InvalidOperationError(\"Specified char must be one character long.\");\r\n        var result = \"\";\r\n        for (var i = 0; i < str.length; i++) {\r\n            if (str[i] === char)\r\n                result += \"\\\\\";\r\n            result += str[i];\r\n        }\r\n        return result;\r\n    };\r\n    return StringUtils;\r\n}());\r\nexports.StringUtils = StringUtils;\r\nvar Es5StringUtils = /** @class */ (function () {\r\n    function Es5StringUtils() {\r\n    }\r\n    Es5StringUtils.startsWith = function (str, startsWithString) {\r\n        return str.substr(0, startsWithString.length) === startsWithString;\r\n    };\r\n    Es5StringUtils.endsWith = function (str, endsWithString) {\r\n        return str.substr(str.length - endsWithString.length, endsWithString.length) === endsWithString;\r\n    };\r\n    return Es5StringUtils;\r\n}());\r\nexports.Es5StringUtils = Es5StringUtils;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/StringUtils.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/TypeGuards.js":
/*!*************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/TypeGuards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n// -----------------------\r\n// WARNING - DO NOT modify the \"is\" methods of the TypeGuards class directly. It is code generated by createTypeGuardsUtility.ts\r\n//\r\n// Note: This file is excluded from code coverage reports because it's automatically maintained (low risk).\r\n// -----------------------\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\n/**\r\n * Type guards for checking the type of a node.\r\n */\r\nvar TypeGuards = /** @class */ (function () {\r\n    function TypeGuards() {\r\n    }\r\n    /**\r\n     * Gets if the node has an expression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.hasExpression = function (node) {\r\n        // this method is manually maintained\r\n        if (node.getExpression == null)\r\n            return false;\r\n        return node.getExpression() != null;\r\n    };\r\n    /**\r\n     * Gets if the node has a name.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.hasName = function (node) {\r\n        // this method is manually maintained\r\n        if (node.getName == null)\r\n            return false;\r\n        return typeof node.getName() === \"string\";\r\n    };\r\n    /**\r\n     * Gets if the node has a body.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.hasBody = function (node) {\r\n        // this method is manually maintained\r\n        if (node.getBody == null)\r\n            return false;\r\n        return node.getBody() != null;\r\n    };\r\n    /**\r\n     * Gets if the node is an AbstractableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAbstractableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an AmbientableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAmbientableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an AnyKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAnyKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.AnyKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is an ArgumentedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isArgumentedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an ArrayBindingPattern.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isArrayBindingPattern = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ArrayBindingPattern;\r\n    };\r\n    /**\r\n     * Gets if the node is an ArrayLiteralExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isArrayLiteralExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ArrayLiteralExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is an ArrayTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isArrayTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ArrayType;\r\n    };\r\n    /**\r\n     * Gets if the node is an ArrowFunction.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isArrowFunction = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ArrowFunction;\r\n    };\r\n    /**\r\n     * Gets if the node is an AsExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAsExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.AsExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is an AsyncableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAsyncableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an AwaitExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAwaitExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.AwaitExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is an AwaitableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isAwaitableNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ForOfStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a BinaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBinaryExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.BinaryExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a BindingElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBindingElement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.BindingElement;\r\n    };\r\n    /**\r\n     * Gets if the node is a BindingNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBindingNamedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.BindingElement:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a Block.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBlock = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Block;\r\n    };\r\n    /**\r\n     * Gets if the node is a BodiedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBodiedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a BodyableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBodyableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a BooleanKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBooleanKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.BooleanKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a BooleanLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBooleanLiteral = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a BreakStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isBreakStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.BreakStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a CallExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isCallExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.CallExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a CallSignatureDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isCallSignatureDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.CallSignature;\r\n    };\r\n    /**\r\n     * Gets if the node is a CaseBlock.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isCaseBlock = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.CaseBlock;\r\n    };\r\n    /**\r\n     * Gets if the node is a CaseClause.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isCaseClause = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.CaseClause;\r\n    };\r\n    /**\r\n     * Gets if the node is a CatchClause.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isCatchClause = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.CatchClause;\r\n    };\r\n    /**\r\n     * Gets if the node is a ChildOrderableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isChildOrderableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.IndexSignature:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.BreakStatement:\r\n            case typescript_1.SyntaxKind.CaseClause:\r\n            case typescript_1.SyntaxKind.ContinueStatement:\r\n            case typescript_1.SyntaxKind.DefaultClause:\r\n            case typescript_1.SyntaxKind.DoStatement:\r\n            case typescript_1.SyntaxKind.ExpressionStatement:\r\n            case typescript_1.SyntaxKind.ForInStatement:\r\n            case typescript_1.SyntaxKind.ForOfStatement:\r\n            case typescript_1.SyntaxKind.ForStatement:\r\n            case typescript_1.SyntaxKind.IfStatement:\r\n            case typescript_1.SyntaxKind.LabeledStatement:\r\n            case typescript_1.SyntaxKind.ReturnStatement:\r\n            case typescript_1.SyntaxKind.SwitchStatement:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n            case typescript_1.SyntaxKind.WhileStatement:\r\n            case typescript_1.SyntaxKind.WithStatement:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ClassDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isClassDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ClassDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a CommaListExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isCommaListExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.CommaListExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a ComputedPropertyName.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isComputedPropertyName = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ComputedPropertyName;\r\n    };\r\n    /**\r\n     * Gets if the node is a ConditionalExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isConditionalExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ConditionalExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a ConstructSignatureDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isConstructSignatureDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ConstructSignature;\r\n    };\r\n    /**\r\n     * Gets if the node is a ConstructorDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isConstructorDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Constructor;\r\n    };\r\n    /**\r\n     * Gets if the node is a ConstructorTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isConstructorTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ConstructorType;\r\n    };\r\n    /**\r\n     * Gets if the node is a ContinueStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isContinueStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ContinueStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a DebuggerStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDebuggerStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.DebuggerStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a DeclarationNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDeclarationNamedNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Parameter;\r\n    };\r\n    /**\r\n     * Gets if the node is a DecoratableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDecoratableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a Decorator.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDecorator = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Decorator;\r\n    };\r\n    /**\r\n     * Gets if the node is a DefaultClause.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDefaultClause = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.DefaultClause;\r\n    };\r\n    /**\r\n     * Gets if the node is a DeleteExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDeleteExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.DeleteExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a DoStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isDoStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.DoStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is an ElementAccessExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isElementAccessExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ElementAccessExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is an EmptyStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isEmptyStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.EmptyStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is an EnumDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isEnumDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.EnumDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is an EnumMember.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isEnumMember = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.EnumMember;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExclamationTokenableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExclamationTokenableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an ExportAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExportAssignment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ExportAssignment;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExportDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExportDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ExportDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExportSpecifier.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExportSpecifier = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ExportSpecifier;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExportableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExportableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an Expression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.AnyKeyword:\r\n            case typescript_1.SyntaxKind.BooleanKeyword:\r\n            case typescript_1.SyntaxKind.NeverKeyword:\r\n            case typescript_1.SyntaxKind.NumberKeyword:\r\n            case typescript_1.SyntaxKind.ObjectKeyword:\r\n            case typescript_1.SyntaxKind.StringKeyword:\r\n            case typescript_1.SyntaxKind.SymbolKeyword:\r\n            case typescript_1.SyntaxKind.UndefinedKeyword:\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.AsExpression:\r\n            case typescript_1.SyntaxKind.AwaitExpression:\r\n            case typescript_1.SyntaxKind.BinaryExpression:\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.CommaListExpression:\r\n            case typescript_1.SyntaxKind.ConditionalExpression:\r\n            case typescript_1.SyntaxKind.DeleteExpression:\r\n            case typescript_1.SyntaxKind.ElementAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportKeyword:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.NonNullExpression:\r\n            case typescript_1.SyntaxKind.OmittedExpression:\r\n            case typescript_1.SyntaxKind.ParenthesizedExpression:\r\n            case typescript_1.SyntaxKind.PartiallyEmittedExpression:\r\n            case typescript_1.SyntaxKind.PostfixUnaryExpression:\r\n            case typescript_1.SyntaxKind.PrefixUnaryExpression:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.SpreadElement:\r\n            case typescript_1.SyntaxKind.SuperKeyword:\r\n            case typescript_1.SyntaxKind.ThisKeyword:\r\n            case typescript_1.SyntaxKind.TypeAssertionExpression:\r\n            case typescript_1.SyntaxKind.TypeOfExpression:\r\n            case typescript_1.SyntaxKind.VoidKeyword:\r\n            case typescript_1.SyntaxKind.YieldExpression:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.JsxClosingFragment:\r\n            case typescript_1.SyntaxKind.JsxElement:\r\n            case typescript_1.SyntaxKind.JsxExpression:\r\n            case typescript_1.SyntaxKind.JsxFragment:\r\n            case typescript_1.SyntaxKind.JsxOpeningElement:\r\n            case typescript_1.SyntaxKind.JsxOpeningFragment:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n            case typescript_1.SyntaxKind.NullKeyword:\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.ArrayLiteralExpression:\r\n            case typescript_1.SyntaxKind.ObjectLiteralExpression:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TaggedTemplateExpression:\r\n            case typescript_1.SyntaxKind.TemplateExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an ExpressionStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExpressionStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ExpressionStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExpressionWithTypeArguments.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExpressionWithTypeArguments = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ExpressionWithTypeArguments;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExpressionedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExpressionedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.AsExpression:\r\n            case typescript_1.SyntaxKind.NonNullExpression:\r\n            case typescript_1.SyntaxKind.ParenthesizedExpression:\r\n            case typescript_1.SyntaxKind.PartiallyEmittedExpression:\r\n            case typescript_1.SyntaxKind.SpreadElement:\r\n            case typescript_1.SyntaxKind.SpreadAssignment:\r\n            case typescript_1.SyntaxKind.TemplateSpan:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is an ExtendsClauseableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExtendsClauseableNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.InterfaceDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is an ExternalModuleReference.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isExternalModuleReference = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ExternalModuleReference;\r\n    };\r\n    /**\r\n     * Gets if the node is a FalseKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isFalseKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.FalseKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a ForInStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isForInStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ForInStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a ForOfStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isForOfStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ForOfStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a ForStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isForStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ForStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a FunctionDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isFunctionDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.FunctionDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a FunctionExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isFunctionExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.FunctionExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a FunctionLikeDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isFunctionLikeDeclaration = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a FunctionOrConstructorTypeNodeBase.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isFunctionOrConstructorTypeNodeBase = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ConstructorType:\r\n            case typescript_1.SyntaxKind.FunctionType:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a FunctionTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isFunctionTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.FunctionType;\r\n    };\r\n    /**\r\n     * Gets if the node is a GeneratorableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isGeneratorableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.YieldExpression:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a GetAccessorDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isGetAccessorDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.GetAccessor;\r\n    };\r\n    /**\r\n     * Gets if the node is a HeritageClause.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isHeritageClause = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.HeritageClause;\r\n    };\r\n    /**\r\n     * Gets if the node is a HeritageClauseableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isHeritageClauseableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a Identifier.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isIdentifier = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Identifier;\r\n    };\r\n    /**\r\n     * Gets if the node is a IfStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isIfStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.IfStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a ImplementsClauseableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isImplementsClauseableNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ClassDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a ImportDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isImportDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ImportDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a ImportEqualsDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isImportEqualsDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ImportEqualsDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a ImportExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isImportExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ImportKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a ImportSpecifier.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isImportSpecifier = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ImportSpecifier;\r\n    };\r\n    /**\r\n     * Gets if the node is a ImportTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isImportTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ImportType;\r\n    };\r\n    /**\r\n     * Gets if the node is a IndexSignatureDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isIndexSignatureDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.IndexSignature;\r\n    };\r\n    /**\r\n     * Gets if the node is a InitializerExpressionableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isInitializerExpressionableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.BindingElement:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a InitializerGetExpressionableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isInitializerGetExpressionableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.BindingElement:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyAssignment:\r\n            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a InitializerSetExpressionableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isInitializerSetExpressionableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.BindingElement:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a InterfaceDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isInterfaceDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.InterfaceDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a IntersectionTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isIntersectionTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.IntersectionType;\r\n    };\r\n    /**\r\n     * Gets if the node is a IterationStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isIterationStatement = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.DoStatement:\r\n            case typescript_1.SyntaxKind.ForInStatement:\r\n            case typescript_1.SyntaxKind.ForOfStatement:\r\n            case typescript_1.SyntaxKind.ForStatement:\r\n            case typescript_1.SyntaxKind.WhileStatement:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDoc.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDoc = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocComment;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocAugmentsTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocAugmentsTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocAugmentsTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocClassTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocClassTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocClassTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocParameterTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocParameterTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocParameterTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocPropertyLikeTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocPropertyLikeTag = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.JSDocParameterTag:\r\n            case typescript_1.SyntaxKind.JSDocPropertyTag:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocPropertyTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocPropertyTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocPropertyTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocReturnTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocReturnTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocReturnTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocTag = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.JSDocAugmentsTag:\r\n            case typescript_1.SyntaxKind.JSDocClassTag:\r\n            case typescript_1.SyntaxKind.JSDocParameterTag:\r\n            case typescript_1.SyntaxKind.JSDocPropertyTag:\r\n            case typescript_1.SyntaxKind.JSDocReturnTag:\r\n            case typescript_1.SyntaxKind.JSDocTypedefTag:\r\n            case typescript_1.SyntaxKind.JSDocTypeTag:\r\n            case typescript_1.SyntaxKind.JSDocTag:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocTypeTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocTypeTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocTypeTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocTypedefTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocTypedefTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocTypedefTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocUnknownTag.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocUnknownTag = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JSDocTag;\r\n    };\r\n    /**\r\n     * Gets if the node is a JSDocableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJSDocableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.ImportEqualsDeclaration:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.IndexSignature:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.ExpressionStatement:\r\n            case typescript_1.SyntaxKind.LabeledStatement:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxAttribute.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxAttribute = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxAttribute;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxAttributedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxAttributedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.JsxOpeningElement:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxClosingElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxClosingElement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxClosingElement;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxClosingFragment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxClosingFragment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxClosingFragment;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxElement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxElement;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxFragment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxFragment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxFragment;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxOpeningElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxOpeningElement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxOpeningElement;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxOpeningFragment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxOpeningFragment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxOpeningFragment;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxSelfClosingElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxSelfClosingElement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxSelfClosingElement;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxSpreadAttribute.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxSpreadAttribute = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxSpreadAttribute;\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxTagNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxTagNamedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.JsxClosingElement:\r\n            case typescript_1.SyntaxKind.JsxOpeningElement:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a JsxText.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isJsxText = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.JsxText;\r\n    };\r\n    /**\r\n     * Gets if the node is a LabeledStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isLabeledStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.LabeledStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a LeftHandSideExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isLeftHandSideExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.ElementAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportKeyword:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.NonNullExpression:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.SuperKeyword:\r\n            case typescript_1.SyntaxKind.ThisKeyword:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.JsxElement:\r\n            case typescript_1.SyntaxKind.JsxFragment:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n            case typescript_1.SyntaxKind.NullKeyword:\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.ArrayLiteralExpression:\r\n            case typescript_1.SyntaxKind.ObjectLiteralExpression:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TaggedTemplateExpression:\r\n            case typescript_1.SyntaxKind.TemplateExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a LeftHandSideExpressionedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isLeftHandSideExpressionedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.ElementAccessExpression:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.ExpressionWithTypeArguments:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a LiteralExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isLiteralExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a LiteralLikeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isLiteralLikeNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TemplateHead:\r\n            case typescript_1.SyntaxKind.TemplateMiddle:\r\n            case typescript_1.SyntaxKind.TemplateTail:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a LiteralTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isLiteralTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.LiteralType;\r\n    };\r\n    /**\r\n     * Gets if the node is a MemberExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isMemberExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.ElementAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportKeyword:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.SuperKeyword:\r\n            case typescript_1.SyntaxKind.ThisKeyword:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.JsxElement:\r\n            case typescript_1.SyntaxKind.JsxFragment:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n            case typescript_1.SyntaxKind.NullKeyword:\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.ArrayLiteralExpression:\r\n            case typescript_1.SyntaxKind.ObjectLiteralExpression:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TaggedTemplateExpression:\r\n            case typescript_1.SyntaxKind.TemplateExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a MetaProperty.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isMetaProperty = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.MetaProperty;\r\n    };\r\n    /**\r\n     * Gets if the node is a MethodDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isMethodDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.MethodDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a MethodSignature.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isMethodSignature = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.MethodSignature;\r\n    };\r\n    /**\r\n     * Gets if the node is a ModifierableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isModifierableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.IndexSignature:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n            case typescript_1.SyntaxKind.VariableDeclarationList:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a NameableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNameableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a NamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNamedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportEqualsDeclaration:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.JsxAttribute:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n            case typescript_1.SyntaxKind.TypeParameter:\r\n            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a NamespaceChildableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNamespaceChildableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a NamespaceDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNamespaceDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ModuleDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a NeverKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNeverKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NeverKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a NewExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNewExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NewExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a NoSubstitutionTemplateLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNoSubstitutionTemplateLiteral = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral;\r\n    };\r\n    /**\r\n     * Gets if the node is a NonNullExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNonNullExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NonNullExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a NotEmittedStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNotEmittedStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NotEmittedStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a NullLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNullLiteral = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NullKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a NumberKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNumberKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NumberKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a NumericLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isNumericLiteral = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.NumericLiteral;\r\n    };\r\n    /**\r\n     * Gets if the node is a ObjectBindingPattern.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isObjectBindingPattern = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ObjectBindingPattern;\r\n    };\r\n    /**\r\n     * Gets if the node is a ObjectKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isObjectKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ObjectKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a ObjectLiteralExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isObjectLiteralExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ObjectLiteralExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a OmittedExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isOmittedExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.OmittedExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a OverloadableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isOverloadableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ParameterDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isParameterDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Parameter;\r\n    };\r\n    /**\r\n     * Gets if the node is a ParameteredNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isParameteredNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.ConstructorType:\r\n            case typescript_1.SyntaxKind.FunctionType:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ParenthesizedExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isParenthesizedExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ParenthesizedExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a ParenthesizedTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isParenthesizedTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ParenthesizedType;\r\n    };\r\n    /**\r\n     * Gets if the node is a PartiallyEmittedExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPartiallyEmittedExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PartiallyEmittedExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a PostfixUnaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPostfixUnaryExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PostfixUnaryExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a PrefixUnaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPrefixUnaryExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PrefixUnaryExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a PrimaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPrimaryExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.ImportKeyword:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.SuperKeyword:\r\n            case typescript_1.SyntaxKind.ThisKeyword:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.JsxElement:\r\n            case typescript_1.SyntaxKind.JsxFragment:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n            case typescript_1.SyntaxKind.NullKeyword:\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.ArrayLiteralExpression:\r\n            case typescript_1.SyntaxKind.ObjectLiteralExpression:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TemplateExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a PropertyAccessExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPropertyAccessExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PropertyAccessExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a PropertyAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPropertyAssignment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PropertyAssignment;\r\n    };\r\n    /**\r\n     * Gets if the node is a PropertyDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPropertyDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PropertyDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a PropertyNamedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPropertyNamedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.PropertyAssignment:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a PropertySignature.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isPropertySignature = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.PropertySignature;\r\n    };\r\n    /**\r\n     * Gets if the node is a QualifiedName.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isQualifiedName = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.QualifiedName;\r\n    };\r\n    /**\r\n     * Gets if the node is a QuestionTokenableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isQuestionTokenableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.PropertyAssignment:\r\n            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ReadonlyableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isReadonlyableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.IndexSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ReferenceFindableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isReferenceFindableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.BindingElement:\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportEqualsDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.JsxAttribute:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n            case typescript_1.SyntaxKind.TypeParameter:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyAssignment:\r\n            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a RegularExpressionLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isRegularExpressionLiteral = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.RegularExpressionLiteral;\r\n    };\r\n    /**\r\n     * Gets if the node is a RenameableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isRenameableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.BindingElement:\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.EnumMember:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportEqualsDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.JsxAttribute:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n            case typescript_1.SyntaxKind.TypeParameter:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyAssignment:\r\n            case typescript_1.SyntaxKind.ShorthandPropertyAssignment:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ReturnStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isReturnStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ReturnStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a ReturnTypedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isReturnTypedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.ConstructorType:\r\n            case typescript_1.SyntaxKind.FunctionType:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ScopeableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isScopeableNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.Parameter;\r\n    };\r\n    /**\r\n     * Gets if the node is a ScopedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isScopedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a SemicolonToken.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSemicolonToken = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SemicolonToken;\r\n    };\r\n    /**\r\n     * Gets if the node is a SetAccessorDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSetAccessorDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SetAccessor;\r\n    };\r\n    /**\r\n     * Gets if the node is a ShorthandPropertyAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isShorthandPropertyAssignment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ShorthandPropertyAssignment;\r\n    };\r\n    /**\r\n     * Gets if the node is a SignaturedDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSignaturedDeclaration = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.ConstructorType:\r\n            case typescript_1.SyntaxKind.FunctionType:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a SourceFile.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSourceFile = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SourceFile;\r\n    };\r\n    /**\r\n     * Gets if the node is a SpreadAssignment.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSpreadAssignment = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SpreadAssignment;\r\n    };\r\n    /**\r\n     * Gets if the node is a SpreadElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSpreadElement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SpreadElement;\r\n    };\r\n    /**\r\n     * Gets if the node is a Statement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isStatement = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.ExportAssignment:\r\n            case typescript_1.SyntaxKind.ExportDeclaration:\r\n            case typescript_1.SyntaxKind.ImportDeclaration:\r\n            case typescript_1.SyntaxKind.ImportEqualsDeclaration:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.Block:\r\n            case typescript_1.SyntaxKind.BreakStatement:\r\n            case typescript_1.SyntaxKind.ContinueStatement:\r\n            case typescript_1.SyntaxKind.DebuggerStatement:\r\n            case typescript_1.SyntaxKind.DoStatement:\r\n            case typescript_1.SyntaxKind.EmptyStatement:\r\n            case typescript_1.SyntaxKind.ExpressionStatement:\r\n            case typescript_1.SyntaxKind.ForInStatement:\r\n            case typescript_1.SyntaxKind.ForOfStatement:\r\n            case typescript_1.SyntaxKind.ForStatement:\r\n            case typescript_1.SyntaxKind.IfStatement:\r\n            case typescript_1.SyntaxKind.LabeledStatement:\r\n            case typescript_1.SyntaxKind.NotEmittedStatement:\r\n            case typescript_1.SyntaxKind.ReturnStatement:\r\n            case typescript_1.SyntaxKind.SwitchStatement:\r\n            case typescript_1.SyntaxKind.ThrowStatement:\r\n            case typescript_1.SyntaxKind.TryStatement:\r\n            case typescript_1.SyntaxKind.VariableStatement:\r\n            case typescript_1.SyntaxKind.WhileStatement:\r\n            case typescript_1.SyntaxKind.WithStatement:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a StatementedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isStatementedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.SourceFile:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.Block:\r\n            case typescript_1.SyntaxKind.CaseClause:\r\n            case typescript_1.SyntaxKind.DefaultClause:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a StaticableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isStaticableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a StringKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isStringKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.StringKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a StringLiteral.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isStringLiteral = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.StringLiteral;\r\n    };\r\n    /**\r\n     * Gets if the node is a SuperExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSuperExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SuperKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a SwitchStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSwitchStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SwitchStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a SymbolKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSymbolKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SymbolKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a SyntaxList.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isSyntaxList = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.SyntaxList;\r\n    };\r\n    /**\r\n     * Gets if the node is a TaggedTemplateExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTaggedTemplateExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TaggedTemplateExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a TemplateExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTemplateExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TemplateExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a TemplateHead.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTemplateHead = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TemplateHead;\r\n    };\r\n    /**\r\n     * Gets if the node is a TemplateMiddle.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTemplateMiddle = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TemplateMiddle;\r\n    };\r\n    /**\r\n     * Gets if the node is a TemplateSpan.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTemplateSpan = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TemplateSpan;\r\n    };\r\n    /**\r\n     * Gets if the node is a TemplateTail.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTemplateTail = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TemplateTail;\r\n    };\r\n    /**\r\n     * Gets if the node is a TextInsertableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTextInsertableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.EnumDeclaration:\r\n            case typescript_1.SyntaxKind.SourceFile:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n            case typescript_1.SyntaxKind.Block:\r\n            case typescript_1.SyntaxKind.CaseBlock:\r\n            case typescript_1.SyntaxKind.CaseClause:\r\n            case typescript_1.SyntaxKind.DefaultClause:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a ThisExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isThisExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ThisKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a ThrowStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isThrowStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.ThrowStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a TrueKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTrueKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TrueKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a TryStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTryStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TryStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a TupleTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTupleTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TupleType;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeAliasDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeAliasDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TypeAliasDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeArgumentedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeArgumentedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.ImportType:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeAssertion.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeAssertion = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TypeAssertionExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeElement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeElement = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.IndexSignature:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeElementMemberedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeElementMemberedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.TypeLiteral:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeLiteralNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeLiteralNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TypeLiteral;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.TypePredicate:\r\n            case typescript_1.SyntaxKind.ArrayType:\r\n            case typescript_1.SyntaxKind.ConstructorType:\r\n            case typescript_1.SyntaxKind.ExpressionWithTypeArguments:\r\n            case typescript_1.SyntaxKind.FunctionType:\r\n            case typescript_1.SyntaxKind.ImportType:\r\n            case typescript_1.SyntaxKind.IntersectionType:\r\n            case typescript_1.SyntaxKind.LiteralType:\r\n            case typescript_1.SyntaxKind.ParenthesizedType:\r\n            case typescript_1.SyntaxKind.TupleType:\r\n            case typescript_1.SyntaxKind.TypeLiteral:\r\n            case typescript_1.SyntaxKind.TypeReference:\r\n            case typescript_1.SyntaxKind.UnionType:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeOfExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeOfExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TypeOfExpression;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeParameterDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeParameterDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TypeParameter;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeParameteredNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeParameteredNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.ClassDeclaration:\r\n            case typescript_1.SyntaxKind.Constructor:\r\n            case typescript_1.SyntaxKind.GetAccessor:\r\n            case typescript_1.SyntaxKind.MethodDeclaration:\r\n            case typescript_1.SyntaxKind.SetAccessor:\r\n            case typescript_1.SyntaxKind.ArrowFunction:\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.CallSignature:\r\n            case typescript_1.SyntaxKind.ConstructSignature:\r\n            case typescript_1.SyntaxKind.InterfaceDeclaration:\r\n            case typescript_1.SyntaxKind.MethodSignature:\r\n            case typescript_1.SyntaxKind.FunctionType:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a TypeReferenceNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypeReferenceNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.TypeReference;\r\n    };\r\n    /**\r\n     * Gets if the node is a TypedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isTypedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.PropertyDeclaration:\r\n            case typescript_1.SyntaxKind.AsExpression:\r\n            case typescript_1.SyntaxKind.TypeAssertionExpression:\r\n            case typescript_1.SyntaxKind.Parameter:\r\n            case typescript_1.SyntaxKind.PropertySignature:\r\n            case typescript_1.SyntaxKind.TypeAliasDeclaration:\r\n            case typescript_1.SyntaxKind.VariableDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a UnaryExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isUnaryExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.AwaitExpression:\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.DeleteExpression:\r\n            case typescript_1.SyntaxKind.ElementAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportKeyword:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.NonNullExpression:\r\n            case typescript_1.SyntaxKind.PostfixUnaryExpression:\r\n            case typescript_1.SyntaxKind.PrefixUnaryExpression:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.SuperKeyword:\r\n            case typescript_1.SyntaxKind.ThisKeyword:\r\n            case typescript_1.SyntaxKind.TypeAssertionExpression:\r\n            case typescript_1.SyntaxKind.TypeOfExpression:\r\n            case typescript_1.SyntaxKind.VoidKeyword:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.JsxElement:\r\n            case typescript_1.SyntaxKind.JsxFragment:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n            case typescript_1.SyntaxKind.NullKeyword:\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.ArrayLiteralExpression:\r\n            case typescript_1.SyntaxKind.ObjectLiteralExpression:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TaggedTemplateExpression:\r\n            case typescript_1.SyntaxKind.TemplateExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a UnaryExpressionedNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isUnaryExpressionedNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.AwaitExpression:\r\n            case typescript_1.SyntaxKind.DeleteExpression:\r\n            case typescript_1.SyntaxKind.TypeAssertionExpression:\r\n            case typescript_1.SyntaxKind.TypeOfExpression:\r\n            case typescript_1.SyntaxKind.VoidKeyword:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a UndefinedKeyword.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isUndefinedKeyword = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.UndefinedKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a UnionTypeNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isUnionTypeNode = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.UnionType;\r\n    };\r\n    /**\r\n     * Gets if the node is a UnwrappableNode.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isUnwrappableNode = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.FunctionDeclaration:\r\n            case typescript_1.SyntaxKind.ModuleDeclaration:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a UpdateExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isUpdateExpression = function (node) {\r\n        switch (node.getKind()) {\r\n            case typescript_1.SyntaxKind.Identifier:\r\n            case typescript_1.SyntaxKind.CallExpression:\r\n            case typescript_1.SyntaxKind.ElementAccessExpression:\r\n            case typescript_1.SyntaxKind.ImportKeyword:\r\n            case typescript_1.SyntaxKind.MetaProperty:\r\n            case typescript_1.SyntaxKind.NewExpression:\r\n            case typescript_1.SyntaxKind.NonNullExpression:\r\n            case typescript_1.SyntaxKind.PropertyAccessExpression:\r\n            case typescript_1.SyntaxKind.SuperKeyword:\r\n            case typescript_1.SyntaxKind.ThisKeyword:\r\n            case typescript_1.SyntaxKind.FunctionExpression:\r\n            case typescript_1.SyntaxKind.JsxElement:\r\n            case typescript_1.SyntaxKind.JsxFragment:\r\n            case typescript_1.SyntaxKind.JsxSelfClosingElement:\r\n            case typescript_1.SyntaxKind.FalseKeyword:\r\n            case typescript_1.SyntaxKind.TrueKeyword:\r\n            case typescript_1.SyntaxKind.NullKeyword:\r\n            case typescript_1.SyntaxKind.NumericLiteral:\r\n            case typescript_1.SyntaxKind.RegularExpressionLiteral:\r\n            case typescript_1.SyntaxKind.StringLiteral:\r\n            case typescript_1.SyntaxKind.ArrayLiteralExpression:\r\n            case typescript_1.SyntaxKind.ObjectLiteralExpression:\r\n            case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n            case typescript_1.SyntaxKind.TaggedTemplateExpression:\r\n            case typescript_1.SyntaxKind.TemplateExpression:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n    /**\r\n     * Gets if the node is a VariableDeclaration.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isVariableDeclaration = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.VariableDeclaration;\r\n    };\r\n    /**\r\n     * Gets if the node is a VariableDeclarationList.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isVariableDeclarationList = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.VariableDeclarationList;\r\n    };\r\n    /**\r\n     * Gets if the node is a VariableStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isVariableStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.VariableStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a VoidExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isVoidExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.VoidKeyword;\r\n    };\r\n    /**\r\n     * Gets if the node is a WhileStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isWhileStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.WhileStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a WithStatement.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isWithStatement = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.WithStatement;\r\n    };\r\n    /**\r\n     * Gets if the node is a YieldExpression.\r\n     * @param node - Node to check.\r\n     */\r\n    TypeGuards.isYieldExpression = function (node) {\r\n        return node.getKind() === typescript_1.SyntaxKind.YieldExpression;\r\n    };\r\n    return TypeGuards;\r\n}());\r\nexports.TypeGuards = TypeGuards;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/TypeGuards.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/Es5Map.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/Es5Map.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar Es5PropSaver_1 = __webpack_require__(/*! ../Es5PropSaver */ \"./node_modules/ts-simple-ast/dist/utils/Es5PropSaver.js\");\r\nvar Es5Map = /** @class */ (function () {\r\n    function Es5Map() {\r\n        this.propSaver = new Es5PropSaver_1.Es5PropSaver();\r\n        this.items = {};\r\n        this.itemCount = 0;\r\n    }\r\n    Object.defineProperty(Es5Map.prototype, \"size\", {\r\n        get: function () {\r\n            return Object.keys(this.items).length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Es5Map.prototype.set = function (key, value) {\r\n        var identifier = this.getIdentifier(key) || this.createIdentifier(key);\r\n        this.items[identifier] = [key, value];\r\n    };\r\n    Es5Map.prototype.get = function (key) {\r\n        var identifier = this.getIdentifier(key);\r\n        if (identifier == null)\r\n            return undefined;\r\n        var keyValue = this.items[identifier];\r\n        if (keyValue == null)\r\n            return undefined;\r\n        return keyValue[1];\r\n    };\r\n    Es5Map.prototype.has = function (key) {\r\n        var identifier = this.getIdentifier(key);\r\n        if (identifier == null)\r\n            return false;\r\n        return this.items.hasOwnProperty(identifier);\r\n    };\r\n    Es5Map.prototype.delete = function (key) {\r\n        var identifier = this.getIdentifier(key);\r\n        if (identifier != null)\r\n            delete this.items[identifier];\r\n    };\r\n    Es5Map.prototype.clear = function () {\r\n        this.propSaver = new Es5PropSaver_1.Es5PropSaver();\r\n        this.items = {};\r\n    };\r\n    Es5Map.prototype.entries = function () {\r\n        var e_1, _a, _b, _c, key, e_1_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(Object.keys(this.items)), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    key = _c.value;\r\n                    return [4 /*yield*/, this.items[key]];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_1_1 = _d.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Es5Map.prototype.keys = function () {\r\n        var e_2, _a, _b, _c, entry, e_2_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(this.entries()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    entry = _c.value;\r\n                    return [4 /*yield*/, entry[0]];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_2_1 = _d.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Es5Map.prototype.values = function () {\r\n        var e_3, _a, _b, _c, entry, e_3_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(this.entries()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    entry = _c.value;\r\n                    return [4 /*yield*/, entry[1]];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_3_1 = _d.sent();\r\n                    e_3 = { error: e_3_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    Es5Map.prototype.getIdentifier = function (key) {\r\n        if (typeof key === \"string\")\r\n            return key;\r\n        return this.propSaver.get(key);\r\n    };\r\n    Es5Map.prototype.createIdentifier = function (key) {\r\n        if (typeof key === \"string\")\r\n            return key;\r\n        var identifier = (this.itemCount++).toString();\r\n        this.propSaver.set(key, identifier);\r\n        return identifier;\r\n    };\r\n    return Es5Map;\r\n}());\r\nexports.Es5Map = Es5Map;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/Es5Map.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/Es5WeakMap.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/Es5WeakMap.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Es5PropSaver_1 = __webpack_require__(/*! ../Es5PropSaver */ \"./node_modules/ts-simple-ast/dist/utils/Es5PropSaver.js\");\r\nvar Es5WeakMap = /** @class */ (function () {\r\n    function Es5WeakMap() {\r\n        this.propSaver = new Es5PropSaver_1.Es5PropSaver();\r\n    }\r\n    Es5WeakMap.prototype.get = function (key) {\r\n        return this.propSaver.get(key);\r\n    };\r\n    Es5WeakMap.prototype.set = function (key, value) {\r\n        this.propSaver.set(key, value);\r\n    };\r\n    Es5WeakMap.prototype.has = function (key) {\r\n        return this.propSaver.get(key) != null;\r\n    };\r\n    Es5WeakMap.prototype.delete = function (key) {\r\n        this.propSaver.remove(key);\r\n    };\r\n    return Es5WeakMap;\r\n}());\r\nexports.Es5WeakMap = Es5WeakMap;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/Es5WeakMap.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/HashSet.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/HashSet.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nfunction createHashSet() {\r\n    if (typeof Set !== \"undefined\")\r\n        return new Set();\r\n    return new Es5HashSet();\r\n}\r\nexports.createHashSet = createHashSet;\r\nvar Es5HashSet = /** @class */ (function () {\r\n    function Es5HashSet() {\r\n        this.items = [];\r\n    }\r\n    Es5HashSet.prototype.has = function (value) {\r\n        // slow and O(n)...\r\n        return this.items.indexOf(value) >= 0;\r\n    };\r\n    Es5HashSet.prototype.add = function (value) {\r\n        if (!this.has(value))\r\n            this.items.push(value);\r\n    };\r\n    Es5HashSet.prototype.delete = function (value) {\r\n        var index = this.items.indexOf(value);\r\n        if (index === -1)\r\n            return false;\r\n        this.items.splice(index, 1);\r\n        return true;\r\n    };\r\n    Es5HashSet.prototype.clear = function () {\r\n        this.items.length = 0;\r\n    };\r\n    Es5HashSet.prototype.values = function () {\r\n        var e_1, _a, _b, _c, item, e_1_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 5, 6, 7]);\r\n                    _b = tslib_1.__values(this.items), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 4];\r\n                    item = _c.value;\r\n                    return [4 /*yield*/, item];\r\n                case 2:\r\n                    _d.sent();\r\n                    _d.label = 3;\r\n                case 3:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 4: return [3 /*break*/, 7];\r\n                case 5:\r\n                    e_1_1 = _d.sent();\r\n                    e_1 = { error: e_1_1 };\r\n                    return [3 /*break*/, 7];\r\n                case 6:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_1) throw e_1.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Es5HashSet;\r\n}());\r\nexports.Es5HashSet = Es5HashSet;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/HashSet.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/KeyValueCache.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/KeyValueCache.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ArrayUtils_1 = __webpack_require__(/*! ../ArrayUtils */ \"./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js\");\r\nvar Es5Map_1 = __webpack_require__(/*! ./Es5Map */ \"./node_modules/ts-simple-ast/dist/utils/collections/Es5Map.js\");\r\nvar KeyValueCache = /** @class */ (function () {\r\n    function KeyValueCache() {\r\n        if (typeof Map !== undefined)\r\n            this.cacheItems = new Map();\r\n        else\r\n            this.cacheItems = new Es5Map_1.Es5Map();\r\n    }\r\n    KeyValueCache.prototype.getSize = function () {\r\n        return this.cacheItems.size;\r\n    };\r\n    KeyValueCache.prototype.getValues = function () {\r\n        return this.cacheItems.values();\r\n    };\r\n    KeyValueCache.prototype.getValuesAsArray = function () {\r\n        return ArrayUtils_1.ArrayUtils.from(this.getValues());\r\n    };\r\n    KeyValueCache.prototype.getKeys = function () {\r\n        return this.cacheItems.keys();\r\n    };\r\n    KeyValueCache.prototype.getEntries = function () {\r\n        return this.cacheItems.entries();\r\n    };\r\n    KeyValueCache.prototype.getOrCreate = function (key, createFunc) {\r\n        var item = this.get(key);\r\n        if (item == null) {\r\n            item = createFunc();\r\n            this.set(key, item);\r\n        }\r\n        return item;\r\n    };\r\n    KeyValueCache.prototype.has = function (key) {\r\n        return this.cacheItems.has(key);\r\n    };\r\n    KeyValueCache.prototype.get = function (key) {\r\n        return this.cacheItems.get(key);\r\n    };\r\n    KeyValueCache.prototype.set = function (key, value) {\r\n        this.cacheItems.set(key, value);\r\n    };\r\n    KeyValueCache.prototype.replaceKey = function (key, newKey) {\r\n        if (!this.cacheItems.has(key))\r\n            throw new Error(\"Key not found.\");\r\n        var value = this.cacheItems.get(key);\r\n        this.cacheItems.delete(key);\r\n        this.cacheItems.set(newKey, value);\r\n    };\r\n    KeyValueCache.prototype.removeByKey = function (key) {\r\n        this.cacheItems.delete(key);\r\n    };\r\n    KeyValueCache.prototype.clear = function () {\r\n        this.cacheItems.clear();\r\n    };\r\n    return KeyValueCache;\r\n}());\r\nexports.KeyValueCache = KeyValueCache;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/KeyValueCache.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/SortedKeyValueArray.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/SortedKeyValueArray.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar ArrayUtils_1 = __webpack_require__(/*! ../ArrayUtils */ \"./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js\");\r\nvar comparers_1 = __webpack_require__(/*! ../comparers */ \"./node_modules/ts-simple-ast/dist/utils/comparers/index.js\");\r\nvar SortedKeyValueArray = /** @class */ (function () {\r\n    function SortedKeyValueArray(getKey, comparer) {\r\n        this.getKey = getKey;\r\n        this.comparer = comparer;\r\n        this.array = [];\r\n    }\r\n    SortedKeyValueArray.prototype.set = function (value) {\r\n        ArrayUtils_1.ArrayUtils.binaryInsertWithOverwrite(this.array, value, new comparers_1.PropertyComparer(this.getKey, this.comparer));\r\n    };\r\n    SortedKeyValueArray.prototype.removeByValue = function (value) {\r\n        this.removeByKey(this.getKey(value));\r\n    };\r\n    SortedKeyValueArray.prototype.removeByKey = function (key) {\r\n        var storedComparer = new comparers_1.ComparerToStoredComparer(this.comparer, key);\r\n        var index = ArrayUtils_1.ArrayUtils.binarySearch(this.array, new comparers_1.PropertyStoredComparer(this.getKey, storedComparer));\r\n        if (index >= 0)\r\n            this.array.splice(index, 1);\r\n    };\r\n    SortedKeyValueArray.prototype.getArrayCopy = function () {\r\n        return tslib_1.__spread(this.array);\r\n    };\r\n    SortedKeyValueArray.prototype.hasItems = function () {\r\n        return this.array.length > 0;\r\n    };\r\n    SortedKeyValueArray.prototype.entries = function () {\r\n        return tslib_1.__generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [5 /*yield**/, tslib_1.__values(this.array)];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return SortedKeyValueArray;\r\n}());\r\nexports.SortedKeyValueArray = SortedKeyValueArray;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/SortedKeyValueArray.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/WeakCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/WeakCache.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Es5WeakMap_1 = __webpack_require__(/*! ./Es5WeakMap */ \"./node_modules/ts-simple-ast/dist/utils/collections/Es5WeakMap.js\");\r\nvar WeakCache = /** @class */ (function () {\r\n    function WeakCache() {\r\n        if (typeof WeakMap !== undefined)\r\n            this.cacheItems = new WeakMap();\r\n        else\r\n            this.cacheItems = new Es5WeakMap_1.Es5WeakMap();\r\n    }\r\n    WeakCache.prototype.getOrCreate = function (key, createFunc) {\r\n        var item = this.get(key);\r\n        if (item == null) {\r\n            item = createFunc();\r\n            this.set(key, item);\r\n        }\r\n        return item;\r\n    };\r\n    WeakCache.prototype.has = function (key) {\r\n        return this.cacheItems.has(key);\r\n    };\r\n    WeakCache.prototype.get = function (key) {\r\n        return this.cacheItems.get(key);\r\n    };\r\n    WeakCache.prototype.set = function (key, value) {\r\n        this.cacheItems.set(key, value);\r\n    };\r\n    WeakCache.prototype.removeByKey = function (key) {\r\n        this.cacheItems.delete(key);\r\n    };\r\n    return WeakCache;\r\n}());\r\nexports.WeakCache = WeakCache;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/WeakCache.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/collections/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/collections/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Es5Map */ \"./node_modules/ts-simple-ast/dist/utils/collections/Es5Map.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Es5WeakMap */ \"./node_modules/ts-simple-ast/dist/utils/collections/Es5WeakMap.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./HashSet */ \"./node_modules/ts-simple-ast/dist/utils/collections/HashSet.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./KeyValueCache */ \"./node_modules/ts-simple-ast/dist/utils/collections/KeyValueCache.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SortedKeyValueArray */ \"./node_modules/ts-simple-ast/dist/utils/collections/SortedKeyValueArray.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./WeakCache */ \"./node_modules/ts-simple-ast/dist/utils/collections/WeakCache.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/collections/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/comparers/ComparerToStoredComparer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/comparers/ComparerToStoredComparer.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ComparerToStoredComparer = /** @class */ (function () {\r\n    function ComparerToStoredComparer(comparer, storedValue) {\r\n        this.comparer = comparer;\r\n        this.storedValue = storedValue;\r\n    }\r\n    ComparerToStoredComparer.prototype.compareTo = function (value) {\r\n        return this.comparer.compareTo(this.storedValue, value);\r\n    };\r\n    return ComparerToStoredComparer;\r\n}());\r\nexports.ComparerToStoredComparer = ComparerToStoredComparer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/comparers/ComparerToStoredComparer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/comparers/LocaleStringComparer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/comparers/LocaleStringComparer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar LocaleStringComparer = /** @class */ (function () {\r\n    function LocaleStringComparer() {\r\n    }\r\n    LocaleStringComparer.prototype.compareTo = function (a, b) {\r\n        // always use en-us to everyone gets the same behaviour\r\n        var comparisonResult = a.localeCompare(b, \"en-us-u-kf-upper\");\r\n        if (comparisonResult < 0)\r\n            return -1;\r\n        else if (comparisonResult === 0)\r\n            return 0;\r\n        return 1;\r\n    };\r\n    LocaleStringComparer.instance = new LocaleStringComparer();\r\n    return LocaleStringComparer;\r\n}());\r\nexports.LocaleStringComparer = LocaleStringComparer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/comparers/LocaleStringComparer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/comparers/PropertyComparer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/comparers/PropertyComparer.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PropertyComparer = /** @class */ (function () {\r\n    function PropertyComparer(getProperty, comparer) {\r\n        this.getProperty = getProperty;\r\n        this.comparer = comparer;\r\n    }\r\n    PropertyComparer.prototype.compareTo = function (a, b) {\r\n        return this.comparer.compareTo(this.getProperty(a), this.getProperty(b));\r\n    };\r\n    return PropertyComparer;\r\n}());\r\nexports.PropertyComparer = PropertyComparer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/comparers/PropertyComparer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/comparers/PropertyStoredComparer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/comparers/PropertyStoredComparer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar PropertyStoredComparer = /** @class */ (function () {\r\n    function PropertyStoredComparer(getProperty, comparer) {\r\n        this.getProperty = getProperty;\r\n        this.comparer = comparer;\r\n    }\r\n    PropertyStoredComparer.prototype.compareTo = function (value) {\r\n        return this.comparer.compareTo(this.getProperty(value));\r\n    };\r\n    return PropertyStoredComparer;\r\n}());\r\nexports.PropertyStoredComparer = PropertyStoredComparer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/comparers/PropertyStoredComparer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/comparers/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/comparers/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ComparerToStoredComparer */ \"./node_modules/ts-simple-ast/dist/utils/comparers/ComparerToStoredComparer.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LocaleStringComparer */ \"./node_modules/ts-simple-ast/dist/utils/comparers/LocaleStringComparer.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyComparer */ \"./node_modules/ts-simple-ast/dist/utils/comparers/PropertyComparer.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./PropertyStoredComparer */ \"./node_modules/ts-simple-ast/dist/utils/comparers/PropertyStoredComparer.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/comparers/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/ModuleUtils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/ModuleUtils.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar StringUtils_1 = __webpack_require__(/*! ../StringUtils */ \"./node_modules/ts-simple-ast/dist/utils/StringUtils.js\");\r\nvar ModuleUtils = /** @class */ (function () {\r\n    function ModuleUtils() {\r\n    }\r\n    ModuleUtils.isModuleSpecifierRelative = function (text) {\r\n        return StringUtils_1.StringUtils.startsWith(text, \"./\")\r\n            || StringUtils_1.StringUtils.startsWith(text, \"../\");\r\n    };\r\n    ModuleUtils.getReferencedSourceFileFromSymbol = function (symbol) {\r\n        var declarations = symbol.getDeclarations();\r\n        if (declarations.length === 0 || declarations[0].getKind() !== typescript_1.SyntaxKind.SourceFile)\r\n            return undefined;\r\n        return declarations[0];\r\n    };\r\n    return ModuleUtils;\r\n}());\r\nexports.ModuleUtils = ModuleUtils;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/ModuleUtils.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/createWrappedNode.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/createWrappedNode.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar fileSystem_1 = __webpack_require__(/*! ../../fileSystem */ \"./node_modules/ts-simple-ast/dist/fileSystem/index.js\");\r\nvar ProjectContext_1 = __webpack_require__(/*! ../../ProjectContext */ \"./node_modules/ts-simple-ast/dist/ProjectContext.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\n/**\r\n * Creates a wrapped node from a compiler node.\r\n * @param node - Node to create a wrapped node from.\r\n * @param info - Info for creating the wrapped node.\r\n */\r\nfunction createWrappedNode(node, opts) {\r\n    if (opts === void 0) { opts = {}; }\r\n    var _a = opts.compilerOptions, compilerOptions = _a === void 0 ? {} : _a, sourceFile = opts.sourceFile, typeChecker = opts.typeChecker;\r\n    var projectContext = new ProjectContext_1.ProjectContext(new fileSystem_1.FileSystemWrapper(new fileSystem_1.DefaultFileSystemHost()), compilerOptions, { createLanguageService: false, typeChecker: typeChecker });\r\n    var wrappedSourceFile = projectContext.compilerFactory.getSourceFile(getSourceFileNode());\r\n    return projectContext.compilerFactory.getNodeFromCompilerNode(node, wrappedSourceFile);\r\n    function getSourceFileNode() {\r\n        return sourceFile == null ? getSourceFileFromNode(node) : sourceFile;\r\n    }\r\n    function getSourceFileFromNode(compilerNode) {\r\n        if (compilerNode.kind === typescript_1.SyntaxKind.SourceFile)\r\n            return compilerNode;\r\n        if (compilerNode.parent == null)\r\n            throw new errors.InvalidOperationError(\"Please ensure the node was created from a source file with 'setParentNodes' set to 'true'.\");\r\n        var parent = compilerNode;\r\n        while (parent.parent != null)\r\n            parent = parent.parent;\r\n        if (parent.kind !== typescript_1.SyntaxKind.SourceFile)\r\n            throw new errors.NotImplementedError(\"For some reason the top parent was not a source file.\");\r\n        return parent;\r\n    }\r\n}\r\nexports.createWrappedNode = createWrappedNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/createWrappedNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/getNodeByNameOrFindFunction.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/getNodeByNameOrFindFunction.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ArrayUtils_1 = __webpack_require__(/*! ../ArrayUtils */ \"./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js\");\r\nfunction getNodeByNameOrFindFunction(items, nameOrFindFunc) {\r\n    var findFunc;\r\n    if (typeof nameOrFindFunc === \"string\")\r\n        findFunc = function (dec) { return dec.getName != null && dec.getName() === nameOrFindFunc; };\r\n    else\r\n        findFunc = nameOrFindFunc;\r\n    return ArrayUtils_1.ArrayUtils.find(items, findFunc);\r\n}\r\nexports.getNodeByNameOrFindFunction = getNodeByNameOrFindFunction;\r\nfunction getNotFoundErrorMessageForNameOrFindFunction(findName, nameOrFindFunction) {\r\n    if (typeof nameOrFindFunction === \"string\")\r\n        return \"Expected to find \" + findName + \" named '\" + nameOrFindFunction + \"'.\";\r\n    return \"Expected to find \" + findName + \" that matched the provided condition.\";\r\n}\r\nexports.getNotFoundErrorMessageForNameOrFindFunction = getNotFoundErrorMessageForNameOrFindFunction;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/getNodeByNameOrFindFunction.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/getParentSyntaxList.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/getParentSyntaxList.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nfunction getParentSyntaxList(node) {\r\n    var e_1, _a;\r\n    var parent = node.parent;\r\n    if (parent == null)\r\n        return undefined;\r\n    var pos = node.pos, end = node.end;\r\n    try {\r\n        for (var _b = tslib_1.__values(parent.getChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var child = _c.value;\r\n            if (child.pos > end || child === node)\r\n                return undefined;\r\n            if (child.kind === typescript_1.SyntaxKind.SyntaxList && child.pos <= pos && child.end >= end)\r\n                return child;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return undefined; // shouldn't happen\r\n}\r\nexports.getParentSyntaxList = getParentSyntaxList;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/getParentSyntaxList.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/getSymbolByNameOrFindFunction.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/getSymbolByNameOrFindFunction.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ArrayUtils_1 = __webpack_require__(/*! ../ArrayUtils */ \"./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js\");\r\n// todo: merge with getNamedNodeByNameOrFindFunction\r\nfunction getSymbolByNameOrFindFunction(items, nameOrFindFunc) {\r\n    var findFunc;\r\n    if (typeof nameOrFindFunc === \"string\")\r\n        findFunc = function (dec) { return dec.getName() === nameOrFindFunc; };\r\n    else\r\n        findFunc = nameOrFindFunc;\r\n    return ArrayUtils_1.ArrayUtils.find(items, findFunc);\r\n}\r\nexports.getSymbolByNameOrFindFunction = getSymbolByNameOrFindFunction;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/getSymbolByNameOrFindFunction.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/getSyntaxKindName.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/getSyntaxKindName.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nfunction getSyntaxKindName(kind) {\r\n    return getKindCache()[kind];\r\n}\r\nexports.getSyntaxKindName = getSyntaxKindName;\r\nvar kindCache = undefined;\r\nfunction getKindCache() {\r\n    var e_1, _a;\r\n    if (kindCache != null)\r\n        return kindCache;\r\n    kindCache = {};\r\n    try {\r\n        // some SyntaxKinds are repeated, so only use the first one\r\n        for (var _b = tslib_1.__values(Object.keys(typescript_1.SyntaxKind).filter(function (k) { return isNaN(parseInt(k, 10)); })), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var name = _c.value;\r\n            var value = typescript_1.SyntaxKind[name];\r\n            if (kindCache[value] == null)\r\n                kindCache[value] = name;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return kindCache;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/getSyntaxKindName.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getNodeByNameOrFindFunction */ \"./node_modules/ts-simple-ast/dist/utils/compiler/getNodeByNameOrFindFunction.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getParentSyntaxList */ \"./node_modules/ts-simple-ast/dist/utils/compiler/getParentSyntaxList.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getSymbolByNameOrFindFunction */ \"./node_modules/ts-simple-ast/dist/utils/compiler/getSymbolByNameOrFindFunction.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getSyntaxKindName */ \"./node_modules/ts-simple-ast/dist/utils/compiler/getSyntaxKindName.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./isNodeAmbientOrInAmbientContext */ \"./node_modules/ts-simple-ast/dist/utils/compiler/isNodeAmbientOrInAmbientContext.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./isStringKind */ \"./node_modules/ts-simple-ast/dist/utils/compiler/isStringKind.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ModuleUtils */ \"./node_modules/ts-simple-ast/dist/utils/compiler/ModuleUtils.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./printNode */ \"./node_modules/ts-simple-ast/dist/utils/compiler/printNode.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/isNodeAmbientOrInAmbientContext.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/isNodeAmbientOrInAmbientContext.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar TypeGuards_1 = __webpack_require__(/*! ../TypeGuards */ \"./node_modules/ts-simple-ast/dist/utils/TypeGuards.js\");\r\nfunction isNodeAmbientOrInAmbientContext(node) {\r\n    var e_1, _a;\r\n    if (checkNodeIsAmbient(node) || node.sourceFile.isDeclarationFile())\r\n        return true;\r\n    try {\r\n        for (var _b = tslib_1.__values(node.getAncestorsIterator(false)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var ancestor = _c.value;\r\n            if (checkNodeIsAmbient(ancestor))\r\n                return true;\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return false;\r\n}\r\nexports.isNodeAmbientOrInAmbientContext = isNodeAmbientOrInAmbientContext;\r\nfunction checkNodeIsAmbient(node) {\r\n    var isThisAmbient = (node.getCombinedModifierFlags() & typescript_1.ts.ModifierFlags.Ambient) === typescript_1.ts.ModifierFlags.Ambient;\r\n    return isThisAmbient || TypeGuards_1.TypeGuards.isInterfaceDeclaration(node) || TypeGuards_1.TypeGuards.isTypeAliasDeclaration(node);\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/isNodeAmbientOrInAmbientContext.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/isStringKind.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/isStringKind.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\n/**\r\n * Gets if the kind is a string kind.\r\n * @param kind - Node kind.\r\n */\r\nfunction isStringKind(kind) {\r\n    switch (kind) {\r\n        case typescript_1.SyntaxKind.StringLiteral:\r\n        case typescript_1.SyntaxKind.NoSubstitutionTemplateLiteral:\r\n        case typescript_1.SyntaxKind.TemplateHead:\r\n        case typescript_1.SyntaxKind.TemplateMiddle:\r\n        case typescript_1.SyntaxKind.TemplateTail:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nexports.isStringKind = isStringKind;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/isStringKind.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/compiler/printNode.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/compiler/printNode.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nfunction printNode(node, sourceFileOrOptions, secondOverloadOptions) {\r\n    var isFirstOverload = sourceFileOrOptions == null || sourceFileOrOptions.kind !== typescript_1.SyntaxKind.SourceFile;\r\n    var options = getOptions();\r\n    var sourceFile = getSourceFile();\r\n    var printer = typescript_1.ts.createPrinter({\r\n        newLine: options.newLineKind == null ? typescript_1.NewLineKind.LineFeed : options.newLineKind,\r\n        removeComments: options.removeComments || false\r\n    });\r\n    if (sourceFile == null)\r\n        return printer.printFile(node);\r\n    else\r\n        return printer.printNode(options.emitHint == null ? typescript_1.EmitHint.Unspecified : options.emitHint, node, sourceFile);\r\n    function getSourceFile() {\r\n        if (isFirstOverload) {\r\n            if (node.kind === typescript_1.SyntaxKind.SourceFile)\r\n                return undefined;\r\n            var scriptKind = getScriptKind();\r\n            return typescript_1.ts.createSourceFile(\"print.\" + getFileExt(scriptKind), \"\", typescript_1.ScriptTarget.Latest, false, scriptKind);\r\n        }\r\n        return sourceFileOrOptions;\r\n        function getScriptKind() {\r\n            return options.scriptKind == null ? typescript_1.ScriptKind.TSX : options.scriptKind;\r\n        }\r\n        function getFileExt(scriptKind) {\r\n            if (scriptKind === typescript_1.ScriptKind.JSX || scriptKind === typescript_1.ScriptKind.TSX)\r\n                return \"tsx\";\r\n            return \"ts\";\r\n        }\r\n    }\r\n    function getOptions() {\r\n        return (isFirstOverload ? sourceFileOrOptions : secondOverloadOptions) || {};\r\n    }\r\n}\r\nexports.printNode = printNode;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/compiler/printNode.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/decorators/Memoize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/decorators/Memoize.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction Memoize(target, propertyName, descriptor) {\r\n    if (descriptor.value != null)\r\n        descriptor.value = getNewFunction(descriptor.value);\r\n    else if (descriptor.get != null)\r\n        descriptor.get = getNewFunction(descriptor.get);\r\n    else\r\n        throw new Error(\"Only put a Memoize decorator on a method or get accessor.\");\r\n}\r\nexports.Memoize = Memoize;\r\nvar counter = 0;\r\nfunction getNewFunction(originalFunction) {\r\n    var identifier = ++counter;\r\n    function decorator() {\r\n        var propName = \"__memoized_value_\" + identifier;\r\n        if (arguments.length > 0)\r\n            propName += \"_\" + JSON.stringify(arguments);\r\n        var returnedValue;\r\n        if (this.hasOwnProperty(propName))\r\n            returnedValue = this[propName];\r\n        else {\r\n            returnedValue = originalFunction.apply(this, arguments);\r\n            Object.defineProperty(this, propName, {\r\n                configurable: false,\r\n                enumerable: false,\r\n                writable: false,\r\n                value: returnedValue\r\n            });\r\n        }\r\n        return returnedValue;\r\n    }\r\n    return decorator;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/decorators/Memoize.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/decorators/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/decorators/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./Memoize */ \"./node_modules/ts-simple-ast/dist/utils/decorators/Memoize.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/decorators/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/fillDefaultEditorSettings.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/fillDefaultEditorSettings.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar options_1 = __webpack_require__(/*! ../options */ \"./node_modules/ts-simple-ast/dist/options/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar setValueIfUndefined_1 = __webpack_require__(/*! ./setValueIfUndefined */ \"./node_modules/ts-simple-ast/dist/utils/setValueIfUndefined.js\");\r\nfunction fillDefaultEditorSettings(settings, manipulationSettings) {\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"convertTabsToSpaces\", manipulationSettings.getIndentationText() !== options_1.IndentationText.Tab);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"newLineCharacter\", manipulationSettings.getNewLineKindAsString());\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"indentStyle\", typescript_1.IndentStyle.Smart);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"indentSize\", manipulationSettings.getIndentationText().length);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"tabSize\", manipulationSettings.getIndentationText().length);\r\n}\r\nexports.fillDefaultEditorSettings = fillDefaultEditorSettings;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/fillDefaultEditorSettings.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/fillDefaultFormatCodeSettings.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/fillDefaultFormatCodeSettings.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar fillDefaultEditorSettings_1 = __webpack_require__(/*! ./fillDefaultEditorSettings */ \"./node_modules/ts-simple-ast/dist/utils/fillDefaultEditorSettings.js\");\r\nvar setValueIfUndefined_1 = __webpack_require__(/*! ./setValueIfUndefined */ \"./node_modules/ts-simple-ast/dist/utils/setValueIfUndefined.js\");\r\nfunction fillDefaultFormatCodeSettings(settings, manipulationSettings) {\r\n    fillDefaultEditorSettings_1.fillDefaultEditorSettings(settings, manipulationSettings);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterCommaDelimiter\", true);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterConstructor\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterSemicolonInForStatements\", true);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterKeywordsInControlFlowStatements\", true);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\", true);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceBeforeFunctionParenthesis\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"insertSpaceBeforeAndAfterBinaryOperators\", true);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"placeOpenBraceOnNewLineForFunctions\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"placeOpenBraceOnNewLineForControlBlocks\", false);\r\n    setValueIfUndefined_1.setValueIfUndefined(settings, \"ensureNewLineAtEndOfFile\", true);\r\n}\r\nexports.fillDefaultFormatCodeSettings = fillDefaultFormatCodeSettings;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/fillDefaultFormatCodeSettings.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/getTextFromStringOrWriter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/getTextFromStringOrWriter.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction getTextFromStringOrWriter(writer, textOrWriterFunction) {\r\n    // note: this should always use a writer to ensure the proper indentation is used\r\n    printTextFromStringOrWriter(writer, textOrWriterFunction);\r\n    return writer.toString();\r\n}\r\nexports.getTextFromStringOrWriter = getTextFromStringOrWriter;\r\nfunction printTextFromStringOrWriter(writer, textOrWriterFunction) {\r\n    if (typeof textOrWriterFunction === \"string\")\r\n        writer.write(textOrWriterFunction);\r\n    else\r\n        textOrWriterFunction(writer);\r\n}\r\nexports.printTextFromStringOrWriter = printTextFromStringOrWriter;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/getTextFromStringOrWriter.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./AdvancedIterator */ \"./node_modules/ts-simple-ast/dist/utils/AdvancedIterator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ArrayUtils */ \"./node_modules/ts-simple-ast/dist/utils/ArrayUtils.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./comparers */ \"./node_modules/ts-simple-ast/dist/utils/comparers/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./collections */ \"./node_modules/ts-simple-ast/dist/utils/collections/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./compiler */ \"./node_modules/ts-simple-ast/dist/utils/compiler/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./decorators */ \"./node_modules/ts-simple-ast/dist/utils/decorators/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EventContainer */ \"./node_modules/ts-simple-ast/dist/utils/EventContainer.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./FileUtils */ \"./node_modules/ts-simple-ast/dist/utils/FileUtils.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./fillDefaultEditorSettings */ \"./node_modules/ts-simple-ast/dist/utils/fillDefaultEditorSettings.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./fillDefaultFormatCodeSettings */ \"./node_modules/ts-simple-ast/dist/utils/fillDefaultFormatCodeSettings.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getTextFromStringOrWriter */ \"./node_modules/ts-simple-ast/dist/utils/getTextFromStringOrWriter.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./logging */ \"./node_modules/ts-simple-ast/dist/utils/logging/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./matchGlobs */ \"./node_modules/ts-simple-ast/dist/utils/matchGlobs.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./newLineKindToString */ \"./node_modules/ts-simple-ast/dist/utils/newLineKindToString.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ObjectUtils */ \"./node_modules/ts-simple-ast/dist/utils/ObjectUtils.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./references */ \"./node_modules/ts-simple-ast/dist/utils/references/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./setValueIfUndefined */ \"./node_modules/ts-simple-ast/dist/utils/setValueIfUndefined.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./StringUtils */ \"./node_modules/ts-simple-ast/dist/utils/StringUtils.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./tsconfig */ \"./node_modules/ts-simple-ast/dist/utils/tsconfig/index.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TypeGuards */ \"./node_modules/ts-simple-ast/dist/utils/TypeGuards.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/logging/ConsoleLogger.js":
/*!************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/logging/ConsoleLogger.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar EnableableLogger_1 = __webpack_require__(/*! ./EnableableLogger */ \"./node_modules/ts-simple-ast/dist/utils/logging/EnableableLogger.js\");\r\nvar ConsoleLogger = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ConsoleLogger, _super);\r\n    function ConsoleLogger() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ConsoleLogger.prototype.logInternal = function (text) {\r\n        console.log(text);\r\n    };\r\n    ConsoleLogger.prototype.warnInternal = function (text) {\r\n        console.warn(text);\r\n    };\r\n    return ConsoleLogger;\r\n}(EnableableLogger_1.EnableableLogger));\r\nexports.ConsoleLogger = ConsoleLogger;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/logging/ConsoleLogger.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/logging/EnableableLogger.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/logging/EnableableLogger.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar EnableableLogger = /** @class */ (function () {\r\n    function EnableableLogger() {\r\n        this.enabled = false;\r\n    }\r\n    EnableableLogger.prototype.setEnabled = function (enabled) {\r\n        this.enabled = enabled;\r\n    };\r\n    EnableableLogger.prototype.log = function (text) {\r\n        if (this.enabled)\r\n            this.logInternal(text);\r\n    };\r\n    EnableableLogger.prototype.warn = function (text) {\r\n        if (this.enabled)\r\n            this.warnInternal(text);\r\n    };\r\n    return EnableableLogger;\r\n}());\r\nexports.EnableableLogger = EnableableLogger;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/logging/EnableableLogger.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/logging/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/logging/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./ConsoleLogger */ \"./node_modules/ts-simple-ast/dist/utils/logging/ConsoleLogger.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./EnableableLogger */ \"./node_modules/ts-simple-ast/dist/utils/logging/EnableableLogger.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/logging/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/matchGlobs.js":
/*!*************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/matchGlobs.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar multimatch = __webpack_require__(/*! multimatch */ \"./node_modules/multimatch/index.js\");\r\nvar FileUtils_1 = __webpack_require__(/*! ./FileUtils */ \"./node_modules/ts-simple-ast/dist/utils/FileUtils.js\");\r\nfunction matchGlobs(paths, patterns, cwd) {\r\n    if (typeof patterns === \"string\")\r\n        patterns = FileUtils_1.FileUtils.toAbsoluteGlob(patterns, cwd);\r\n    else\r\n        patterns = patterns.map(function (p) { return FileUtils_1.FileUtils.toAbsoluteGlob(p, cwd); });\r\n    // @types/multimatch incorrectly specifies `string[]` type despite not modifying the array\r\n    return multimatch(paths, patterns);\r\n}\r\nexports.matchGlobs = matchGlobs;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/matchGlobs.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/newLineKindToString.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/newLineKindToString.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/ts-simple-ast/dist/errors/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nfunction newLineKindToString(kind) {\r\n    switch (kind) {\r\n        case typescript_1.NewLineKind.CarriageReturnLineFeed:\r\n            return \"\\r\\n\";\r\n        case typescript_1.NewLineKind.LineFeed:\r\n            return \"\\n\";\r\n        default:\r\n            throw new errors.NotImplementedError(\"Not implemented newline kind: \" + kind);\r\n    }\r\n}\r\nexports.newLineKindToString = newLineKindToString;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/newLineKindToString.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/references/LazyReferenceCoordinator.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/references/LazyReferenceCoordinator.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar collections_1 = __webpack_require__(/*! ../collections */ \"./node_modules/ts-simple-ast/dist/utils/collections/index.js\");\r\n/**\r\n * Updates all the source file's reference containers.\r\n */\r\nvar LazyReferenceCoordinator = /** @class */ (function () {\r\n    function LazyReferenceCoordinator(factory) {\r\n        var _this = this;\r\n        this.dirtySourceFiles = collections_1.createHashSet();\r\n        var onSourceFileModified = function (sourceFile) {\r\n            if (!sourceFile.wasForgotten())\r\n                _this.dirtySourceFiles.add(sourceFile);\r\n        };\r\n        factory.onSourceFileAdded(function (sourceFile) {\r\n            _this.dirtySourceFiles.add(sourceFile);\r\n            sourceFile.onModified(onSourceFileModified);\r\n        });\r\n        factory.onSourceFileRemoved(function (sourceFile) {\r\n            sourceFile._referenceContainer.clear();\r\n            _this.dirtySourceFiles.delete(sourceFile);\r\n            sourceFile.onModified(onSourceFileModified, false);\r\n        });\r\n    }\r\n    LazyReferenceCoordinator.prototype.refreshDirtySourceFiles = function () {\r\n        var e_1, _a;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.dirtySourceFiles.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var sourceFile = _c.value;\r\n                sourceFile._referenceContainer.refresh();\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        this.clearDirtySourceFiles();\r\n    };\r\n    LazyReferenceCoordinator.prototype.refreshSourceFileIfDirty = function (sourceFile) {\r\n        if (!this.dirtySourceFiles.has(sourceFile))\r\n            return;\r\n        sourceFile._referenceContainer.refresh();\r\n        this.clearDityForSourceFile(sourceFile);\r\n    };\r\n    LazyReferenceCoordinator.prototype.addDirtySourceFile = function (sourceFile) {\r\n        this.dirtySourceFiles.add(sourceFile);\r\n    };\r\n    LazyReferenceCoordinator.prototype.clearDirtySourceFiles = function () {\r\n        this.dirtySourceFiles.clear();\r\n    };\r\n    LazyReferenceCoordinator.prototype.clearDityForSourceFile = function (sourceFile) {\r\n        this.dirtySourceFiles.delete(sourceFile);\r\n    };\r\n    return LazyReferenceCoordinator;\r\n}());\r\nexports.LazyReferenceCoordinator = LazyReferenceCoordinator;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/references/LazyReferenceCoordinator.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/references/SourceFileReferenceContainer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/references/SourceFileReferenceContainer.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar collections_1 = __webpack_require__(/*! ../collections */ \"./node_modules/ts-simple-ast/dist/utils/collections/index.js\");\r\nvar compiler_1 = __webpack_require__(/*! ../compiler */ \"./node_modules/ts-simple-ast/dist/utils/compiler/index.js\");\r\nvar TypeGuards_1 = __webpack_require__(/*! ../TypeGuards */ \"./node_modules/ts-simple-ast/dist/utils/TypeGuards.js\");\r\nvar SourceFileReferenceContainer = /** @class */ (function () {\r\n    function SourceFileReferenceContainer(sourceFile) {\r\n        var _this = this;\r\n        this.sourceFile = sourceFile;\r\n        this.nodesInThis = new collections_1.KeyValueCache();\r\n        this.nodesInOther = new collections_1.KeyValueCache();\r\n        this.unresolvedLiterals = [];\r\n        this.resolveUnresolved = function () {\r\n            for (var i = _this.unresolvedLiterals.length - 1; i >= 0; i--) {\r\n                var literal = _this.unresolvedLiterals[i];\r\n                var sourceFile = _this.getSourceFileForLiteral(literal);\r\n                if (sourceFile != null) {\r\n                    _this.unresolvedLiterals.splice(i, 1);\r\n                    _this.addNodeInThis(literal, sourceFile);\r\n                }\r\n            }\r\n            if (_this.unresolvedLiterals.length === 0)\r\n                _this.sourceFile.context.compilerFactory.onSourceFileAdded(_this.resolveUnresolved, false);\r\n        };\r\n    }\r\n    SourceFileReferenceContainer.prototype.getDependentSourceFiles = function () {\r\n        var e_1, _a;\r\n        this.sourceFile.context.lazyReferenceCoordinator.refreshDirtySourceFiles();\r\n        var hashSet = collections_1.createHashSet();\r\n        try {\r\n            for (var _b = tslib_1.__values(this.nodesInOther.getKeys()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var nodeInOther = _c.value;\r\n                hashSet.add(nodeInOther.sourceFile);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return hashSet.values();\r\n    };\r\n    SourceFileReferenceContainer.prototype.getLiteralsReferencingOtherSourceFilesEntries = function () {\r\n        this.sourceFile.context.lazyReferenceCoordinator.refreshSourceFileIfDirty(this.sourceFile);\r\n        return this.nodesInThis.getEntries();\r\n    };\r\n    SourceFileReferenceContainer.prototype.getReferencingLiteralsInOtherSourceFiles = function () {\r\n        this.sourceFile.context.lazyReferenceCoordinator.refreshDirtySourceFiles();\r\n        return this.nodesInOther.getKeys();\r\n    };\r\n    SourceFileReferenceContainer.prototype.getReferencingNodesInOtherSourceFiles = function () {\r\n        var e_2, _a, _b, _c, literal, parent, grandParent, e_2_1;\r\n        return tslib_1.__generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    _d.trys.push([0, 7, 8, 9]);\r\n                    _b = tslib_1.__values(this.getReferencingLiteralsInOtherSourceFiles()), _c = _b.next();\r\n                    _d.label = 1;\r\n                case 1:\r\n                    if (!!_c.done) return [3 /*break*/, 6];\r\n                    literal = _c.value;\r\n                    parent = literal.getParentOrThrow();\r\n                    grandParent = parent.getParent();\r\n                    if (!(grandParent != null && TypeGuards_1.TypeGuards.isImportEqualsDeclaration(grandParent))) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, grandParent];\r\n                case 2:\r\n                    _d.sent();\r\n                    return [3 /*break*/, 5];\r\n                case 3: return [4 /*yield*/, literal.getParentOrThrow()];\r\n                case 4:\r\n                    _d.sent();\r\n                    _d.label = 5;\r\n                case 5:\r\n                    _c = _b.next();\r\n                    return [3 /*break*/, 1];\r\n                case 6: return [3 /*break*/, 9];\r\n                case 7:\r\n                    e_2_1 = _d.sent();\r\n                    e_2 = { error: e_2_1 };\r\n                    return [3 /*break*/, 9];\r\n                case 8:\r\n                    try {\r\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                    return [7 /*endfinally*/];\r\n                case 9: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    SourceFileReferenceContainer.prototype.refresh = function () {\r\n        if (this.unresolvedLiterals.length > 0)\r\n            this.sourceFile.context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);\r\n        this.clear();\r\n        this.populateReferences();\r\n        if (this.unresolvedLiterals.length > 0)\r\n            this.sourceFile.context.compilerFactory.onSourceFileAdded(this.resolveUnresolved);\r\n    };\r\n    SourceFileReferenceContainer.prototype.clear = function () {\r\n        var e_3, _a;\r\n        this.unresolvedLiterals.length = 0;\r\n        try {\r\n            for (var _b = tslib_1.__values(this.nodesInThis.getEntries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = tslib_1.__read(_c.value, 2), node = _d[0], sourceFile = _d[1];\r\n                this.nodesInThis.removeByKey(node);\r\n                sourceFile._referenceContainer.nodesInOther.removeByKey(node);\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    SourceFileReferenceContainer.prototype.populateReferences = function () {\r\n        var _this = this;\r\n        this.sourceFile.context.compilerFactory.forgetNodesCreatedInBlock(function (remember) {\r\n            var e_4, _a;\r\n            try {\r\n                for (var _b = tslib_1.__values(_this.sourceFile.getImportStringLiterals()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var literal = _c.value;\r\n                    var sourceFile = _this.getSourceFileForLiteral(literal);\r\n                    remember(literal);\r\n                    if (sourceFile == null)\r\n                        _this.unresolvedLiterals.push(literal);\r\n                    else\r\n                        _this.addNodeInThis(literal, sourceFile);\r\n                }\r\n            }\r\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_4) throw e_4.error; }\r\n            }\r\n        });\r\n    };\r\n    SourceFileReferenceContainer.prototype.getSourceFileForLiteral = function (literal) {\r\n        var parent = literal.getParentOrThrow();\r\n        var grandParent = parent.getParent();\r\n        if (TypeGuards_1.TypeGuards.isImportDeclaration(parent) || TypeGuards_1.TypeGuards.isExportDeclaration(parent))\r\n            return parent.getModuleSpecifierSourceFile();\r\n        else if (grandParent != null && TypeGuards_1.TypeGuards.isImportEqualsDeclaration(grandParent))\r\n            return grandParent.getExternalModuleReferenceSourceFile();\r\n        else if (TypeGuards_1.TypeGuards.isCallExpression(parent)) {\r\n            var literalSymbol = literal.getSymbol();\r\n            if (literalSymbol != null)\r\n                return compiler_1.ModuleUtils.getReferencedSourceFileFromSymbol(literalSymbol);\r\n        }\r\n        else\r\n            this.sourceFile.context.logger.warn(\"Unknown import string literal parent: \" + parent.getKindName());\r\n        return undefined;\r\n    };\r\n    SourceFileReferenceContainer.prototype.addNodeInThis = function (literal, sourceFile) {\r\n        this.nodesInThis.set(literal, sourceFile);\r\n        sourceFile._referenceContainer.nodesInOther.set(literal, sourceFile);\r\n    };\r\n    return SourceFileReferenceContainer;\r\n}());\r\nexports.SourceFileReferenceContainer = SourceFileReferenceContainer;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/references/SourceFileReferenceContainer.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/references/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/references/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./LazyReferenceCoordinator */ \"./node_modules/ts-simple-ast/dist/utils/references/LazyReferenceCoordinator.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./SourceFileReferenceContainer */ \"./node_modules/ts-simple-ast/dist/utils/references/SourceFileReferenceContainer.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/references/index.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/setValueIfUndefined.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/setValueIfUndefined.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction setValueIfUndefined(obj, propertyName, defaultValue) {\r\n    if (typeof obj[propertyName] === \"undefined\")\r\n        obj[propertyName] = defaultValue;\r\n}\r\nexports.setValueIfUndefined = setValueIfUndefined;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/setValueIfUndefined.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/tsconfig/TsConfigResolver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/tsconfig/TsConfigResolver.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar compiler_1 = __webpack_require__(/*! ../../compiler */ \"./node_modules/ts-simple-ast/dist/compiler/index.js\");\r\nvar typescript_1 = __webpack_require__(/*! ../../typescript */ \"./node_modules/ts-simple-ast/dist/typescript/index.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nvar getTsParseConfigHost_1 = __webpack_require__(/*! ./getTsParseConfigHost */ \"./node_modules/ts-simple-ast/dist/utils/tsconfig/getTsParseConfigHost.js\");\r\nvar TsConfigResolver = /** @class */ (function () {\r\n    function TsConfigResolver(fileSystem, tsConfigFilePath, encoding) {\r\n        this.fileSystem = fileSystem;\r\n        this.encoding = encoding;\r\n        this.host = getTsParseConfigHost_1.getTsParseConfigHost(fileSystem, { encoding: encoding });\r\n        this.tsConfigFilePath = fileSystem.getStandardizedAbsolutePath(tsConfigFilePath);\r\n        this.tsConfigDirPath = utils_1.FileUtils.getDirPath(this.tsConfigFilePath);\r\n    }\r\n    TsConfigResolver.prototype.getCompilerOptions = function () {\r\n        return this.parseJsonConfigFileContent(this.tsConfigDirPath).options;\r\n    };\r\n    TsConfigResolver.prototype.getErrors = function () {\r\n        return (this.parseJsonConfigFileContent(this.tsConfigDirPath).errors || []).map(function (e) { return new compiler_1.Diagnostic(undefined, e); });\r\n    };\r\n    TsConfigResolver.prototype.getPaths = function (compilerOptions) {\r\n        var e_1, _a, e_2, _b, e_3, _c;\r\n        var files = utils_1.createHashSet();\r\n        var tsConfigDirPath = this.tsConfigDirPath;\r\n        var directories = utils_1.createHashSet();\r\n        compilerOptions = compilerOptions || this.getCompilerOptions();\r\n        try {\r\n            for (var _d = tslib_1.__values(getRootDirs(compilerOptions)), _e = _d.next(); !_e.done; _e = _d.next()) {\r\n                var rootDir = _e.value;\r\n                var result = this.parseJsonConfigFileContent(this.fileSystem.getStandardizedAbsolutePath(rootDir, this.tsConfigDirPath));\r\n                try {\r\n                    for (var _f = tslib_1.__values(result.fileNames), _g = _f.next(); !_g.done; _g = _f.next()) {\r\n                        var filePath = _g.value;\r\n                        var absoluteFilePath = this.fileSystem.getStandardizedAbsolutePath(filePath);\r\n                        if (this.fileSystem.fileExistsSync(absoluteFilePath)) {\r\n                            files.add(absoluteFilePath);\r\n                        }\r\n                    }\r\n                }\r\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                }\r\n                try {\r\n                    for (var _h = tslib_1.__values(result.directories), _j = _h.next(); !_j.done; _j = _h.next()) {\r\n                        var dirPath = _j.value;\r\n                        var absoluteDirPath = this.fileSystem.getStandardizedAbsolutePath(dirPath);\r\n                        if (this.fileSystem.directoryExistsSync(absoluteDirPath)) {\r\n                            directories.add(absoluteDirPath);\r\n                        }\r\n                    }\r\n                }\r\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return {\r\n            filePaths: utils_1.ArrayUtils.from(files.values()),\r\n            directoryPaths: utils_1.ArrayUtils.from(directories.values())\r\n        };\r\n        function getRootDirs(options) {\r\n            var result = [];\r\n            if (typeof options.rootDir === \"string\")\r\n                result.push(options.rootDir);\r\n            if (options.rootDirs != null)\r\n                result.push.apply(result, tslib_1.__spread(options.rootDirs));\r\n            // use the tsconfig directory if no rootDir or rootDirs is specified\r\n            if (result.length === 0)\r\n                result.push(tsConfigDirPath);\r\n            return result;\r\n        }\r\n    };\r\n    TsConfigResolver.prototype.parseJsonConfigFileContent = function (dirPath) {\r\n        this.host.clearDirectories();\r\n        // do not provide a tsconfig.json filepath to this because it will start searching in incorrect directories\r\n        var result = typescript_1.ts.parseJsonConfigFileContent(this.getTsConfigFileJson(), this.host, dirPath, undefined, undefined);\r\n        delete result.options.configFilePath;\r\n        return tslib_1.__assign({}, result, { directories: this.host.getDirectories() });\r\n    };\r\n    TsConfigResolver.prototype.getTsConfigFileJson = function () {\r\n        var text = this.fileSystem.readFileSync(this.tsConfigFilePath, this.encoding);\r\n        var parseResult = typescript_1.ts.parseConfigFileTextToJson(this.tsConfigFilePath, text);\r\n        if (parseResult.error != null)\r\n            throw new Error(parseResult.error.messageText.toString());\r\n        return parseResult.config;\r\n    };\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], TsConfigResolver.prototype, \"getCompilerOptions\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], TsConfigResolver.prototype, \"getErrors\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], TsConfigResolver.prototype, \"getPaths\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], TsConfigResolver.prototype, \"parseJsonConfigFileContent\", null);\r\n    tslib_1.__decorate([\r\n        utils_1.Memoize\r\n    ], TsConfigResolver.prototype, \"getTsConfigFileJson\", null);\r\n    return TsConfigResolver;\r\n}());\r\nexports.TsConfigResolver = TsConfigResolver;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/tsconfig/TsConfigResolver.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/tsconfig/getCompilerOptionsFromTsConfig.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/tsconfig/getCompilerOptionsFromTsConfig.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar fileSystem_1 = __webpack_require__(/*! ../../fileSystem */ \"./node_modules/ts-simple-ast/dist/fileSystem/index.js\");\r\nvar TsConfigResolver_1 = __webpack_require__(/*! ./TsConfigResolver */ \"./node_modules/ts-simple-ast/dist/utils/tsconfig/TsConfigResolver.js\");\r\n/**\r\n * Gets the compiler options from a specified tsconfig.json\r\n * @param filePath - File path to the tsconfig.json.\r\n * @param options - Options.\r\n */\r\nfunction getCompilerOptionsFromTsConfig(filePath, options) {\r\n    if (options === void 0) { options = {}; }\r\n    // remember, this is a public function\r\n    var fileSystemWrapper = new fileSystem_1.FileSystemWrapper(options.fileSystem || new fileSystem_1.DefaultFileSystemHost());\r\n    var tsConfigResolver = new TsConfigResolver_1.TsConfigResolver(fileSystemWrapper, filePath, options.encoding || \"utf-8\");\r\n    return {\r\n        options: tsConfigResolver.getCompilerOptions(),\r\n        errors: tsConfigResolver.getErrors()\r\n    };\r\n}\r\nexports.getCompilerOptionsFromTsConfig = getCompilerOptionsFromTsConfig;\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/tsconfig/getCompilerOptionsFromTsConfig.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/tsconfig/getTsParseConfigHost.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/tsconfig/getTsParseConfigHost.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\nvar tsInternal = __webpack_require__(/*! ../../typescript/tsInternal */ \"./node_modules/ts-simple-ast/dist/typescript/tsInternal.js\");\r\nvar utils_1 = __webpack_require__(/*! ../../utils */ \"./node_modules/ts-simple-ast/dist/utils/index.js\");\r\nfunction getTsParseConfigHost(fileSystemWrapper, options) {\r\n    var directories = [];\r\n    var currentDir = fileSystemWrapper.getCurrentDirectory();\r\n    var useCaseSensitiveFileNames = false; // shouldn't this be true? (it was false like this in the compiler)\r\n    var host = {\r\n        useCaseSensitiveFileNames: useCaseSensitiveFileNames,\r\n        readDirectory: function (rootDir, extensions, excludes, includes) {\r\n            // start: code from compiler api\r\n            var regexFlag = useCaseSensitiveFileNames ? \"\" : \"i\";\r\n            var patterns = tsInternal.getFileMatcherPatterns(rootDir, excludes || [], includes, useCaseSensitiveFileNames, currentDir);\r\n            var includeDirectoryRegex = patterns.includeDirectoryPattern && new RegExp(patterns.includeDirectoryPattern, regexFlag);\r\n            var excludeRegex = patterns.excludePattern && new RegExp(patterns.excludePattern, regexFlag);\r\n            // end\r\n            return tsInternal.matchFiles(rootDir, extensions, excludes || [], includes, useCaseSensitiveFileNames, currentDir, undefined, function (path) {\r\n                var includeDir = dirPathMatches(path);\r\n                path = fileSystemWrapper.getStandardizedAbsolutePath(path);\r\n                if (includeDir)\r\n                    directories.push(path);\r\n                return getFileSystemEntries(path, fileSystemWrapper);\r\n            });\r\n            function dirPathMatches(absoluteName) {\r\n                // needed for the regex to match\r\n                if (absoluteName[absoluteName.length - 1] !== \"/\")\r\n                    absoluteName += \"/\";\r\n                // condition is from compiler api\r\n                return (!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName))\r\n                    && (!excludeRegex || !excludeRegex.test(absoluteName));\r\n            }\r\n        },\r\n        fileExists: function (path) { return fileSystemWrapper.fileExistsSync(path); },\r\n        readFile: function (path) { return fileSystemWrapper.readFileSync(path, options.encoding); },\r\n        getDirectories: function () { return tslib_1.__spread(directories); },\r\n        clearDirectories: function () { return directories.length = 0; }\r\n    };\r\n    return host;\r\n}\r\nexports.getTsParseConfigHost = getTsParseConfigHost;\r\nfunction getFileSystemEntries(path, fileSystemWrapper) {\r\n    var e_1, _a;\r\n    var files = [];\r\n    var directories = [];\r\n    try {\r\n        var entries = fileSystemWrapper.readDirSync(path);\r\n        try {\r\n            for (var entries_1 = tslib_1.__values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {\r\n                var entry = entries_1_1.value;\r\n                if (fileSystemWrapper.fileExistsSync(entry))\r\n                    files.push(entry);\r\n                else\r\n                    directories.push(entry);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n    catch (err) {\r\n        if (!utils_1.FileUtils.isNotExistsError(err))\r\n            throw err;\r\n    }\r\n    return { files: files, directories: directories };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/tsconfig/getTsParseConfigHost.js?");

/***/ }),

/***/ "./node_modules/ts-simple-ast/dist/utils/tsconfig/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ts-simple-ast/dist/utils/tsconfig/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\r\ntslib_1.__exportStar(__webpack_require__(/*! ./getCompilerOptionsFromTsConfig */ \"./node_modules/ts-simple-ast/dist/utils/tsconfig/getCompilerOptionsFromTsConfig.js\"), exports);\r\ntslib_1.__exportStar(__webpack_require__(/*! ./TsConfigResolver */ \"./node_modules/ts-simple-ast/dist/utils/tsconfig/TsConfigResolver.js\"), exports);\r\n\n\n//# sourceURL=webpack:///./node_modules/ts-simple-ast/dist/utils/tsconfig/index.js?");

/***/ }),

/***/ "./node_modules/unc-path-regex/index.js":
/*!**********************************************!*\
  !*** ./node_modules/unc-path-regex/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function uncPathRegex() {\n  return /^[\\\\\\/]{2,}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+/;\n};\n\n\n//# sourceURL=webpack:///./node_modules/unc-path-regex/index.js?");

/***/ }),

/***/ "./node_modules/zen-observable-ts/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/zen-observable-ts/lib/index.js ***!
  \*****************************************************/
/*! exports provided: default, Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _zenObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zenObservable */ \"./node_modules/zen-observable-ts/lib/zenObservable.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Observable\", function() { return _zenObservable__WEBPACK_IMPORTED_MODULE_0__[\"Observable\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_zenObservable__WEBPACK_IMPORTED_MODULE_0__[\"Observable\"]);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/zen-observable-ts/lib/index.js?");

/***/ }),

/***/ "./node_modules/zen-observable-ts/lib/zenObservable.js":
/*!*************************************************************!*\
  !*** ./node_modules/zen-observable-ts/lib/zenObservable.js ***!
  \*************************************************************/
/*! exports provided: Observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Observable\", function() { return Observable; });\n/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zen-observable */ \"./node_modules/zen-observable/index.js\");\n/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zen_observable__WEBPACK_IMPORTED_MODULE_0__);\n\nvar Observable = zen_observable__WEBPACK_IMPORTED_MODULE_0___default.a;\n//# sourceMappingURL=zenObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/zen-observable-ts/lib/zenObservable.js?");

/***/ }),

/***/ "./node_modules/zen-observable/index.js":
/*!**********************************************!*\
  !*** ./node_modules/zen-observable/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/Observable.js */ \"./node_modules/zen-observable/lib/Observable.js\").Observable;\n\n\n//# sourceURL=webpack:///./node_modules/zen-observable/index.js?");

/***/ }),

/***/ "./node_modules/zen-observable/lib/Observable.js":
/*!*******************************************************!*\
  !*** ./node_modules/zen-observable/lib/Observable.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// === Symbol Support ===\n\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) return undefined;\n\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[getSymbol('species')];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({ type: type, value: value });\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{ type: type, value: value }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: 'next',\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: 'error',\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: 'complete',\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = exports.Observable = function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: 'subscribe',\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: 'map',\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'filter',\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'concat',\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscription = void 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (sources.length === 0) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources.shift()));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: 'flatMap',\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: getSymbol('observable'),\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: 'from',\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n\n      if (x == null) throw new TypeError(x + ' is not an object');\n\n      var method = getMethod(x, getSymbol('observable'));\n      if (method) {\n        var observable = method.call(x);\n\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n\n        if (isObservable(observable) && observable.constructor === C) return observable;\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, getSymbol('iterator'));\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var item = _step.value;\n\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: 'of',\n    value: function of() {\n      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: getSymbol('species'),\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: getSymbol('observable'),\n      hostReportError: hostReportError\n    },\n    configurabe: true\n  });\n}\n\n//# sourceURL=webpack:///./node_modules/zen-observable/lib/Observable.js?");

/***/ }),

/***/ "./src/modules/produtos/produto.module.ts":
/*!************************************************!*\
  !*** ./src/modules/produtos/produto.module.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\r\nconst passport_1 = __webpack_require__(/*! @nestjs/passport */ \"@nestjs/passport\");\r\nconst database_module_1 = __webpack_require__(/*! ../database/database.module */ \"./src/modules/database/database.module.ts\");\r\nconst produto_controller_1 = __webpack_require__(/*! ./produto.controller */ \"./src/modules/produtos/produto.controller.ts\");\r\nconst produto_provider_1 = __webpack_require__(/*! ./produto.provider */ \"./src/modules/produtos/produto.provider.ts\");\r\nconst produto_repository_1 = __webpack_require__(/*! ./produto.repository */ \"./src/modules/produtos/produto.repository.ts\");\r\nconst produto_resolvers_1 = __webpack_require__(/*! ./produto.resolvers */ \"./src/modules/produtos/produto.resolvers.ts\");\r\nconst produto_service_1 = __webpack_require__(/*! ./produto.service */ \"./src/modules/produtos/produto.service.ts\");\r\nlet ProdutoModule = class ProdutoModule {\r\n    configure(consumer) {\r\n        consumer\r\n            .apply()\r\n            .forRoutes({ path: \"/produtos\", method: common_1.RequestMethod.GET }, { path: \"/produtos\", method: common_1.RequestMethod.POST }, { path: \"/produtos/:id\", method: common_1.RequestMethod.PUT }, { path: \"/produtos/:id\", method: common_1.RequestMethod.DELETE });\r\n    }\r\n};\r\nProdutoModule = __decorate([\r\n    common_1.Module({\r\n        controllers: [produto_controller_1.ProdutoController],\r\n        imports: [\r\n            database_module_1.DatabaseModule,\r\n            passport_1.PassportModule.register({ defaultStrategy: \"bearer\" }),\r\n        ],\r\n        providers: [\r\n            produto_repository_1.ProdutoRepository,\r\n            produto_provider_1.produtoProvider,\r\n            produto_service_1.ProdutoService,\r\n            produto_provider_1.repositoryProvide,\r\n            produto_resolvers_1.ProdutoResolvers,\r\n        ],\r\n    })\r\n], ProdutoModule);\r\nexports.ProdutoModule = ProdutoModule;\r\n\n\n//# sourceURL=webpack:///./src/modules/produtos/produto.module.ts?");

/***/ }),

/***/ "./src/modules/produtos/produto.resolvers.ts":
/*!***************************************************!*\
  !*** ./src/modules/produtos/produto.resolvers.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __metadata = (this && this.__metadata) || function (k, v) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst common_1 = __webpack_require__(/*! @nestjs/common */ \"@nestjs/common\");\r\nconst graphql_1 = __webpack_require__(/*! @nestjs/graphql */ \"./node_modules/@nestjs/graphql/index.js\");\r\nconst produto_service_1 = __webpack_require__(/*! ./produto.service */ \"./src/modules/produtos/produto.service.ts\");\r\nlet ProdutoResolvers = class ProdutoResolvers {\r\n    constructor(produtoService) {\r\n        this.produtoService = produtoService;\r\n    }\r\n    getProdutos() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.produtoService.getAll();\r\n        });\r\n    }\r\n    findOneById(id) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return yield this.produtoService.get(id);\r\n        });\r\n    }\r\n};\r\n__decorate([\r\n    graphql_1.Query(),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", []),\r\n    __metadata(\"design:returntype\", Promise)\r\n], ProdutoResolvers.prototype, \"getProdutos\", null);\r\n__decorate([\r\n    graphql_1.Query(\"produto\"),\r\n    __param(0, graphql_1.Args(\"id\", common_1.ParseIntPipe)),\r\n    __metadata(\"design:type\", Function),\r\n    __metadata(\"design:paramtypes\", [Number]),\r\n    __metadata(\"design:returntype\", Promise)\r\n], ProdutoResolvers.prototype, \"findOneById\", null);\r\nProdutoResolvers = __decorate([\r\n    graphql_1.Resolver(\"Produto\"),\r\n    __metadata(\"design:paramtypes\", [produto_service_1.ProdutoService])\r\n], ProdutoResolvers);\r\nexports.ProdutoResolvers = ProdutoResolvers;\r\n\n\n//# sourceURL=webpack:///./src/modules/produtos/produto.resolvers.ts?");

/***/ }),

/***/ "@nestjs/common/utils/shared.utils":
/*!****************************************************!*\
  !*** external "@nestjs/common/utils/shared.utils" ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@nestjs/common/utils/shared.utils\");\n\n//# sourceURL=webpack:///external_%22@nestjs/common/utils/shared.utils%22?");

/***/ }),

/***/ "@nestjs/core/helpers/execution-context.host":
/*!**************************************************************!*\
  !*** external "@nestjs/core/helpers/execution-context.host" ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@nestjs/core/helpers/execution-context.host\");\n\n//# sourceURL=webpack:///external_%22@nestjs/core/helpers/execution-context.host%22?");

/***/ }),

/***/ "@nestjs/core/helpers/external-context-creator":
/*!****************************************************************!*\
  !*** external "@nestjs/core/helpers/external-context-creator" ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@nestjs/core/helpers/external-context-creator\");\n\n//# sourceURL=webpack:///external_%22@nestjs/core/helpers/external-context-creator%22?");

/***/ }),

/***/ "@nestjs/core/injector/modules-container":
/*!**********************************************************!*\
  !*** external "@nestjs/core/injector/modules-container" ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@nestjs/core/injector/modules-container\");\n\n//# sourceURL=webpack:///external_%22@nestjs/core/injector/modules-container%22?");

/***/ }),

/***/ "@nestjs/core/metadata-scanner":
/*!************************************************!*\
  !*** external "@nestjs/core/metadata-scanner" ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@nestjs/core/metadata-scanner\");\n\n//# sourceURL=webpack:///external_%22@nestjs/core/metadata-scanner%22?");

/***/ }),

/***/ "accepts":
/*!**************************!*\
  !*** external "accepts" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"accepts\");\n\n//# sourceURL=webpack:///external_%22accepts%22?");

/***/ }),

/***/ "arrify":
/*!*************************!*\
  !*** external "arrify" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"arrify\");\n\n//# sourceURL=webpack:///external_%22arrify%22?");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");\n\n//# sourceURL=webpack:///external_%22assert%22?");

/***/ }),

/***/ "body-parser":
/*!******************************!*\
  !*** external "body-parser" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"body-parser\");\n\n//# sourceURL=webpack:///external_%22body-parser%22?");

/***/ }),

/***/ "busboy":
/*!*************************!*\
  !*** external "busboy" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"busboy\");\n\n//# sourceURL=webpack:///external_%22busboy%22?");

/***/ }),

/***/ "core-js/library/fn/map":
/*!*****************************************!*\
  !*** external "core-js/library/fn/map" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"core-js/library/fn/map\");\n\n//# sourceURL=webpack:///external_%22core-js/library/fn/map%22?");

/***/ }),

/***/ "core-js/library/fn/object/entries":
/*!****************************************************!*\
  !*** external "core-js/library/fn/object/entries" ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"core-js/library/fn/object/entries\");\n\n//# sourceURL=webpack:///external_%22core-js/library/fn/object/entries%22?");

/***/ }),

/***/ "core-js/library/fn/promise":
/*!*********************************************!*\
  !*** external "core-js/library/fn/promise" ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"core-js/library/fn/promise\");\n\n//# sourceURL=webpack:///external_%22core-js/library/fn/promise%22?");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"cors\");\n\n//# sourceURL=webpack:///external_%22cors%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack:///external_%22events%22?");

/***/ }),

/***/ "fast-json-stable-stringify":
/*!*********************************************!*\
  !*** external "fast-json-stable-stringify" ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fast-json-stable-stringify\");\n\n//# sourceURL=webpack:///external_%22fast-json-stable-stringify%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "fs-extra":
/*!***************************!*\
  !*** external "fs-extra" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs-extra\");\n\n//# sourceURL=webpack:///external_%22fs-extra%22?");

/***/ }),

/***/ "glob":
/*!***********************!*\
  !*** external "glob" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"glob\");\n\n//# sourceURL=webpack:///external_%22glob%22?");

/***/ }),

/***/ "glob-parent":
/*!******************************!*\
  !*** external "glob-parent" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"glob-parent\");\n\n//# sourceURL=webpack:///external_%22glob-parent%22?");

/***/ }),

/***/ "hash.js/lib/hash/sha/256":
/*!*******************************************!*\
  !*** external "hash.js/lib/hash/sha/256" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"hash.js/lib/hash/sha/256\");\n\n//# sourceURL=webpack:///external_%22hash.js/lib/hash/sha/256%22?");

/***/ }),

/***/ "is-glob":
/*!**************************!*\
  !*** external "is-glob" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"is-glob\");\n\n//# sourceURL=webpack:///external_%22is-glob%22?");

/***/ }),

/***/ "is-windows":
/*!*****************************!*\
  !*** external "is-windows" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"is-windows\");\n\n//# sourceURL=webpack:///external_%22is-windows%22?");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lodash\");\n\n//# sourceURL=webpack:///external_%22lodash%22?");

/***/ }),

/***/ "lru-cache":
/*!****************************!*\
  !*** external "lru-cache" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"lru-cache\");\n\n//# sourceURL=webpack:///external_%22lru-cache%22?");

/***/ }),

/***/ "micromatch":
/*!*****************************!*\
  !*** external "micromatch" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"micromatch\");\n\n//# sourceURL=webpack:///external_%22micromatch%22?");

/***/ }),

/***/ "minimatch":
/*!****************************!*\
  !*** external "minimatch" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"minimatch\");\n\n//# sourceURL=webpack:///external_%22minimatch%22?");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"node-fetch\");\n\n//# sourceURL=webpack:///external_%22node-fetch%22?");

/***/ }),

/***/ "object-assign":
/*!********************************!*\
  !*** external "object-assign" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"object-assign\");\n\n//# sourceURL=webpack:///external_%22object-assign%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack:///external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "path-type":
/*!****************************!*\
  !*** external "path-type" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path-type\");\n\n//# sourceURL=webpack:///external_%22path-type%22?");

/***/ }),

/***/ "pify":
/*!***********************!*\
  !*** external "pify" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"pify\");\n\n//# sourceURL=webpack:///external_%22pify%22?");

/***/ }),

/***/ "reflect-metadata":
/*!***********************************!*\
  !*** external "reflect-metadata" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"reflect-metadata\");\n\n//# sourceURL=webpack:///external_%22reflect-metadata%22?");

/***/ }),

/***/ "slash":
/*!************************!*\
  !*** external "slash" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"slash\");\n\n//# sourceURL=webpack:///external_%22slash%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack:///external_%22stream%22?");

/***/ }),

/***/ "symbol-observable":
/*!************************************!*\
  !*** external "symbol-observable" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"symbol-observable\");\n\n//# sourceURL=webpack:///external_%22symbol-observable%22?");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tslib\");\n\n//# sourceURL=webpack:///external_%22tslib%22?");

/***/ }),

/***/ "type-is":
/*!**************************!*\
  !*** external "type-is" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"type-is\");\n\n//# sourceURL=webpack:///external_%22type-is%22?");

/***/ }),

/***/ "typescript":
/*!*****************************!*\
  !*** external "typescript" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"typescript\");\n\n//# sourceURL=webpack:///external_%22typescript%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack:///external_%22util%22?");

/***/ }),

/***/ "util.promisify":
/*!*********************************!*\
  !*** external "util.promisify" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util.promisify\");\n\n//# sourceURL=webpack:///external_%22util.promisify%22?");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"uuid\");\n\n//# sourceURL=webpack:///external_%22uuid%22?");

/***/ }),

/***/ "ws":
/*!*********************!*\
  !*** external "ws" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"ws\");\n\n//# sourceURL=webpack:///external_%22ws%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack:///external_%22zlib%22?");

/***/ })

};